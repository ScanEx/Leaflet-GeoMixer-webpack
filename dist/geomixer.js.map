{"version":3,"sources":["webpack:///dist/geomixer.js","webpack:///webpack/bootstrap a47e3cc6244f5f8b025f","webpack:///./src/includes.js","webpack:///./src/Parsers.js","webpack:///./src/Deferred.js","webpack:///./src/ImageLoader.js","webpack:///./src/Utils.js","webpack:///./src/DrawCanvas.js","webpack:///./src/SessionManager.js","webpack:///./src/MapManager.js","webpack:///./src/GeomixerMap.js","webpack:///./src/EventsManager.js","webpack:///./src/Locale.js","webpack:///./src/lang_ru.js","webpack:///./src/lang_en.js","webpack:///./src/DataManager/VectorTileLoader.js","webpack:///./src/DataManager/VectorTile.js","webpack:///./src/DataManager/Observer.js","webpack:///./src/DataManager/TilesTree.js","webpack:///./src/DataManager/DataManager.js","webpack:///./src/Layer/VectorLayer.js","webpack:///./src/Layer/StyleManager.js","webpack:///./src/Layer/ScreenVectorTile.js","webpack:///./src/Layer/ObjectsReorder.js","webpack:///./src/Layer/VectorLayer.Popup.js","webpack:///./src/Layer/VectorLayer.Hover.js","webpack:///./src/Layer/LayersVersion.js","webpack:///./src/Layer/RasterLayer.js","webpack:///./src/Layer/LabelsLayer.js","webpack:///./src/Layer/ClipPolygon.js","webpack:///./src/Layer/ImageTransform.js","webpack:///./src/Layer/ProjectiveImageWebGL.js","webpack:///./src/Layer/ProjectiveImage.js","webpack:///./src/Layer/external/RotatedMarker.js","webpack:///./src/Layer/external/ExternalLayer.js","webpack:///./src/Layer/external/BindWMS.js","webpack:///./src/Layer/external/HeatMap.js","webpack:///./src/Layer/external/MarkerCluster.js","webpack:///./src/LayerFactory.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_MapManager","_Observer","_DataManager","L","gmx","gmxMapManager","observer","options","Observer","DataManager","regexExpression","regexMath","Parsers","functionFromExpression","s","Function","replace","makePair","t1","t2","head","tail","LinkedList","ParserState","fail","failed","state","advance","n","token","tok","len","length","substr","caseInsensitiveToken","toLowerCase","range","startChar","endChar","startCode","charCodeAt","endCode","code","anythingExcept","parser","sequence","parsers","i","choice","newState","nothing","maybe","repeat","minCount","count","separatedList","separator","parser1","whitespace","whitespaceSeparatedList","whitespaceSeparatedSequence","newParsers","push","capture","action","func","oldState","fieldName","fieldNameWithSpaces","quotedFieldName","stringLiteral","digits","numberLiteral","literal","applyParser","opTerm","op","referenceValue","matchPattern","toUpperCase","fieldValue","_matchFrom","referenceIdx","fieldIdx","referenceChar","charAt","fieldChar","props","indexes","types","rValue","gmxUtil","getUnixTimeFromStr","f1","f2","parseFloat","inTerm","node","value","_term","_expression","notTerm","innerTerm","andExpression","flag","orExpression","whereClause","parseSQL","str","result","_additiveExpression","_multiplicativeExpression","pos","term","multiplicativeTerm","res","Math","floor","arithmeticExpression","parseExpression","svgPath","coords","reverse","parseSVGPath","Deferred","cancelFunc","fulfilledData","resolveCallbacks","rejectCallbacks","isFulfilled","isResolved","onceAdded","isCancelled","fulfill","this","_fulfill","resolved","callbacks","slice","arguments","forEach","callback","apply","resolve","concat","reject","cancel","then","resolveCallback","rejectCallback","userFuncDef","def","fulfillFunc","once","onceResolveCallback","always","getFulfilledData","all","defArray","resdef","left","results","Array","ImageRequest","url","_id","imageLoader","_cancelRequest","bind","remove","_removeRequestFromCache","GmxImageLoader","Class","extend","includes","Mixin","Events","statics","MAX_COUNT","initialize","curCount","requests","inProgress","requestsCache","uniqueID","_resolveRequest","request","image","canceled","cache","cacheItem","cacheKey","fire","_imageLoaded","resolveRequest","it","loaderStatus","_nextLoad","shift","k","splice","_loadImage","width","imageObj","Image","_this","crossOrigin","onload","onerror","src","loadingImg","Util","falseFn","emptyImageUrl","_clearCacheItem","Object","keys","_add","atBegin","unshift","defineProperty","_typeof","Symbol","iterator","obj","constructor","prototype","gmxAPIutils","lastMapId","newId","uniqueGlobalName","thing","window","isPageHidden","document","hidden","msHidden","webkitHidden","mozHidden","normalizeHostname","hostName","parsedHost","parseUri","host","directory","substring","getLayerItemFromServer","query","field","req","WrapStyle","geometry","layer","layerID","border","requestJSONP","serverBase","getCadastreFeatures","latlng","text","lat","lng","tolerance","getFormData","json","arr","key","val","JSON","stringify","join","params","script","createElement","setAttribute","callbackParamName","urlParams","syncParams","callbackName","paramsStringItems","encodeURIComponent","indexOf","e","parentNode","removeChild","getElementsByTagName","item","appendChild","getXmlHttp","xmlhttp","XMLHttpRequest","ActiveXObject","E","ph","xhr","open","type","async","headers","setRequestHeader","reqId","withCredentials","onreadystatechange","readyState","status","responseText","onError","getSyncParams","send","Error","tileSizes","getTileNumFromLeaflet","tilePoint","zoom","z","pz","pow","tx","x","ty","y","getTilePosZoomDelta","zoomFrom","zoomTo","dz","size","dx","dy","zDelta","geoItemBounds","geo","bounds","boundsArr","coordinates","b","arr1","j","len1","extendBounds","getUnFlattenGeo","isLikePolygon","coordsOut","isPolygon","ring","unFlattenRing","cnt","geoFlatten","flattenRing","CurArray","Float64Array","isRectangle","getGeometryBounds","pt","getMarkerPolygon","min","max","getQuicklookPointsFromProperties","pArr","tileAttributeIndexes","points","x1","getPropItem","quicklookX1","y1","quicklookY1","x2","quicklookX2","y2","quicklookY2","x3","quicklookX3","y3","quicklookY3","x4","quicklookX4","y4","quicklookY4","quicklookPlatform","merc","Projection","Mercator","project","latLng","getPropertiesHash","properties","dec2rgba","a","r","g","dec2hex","toString","dec2color","oneDay","isTileKeysIntersects","tk1","tk2","t","rotatePoints","angle","iconScale","center","out","PI","sin","cos","getPatternIcon","style","fillPattern","notFunc","pattern","prop","step","patternDefaults","minWidth","maxWidth","minStep","maxStep","patternStepFunction","patternWidthFunction","fillOpacity","opacityFunction","rgb","colors","resColors","col","patternColorsFunction","delta","allSize","rad","hh","ww","flagRotate","console","log","alert","canvas","height","ptx","getContext","clearRect","translate","rotate","beginPath","fillStyle","xx1","moveTo","lineTo","arc","fillRect","closePath","fill","canvas1","ptx1","drawImage","getSVGIcon","svg","Path","SVG_NS","stroke","strokeStyle","strokeWidth","lineWidth","iconOptions","className","iconSize","fillRadialGradient","stopColor","colorStop","addColorStop","html","DivIcon","toPixels","tpx","tpy","mInPixel","px1","py1","getPixelPoint","attr","currentStyle","parsedStyleKeys","iconCenter","sx","sy","weight","iconAnchor","px","py","worldWidthMerc","getImageData","img","isIE9","isIE10","data","DEFAULT_REPLACEMENT_COLOR","isIE","v","getIEversion","gtIE","ua","navigator","userAgent","msie","parseInt","trident","rv","edge","replaceColor","color","fromData","imageData","createImageData","toData","putImageData","drawIconPath","path","isArray","ctx","trFlag","radian","rotateRes","degRad","setTransform","pointToCanvas","pointAttr","px1sx","py1sy","iconPath","iconColor","globalAlpha","opacity","transformFlag","fillColor","circle","rgr","r2","radgrad","createRadialGradient","r1","strokeRect","lineToCanvasAsIcon","pixels","getLineDash","setLineDash","lineToCanvas","lastX","lastY","getCoordsPixels","hiddenLines","hiddenFlag","hash","coords1","hiddenLines1","pixels1","hidden1","j1","getRingPixels","currentZoom","cntHide","vectorSize","lineIsOnEdge","round","polygonToCanvas","polygonToCanvasFill","isPatternNode","HTMLCanvasElement","HTMLImageElement","labelCanvasContext","getLabelWidth","txt","font","split","map","fillText","measureText","setLabel","coord","shadowColor","shadowBlur","strokeText","rMajor","ang","distVincenty","lon1","lat1","lon2","lat2","p1","lon","p2","f","L1","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","lambda","lambdaP","iterLimit","abs","sinLambda","cosLambda","sinSigma","sqrt","cosSigma","sigma","atan2","sinAlpha","cosSqAlpha","cos2SigmaM","isNaN","C","NaN","uSq","A","B","deltaSigma","_vfi","fi","getCircleLatLngs","LatLng","R","d","Rd","VR","latlngs","limit","acos","asin","parseCoordinates","crs","regex","exec","match","ii","mul","SphericalMercator","unproject","Point","_divideBy","pad2","trunc","formatDegrees","format","a1","a2","a3","toPrecision","st","undefined","latLonFormatCoordinates","formatCoordinates","latLonFormatCoordinates2","formatCoordinates2","getPixelScale","forEachPoint","ret","getItemCenter","geoItems","isPoint","geom","dataOption","bbox","contains","len2","getHSegmentsInPolygon","poly","isGt1","isGt2","sort","index","segArr","isPointInPolygonArr","chkPoint","isIn","xmin","xmax","ymax","xinters","isPointInPolygonWithHoles","isClockwise","area","isPointInPolyLine","lineHeight","nullPoint","minx","maxx","miny","maxy","sqDist","LineUtil","_sqClosestPointOnSegment","isPointInLines","point","getLength","isMerc","prettifyDistance","km","gmxLocale","getText","geoJSONGetLength","geoJSON","geometries","features","getRingLength","lnglat","geoJSONGetArea","getRingArea","geoJSONGetLatLng","ipp","lambertCoefX","lambertCoefY","getArea","prettifyArea","km2","geoLength","geometryToGeoJSON","mercFlag","coordsFromMercator","convertGeometry","fromMerc","coordsToMercator","geoJSONtoGeometry","_coordsConvert","toMerc","resCoords","transformGeometry","geoArea","getGeoJSONSummary","unitOptions","units","squareUnit","distanceUnit","getCoordinatesString","num","formats","CRS","EPSG3857","getGeometriesSummary","coordinatesFormat","getGeometrySummary","chkOnEdge","ext","getHidden","tb","prev","getNormalizeBounds","screenBounds","mercDeltaY","northWest","getNorthWest","southEast","getSouthEast","minX","maxX","w","minX1","maxX1","m1","m2","m11","m12","prec","zn","getTileBounds","tileSize","parseTemplate","matches","key1","getDefaultBalloonTemplate","tileAttributeTypes","parseBalloonTemplate","attrToString","summary","styleKeys","marker","server","client","outline","label","styleFuncKeys","iconAngle","styleFuncError","defaultStyles","MinZoom","MaxZoom","Filter","Balloon","DisableBalloonOnMouseMove","DisableBalloonOnClick","RenderStyle","linestring","polygon","getDefaultStyle","from","toServerStyle","fromServerStyle","newKey","Number","trim","Date","UTC","getDateFromStr","dt","getUTCdate","utime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCtime","h","getUTCdateTime","time","getTileAttributes","attributes","attrs","attrTypes","identityField","Bounds","MAX_VALUE","extendArray","addBuffer","dxmin","dymin","dxmax","dymax","getCenter","addOffset","offset","intersects","min2","max2","intersectsWithDelta","isEqual","isNodeIntersect","clipPolygon","cp1","cp2","clip","inside","intersection","dc","dp","n1","n2","n3","outputList","inputList","clipPolyLine","angleFlag","codeB","lastCode","bitCode","getAngle","intersect","codeA","part","o","strictMode","uri","q","name","$0","$1","$2","hostOnly","authority","strict","loose","isIE11","gtIE11","createPostIframe2","uniqueId","lastRequestId","iframe","DomUtil","create","display","parsedURL","origin","protocol","location","processMessage","dataStr","decodeURIComponent","dataObj","parse","ev","Status","ErrorInfo","ErrorMessage","ExceptionType","StackTrace","CallbackName","DomEvent","on","sendCrossDomainPostRequest","baseForm","form","originalFormAction","getAttribute","target","Browser","ielt9","hiddenParamsDiv","paramName","input","body","submit","removeAttribute","_Utils","styleCanvasKeys","styleCanvasKeysLen","setCanvasStyle","valKey","dashArray","dashes","dashOffset","lineDashOffset","lineCap","lineJoin","canvasPattern","createPattern","fillLinearGradient","x1Function","y1Function","x2Function","y2Function","lineargrad","createLinearGradient","arrFunc","addColorStopFunctions","p0","drawGeoItem","geoItem","propsArr","idr","rasters","tbounds","styleHook","styleExtend","lastHover","geoType","dattr","lastImage","lastImageData","pixelsMap","flagPixels","coordsToCanvas","flagFill","bgImage","skipRasters","imagePattern","rasterOpacity","maxSize","save","restore","gmxSessionManager","APIKEY_PARAM","SCRIPT_REGEXP","_scriptSearched","_scriptAPIKey","_searchScriptAPIKey","scripts","parsedParam","requestSessionKey","serverHost","apiKey","_sessionKeys","Key","response","Result","getSessionKey","keyPromise","getMap","mapName","skipTiles","maps","_maps","promise","sessionKey","MapName","ModeKey","setSyncParams","stringFlag","findLayerInfo","mapID","hostMaps","mapInfo","layers","serverData","iterateLayers","layerInfo","treeInfo","iterate","content","children","gmxMap","commonLayerOptions","layersByTitle","layersByID","dataManagers","BaseLayers","rawTree","layersCreated","missingLayerTypes","dataSources","meta","MetaProperties","ContentID","layerOptions","dataSource","parentLayer","Value","info","_layerClasses","addLayer","createLayer","loaders","_loadLayerClass","hosts","opt","pId","pLayer","parentOptions","getGmxProperties","dataManager","prefix","Layer","Layers","ids","addDataManager","DummyLayer","pid","getDataManager","title","removeLayer","addLayersToMap","leafletMap","l","visible","GmxEventsManager","Handler","_map","_layers","_lastLayer","_lastId","_drawstart","_lastCursor","isDrawing","gmxControlsManager","drawingControl","get","activeIcon","_container","cursor","getDomIndex","container","childNodes","skipNodeName","IMG","DIV","clearLastHover","gmxEventCheck","eventCheck","skipNode","originalEvent","gmxMouseDown","webkit","which","buttons","nodeName","hasClass","_animatingZoom","_skipClick","layerPoint","_gmxMouseLatLng","gmxMousePos","getPixelOrigin","add","la","lb","oa","ob","za","zIndexOffset","zIndex","zb","foundLayer","_animating","clickable","hasEventListeners","zoomend","setTimeout","click","dblclick","mousedown","mouseup","mousemove","contextmenu","layeradd","_leaflet_id","layerremove","Map","addInitHook","_gmxEventsManager","isGmxDrawing","removeHooks","DEFAULT_LANGUAGE","_setKeyText","lang","setLanguage","_language","getLanguage","language","gmxLocaleMixin","addText","newHash","k1","locale","keyArr","rus","Coordinates","Length","nodeLength","edgeLength","Area","Perimeter","nm","ha","m2html","km2html","eng","gmxVectorTileLoader","_loadedTiles","_getKey","ti","load","tileSenderPrefix","tileInfo","requestParams","LayerName","Level","Span","gmxAPI","_vectorTileReceiver","level","span","values","VectorTile","dataProvider","loadDef","dataOptions","isGeneralized","isFlatten","gmxTilePoint","vectorTileKey","makeTileKey","dateZero","beginDate","valueOf","endDate","addData","removeData","dataBounds","_parseItem","clear","needFlatten","edgeBounds","edgeArr","createTileKey","parseTileKey","gmxTileKey","boundsFromTileKey","_callback","_items","filters","targetZoom","active","setBounds","bbox1","world","dateInterval","_setDateInterval","hasFilter","filterName","activate","deactivate","toggleActive","isActive","updateData","prevItems","newItems","added","removed","tileKey","items","latLngBounds","sw","getSouthWest","ne","getNorthEast","minY","maxY","intersectsWithTile","tile","di","setDateInterval","isValid","temporalFilter","TilesTree","_rootNodes","tiles","TemporalTiles","vers","TemporalVers","periods","TemporalPeriods","maxPeriod","smin","ZeroDate","getTime","getTimezoneOffset","zeroUT","addTile","pd","childrenCount","sChild","ds","pdOneDay","dmax","dmaxOneDay","cs","selectTiles","t1Val","t2Val","minLevel","dateIntervalLength","maxLevel","getCountOfIntersected","tileBounds","selectTilesForNode","nodes","childrenRes","intersectCount","resTilesArr","resNodesArr","resTiles","nodeSelection","resTilesHash","getNode","findNode","tilesTree","_VectorTile","_VectorTileLoader","ObserverTileLoader","_dataManager","_observerData","_tileData","addObserver","leftToLoad","loadingState","_updateObserver","removeObserver","obsTiles","tileId","observers","leftToLoadDelta","_tileLoadedCallback","tileObservers","obsInfo","removeTile","tileData","observerData","startLoadTiles","_getActiveTileKeys","obsData","getTileObservers","getObserverLoadingState","newObserverTiles","tilesVers","LayerVersion","GeoProcessing","Temporal","TemporalColumnName","setOptions","_clearProcessing","processingTile","_chkProcessing","optionsLink","_isTemporalLayer","tileAttributes","_needCheckActiveTiles","_vectorTileDataProviderLoad","clearVersion","_tilesTree","_activeTileKeys","_endDate","_beginDate","_tiles","_filters","_freeSubscrID","_observers","_needCheckDateInterval","_vectorTileDataProvider","_observerTileLoader","event","_updateItemsFromTile","treeNode","needRefresh","getItems","addFilter","unixTimeStamp","dates","_chkMaxDateInterval","newTileKeys","initTilesTree","_updateActiveTilesList","initTilesList","_getObserversByFilterName","oKeys","filterFunc","_triggerObservers","removeFilter","oId","resItems","filter","putData","getItem","isFiltered","activeTileKeys","tkey","geomIndex","processing","currentFilter","fromTiles","getMaxDateInterval","newBeginDate","newEndDate","_waitCheckObservers","checkObserver","getActiveObserversCount","getObserver","getItemsBounds","_itemsBounds","getItemMembers","members","objIndex","getItemGeometries","geomItems","checkObservers","_checkObserversTimer","clearTimeout","_removeDataFromObservers","preloadTiles","dateBegin","dateEnd","tileKeys","loadingDefs","_getVectorTile","newTilesList","_tileFilteringHook","filteredTilesList","tk","oldTilesList","observersToUpdate","_rasterVectorTile","checkSubscription","vKey","observerIds","sid","_propertiesToArray","fromServerProps","needProcessingFilter","skip","Deleted","Inserted","Updated","enableGeneralization","_resetTilesTree","disableGeneralization","updateVersion","_getDataKeys","chkKeys","_getProcessingTile","vTile","createFlag","_addVectorTile","_getGeneralizedTileKeys","vTilePoint","temp","gKey","newActiveTileKeys","tKey","tHash","generalizedKeys","newTiles","gKeys","gPoint","setTileFilteringHook","filteringHook","removeTileFilteringHook","_StyleManager","_ScreenVectorTile","VectorLayer","TileLayer","Canvas","openPopups","minZoom","useWebGL","initPromise","_drawQueue","_drawQueueHash","_drawInProgress","_anyDrawings","repaintObservers","_gmx","sortItems","styles","tileSubscriptions","_tilesToLoad","shiftXlayer","shiftYlayer","renderHooks","preRenderHooks","_needPopups","_clearTileSubscription","zKey","_removeTile","tileLink","el","onAdd","EPSG3395","shiftY","applyShift","getZoom","styleManager","initStyles","_zoomStart","_zoomEnd","_moveEnd","pointerEvents","balloonEnable","_popup","bindPopup","_onStyleChange","_onVersionChange","layersVersion","onRemove","off","viewreset","_reset","moveend","_update","_animated","zoomanim","_animateZoom","_endZoomAnim","updateWhenIdle","_limitedUpdate","_clearAllSubscriptions","_initContainer","_prpZoomData","setZIndexOffset","_updateZIndex","isExternalVisible","_zoom","deferred","__update","_addTile","myLayer","layerType","isVisibleAtZoom","_tileLoaded","_tileCoordsToKey","isDrawnFirstTime","done","getStyleBounds","_drawTileAsync","_chkDrawingState","_getLoadedTilesPercentage","_tileComplete","addClass","_tileContainer","_setClearBgBuffer","_tileOnLoad","_tileOnError","tileDrawn","_getTiledPixelBounds","shiftPoint","shiftX","pixelCenter","_tileZoom","_floor","halfSize","getSize","divideBy","subtract","_pxBoundsToTileRange","_round","initFromDescription","_initDone","worldSize","rawProperties","_updateProperties","StyleManager","maxZoom","chkUpdate","_objectsReorderInit","clusters","bindClusters","redraw","setRasterOpacity","repaint","getStyles","getIcons","setStyles","clearStyles","setStyle","getStyle","setStyleHook","removeStyleHook","setRasterHook","rasterProcessingHook","removeRasterHook","setFilter","maxShownPeriod","msecPeriod","gmxSkipTiles","UseTiles","now","getDateInterval","setPositionOffset","getPositionOffset","zKeys","redrawItem","gmxTiles","_getTilesByBounds","gmxGetCanvasTile","_getTile","current","_tilePoint","appendTileToContainer","tilePos","_getTilePos","setPosition","chrome","android23","getStylesByProperties","propArray","getCurrentFilters","getItemStyle","getObjStyle","getTileAttributeTypes","getTileAttributeIndexes","getItemBalloon","getItemProperties","addPreRenderHook","renderHook","removePreRenderHook","hook","addRenderHook","removeRenderHook","getBounds","proj","gmxBounds","LatLngBounds","getGeometry","latLngGeometry","subscription","screenTile","destructor","zoomstart","setCurrentZoom","unbindPopup","_updateZoomLevels","labelsLayer","_labelsLayer","parsedKey","_removeInProgressDrawing","queue","isEmpty","drawNextTile","queueItem","drawDef","_gmxDrawTile","tp","gtp","elem","_updateShiftY","deltaY","zd","_clearBgBufferTimer","_bgBuffer","_clearBgBuffer","_getNeedPopups","pixelBounds","tileRange","_getWrapTileNum","_chkTileSubscriptions","_getScreenTile","ScreenVectorTile","cancelled","screenTileDrawPromise","drawTile","minLatLng","maxLatLng","getPixelBounds","minPoint","maxPoint","apikeyRequestHost","GeometryType","minZoomRasters","RCMinZoomForRasters","minZoomQuicklooks","ZIndexField","zIndexField","_objectsReorder","shiftXfield","shiftYfield","multiFilters","IsRasterCatalog","layerLink","GMX_RasterCatalogID","rasterBGfunc","Quicklook","quicklookParams","template","X1","Y1","X2","Y2","X3","Y3","X4","Y4","quicklookBGfunc","reg","imageQuicklookProcessingHook","gmxImageTransform","attribution","Copyright","getViewRasters","itemsView","propArr","_maxVersion","_maxStyleSize","_styles","_deferredIcons","_parserFunctions","_serverStylesParsed","Infinity","_getMaxStyleSize","_needLoadIcons","MAX_STYLE_SIZE","maxShift","mercSize","HoverStyle","_chkReady","_chkStyleFilter","_parseServerStyles","_getImageSize","getStyleKeys","filterFunction","version","common","_changeStylesVersion","_prepareItem","DEFAULT_KEYS","_parseStyle","_checkStyles","templateBalloon","isSummary","test","hoverDiff","styleVersion","parsedStyleHover","_itemStyleParser","iconUrl","fillIconUrl","offsetWidth","offsetHeight","scaleFunction","rotateFunction","toFixed","fnum","curr","needParse","_lastZoom","parsed","parsedHover","styleHover","parsedStyle","DEFAULT_STYLE","gmxStyle","hoveredStyle","thickness","_isLabel","BalloonEnable","checkDiff","renderStyle","fkey","parsePattern","iconCircle","DEFAULT_ICONPATH","parseRadialGradient","parseLinearGradient","labelTemplate","labelField","itemType","iconColorFunction","r1Function","r2Function","r2max","p3","_radialGradientParsed","sizeFunction","colorFunction","fop","fc","fcDec","fillColorFunction","fillOpacityFunction","labelText","labelAnchor","rt","st1","rg","resFunc","lg","utils","showRaster","rasterRequests","_uniqueID","badTiles","_loadTileRecursive","urlFunction","currentUrl","requestPromise","tryLoad","rUrl","tryHigherLevelTile","maxNativeZoom","tileRastersId","_rasterHook","source","sourceTilePoint","destinationTilePoint","destination","quicklook","_defaultRasterHook","sh","dw","dh","_getShiftPixels","_getShiftTilesArray","deltaX","tminX","tminY","rminX","rmaxX","rminY","rmaxY","_getItemRasters","recursiveLoaders","mainRasterLoader","isShift","urlBG","itemImageProcessingHook","isTiles","resCanvas","imageItem","itemRasterPromise","tileToLoadPoints","chkReadyRasters","skipRasterFunc","onLoadFunction","isImage","posInfo","hookResult","resImage","loader","loadResult","imageLoaded","imgAttr","prepareItem","imageElement","_getVisibleItems","_tileCanvas","dm","imageSmoothingEnabled","_getNeedRasterItems","platform","_getTileRasters","itemPromises","itemRasters","needLoadRasters","_chkItems","tLink","getSortedItems","_cancelRastersPromise","rastersPromise","drawPromise","currentDrawPromise","_preRenderPromise","_renderPromise","_drawDone","_zKey","doDraw","hookInfo","hookBgImage","hover","hookTile","_clearCache","MAX","ObjectsReorder","userSetSortFunc","sortFunc","disabled","addToReorder","bottomFlag","clickFunc","ctrlKey","reorder","ap","bp","resetSortFunc","include","getReorderArrays","top","bottom","bringToTopItem","bringToBottomItem","clearReorderArrays","setReorderArrays","setSortFunc","disableFlip","enableFlip","popupOptions","layerId","Popup","setContent","_initContent","_state","_popupHandlersAdded","_openClickPopup","_movePopup","_overPopup","_outPopup","_chkNeedOpenPopup","popupopen","_popupopen","updateLayout","_updateLayout","addPopup","disablePopup","_popupDisabled","enablePopup","openPopup","_latlng","_latlngs","_openPopup","closePopup","_close","popup","_gmxID","_setPopupContent","setLatLng","prevId","_callBalloonHook","div","spans","hooksCount","_balloonHook","hookID","fid","notFound","balloonData","skipSummary","outItem","nodePoint","protoOffset","contentNode","_contentNode","containerPoint","HTMLElement","resStr","contentDiv","innerHTML","getContent","altKey","shiftKey","layerProp","notSkip","_gmxPopups","maxPopupCount","_gmxPopupsInit","_clearPopup","reduce","closeOnClick","autoPan","objectId","addTo","_closeButton","closeStyle","visibility","marginBottom","flagPopup","getPopups","getHoverOption","addPopupHook","stamp","removePopupHook","_gmxFirstObjectsByPoint","mercPoint","radius","objBounds","chktype","pBounds","isPointInClipPolygons","skipOver","chkHover","evType","fromType","_subtract","mercatorPoint","observerOptions","changed","targets","lastMouseover","doubleClickZoom","disable","enable","delay","dataManagersLinks","intervalID","timeoutID","lastLayersStr","isExistsTiles","tilesKey","getParams","layerDateInterval","Name","Version","maxDateInterval","getRequestParams","skipItems","isDataManager","chkVersion","processResponse","curLayer","chkHost","layersStr","Content-type","timeStamp","_stampVersionRequest","removeDataManager","pOptions","_chkVersion","start","stop","clearInterval","msec","setInterval","layerDescription","RasterLayer","vectorProperties","vectorDataProvider","objects","itemBounds","ww2","bboxArr","it1","it2","setZoomBounds","LabelsLayer","pane","_styleManagers","_labels","chkData","labels","fieldType","String","arrTxtWidth","fontSize","labelFontSize","labelStyle","labelHaloColor","labelColor","labelAlign","pstyle","_updateBbox","_layeradd","_layerremove","_frame","requestAnimFrame","_redraw","_addToPane","getPanes","insertBefore","_canvas","firstChild","_initCanvas","zoomAnimation","any3d","animated","southWest","northEast","_ctxShift","mapSize","latLngToContainerPoint","topLeft","containerPointToLayerPoint","w2","width2","size2","scale","getZoomScale","pixelBoundsMin","_getCenterOffset","_multiplyBy","_getMapPanePos","multiplyBy","TRANSFORM","getTranslateString","isBoundsIntersects","clipPolygons","isObserverIntersects","_isPointInClipPolygons","j2","len3","getClipPolygonItem","clipTileByPolygon","i1","_clipPolygons","addClipPolygon","Polygon","toGeoJSON","GeoJSON","getLayers","feature","MultiPolygon","removeClipPolygon","boundsP","itbounds","wMerc","shiftPoints","ProjectiveImage","projectiveImageWebGL","projectiveImage","getCanvas","wView","hView","adj","multmm","cij","multmv","basisToPoints","ProjectiveImageWebGL","antialias","depth","preserveDrawingBuffer","shaderVS","shaderFS","glOpts","gl","glResources","_setupGlContext","_getShader","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","vertices","Float32Array","vertexBuffer","createBuffer","vertAttrib","getAttribLocation","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","transMatUniform","getUniformLocation","samplerUniform","screenTexture","createTexture","_bindTexture","texture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","dstPoints","Utils","general2DProjection","viewport","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","uniformMatrix4fv","activeTexture","TEXTURE0","uniform1i","drawArrays","TRIANGLE_STRIP","to","getWebGlResources","patchSize","transform","allocate","Matrix","cloneValues","clone","operand","transformProjectiveVector","iz","multiply","accum","rowEchelon","yp","pivot","ys","tmpRow","factor","invert","getProjectiveTransform","eqMatrix","kernel","divide","u1","v1","u4","v4","p4","d1","d2","d3","umid","vmid","pmid","pb","pl","pr","d12","d24","d43","d31","a4","amax","padx","pady","du","dv","iw","ih","ptl","ptr","pbl","pbr","RotatedMarker","Marker","TRANSFORM_ORIGIN","testProp","_initIcon","_icon","_getTransformOrigin","icon","_setPos","ie","costheta","sintheta","setAngle","rotatedMarker","ExternalLayer","createExternalLayer","_observer","useDataManager","_addEvent","_addObserver","externalLayer","unbindLayer","_onRemove","_removeMapHandlers","_addMapHandlers","_chkZoom","_isParentLayer","fromMapFlag","hasLayer","isExtLayerOnMap","BindWMS","transparent","poptions","_extendOptionsByDateInterval","apikey","tileLayer","wms","StartDate","toLocaleDateString","EndDate","wmsParams","bindWMS","_layerWMS","unbindWMS","GmxHeatMap","minHeatMapZoom","maxHeatMapZoom","intensityField","intensityScale","heatLayer","altIndex","alt","setLatLngs","bindHeatMap","_heatmap","unbindHeatMap","_DEFAULTS","radiusFunc","stroke-width","text-anchor","GmxMarkerCluster","spiderfyOnMaxZoom","mOptions","showCoverageOnHover","disableClusteringAtZoom","clusterIconOptions","radialGradient","iconCreateFunction","cluster","childCount","getChildCount","clusterclick","zoomToBoundsOnClick","markers","MarkerClusterGroup","currentSpiderfiedCluster","getAllChildMarkers","unspiderfy","eventFrom","originalEventType","spiderfy","vectorTileItem","removeLayers","mPoint","notClusteredIcon","Icon","addLayers","openOn","_clusters","unbindClusters","DEFAULT_HOSTNAME","DEFAULT_VECTOR_LAYER_ZINDEXOFFSET","Raster","Vector","VectorView","_loadingLayerClasses","addLayerClass","layerClass","_layerClassLoaders","addLayerClassLoader","layerClassLoader","loadLayer","layerParams","doCreateLayer","error","loadLayers","globalOptions","defs","loadMap","loadedMap","setZIndex","curZIndex","LayerOrder","errorMessage"],"mappings":"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6iCN,MM7iC8B,IN+iClClY,UM9iCU,WN+iCN,MM/iC8B,INijClCiI,UMhjCU,WNijCN,MMjjCiC,MNmjCrCE,QMljCQ,WNmjCJ,MMnjC4B,INqjChC/G,YMpjCY,WNqjCR,MMrjCkC,INujCtCyF,MMtjCM,WNujCF,MMvjC6B,MNyjCjCwB,UMxjCU,WNyjCN,MMzjCiC,ON4jCzC+P,eACIC,QMzjCF,EN0jCEC,QMzjCF,GN0jCEC,OMzjCF,GN0jCEC,QMzjCF,GN0jCEC,2BMzjCF,EN0jCEC,uBMzjCF,EN0jCEC,aACIjG,OACI7L,MMzjCD,IN0jCCxB,OMzjCD,EN0jCCpB,SMxjCL,GN0jCC2U,YACI/R,MMzjCD,IN0jCCxB,OMxjCL,GN0jCCwT,SACIhS,MMzjCD,IN0jCCxB,OMrjCb,KN0jCCyT,gBM1jCgB,SAASrf,GN2jCrB,GM1jCGsf,GAAO3jB,EAAYgjB,cACnBlY,EAAM9Y,EAAE0K,UACZinB,EN2jCC,OADA7Y,GM1jCGyY,YAAcI,EAAKJ,YACvBlf,GACHyG,GN4jCA8Y,cM1jCc,SAASzY,GN4jCnB,GM3jCGL,KN6jCH,KM3jCI,GAAIvI,KAAOvC,GAAYuiB,UN6jCvB,IM3jCI,GADDljB,GAAOW,EAAYuiB,UACvBhgB,GAAS3N,EAAI,EAAGhB,EAAMyL,EAAKqjB,OAAO7uB,OAAQe,EAAIhB,EAAKgB,IAC/C,CN2jCC,GM3jCGqtB,GAAO5iB,EAAKqjB,OAChB9tB,EN2jCC,IM3jCGqtB,IAAQ9W,GACR,CAAKL,EAAIvI,KN4jCJuI,EM5jCgBvI,MN8jCpB,IM7jCGqf,GAAKzW,EACT8W,EAAa,aAATA,GAA+B,gBAATA,IN8jCrBL,GM5jCJ,KN8jCA9W,EM7jCGvI,GAAKlD,EAAKojB,OAAO7tB,IACxBgtB,GNukCR,MMpkCG,cAAgBzW,KACXL,EAAI0X,SN8jCJ1X,EM9jCkB0X,WNgkCtB1X,EM/jCG0X,OAAOrc,IAAMgF,EAAM+E,WACvB,GN+jCCpF,EM/jCG0X,OAAOpc,IAAM+E,EAAM+E,WAC1B,IAEJpF,GNikCA+Y,gBM/jCgB,SAAS1Y,GNikCrB,GMhkCGsP,GAAI7lB,EAAG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,YAGpBxF,EAAE0K,OAAO1K,EAAEwF,SNkmCN0I,MMjmCMF,EACPE,MNimCCjC,aMjmCa,aNkmCbuS,MMjmCMxQ,EAAY4Q,KACnB,GNimCCH,OMjmCOzQ,EAAY4Q,KACpB,INimCC0X,OMjmCOtoB,EAAY4Q,KACpB,INimCC2X,OMjmCOvoB,EAAY+Q,KACpB,INimCC3O,YMjmCYpC,EACboC,YNimCCR,aMjmCa5B,EACd4B,aNimCCE,oBMjmCoB9B,EACrB8B,oBNimCCvE,QMjmCQyC,EACTzC,QNimCC4D,uBMjmCuBnB,EACxBmB,uBNimCC0iB,gBMjmCgB7jB,EACjB6jB,gBNimCCD,cMjmCc5jB,EACf4jB,cNimCCF,gBMjmCgB1jB,EACjB0jB,gBNimCCld,OMjmCOxG,EACRwG,ONimCCoB,kBMjmCkB5H,EACnB4H,kBNimCCzC,UMjmCUnF,EACXmF,UNimCCgf,eMjmCenkB,EAChBmkB,eNimCC1sB,mBMjmCmBuI,EACpBvI,mBNimCC4sB,WMjmCWrkB,EACZqkB,WNimCCK,WMjmCW1kB,EACZ0kB,WNimCCE,eMjmCe5kB,EAChB4kB,eNimCCvC,aMjmCariB,EACdqiB,aNimCCyC,kBMjmCkB9kB,EACnB8kB,kBNimCClK,kBMjmCkB,SAAU7Y,EAAQsC,GNkmChC,MMjmCMrE,GAAY,qBAAuBqE,EAAO,IAAM,KAAKtC,EAAOG,IAAKH,EAC3EE,MNkmCAkY,cMjmCcna,EACfma,cNimCCF,KMjmCKja,EACNia,KNimCC/P,QMjmCQlK,EACZkK,QNimCIJ,SMjmCM9J,EACP8J,SNimCCoQ,MMjmCMla,EACPka,MNimCCS,wBMjmCwB3a,EACzB2a,wBNimCCE,yBMjmCyB7a,EAC1B6a,yBNimCC0C,UMjmCUvd,EACXud,UNimCCqB,UMjmCU5e,EACX4e,UNimCCnB,iBMjmCiBzd,EAClByd,iBNimCCgB,QMjmCQze,EACTye,QNimCCC,aMjmCa1e,EACd0e,aNimCCc,QMjmCQxf,EACTwf,QNimCC4C,qBMjmCqBpiB,EACtBoiB,qBNimCCjU,WMjmCWnO,EACZmO,WNimCC2R,qBMjmCqB9f,EACtB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AAMh1B,GACdoB,EZyyJJ3R,GYxyJC2rB,WZ0yJG6Z,YYxyJY,SAASD,GZyyJjBp9B,KYxyJIs9B,UACRF,GZ0yJAG,YYxyJY,WZyyJR,MYxyJMr3B,QAAOs3B,UAAYx9B,KAAKs9B,WAClCJ,IZ2yJJrlC,EYxyJC4lC,gBZyyJGC,QYxyJQ,WZyyJJ,GYxyJGN,GAAO/8B,UAAU,GACjBs9B,EAAUt9B,UACd,EAAyB,KAArBA,UAAU3G,SZyyJTikC,EYvyJDP,EZwyJCA,EYvyJJ,KZyyJA,KYxyJI,GAAIn5B,KAAK05B,GZyyJT,GYxyJY,OAATP,EZyyJC,IYxyJI,GAAIQ,KAAMD,GAAQ15B,GZyyJlBk5B,EYxyJWl5B,EAAG25B,EAAID,EAAQ15B,GAAG25B,GACjC59B,UZ0yJAm9B,GYxyJWC,EAAMn5B,EAAG05B,EAAQ15B,GAChCjE,KZ0yJJ,OYvyJJA,OZ0yJAyjB,QYxyJQ,SAASrb,GZ6yJb,IYxyJI,GAJDg1B,GAAOvlC,EAAE2rB,UAAU+Z,cACnBM,EAAS79B,KAAKo9B,OAEdU,EAAS11B,EAAMA,EAAIiT,MAAM,SACpB5gB,EAAI,EAAGhB,EAAMqkC,EAAOpkC,OAAQe,EAAIhB,GAChCokC,EADqCpjC,IZ4yJzCojC,EY1yJQA,EAAOC,EACnBrjC,GZ2yJA,OYzyJJojC,KZ4yJJhmC,EY1yJC0K,OAAO1K,EAAE2rB,UAAW3rB,EACzB4lC,oBZ8yJK,SAAStmC,EAAQD,GAEtB,Yal2JDW,GAAE0K,OAAO1K,EAAE2rB,Wbq2JNua,KACIC,Yan2JD,abo2JCC,Oan2JD,Qbo2JCC,Wan2JD,kBbo2JCC,Wan2JD,iBbo2JCC,Kan2JD,Ubo2JCC,Uan2JD,Wbo2JC7Y,OACIjuB,Ean2JD,Ibo2JC+mC,Gan2JD,Sbo2JC/a,Gan2JD,Kbo2JC8D,Gan2JD,Qbo2JC7C,Ian2JD,Sbo2JC+Z,Gan2JD,Kbo2JCC,Oan2JD,Ubo2JCC,Qap2JQ,gBb22Jf,SAAStnC,EAAQD,GAEtB,Yc73JDW,GAAE0K,OAAO1K,EAAE2rB,Wdg4JNkb,KACIV,Yc93JD,cd+3JCC,Oc93JD,Sd+3JCC,Wc93JD,mBd+3JCC,Wc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ND,EpB4wNC/T,WoBzwNL,GpB4wNCn5B,WoB5wNW,SAAS5K,GpB6wNhBA,EoB5wNSJ,EAAEswC,WAAWnoC,KAEvB/H,GpB4wNC+H,KoB5wNIgwC,YAAc,GAAIn4C,GAAEC,IAEzBwH,SpB4wNCU,KoB5wNIiwC,cpB6wNJjwC,KoB5wNIkwC,kBpB8wNJlwC,KoB5wNImwC,mBpB8wNJnwC,KoB5wNIowC,cAAe,EpB6wNnBpwC,KoB5wNIqwC,mBpB8wNJ,IoB5wNG9rC,GAEJvE,IpB4wNCA,MoB5wNIswC,MpB6wNA5pC,SoB5wNSkqB,EAAA/qB,YAAYY,kBAAkBxO,EAAQyO,UAChD,uBpB4wNCmuB,QoB5wNQ58B,EACTu9B,MpB4wNCua,SoB5wNS93C,EACV83C,SpB4wNCxoC,QoB5wNQtP,EACTsP,QpB4wNC84B,UoB5wNUpoC,EACXooC,UpB4wNCE,QoB5wNQtoC,EACTsoC,QpB4wNCgQ,UoB5wNUt4C,EAAQs4C,WACnB,KpB4wNCC,OoB5wNOv4C,EAAQu4C,WpB6wNfC,qBACAC,aoB3wND,EpB4wNCC,YoB3wND,EpB4wNCC,YoB3wND,EpB4wNCC,eACAC,kBACAC,gBoB1wND94C,EAAQuM,cpB6wNPxE,KoB5wNIswC,KAAK9rC,YAAcvM,EAC3BuM,apB8wNAxE,KoB5wNI6vB,GAAG,aAAc,SAASzmB,GpB6wN1B7E,EoB5wNKysC,uBAAuB5nC,EAAE+5B,KAClC8N,SpBgxNJC,YoB5wNY,SAAUD,GpB6wNlB,GoB5wNGE,GAAWnxC,KAAKipC,OACpBgI,EpB4wNC,IoB5wNGE,EACA,CpB4wNC,GoB5wNGhO,GAAOgO,EACXC,EAAIjO,IAAQA,EAAK95B,YpB6wNZ85B,EoB5wNI95B,WAAWC,YACnB65B,SAEMnjC,MAAKipC,OACfgI,KpB+wNJI,MoB5wNM,SAAS/1B,GpB6wNX,GoB5wNGA,EAAIrjB,QAAQmnB,MAAQvnB,EAAEiuB,IAAIC,UAAYzK,EAAIrjB,QAAQmnB,MAAQvnB,EAAEiuB,IAAIwrB,SpB6wN/D,KoB3wNJ,sEpB6wNA,IoB5wNGx5C,GAAMkI,KAEVswC,IpB4wNCx4C,GoB5wNGy5C,OA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BpvD,GAAEC,IAAIwH,UtB++R/B2nD,EsB9+RcpmD,KACdA,GACqB,OAAfomD,GtB++RVz9C,EsB9+RQ6pB,aACL,EACHwzB,KAEAhmD,KtBi/RZqlD,GAAmBS,EsB9+RgBrrC,IAAI,SAASzX,GtB++R5C,GsB9+RGsjD,GAAS5iD,EAAM8/C,mBAAmBxgD,EACtCygD,EtBi/RC,OAHA6C,GsB9+RMtmD,KAAK,SAASumD,GtB++RhBN,EsB9+RcM,EAAWnM,IAAKp3C,EAAIujD,EACtC/jD,QACDwjD,GACHM,ItBg/RAhB,EsB9+RgBtlD,KAAK,WtB++RjB0xB,EsB9+ROD,GACRk0B,EtB8+RCE,EsB7+RJjmD,gBAED,CtB++RC+I,EsB9+RI6pB,aACL,CtB8+RC,IsB9+RGg0B,GAAc,SAASjxC,GtB++RtB,GsB9+RGkxC,ItB++RCxvD,IsB7+RDA,EtB8+RCs6B,QsB7+RDhmB,EtB8+RC5C,KsB7+RDA,EtB8+RCy2B,asB5+RLA,EAAKumB,KtB++RAA,EsB9+RWpgD,SAASuC,cACrB,UtB8+RC69C,EsB9+RSpiD,MAAQoiD,EAAU1zC,OAC/B,ItB++RA,IsB9+RGy0C,GAAc,SAASC,GtB++RtB,GsB9+RGvyB,GAAA1wB,EAAgBugD,atB++Rf1yB,QsB7+RGhmB,EtB8+RHvN,IsB7+RG2nD,EtB8+RHnjD,MsB9+RUijD,EAA0BA,EAAwBkB,EAAcF,GACvEE,EtB8+RHvC,qBsB7+RGhlB,EtB8+RHn+B,IsB9+RQA,IAETjB,EAAO,WtB++RN0xB,EsB9+RWD,GACRk0B,EtB8+RHE,EsB7+RAjmD,UACDw0B,GACIA,YAAmBp9B,GAAEC,IAAIwH,UtB++RxB21B,EsB9+ROp0B,KACXA,GACkB,OAAZo0B,GtB++RNzrB,EsB9+RI6pB,aACL,EtB8+RCqzB,EsB7+RJjmD,WAEAI,ItBg/RJ0mD,GsB7+RDnxC,SAAO7R,GAAM2/C,eAChBpiD,GACG2kD,GtB++RCY,EsB7+RJZ,GtB++RIN,EsB9+RgBtlD,KAAKwmD,EAAYnlD,KAAKlC,MAAO0mD,EACjDjmD,StBs/RJ,MANAimD,GsB9+RiBrlD,OAAO,WtB++Rp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AK0tB,MAAQ,OAAUwZ,EAAc5/C,K1BulV1FihC,E0BrlVRmF,S1B0lVJka,W0BplVLA,E1BslVKla,I0BtlVA,WACHsZ,G1BulVWxkB,a0BvlV4BwkB,G1BylVhCA,E0BxlVC30B,WAAWu1B,EACpB,I1B0lVIY,K0BxlVC,WACEzB,G1BylVK0B,c0BzlVqC1B,G1B2lVzCA,E0BzlVR,M1B4lVIwB,M0B1lVE,SAASG,GACRA,I1B2lVK7B,E0B3lVkB6B,G1B6lVtBngB,E0B3lVLigB,O1B4lVKzB,E0B5lVQ4B,YAAYf,EAC5Bf,IAGA94D,GAAEC,M1B6lVED,E0B7lVOC,Q1B+lVXD,E0B9lVHC,IAAIu6C,cAENA,E1B8lVKx6C,E0B9lVHC,IAAI43C,YAAYua,S1B+lVT9b,c0B9lVU,SAAUukB,G1B+lVhB,G0B9lVDA,EACA,C1B8lVK,G0B9lVD56D,GAAMkI,KACVswC,IAAIoiB,GAAiBrrD,W1B+lVZvP,E0B9lVDuP,SAAWqrD,EAClBrrD,UACGqrD,EAAiBhjD,a1B+lVZ7X,E0B9lVH0K,OAAOzK,EAAI4X,WAAYgjD,EACzBhjD,Y1B8lVK5X,E0B9lVD4X,WAAWs4B,cAAgB0qB,EAAiBhjD,WAChDs4B,c1B8lVKlwC,E0B9lVD+9C,cAAgB/9C,EACpB4X,W1B8lVK1P,K0B9lVA0D,KACjB,iBAAK5L,EAAIm/B,Y1B+lVYn/B,E0B9lVhBkgC,YAAYmW,cAAcr2C,EAC9B+9C,wB1BumVC,SAAS1+C,EAAQD,GAEtB,Y2Bp1VDW,GAAEC,IAAI66D,YAAA96D,EAAgBC,IAAI43C,YAAYntC,Q3Bw1VjCtK,SACI8nC,e2Br1VD,E3Bs1VCpE,a2Br1VD,G3Bw1VH+Z,oB2Bt1VoB,SAAS3rC,G3Bu1VzB,G2Bt1VG9M,GAAQ8M,EAAG2F,WACX8gC,EAASvzC,EAAMuzC,OAAO,KAAO1nB,QAAS7rB,EAAM6rB,SAAW,EAAGC,QAAS9rB,EAAM8rB,SAAW,IACpF6pC,G3Bu1VC1oD,K2Br1VG,S3Bs1VH+lD,S2Bt1VahzD,EACViN,K3Bs1VH6gB,c2Br1VG,U3Bs1VH0xB,a2Br1VG,U3Bs1VHU,iB2Br1VG,E3Bs1V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","file":"./dist/geomixer.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\tvar _MapManager = __webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\tvar _Observer = __webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\tvar _DataManager = __webpack_require__(17);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(20);\n\t\n\t__webpack_require__(21);\n\t\n\t__webpack_require__(19);\n\t\n\t__webpack_require__(22);\n\t\n\t__webpack_require__(23);\n\t\n\t__webpack_require__(24);\n\t\n\t__webpack_require__(25);\n\t\n\t__webpack_require__(26);\n\t\n\t__webpack_require__(27);\n\t\n\t__webpack_require__(28);\n\t\n\t__webpack_require__(29);\n\t\n\t__webpack_require__(30);\n\t\n\t__webpack_require__(31);\n\t\n\t__webpack_require__(32);\n\t\n\t__webpack_require__(33);\n\t\n\t__webpack_require__(34);\n\t\n\t__webpack_require__(35);\n\t\n\t__webpack_require__(36);\n\t\n\tL.gmx = L.gmx || {};\n\t\n\t// import './commonjs.js';\n\tL.gmx.gmxMapManager = _MapManager.gmxMapManager;\n\tL.gmx.observer = function (options) {\n\t  return new _Observer.Observer(options);\n\t};\n\tL.gmx.DataManager = _DataManager.DataManager;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t   Single-pass recursive descent PEG parser library:\r\n\t      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n\t   Inspired by Chris Double's parser combinator library in JavaScript:\r\n\t      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t\t+ Добавлены функции: Math.floor\r\n\t*/\n\t(function () {\n\t\tvar regexExpression = /\\[(.+?)\\]/g,\n\t\t    regexMath = /(floor\\()/g;\n\t\tvar Parsers = { // Парсеры\n\t\t\tfunctionFromExpression: function functionFromExpression(s) {\n\t\t\t\t/*eslint-disable no-new-func*/\n\t\t\t\treturn new Function(\n\t\t\t\t/*eslint-enable */\n\t\t\t\t'props', 'indexes', 'return ' + s.replace(regexExpression, 'props[indexes[\"$1\"]]').replace(regexMath, 'Math.$1') + ';');\n\t\t\t}\n\t\t};\n\t\n\t\tvar makePair = function makePair(t1, t2) {\n\t\t\treturn { head: t1, tail: t2 };\n\t\t};\n\t\n\t\t// C-style linked list via recursive typedef.\n\t\t//   Used purely functionally to get shareable sublists.\n\t\t//typedef LinkedList = Pair<Dynamic, LinkedList>;\n\t\tvar LinkedList = function LinkedList(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser state contains position in string and some accumulated data.\n\t\t//typedef ParserState = Pair<Int, LinkedList>;\n\t\tvar ParserState = function ParserState(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser accepts string and state, returns another state.\n\t\t//typedef Parser = String->ParserState->ParserState;\n\t\n\t\t// A parser state that indicates failure.\n\t\tvar fail = new ParserState(-1, null);\n\t\n\t\t// Check for failure.\n\t\tvar failed = function failed(state) {\n\t\t\treturn state.head === -1;\n\t\t};\n\t\n\t\t// Advance a parser state by n characters.\n\t\tvar advance = function advance(state, n) {\n\t\t\treturn new ParserState(state.head + n, state.tail);\n\t\t};\n\t\n\t\t// Match a specified string.\n\t\tvar token = function token(tok) {\n\t\t\tvar len = tok.length;\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len) === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a string without regard to case.\n\t\tvar caseInsensitiveToken = function caseInsensitiveToken(tok) {\n\t\t\tvar len = tok.length;\n\t\t\ttok = tok.toLowerCase();\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len).toLowerCase() === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a single character in a specified range.\n\t\tvar range = function range(startChar, endChar) {\n\t\t\tvar startCode = startChar.charCodeAt(0);\n\t\t\tvar endCode = endChar.charCodeAt(0);\n\t\t\treturn function (s, state) {\n\t\t\t\tvar code = s.charCodeAt(state.head);\n\t\t\t\treturn code >= startCode && code <= endCode ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match any character outside a certain set.\n\t\t//   This combinator is intended only for single character parsers.\n\t\tvar anythingExcept = function anythingExcept(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.length > state.head && failed(parser(s, state)) ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, then thing2, ..., then thingN.\n\t\tvar sequence = function sequence(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tstate = parsers[i](s, state);\n\t\t\t\t\tif (failed(state)) {\n\t\t\t\t\t\treturn fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn state;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, or thing2, ..., or thingN.\n\t\tvar choice = function choice(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tvar newState = parsers[i](s, state);\n\t\t\t\t\tif (!failed(newState)) {\n\t\t\t\t\t\treturn newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match immediately, without regard to what's in the string.\n\t\tvar nothing = function nothing(s, state) {\n\t\t\treturn state;\n\t\t};\n\t\n\t\t// Match this thing or nothing.\n\t\tvar maybe = function maybe(parser) {\n\t\t\treturn choice([parser, nothing]);\n\t\t};\n\t\n\t\t// Match minCount or more repetitions of this thing.\n\t\tvar repeat = function repeat(minCount, parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar count = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tvar newState = parser(s, state);\n\t\t\t\t\tif (failed(newState)) {\n\t\t\t\t\t\treturn count >= minCount ? state : fail;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// return fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a list of minCount or more instances of thing1, separated by thing2.\n\t\tvar separatedList = function separatedList(minCount, parser, separator) {\n\t\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\n\t\t\treturn minCount > 0 ? parser1 : choice([parser1, nothing]);\n\t\t};\n\t\n\t\tvar whitespace = repeat(0, choice([token(' '), token('\\t'), token('\\n')]));\n\t\n\t\t// Same as separatedList, but can have whitespace between items and separators.\n\t\tvar whitespaceSeparatedList = function whitespaceSeparatedList(minCount, parser, separator) {\n\t\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\n\t\t};\n\t\n\t\t// Same as sequence, but can have whitespace between items.\n\t\tvar whitespaceSeparatedSequence = function whitespaceSeparatedSequence(parsers) {\n\t\t\tvar newParsers = [];\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\tif (newParsers.length > 0) {\n\t\t\t\t\tnewParsers.push(whitespace);\n\t\t\t\t}\n\t\t\t\tnewParsers.push(parsers[i]);\n\t\t\t}\n\t\t\treturn sequence(newParsers);\n\t\t};\n\t\n\t\t// This combinator captures the string that the parser matched\n\t\t//   and adds it to the current parser state, consing a new state.\n\t\tvar capture = function capture(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar newState = parser(s, state);\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// This combinator passes the accumulated parser state to a given\n\t\t//  function for processing. The result goes into the new state.\n\t\tvar action = function action(parser, func) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar oldState = state;\n\t\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// Define a syntactic subset of SQL WHERE clauses.\n\t\tvar fieldName = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('а', 'я'), range('А', 'Я'), range('0', '9'), token('_')])));\n\t\n\t\tvar fieldNameWithSpaces = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('а', 'я'), range('А', 'Я'), range('0', '9'), token('_'), token(' ')])));\n\t\n\t\tvar quotedFieldName = choice([fieldName, sequence([token('\"'), fieldNameWithSpaces, token('\"')]), sequence([token('`'), fieldNameWithSpaces, token('`')])]);\n\t\n\t\tvar stringLiteral = sequence([token('\\''), capture(repeat(0, anythingExcept(token('\\'')))), token('\\'')]);\n\t\n\t\tvar digits = repeat(1, range('0', '9'));\n\t\n\t\tvar numberLiteral = capture(sequence([maybe(token('-')), digits, maybe(sequence([token('.'), digits]))]));\n\t\n\t\tvar literal = choice([numberLiteral, stringLiteral]);\n\t\n\t\tvar applyParser = function applyParser(s, parser) {\n\t\t\treturn parser(s, new ParserState(0, null));\n\t\t};\n\t\n\t\t// Order is important here: longer ops should be tried first.\n\t\tvar opTerm = action(whitespaceSeparatedSequence([quotedFieldName, capture(choice([token('=='), token('!='), token('<>'), token('<='), token('>='), token('='), token('<'), token('>'), caseInsensitiveToken('LIKE')])), choice([literal, quotedFieldName])]), function (state) {\n\t\t\t// Linked list contains fieldname, operation, value\n\t\t\t// (in reverse order).\n\t\n\t\t\tvar fieldName = state.tail.tail.head;\n\t\t\tvar op = state.tail.head;\n\t\t\tvar referenceValue = state.head;\n\t\n\t\t\tvar matchPattern = null;\n\t\t\tif (op.toUpperCase() === 'LIKE') {\n\t\t\t\tmatchPattern = function matchPattern(fieldValue) {\n\t\t\t\t\tvar _matchFrom = null;\n\t\t\t\t\t_matchFrom = function matchFrom(referenceIdx, fieldIdx) {\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\n\t\t\t\t\t\tif (referenceChar === '') {\n\t\t\t\t\t\t\treturn fieldChar === '';\n\t\t\t\t\t\t} else if (referenceChar === '%') {\n\t\t\t\t\t\t\treturn _matchFrom(referenceIdx + 1, fieldIdx) || fieldChar !== '' && _matchFrom(referenceIdx, fieldIdx + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn referenceChar === fieldChar && _matchFrom(referenceIdx + 1, fieldIdx + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn _matchFrom(0, 0);\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\n\t\t\t\t    rValue = referenceValue;\n\t\t\t\tif (referenceValue in indexes) {\n\t\t\t\t\trValue = props[indexes[rValue]];\n\t\t\t\t}\n\t\t\t\tif (types[fieldName] === 'date' && typeof rValue === 'string') {\n\t\t\t\t\trValue = L.gmxUtil.getUnixTimeFromStr(rValue);\n\t\t\t\t}\n\t\t\t\tif (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\n\t\t\t\t\tfieldValue = fieldValue ? 'True' : 'False';\n\t\t\t\t}\n\t\t\t\tif (fieldValue === null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (matchPattern !== null) {\n\t\t\t\t\treturn matchPattern(fieldValue);\n\t\t\t\t\t/*eslint-disable eqeqeq */\n\t\t\t\t} else if (op === '=' || op === '==') {\n\t\t\t\t\treturn fieldValue == rValue;\n\t\t\t\t} else if (op === '!=' || op === '<>') {\n\t\t\t\t\treturn fieldValue != rValue;\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t} else {\n\t\t\t\t\tvar f1, f2;\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\n\t\t\t\t\t\tf2 = parseFloat(rValue);\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf1 = fieldValue;\n\t\t\t\t\t\tf2 = rValue;\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\tvar inTerm = action(whitespaceSeparatedSequence([quotedFieldName, caseInsensitiveToken('IN'), token('('), whitespaceSeparatedList(0, literal, token(',')), token(')')]), function (state) {\n\t\t\t// Linked list contains fieldname and multiple values\n\t\t\t//   (in reverse order).\n\t\n\t\t\tvar node = state;\n\t\t\twhile (node.tail != null) {\n\t\t\t\tnode = node.tail;\n\t\t\t}\n\t\t\tvar fieldName = node.head;\n\t\n\t\t\treturn function (props, indexes) {\n\t\t\t\tvar value = props[indexes[fieldName]];\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node.tail !== null) {\n\t\t\t\t\tif (node.head === value) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\t});\n\t\n\t\t// Forward declarations to allow mutually recursive grammar definitions.\n\t\tvar _term = function term(s, state) {\n\t\t\treturn _term(s, state);\n\t\t};\n\t\tvar _expression = function expression(s, state) {\n\t\t\treturn _expression(s, state);\n\t\t};\n\t\n\t\tvar notTerm = action(whitespaceSeparatedSequence([caseInsensitiveToken('NOT'), _term]), function (state) {\n\t\t\t// Linked list contains only processed inner term.\n\t\t\tvar innerTerm = state.head;\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn !innerTerm(props, indexes, types);\n\t\t\t};\n\t\t});\n\t\n\t\t_term = choice([notTerm, opTerm, inTerm, whitespaceSeparatedSequence([token('('), _expression, token(')')])]);\n\t\n\t\t// AND and OR expressions must have at least 2 terms,\n\t\t//   to disambiguate them from a single term.\n\t\n\t\tvar andExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('AND')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = true;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\tvar orExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('OR')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = false;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\t// Order is important here: term should be tried last,\n\t\t//   because andExpression and orExpression start with it.\n\t\t_expression = choice([andExpression, orExpression, _term]);\n\t\n\t\tvar whereClause = sequence([whitespace, _expression, whitespace]);\n\t\n\t\tParsers.parseSQL = function (str) {\n\t\t\tvar result = applyParser(str, whereClause);\n\t\t\treturn result.head === str.length ? result.tail.head : applyParser(str, whitespace).head === str.length ? function () /*props*/{\n\t\t\t\treturn true;\n\t\t\t} : null;\n\t\t};\n\t\n\t\tvar _additiveExpression = function additiveExpression(s, state) {\n\t\t\treturn _additiveExpression(s, state);\n\t\t};\n\t\tvar _multiplicativeExpression = function multiplicativeExpression(s, state) {\n\t\t\treturn _multiplicativeExpression(s, state);\n\t\t};\n\t\t_additiveExpression = action(whitespaceSeparatedList(1, _multiplicativeExpression, capture(choice([token('+'), token('-')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 0.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm += pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '-') {\n\t\t\t\t\t\t\tterm = -term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tvar multiplicativeTerm = choice([action(numberLiteral, function (state) {\n\t\t\treturn function () /*props, indexes, types*/{\n\t\t\t\treturn parseFloat(state.head);\n\t\t\t};\n\t\t}), action(sequence([token('floor('), _additiveExpression, token(')')]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar res = state.head(props, indexes, types);\n\t\t\t\treturn Math.floor(res);\n\t\t\t};\n\t\t}), action(sequence([token('['), fieldName, token(']')]), function (state) {\n\t\t\treturn function (props, indexes) {\n\t\t\t\treturn parseFloat(props[indexes[state.head]]);\n\t\t\t};\n\t\t}), whitespaceSeparatedSequence([token('('), _additiveExpression, token(')')])]);\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\t_multiplicativeExpression = action(whitespaceSeparatedList(1, multiplicativeTerm, capture(choice([token('*'), token('/')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 1.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '/') {\n\t\t\t\t\t\t\tterm = 1.0 / term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\n\t\tvar arithmeticExpression = sequence([whitespace, _additiveExpression, whitespace]);\n\t\tParsers.parseExpression = function (s) {\n\t\t\tvar result = applyParser(s, arithmeticExpression);\n\t\t\treturn result.head === s.length ? result.tail.head : null;\n\t\t\t// return result.head === s.length ? Parsers.functionFromExpression(s) : null;\n\t\t};\n\t\n\t\tvar svgPath = action(repeat(0, choice([numberLiteral, token(','), token('M'), token('C'), repeat(1, choice([token(' '), token('\\t'), token('\\r'), token('\\n')]))])), function (state) {\n\t\t\tvar coords = [];\n\t\t\twhile (state !== null) {\n\t\t\t\tcoords.push(parseFloat(state.head));\n\t\t\t\tstate = state.tail;\n\t\t\t}\n\t\t\tcoords.reverse();\n\t\t\treturn coords;\n\t\t});\n\t\n\t\tParsers.parseSVGPath = function (s) {\n\t\t\tvar result = applyParser(s, svgPath);\n\t\t\tif (result.head === s.length) {\n\t\t\t\treturn result.tail.head;\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t\n\t\t//extend L.gmx namespace\n\t\tL.gmx = L.gmx || {};\n\t\tL.gmx.Parsers = Parsers;\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t//all the methods can be called without instance itself\n\t//For example:\n\t//\n\t// var def = new Deferred();\n\t// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\n\tvar Deferred = function Deferred(cancelFunc) {\n\t    var resolveCallbacks = [],\n\t        rejectCallbacks = [],\n\t        isFulfilled = false,\n\t        isResolved = false,\n\t        fulfilledData,\n\t        onceAdded = false,\n\t        isCancelled = false;\n\t\n\t    var fulfill = this._fulfill = function (resolved /*, data*/) {\n\t        if (isFulfilled) {\n\t            return;\n\t        }\n\t        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\n\t        fulfilledData = [].slice.call(arguments, 1);\n\t        isFulfilled = true;\n\t        isResolved = resolved;\n\t\n\t        callbacks.forEach(function (callback) {\n\t            callback.apply(null, fulfilledData);\n\t        });\n\t        resolveCallbacks = rejectCallbacks = [];\n\t    };\n\t\n\t    this.resolve = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    this.reject = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    var cancel = this.cancel = function () {\n\t        if (!isCancelled && !isFulfilled) {\n\t            isCancelled = true;\n\t            cancelFunc && cancelFunc();\n\t        }\n\t    };\n\t\n\t    var then = this.then = function (resolveCallback, rejectCallback) {\n\t        if (isCancelled) {\n\t            return null;\n\t        }\n\t\n\t        var userFuncDef = null;\n\t        var def = new Deferred(function () {\n\t            cancel();\n\t            userFuncDef && userFuncDef.cancel();\n\t        });\n\t\n\t        var fulfillFunc = function fulfillFunc(func, resolved) {\n\t            return function () /*data*/{\n\t                if (!func) {\n\t                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\n\t                } else {\n\t                    var res = func.apply(null, arguments);\n\t                    if (res instanceof Deferred) {\n\t                        userFuncDef = res;\n\t                        res.then(def.resolve, def.reject);\n\t                    } else {\n\t                        def.resolve(res);\n\t                    }\n\t                }\n\t            };\n\t        };\n\t\n\t        if (isFulfilled) {\n\t            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\n\t        } else {\n\t            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\n\t            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\n\t        }\n\t        return def;\n\t    };\n\t\n\t    this.once = function (onceResolveCallback) {\n\t        if (!onceAdded) {\n\t            onceAdded = true;\n\t            then(onceResolveCallback);\n\t        }\n\t    };\n\t\n\t    this.always = function (callback) {\n\t        then(callback, callback);\n\t    };\n\t\n\t    this.getFulfilledData = function () {\n\t        return fulfilledData;\n\t    };\n\t};\n\t\n\tDeferred.all = function () {\n\t    var defArray = [].slice.apply(arguments);\n\t    var resdef = new Deferred();\n\t    var left = defArray.length;\n\t    var results = new Array(defArray.length);\n\t\n\t    if (left) {\n\t        defArray.forEach(function (def, i) {\n\t            def.then(function (res) {\n\t                results[i] = res;\n\t                left--;\n\t                if (left === 0) {\n\t                    resdef.resolve.apply(resdef, results);\n\t                }\n\t            }, function () {\n\t                resdef.reject();\n\t            });\n\t        });\n\t    } else {\n\t        resdef.resolve();\n\t    }\n\t\n\t    return resdef;\n\t};\n\t\n\tL.gmx = L.gmx || {};\n\tL.gmx.Deferred = Deferred;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\n\t    var ImageRequest = function ImageRequest(id, url, options) {\n\t        this._id = id;\n\t        this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\n\t        this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\n\t        this.url = url;\n\t        this.options = options || {};\n\t    };\n\t\n\t    var GmxImageLoader = L.Class.extend({\n\t        includes: L.Mixin.Events,\n\t        statics: {\n\t            MAX_COUNT: 20 // max number of parallel requests\n\t        },\n\t\n\t        initialize: function initialize() {\n\t            this.curCount = 0; // number of currently processing requests (number of items in \"inProgress\")\n\t            this.requests = []; // not yet processed image requests\n\t            this.inProgress = {}; // hash of in progress image loadings\n\t            this.requestsCache = {}; // for requests cache by uniqueID\n\t            this.uniqueID = 0;\n\t        },\n\t\n\t        _resolveRequest: function _resolveRequest(request, image, canceled) {\n\t            var def = request.def;\n\t            if (image) {\n\t                if (!canceled && request.options.cache) {\n\t                    var url = request.url,\n\t                        cacheItem = this.requestsCache[url],\n\t                        cacheKey = request._id;\n\t                    if (!cacheItem) {\n\t                        cacheItem = this.requestsCache[url] = { image: image, requests: {} };\n\t                    }\n\t                    if (!cacheItem.requests[cacheKey]) {\n\t                        cacheItem.requests[cacheKey] = request;\n\t                    }\n\t                }\n\t                def.resolve(image);\n\t            } else if (!canceled) {\n\t                def.reject();\n\t            }\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _imageLoaded: function _imageLoaded(url, image, canceled) {\n\t            if (url in this.inProgress) {\n\t                var resolveRequest = function resolveRequest(it) {\n\t                    this._resolveRequest(it, image, canceled);\n\t                };\n\t                this.inProgress[url].requests.forEach(resolveRequest.bind(this));\n\t                --this.curCount;\n\t                delete this.inProgress[url];\n\t            }\n\t            L.gmxUtil.loaderStatus(url, true);\n\t            this.fire('imageloaded', { url: url });\n\t            this._nextLoad();\n\t        },\n\t\n\t        _nextLoad: function _nextLoad() {\n\t            // загрузка следующего\n\t            if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\n\t                return;\n\t            }\n\t\n\t            var request = this.requests.shift(),\n\t                url = request.url;\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                var requests = [request];\n\t                this.inProgress[url] = { requests: requests };\n\t                ++this.curCount;\n\t\n\t                for (var k = this.requests.length - 1; k >= 0; k--) {\n\t                    if (this.requests[k].url === url) {\n\t                        requests.push(this.requests[k]);\n\t                        this.requests.splice(k, 1);\n\t                    }\n\t                }\n\t\n\t                var image = this._loadImage(request);\n\t                if (!image.width) {\n\t                    L.gmxUtil.loaderStatus(url);\n\t                }\n\t\n\t                //theoretically image loading can be synchronous operation\n\t                if (this.inProgress[url]) {\n\t                    this.inProgress[url].image = image;\n\t                }\n\t            }\n\t        },\n\t\n\t        _loadImage: function _loadImage(request) {\n\t            var imageObj = new Image(),\n\t                url = request.url,\n\t                _this = this;\n\t\n\t            if (request.options.crossOrigin) {\n\t                imageObj.crossOrigin = request.options.crossOrigin;\n\t            }\n\t\n\t            imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\n\t            imageObj.onerror = function () {\n\t                _this._imageLoaded(url);\n\t            };\n\t            imageObj.src = url;\n\t\n\t            this.fire('imageloadstart', { url: url });\n\t\n\t            return imageObj;\n\t        },\n\t\n\t        _cancelRequest: function _cancelRequest(request) {\n\t            var id = request._id,\n\t                url = request.url,\n\t                i = 0,\n\t                len;\n\t            if (url in this.inProgress) {\n\t                var loadingImg = this.inProgress[url],\n\t                    requests = loadingImg.requests;\n\t\n\t                len = requests.length;\n\t                if (len === 1 && requests[0]._id === id) {\n\t                    loadingImg.image.onload = L.Util.falseFn;\n\t                    loadingImg.image.onerror = L.Util.falseFn;\n\t                    loadingImg.image.src = L.Util.emptyImageUrl;\n\t                    this._imageLoaded(url, null, true);\n\t                } else {\n\t                    for (i = 0; i < len; i++) {\n\t                        if (requests[i]._id === id) {\n\t                            requests.splice(i, 1);\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (i = 0, len = this.requests.length; i < len; i++) {\n\t                    if (this.requests[i]._id === id) {\n\t                        this.requests.splice(i, 1);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _removeRequestFromCache: function _removeRequestFromCache(request) {\n\t            // remove request from cache\n\t            this._cancelRequest(request);\n\t            this._clearCacheItem(request.url, request._id);\n\t        },\n\t\n\t        _clearCacheItem: function _clearCacheItem(url, cacheKey) {\n\t            // remove cache item\n\t            if (this.requestsCache[url]) {\n\t                var cacheItem = this.requestsCache[url];\n\t                delete cacheItem.requests[cacheKey];\n\t                if (Object.keys(cacheItem.requests).length === 0) {\n\t                    delete this.requestsCache[url];\n\t                }\n\t            }\n\t        },\n\t        _add: function _add(atBegin, url, options) {\n\t            var id = 'id' + ++this.uniqueID,\n\t                request = new ImageRequest(id, url, options);\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                atBegin ? this.requests.unshift(request) : this.requests.push(request);\n\t                this._nextLoad();\n\t            }\n\t\n\t            this.fire('request', { request: request });\n\t\n\t            return request;\n\t        },\n\t\n\t        push: function push(url, options) {\n\t            // добавить запрос в конец очереди\n\t            return this._add(false, url, options);\n\t        },\n\t\n\t        unshift: function unshift(url, options) {\n\t            // добавить запрос в начало очереди\n\t            return this._add(true, url, options);\n\t        }\n\t    });\n\t\n\t    L.gmx.imageLoader = new GmxImageLoader();\n\t})();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\r\n\t* @name L.gmxUtil\r\n\t* @namespace\r\n\t*/\n\tvar gmxAPIutils = {\n\t    lastMapId: 0,\n\t\n\t    newId: function newId() {\n\t        gmxAPIutils.lastMapId += 1;\n\t        return '_' + gmxAPIutils.lastMapId;\n\t    },\n\t\n\t    uniqueGlobalName: function uniqueGlobalName(thing) {\n\t        var id = gmxAPIutils.newId();\n\t        window[id] = thing;\n\t        return id;\n\t    },\n\t\n\t    isPageHidden: function isPageHidden() {\n\t        // Видимость окна браузера\n\t        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\n\t    },\n\t\n\t    normalizeHostname: function normalizeHostname(hostName) {\n\t        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\n\t\n\t        hostName = parsedHost.host + parsedHost.directory;\n\t\n\t        if (hostName[hostName.length - 1] === '/') {\n\t            hostName = hostName.substring(0, hostName.length - 1);\n\t        }\n\t\n\t        return hostName;\n\t    },\n\t\n\t    getLayerItemFromServer: function getLayerItemFromServer(options) {\n\t        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\n\t            req = {\n\t            WrapStyle: 'func',\n\t            geometry: true,\n\t            layer: options.layerID,\n\t            query: query\n\t        };\n\t        if (options.border) {\n\t            req.border = options.border;\n\t        }\n\t        return gmxAPIutils.requestJSONP(options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx', req, options);\n\t    },\n\t\n\t    getCadastreFeatures: function getCadastreFeatures(options) {\n\t        // example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\n\t        if (options.latlng) {\n\t            var latlng = options.latlng,\n\t                req = {\n\t                WrapStyle: 'func',\n\t                text: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\n\t                tolerance: options.tolerance || 0\n\t            };\n\t            return gmxAPIutils.requestJSONP(options.url || 'http://pkk5.rosreestr.ru/api/features/', req, options);\n\t        } else {\n\t            return null;\n\t        }\n\t    },\n\t\n\t    getFormData: function getFormData(json) {\n\t        var arr = [];\n\t        for (var key in json) {\n\t            var val = json[key];\n\t            arr.push(key + '=' + ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val) : val));\n\t        }\n\t        return arr.join('&');\n\t    },\n\t\n\t    /** Sends JSONP requests\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} url - request URL\r\n\t     * @param {Object} params - request params\r\n\t     * @param {Object} [options] - additional request options\r\n\t     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n\t       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n\t     * @return {Deferred} Promise with server JSON response or with error status\r\n\t    */\n\t    requestJSONP: function requestJSONP(url, params, options) {\n\t        options = options || {};\n\t        var def = new L.gmx.Deferred();\n\t\n\t        var script = document.createElement('script');\n\t        script.setAttribute('charset', 'UTF-8');\n\t        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\n\t        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\n\t\n\t        if (callbackParamName) {\n\t            var callbackName = gmxAPIutils.uniqueGlobalName(function (obj) {\n\t                delete window[callbackName];\n\t                def.resolve(obj, options);\n\t            });\n\t\n\t            urlParams[callbackParamName] = callbackName;\n\t        }\n\t\n\t        var paramsStringItems = [];\n\t\n\t        for (var p in urlParams) {\n\t            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\n\t        }\n\t\n\t        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\n\t\n\t        script.onerror = function (e) {\n\t            def.reject(e);\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        script.onload = function () {\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        L.gmxUtil.loaderStatus(src, null, 'vector');\n\t        script.setAttribute('src', src);\n\t\n\t        document.getElementsByTagName('head').item(0).appendChild(script);\n\t        return def;\n\t    },\n\t    getXmlHttp: function getXmlHttp() {\n\t        var xmlhttp;\n\t        if (typeof XMLHttpRequest !== 'undefined') {\n\t            xmlhttp = new XMLHttpRequest();\n\t        } else {\n\t            try {\n\t                xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\n\t            } catch (e) {\n\t                try {\n\t                    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n\t                } catch (E) {\n\t                    xmlhttp = false;\n\t                }\n\t            }\n\t        }\n\t        return xmlhttp;\n\t    },\n\t    request: function request(ph) {\n\t        // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\n\t        var xhr = gmxAPIutils.getXmlHttp();\n\t        if (xhr) {\n\t            xhr.open(ph.type ? ph.type : 'GET', ph.url, ph.async || false);\n\t            if (ph.headers) {\n\t                for (var key in ph.headers) {\n\t                    xhr.setRequestHeader(key, ph.headers[key]);\n\t                }\n\t            }\n\t            var reqId = L.gmxUtil.loaderStatus();\n\t            if (ph.async) {\n\t                if (ph.withCredentials) {\n\t                    xhr.withCredentials = true;\n\t                }\n\t                xhr.onreadystatechange = function () {\n\t                    if (xhr.readyState === 4) {\n\t                        L.gmxUtil.loaderStatus(reqId, true);\n\t                        if (xhr.status === 200) {\n\t                            ph.callback(xhr.responseText);\n\t                            xhr = null;\n\t                        } else if (ph.onError) {\n\t                            ph.onError(xhr);\n\t                        }\n\t                    }\n\t                };\n\t            }\n\t            var params = null;\n\t            if (ph.params) {\n\t                params = ph.params;\n\t                var syncParams = L.gmx.gmxMapManager.getSyncParams(true);\n\t                if (syncParams) {\n\t                    params += '&' + syncParams;\n\t                }\n\t            }\n\t            xhr.send(params);\n\t            if (!ph.async && xhr.status === 200) {\n\t                ph.callback(xhr.responseText);\n\t                L.gmxUtil.loaderStatus(reqId, true);\n\t                return xhr.status;\n\t            }\n\t            return true;\n\t        }\n\t        if (ph.onError) {\n\t            ph.onError({ Error: 'bad XMLHttpRequest!' });\n\t        }\n\t        return false;\n\t    },\n\t\n\t    tileSizes: [], // Размеры тайла по zoom\n\t    getTileNumFromLeaflet: function getTileNumFromLeaflet(tilePoint, zoom) {\n\t        if ('z' in tilePoint) {\n\t            zoom = tilePoint.z;\n\t        }\n\t        var pz = Math.pow(2, zoom),\n\t            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\n\t            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\n\t        return {\n\t            z: zoom,\n\t            x: tx % pz - pz / 2,\n\t            y: pz / 2 - 1 - ty % pz\n\t        };\n\t    },\n\t\n\t    getTilePosZoomDelta: function getTilePosZoomDelta(tilePoint, zoomFrom, zoomTo) {\n\t        // получить смещение тайла на меньшем zoom\n\t        var dz = Math.pow(2, zoomFrom - zoomTo),\n\t            size = 256 / dz,\n\t            dx = tilePoint.x % dz,\n\t            dy = tilePoint.y % dz;\n\t        return {\n\t            size: size,\n\t            zDelta: dz,\n\t            x: size * (dx < 0 ? dz + dx : dx),\n\t            y: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\n\t        };\n\t    },\n\t\n\t    geoItemBounds: function geoItemBounds(geo) {\n\t        // get item bounds array by geometry\n\t        if (!geo) {\n\t            return {\n\t                bounds: null,\n\t                boundsArr: []\n\t            };\n\t        }\n\t        var type = geo.type,\n\t            coords = geo.coordinates,\n\t            b = null,\n\t            i = 0,\n\t            len = 0,\n\t            bounds = null,\n\t            boundsArr = [];\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr1 = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    b = gmxAPIutils.bounds(coords[i][j]);\n\t                    arr1.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                }\n\t                boundsArr.push(arr1);\n\t            }\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                boundsArr.push(b);\n\t                if (i === 0) {\n\t                    bounds.extendBounds(b);\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds([coords[i]]);\n\t                bounds.extendBounds(b);\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = gmxAPIutils.bounds(coords);\n\t            //boundsArr.push(bounds);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                bounds.extendBounds(b);\n\t                //boundsArr.push(b);\n\t            }\n\t        }\n\t        return {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t    },\n\t\n\t    getUnFlattenGeo: function getUnFlattenGeo(geo) {\n\t        // get unFlatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            coords = geo.coordinates,\n\t            coordsOut = coords;\n\t\n\t        if (isLikePolygon) {\n\t            coordsOut = [];\n\t            var isPolygon = type === 'POLYGON' || type === 'Polygon';\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                var ring = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\n\t                }\n\t                coordsOut.push(ring);\n\t            }\n\t            if (isPolygon) {\n\t                coordsOut = coordsOut[0];\n\t            }\n\t        }\n\t        return { type: type, coordinates: coordsOut };\n\t    },\n\t\n\t    unFlattenRing: function unFlattenRing(arr) {\n\t        if (typeof arr[0] !== 'number') {\n\t            return arr;\n\t        }\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            res = new Array(len / 2);\n\t\n\t        for (var i = 0; i < len; i += 2) {\n\t            res[cnt++] = [arr[i], arr[i + 1]];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    geoFlatten: function geoFlatten(geo) {\n\t        // get flatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates;\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    flattenRing: function flattenRing(arr) {\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\n\t            res = new CurArray(2 * len);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            res[cnt++] = arr[i][0];\n\t            res[cnt++] = arr[i][1];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    /** Check rectangle type by coordinates\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n\t     * @return {Boolean}\r\n\t    */\n\t    isRectangle: function isRectangle(coords) {\n\t        return coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4) && (coords[0][0][0] === coords[0][1][0] || coords[0][0][1] === coords[0][1][1]) && (coords[0][1][0] === coords[0][2][0] || coords[0][1][1] === coords[0][2][1]) && (coords[0][2][0] === coords[0][3][0] || coords[0][2][1] === coords[0][3][1]) && (coords[0][3][0] === coords[0][0][0] || coords[0][3][1] === coords[0][0][1]);\n\t    },\n\t\n\t    /** Get bounds from geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n\t     * @return {Object} bounds\r\n\t    */\n\t    getGeometryBounds: function getGeometryBounds(geo) {\n\t        var pt = gmxAPIutils.geoItemBounds(geo);\n\t        return pt.bounds;\n\t    },\n\t\n\t    getMarkerPolygon: function getMarkerPolygon(bounds, dx, dy) {\n\t        var x = (bounds.min.x + bounds.max.x) / 2,\n\t            y = (bounds.min.y + bounds.max.y) / 2;\n\t        return [[x - dx, y - dy], [x - dx, y + dy], [x + dx, y + dy], [x + dx, y - dy], [x - dx, y - dy]];\n\t    },\n\t\n\t    getQuicklookPointsFromProperties: function getQuicklookPointsFromProperties(pArr, gmx) {\n\t        var indexes = gmx.tileAttributeIndexes;\n\t        var points = {\n\t            x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\n\t            y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\n\t            x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\n\t            y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\n\t            x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\n\t            y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\n\t            x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\n\t            y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\n\t        },\n\t            bounds = gmxAPIutils.bounds([[points.x1, points.y1], [points.x2, points.y2], [points.x3, points.y3], [points.x4, points.y4]]);\n\t\n\t        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\n\t            return null;\n\t        }\n\t\n\t        if (!gmx.quicklookPlatform) {\n\t            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\n\t            points.x1 = merc.x;points.y1 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\n\t            points.x2 = merc.x;points.y2 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\n\t            points.x3 = merc.x;points.y3 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\n\t            points.x4 = merc.x;points.y4 = merc.y;\n\t        }\n\t\n\t        return points;\n\t    },\n\t\n\t    /** Get hash properties from array properties\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} properties in Array format\r\n\t     * @param {Object} keys indexes\r\n\t     * @return {Object} properties in Hash format\r\n\t    */\n\t    getPropertiesHash: function getPropertiesHash(arr, indexes) {\n\t        var properties = {};\n\t        for (var key in indexes) {\n\t            properties[key] = arr[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, arr, indexes) {\n\t        return key in indexes ? arr[indexes[key]] : '';\n\t    },\n\t\n\t    dec2rgba: function dec2rgba(i, a) {\n\t        // convert decimal to rgb\n\t        var r = i >> 16 & 255,\n\t            g = i >> 8 & 255,\n\t            b = i & 255;\n\t        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\n\t    },\n\t\n\t    dec2hex: function dec2hex(i) {\n\t        // convert decimal to hex\n\t        return (i + 0x1000000).toString(16).substr(-6);\n\t    },\n\t\n\t    dec2color: function dec2color(i, a) {\n\t        // convert decimal to canvas color\n\t        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\n\t    },\n\t\n\t    oneDay: 60 * 60 * 24, // один день\n\t\n\t    isTileKeysIntersects: function isTileKeysIntersects(tk1, tk2) {\n\t        // пересечение по номерам двух тайлов\n\t        if (tk1.z < tk2.z) {\n\t            var t = tk1;tk1 = tk2;tk2 = t;\n\t        }\n\t\n\t        var dz = tk1.z - tk2.z;\n\t        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\n\t    },\n\t\n\t    rotatePoints: function rotatePoints(arr, angle, iconScale, center) {\n\t        // rotate - массива точек\n\t        var out = [];\n\t        angle *= Math.PI / 180.0;\n\t        var sin = Math.sin(angle);\n\t        var cos = Math.cos(angle);\n\t        if (!iconScale) {\n\t            iconScale = 1;\n\t        }\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var x = iconScale * arr[i].x - center.x;\n\t            var y = iconScale * arr[i].y - center.y;\n\t            out.push({\n\t                'x': cos * x - sin * y + center.x,\n\t                'y': sin * x + cos * y + center.y\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t    getPatternIcon: function getPatternIcon(item, style, indexes) {\n\t        // получить bitmap стиля pattern\n\t        if (!style.fillPattern) {\n\t            return null;\n\t        }\n\t\n\t        var notFunc = true,\n\t            pattern = style.fillPattern,\n\t            prop = item ? item.properties : null,\n\t            step = pattern.step > 0 ? pattern.step : 0,\n\t            patternDefaults = {\n\t            minWidth: 1,\n\t            maxWidth: 1000,\n\t            minStep: 0,\n\t            maxStep: 1000\n\t        };\n\t        if (pattern.patternStepFunction && prop !== null) {\n\t            step = pattern.patternStepFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (step > patternDefaults.maxStep) {\n\t            step = patternDefaults.maxStep;\n\t        } else if (step < patternDefaults.minStep) {\n\t            step = patternDefaults.minStep;\n\t        }\n\t\n\t        var size = pattern.width > 0 ? pattern.width : 8;\n\t        if (pattern.patternWidthFunction && prop !== null) {\n\t            size = pattern.patternWidthFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (size > patternDefaults.maxWidth) {\n\t            size = patternDefaults.maxWidth;\n\t        } else if (size < patternDefaults.minWidth) {\n\t            size = patternDefaults.minWidth;\n\t        }\n\t\n\t        var op = style.fillOpacity;\n\t        if (style.opacityFunction && prop !== null) {\n\t            op = style.opacityFunction(prop, indexes) / 100;\n\t            notFunc = false;\n\t        }\n\t\n\t        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\n\t            arr = pattern.colors != null ? pattern.colors : rgb,\n\t            count = arr.length,\n\t            resColors = [],\n\t            i = 0;\n\t\n\t        for (i = 0; i < count; i++) {\n\t            var col = arr[i];\n\t            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\n\t                col = prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3];\n\t                notFunc = false;\n\t            }\n\t            resColors.push(col);\n\t        }\n\t        if (count === 0) {\n\t            resColors = [0];op = 0;count = 1;\n\t        } // pattern without colors\n\t\n\t        var delta = size + step,\n\t            allSize = delta * count,\n\t            center = 0,\n\t\n\t\n\t        //radius,\n\t        rad = 0,\n\t            hh = allSize,\n\t\n\t        // высота битмапа\n\t        ww = allSize,\n\t\n\t        // ширина битмапа\n\t        type = pattern.style || 'horizontal',\n\t            flagRotate = false;\n\t\n\t        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\n\t            flagRotate = true;\n\t        } else if (type === 'circle') {\n\t            ww = hh = 2 * delta;\n\t            center = Math.floor(ww / 2); // центр круга\n\t            //radius = Math.floor(size / 2);\t// радиус\n\t            rad = 2 * Math.PI / count; // угол в рад.\n\t        } else if (type === 'vertical') {\n\t            hh = 1;\n\t        } else if (type === 'horizontal') {\n\t            ww = 1;\n\t        }\n\t        if (ww * hh > patternDefaults.maxWidth) {\n\t            console.log({ 'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big' });\n\t            return null;\n\t        }\n\t\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.clearRect(0, 0, canvas.width, canvas.height);\n\t        if (type === 'diagonal2' || type === 'vertical') {\n\t            ptx.translate(ww, 0);\n\t            ptx.rotate(Math.PI / 2);\n\t        }\n\t\n\t        for (i = 0; i < count; i++) {\n\t            ptx.beginPath();\n\t            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\n\t            ptx.fillStyle = fillStyle;\n\t\n\t            if (flagRotate) {\n\t                var x1 = i * delta;var xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t\n\t                x1 += allSize;xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t                if (type === 'cross' || type === 'cross1') {\n\t                    x1 = i * delta;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t\n\t                    x1 += allSize;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t                }\n\t            } else if (type === 'circle') {\n\t                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\n\t                ptx.lineTo(center, center);\n\t            } else {\n\t                ptx.fillRect(0, i * delta, ww, size);\n\t            }\n\t            ptx.closePath();\n\t            ptx.fill();\n\t        }\n\t        var canvas1 = document.createElement('canvas');\n\t        canvas1.width = ww;\n\t        canvas1.height = hh;\n\t        var ptx1 = canvas1.getContext('2d');\n\t        ptx1.drawImage(canvas, 0, 0, ww, hh);\n\t        return { 'notFunc': notFunc, 'canvas': canvas1 };\n\t    },\n\t\n\t    getSVGIcon: function getSVGIcon(options) {\n\t        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\n\t            type = options.type,\n\t            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\n\t            stroke = options.strokeStyle || '#0000ff',\n\t            strokeWidth = options.lineWidth || 2,\n\t            iconOptions = {\n\t            className: 'gmx-svg-icon'\n\t        };\n\t\n\t        if (options.className) {\n\t            iconOptions.className = options.className;\n\t        }\n\t        var size = options.iconSize;\n\t        iconOptions.iconSize = [size, size];\n\t        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\n\t\n\t        if (type === 'circle') {\n\t            if (options.fillRadialGradient) {\n\t                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\n\t                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop || [// [%, color, opacity]\n\t                [0, '#ffff00', 0.8], [1, '#ff0000', 0.8]];\n\t\n\t                for (var i = 0, len = stopColor.length; i < len; i++) {\n\t                    var it = stopColor[i];\n\t                    svg += '<stop offset=\"' + 100 * it[0] + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\n\t                }\n\t                svg += '</radialGradient></defs>';\n\t                fill = 'url(#myRadialGradient4)';\n\t                stroke = strokeWidth = null;\n\t            }\n\t            size /= 2;\n\t            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:\"' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:\"' + strokeWidth + ';';\n\t            }\n\t            svg += ';\" />';\n\t        } else if (type === 'square') {\n\t            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:' + 2 * strokeWidth + ';';\n\t            }\n\t            svg += '\" />';\n\t        }\n\t        if (options.text) {\n\t            var text = options.text;\n\t            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\n\t            for (var key in text) {\n\t                if (key !== 'count') {\n\t                    svg += ' ' + key + '=\"' + text[key] + '\"';\n\t                }\n\t            }\n\t            svg += '>' + text.count + '</text>';\n\t        }\n\t        svg += '</g></svg>';\n\t        iconOptions.html = svg;\n\t\n\t        return new L.DivIcon(iconOptions);\n\t    },\n\t\n\t    toPixels: function toPixels(p, tpx, tpy, mInPixel) {\n\t        // get pixel point\n\t        var px1 = p[0] * mInPixel;px1 = 0.5 + px1 << 0;\n\t        var py1 = p[1] * mInPixel;py1 = 0.5 + py1 << 0;\n\t        return [px1 - tpx, tpy - py1].concat(p.slice(2));\n\t    },\n\t\n\t    getPixelPoint: function getPixelPoint(attr, coords) {\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t            style = attr.style || {},\n\t            iconScale = currentStyle.iconScale || 1,\n\t            iconCenter = currentStyle.iconCenter || false,\n\t            sx = currentStyle.sx || style.sx || 4,\n\t            sy = currentStyle.sy || style.sy || 4,\n\t            weight = currentStyle.weight || style.weight || 0,\n\t            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy;\n\t\n\t        if (!iconCenter && iconAnchor) {\n\t            px1 -= iconAnchor[0];\n\t            py1 -= iconAnchor[1];\n\t        }\n\t        sx *= iconScale;\n\t        sy *= iconScale;\n\t        sx += weight;\n\t        sy += weight;\n\t\n\t        var py1 = py - coords[1] * mInPixel,\n\t            px1 = coords[0] * mInPixel - px;\n\t\n\t        if (px1 - sx > 256) {\n\t            px1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        } else if (px1 < -sx) {\n\t            px1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        }\n\t\n\t        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0 ? null : {\n\t            sx: sx,\n\t            sy: sy,\n\t            px1: 0.5 + px1 << 0,\n\t            py1: 0.5 + py1 << 0\n\t        };\n\t    },\n\t    getImageData: function getImageData(img) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return null;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.drawImage(img, 0, 0);\n\t        return ptx.getImageData(0, 0, ww, hh).data;\n\t    },\n\t    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\n\t    isIE: function isIE(v) {\n\t        return v === gmxAPIutils.getIEversion();\n\t    },\n\t    gtIE: function gtIE(v) {\n\t        return v < gmxAPIutils.getIEversion();\n\t    },\n\t\n\t    getIEversion: function getIEversion() {\n\t        var ua = navigator.userAgent || '',\n\t            msie = ua.indexOf('MSIE ');\n\t        if (msie > 0) {\n\t            // IE 10 or older => return version number\n\t            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t        }\n\t\n\t        var trident = ua.indexOf('Trident/');\n\t        if (trident > 0) {\n\t            // IE 11 => return version number\n\t            var rv = ua.indexOf('rv:');\n\t            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t        }\n\t\n\t        var edge = ua.indexOf('Edge/');\n\t        if (edge > 0) {\n\t            // Edge (IE 12+) => return version number\n\t            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t        }\n\t\n\t        // other browser\n\t        return -1;\n\t    },\n\t\n\t    replaceColor: function replaceColor(img, color, fromData) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return img;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var flag = false,\n\t            imageData,\n\t            ptx = canvas.getContext('2d');\n\t\n\t        if (typeof color === 'string') {\n\t            color = parseInt('0x' + color.replace(/#/, ''));\n\t        }\n\t        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\n\t            var r = color >> 16 & 255,\n\t                g = color >> 8 & 255,\n\t                b = color & 255;\n\t\n\t            if (fromData) {\n\t                imageData = ptx.createImageData(ww, hh);\n\t            } else {\n\t                ptx.drawImage(img, 0, 0);\n\t                imageData = ptx.getImageData(0, 0, ww, hh);\n\t                fromData = imageData.data;\n\t            }\n\t            var toData = imageData.data;\n\t            for (var i = 0, len = fromData.length; i < len; i += 4) {\n\t                if ((fromData[i] === 0xff || fromData[i] === 238) && fromData[i + 1] === 0 && fromData[i + 2] === 0xff) {\n\t                    toData[i] = r;\n\t                    toData[i + 1] = g;\n\t                    toData[i + 2] = b;\n\t                    toData[i + 3] = fromData[i + 3];\n\t                    flag = true;\n\t                }\n\t            }\n\t        }\n\t        if (flag) {\n\t            ptx.putImageData(imageData, 0, 0);\n\t        } else {\n\t            ptx.drawImage(img, 0, 0);\n\t        }\n\t        return canvas;\n\t    },\n\t\n\t    drawIconPath: function drawIconPath(path, attr) {\n\t        // draw iconPath in canvas\n\t        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) {\n\t            return;\n\t        }\n\t        var trFlag = false,\n\t            ctx = attr.ctx,\n\t            rad = attr.radian;\n\t\n\t        if (attr.px || attr.py) {\n\t            ctx.translate(attr.px || 0, attr.py || 0);trFlag = true;\n\t        }\n\t        if (!rad && attr.rotateRes) {\n\t            rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes);\n\t        }\n\t        if (rad) {\n\t            ctx.rotate(rad);trFlag = true;\n\t        }\n\t        ctx.moveTo(path[0], path[1]);\n\t        for (var i = 2, len = path.length; i < len; i += 2) {\n\t            ctx.lineTo(path[i], path[i + 1]);\n\t        }\n\t        if (trFlag) {\n\t            ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t        }\n\t    },\n\t\n\t    pointToCanvas: function pointToCanvas(attr) {\n\t        // Точку в canvas\n\t        var gmx = attr.gmx,\n\t            pointAttr = attr.pointAttr,\n\t            style = attr.style || {},\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconScale = currentStyle.iconScale || 1,\n\t            image = currentStyle.image,\n\t            sx = pointAttr.sx,\n\t            sy = pointAttr.sy,\n\t            px1 = pointAttr.px1,\n\t            py1 = pointAttr.py1,\n\t            px1sx = px1,\n\t            py1sy = py1,\n\t            ctx = attr.ctx;\n\t\n\t        if (currentStyle.type === 'image') {\n\t            sx = style.sx;\n\t            sy = style.sy;\n\t            image = style.image;\n\t        }\n\t        if (currentStyle.iconCenter) {\n\t            px1sx -= sx / 2;\n\t            py1sy -= sy / 2;\n\t        } else if (style.type === 'circle') {\n\t            px1 += sx / 2;\n\t            py1 += sy / 2;\n\t        }\n\t        if (currentStyle.iconPath) {\n\t            attr.px = px1;\n\t            attr.py = py1;\n\t            attr.rotateRes = currentStyle.rotate || 0;\n\t        }\n\t        if (image) {\n\t            if ('iconColor' in currentStyle) {\n\t                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\n\t            }\n\t            style.rotateRes = currentStyle.rotate || 0;\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = currentStyle.opacity || style.opacity;\n\t            }\n\t            if (gmx.transformFlag) {\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\n\t                ctx.drawImage(image, px1, -py1, sx, sy);\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\n\t            } else {\n\t                if (iconScale !== 1) {\n\t                    sx *= iconScale;\n\t                    sy *= iconScale;\n\t                    px1 = pointAttr.px1;\n\t                    py1 = pointAttr.py1;\n\t                    px1sx = px1;\n\t                    py1sy = py1;\n\t                    if (currentStyle.iconCenter) {\n\t                        px1sx -= sx / 2;\n\t                        py1sy -= sy / 2;\n\t                    }\n\t                }\n\t                if (style.rotateRes) {\n\t                    ctx.translate(px1, py1);\n\t                    ctx.rotate(gmxAPIutils.degRad(style.rotateRes));\n\t                    ctx.translate(-px1, -py1);\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                } else {\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                }\n\t            }\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = 1;\n\t            }\n\t        } else if (style.fillColor || currentStyle.fillRadialGradient) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\n\t                var circle = style.iconSize / 2;\n\t                if (currentStyle.fillRadialGradient) {\n\t                    var rgr = currentStyle.fillRadialGradient;\n\t                    circle = rgr.r2 * iconScale;\n\t                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\n\t                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\n\t                        var arr = rgr.addColorStop[i];\n\t                        radgrad.addColorStop(arr[0], arr[1]);\n\t                    }\n\t                    ctx.fillStyle = radgrad;\n\t                }\n\t                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.fillRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.fill();\n\t        }\n\t        if (currentStyle.strokeStyle) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle') {\n\t                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.strokeRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.stroke();\n\t        }\n\t    },\n\t    lineToCanvasAsIcon: function lineToCanvasAsIcon(pixels, attr) {\n\t        // add line(as icon) to canvas\n\t        var len = pixels.length,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconPath = currentStyle.iconPath;\n\t\n\t        if (len > 0) {\n\t            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t                ctx.setLineDash([]);\n\t            }\n\t            ctx.beginPath();\n\t            for (var i = 0, p; i < len; i++) {\n\t                p = pixels[i];\n\t                gmxAPIutils.drawIconPath(iconPath, { ctx: ctx, px: p.x, py: p.y, radian: p.radian });\n\t            }\n\t            if (currentStyle.strokeStyle) {\n\t                ctx.stroke();\n\t            }\n\t            if (currentStyle.fillStyle) {\n\t                ctx.fill();\n\t            }\n\t        }\n\t    },\n\t    lineToCanvas: function lineToCanvas(attr) {\n\t        // Lines in canvas\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            pixels = currentStyle.iconPath ? [] : null;\n\t\n\t        var lastX = null,\n\t            lastY = null;\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\n\t                x = p[0],\n\t                y = p[1];\n\t            if (lastX !== x || lastY !== y) {\n\t                if (pixels) {\n\t                    pixels.push({ x: x, y: y, radian: p[2] });\n\t                }\n\t                if (i === 0) {\n\t                    ctx.moveTo(x, y);\n\t                } else {\n\t                    ctx.lineTo(x, y);\n\t                }\n\t                lastX = x;lastY = y;\n\t            }\n\t        }\n\t        ctx.stroke();\n\t        return pixels;\n\t    },\n\t\n\t    getCoordsPixels: function getCoordsPixels(attr) {\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || [],\n\t            pixels = [],\n\t            hidden = [],\n\t            hiddenFlag = false,\n\t            hash = {\n\t            gmx: gmx,\n\t            tpx: attr.tpx,\n\t            tpy: attr.tpy,\n\t            coords: null,\n\t            hiddenLines: null\n\t        };\n\t        for (var j = 0, len = coords.length; j < len; j++) {\n\t            var coords1 = coords[j],\n\t                hiddenLines1 = hiddenLines[j] || [],\n\t                pixels1 = [],\n\t                hidden1 = [];\n\t            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\n\t                hash.coords = coords1[j1];\n\t                hash.hiddenLines = hiddenLines1[j1] || [];\n\t                var res = gmxAPIutils.getRingPixels(hash);\n\t                pixels1.push(res.coords);\n\t                hidden1.push(res.hidden);\n\t                if (res.hidden) {\n\t                    hiddenFlag = true;\n\t                }\n\t            }\n\t            pixels.push(pixels1);\n\t            hidden.push(hidden1);\n\t        }\n\t        return { coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom };\n\t    },\n\t\n\t    getRingPixels: function getRingPixels(attr) {\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            lastX = null,\n\t            lastY = null,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            pixels = [],\n\t            hidden = [];\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var lineIsOnEdge = false;\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x1 = c[0] * mInPixel,\n\t                y1 = c[1] * mInPixel,\n\t                x2 = Math.round(x1 - px),\n\t                y2 = Math.round(py - y1);\n\t\n\t            if (lastX !== x2 || lastY !== y2) {\n\t                lastX = x2;lastY = y2;\n\t                if (lineIsOnEdge) {\n\t                    hidden.push(cnt);\n\t                }\n\t                pixels[cnt++] = x1;\n\t                pixels[cnt++] = y1;\n\t            }\n\t        }\n\t        return { coords: pixels, hidden: hidden.length ? hidden : null };\n\t    },\n\t\n\t    polygonToCanvas: function polygonToCanvas(attr) {\n\t        // Polygons in canvas\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var hiddenLines = attr.hiddenLines || null,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            lastX = null,\n\t            lastY = null;\n\t\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x = Math.round(c[0] - px),\n\t                y = Math.round(py - c[1]),\n\t                lineIsOnEdge = false;\n\t\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t\n\t            if (lastX !== x || lastY !== y) {\n\t                ctx[lineIsOnEdge ? 'moveTo' : 'lineTo'](x, y);\n\t                lastX = x;lastY = y;\n\t                cnt++;\n\t            }\n\t        }\n\t        if (cnt === 1) {\n\t            ctx.lineTo(lastX + 1, lastY);\n\t        }\n\t        ctx.stroke();\n\t    },\n\t\n\t    polygonToCanvasFill: function polygonToCanvasFill(attr) {\n\t        // Polygon fill\n\t        if (attr.coords.length < 3) {\n\t            return;\n\t        }\n\t        var coords = attr.coords,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            vectorSize = 1,\n\t            ctx = attr.ctx;\n\t\n\t        ctx.lineWidth = 0;\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\n\t        } else {\n\t            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\n\t        }\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\n\t        }\n\t    },\n\t\n\t    isPatternNode: function isPatternNode(it) {\n\t        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\n\t    },\n\t    labelCanvasContext: null, // 2dContext canvas for Label size\n\t    getLabelWidth: function getLabelWidth(txt, style) {\n\t        // Get label size Label\n\t        if (style) {\n\t            if (!gmxAPIutils.labelCanvasContext) {\n\t                var canvas = document.createElement('canvas');\n\t                canvas.width = canvas.height = 512;\n\t                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\n\t            }\n\t            var ptx = gmxAPIutils.labelCanvasContext;\n\t            ptx.clearRect(0, 0, 512, 512);\n\t\n\t            if (ptx.font !== style.font) {\n\t                ptx.font = style.font;\n\t            }\n\t            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\n\t            if (ptx.fillStyle !== style.fillStyle) {\n\t                ptx.fillStyle = style.fillStyle;\n\t            }\n\t            var arr = txt.split('\\n');\n\t            return arr.map(function (it) {\n\t                ptx.fillText(it, 0, 0);\n\t                return [it, ptx.measureText(it).width];\n\t            });\n\t        }\n\t        return 0;\n\t    },\n\t    setLabel: function setLabel(ctx, txt, coord, style) {\n\t        var x = coord[0],\n\t            y = coord[1];\n\t\n\t        if (ctx.shadowColor !== style.strokeStyle) {\n\t            ctx.shadowColor = style.strokeStyle;\n\t        }\n\t        if (ctx.shadowBlur !== style.shadowBlur) {\n\t            ctx.shadowBlur = style.shadowBlur;\n\t        }\n\t        if (ctx.font !== style.font) {\n\t            ctx.font = style.font;\n\t        }\n\t        if (ctx.strokeStyle !== style.strokeStyle) {\n\t            ctx.strokeStyle = style.strokeStyle;\n\t        }\n\t        if (ctx.fillStyle !== style.fillStyle) {\n\t            ctx.fillStyle = style.fillStyle;\n\t        }\n\t        ctx.strokeText(txt, x, y);\n\t        ctx.fillText(txt, x, y);\n\t    },\n\t    worldWidthMerc: 20037508,\n\t    rMajor: 6378137.000,\n\t    degRad: function degRad(ang) {\n\t        return ang * (Math.PI / 180.0);\n\t    },\n\t\n\t    distVincenty: function distVincenty(lon1, lat1, lon2, lat2) {\n\t        var p1 = {\n\t            lon: gmxAPIutils.degRad(lon1),\n\t            lat: gmxAPIutils.degRad(lat1)\n\t        },\n\t            p2 = {\n\t            lon: gmxAPIutils.degRad(lon2),\n\t            lat: gmxAPIutils.degRad(lat2)\n\t        },\n\t            a = gmxAPIutils.rMajor,\n\t            b = 6356752.3142,\n\t            f = 1 / 298.257223563; // WGS-84 ellipsiod\n\t\n\t        var L1 = p2.lon - p1.lon,\n\t            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\n\t            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\n\t            sinU1 = Math.sin(U1),\n\t            cosU1 = Math.cos(U1),\n\t            sinU2 = Math.sin(U2),\n\t            cosU2 = Math.cos(U2),\n\t            lambda = L1,\n\t            lambdaP = 2 * Math.PI,\n\t            iterLimit = 20;\n\t        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n\t            var sinLambda = Math.sin(lambda),\n\t                cosLambda = Math.cos(lambda),\n\t                sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n\t            if (sinSigma === 0) {\n\t                return 0;\n\t            }\n\t            var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\n\t                sigma = Math.atan2(sinSigma, cosSigma),\n\t                sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\n\t                cosSqAlpha = 1 - sinAlpha * sinAlpha,\n\t                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n\t            if (isNaN(cos2SigmaM)) {\n\t                cos2SigmaM = 0;\n\t            }\n\t            var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n\t            lambdaP = lambda;\n\t            lambda = L1 + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n\t        }\n\t        if (iterLimit === 0) {\n\t            return NaN;\n\t        }\n\t\n\t        var uSq = cosSqAlpha * (a * a / (b * b) - 1),\n\t\n\t\n\t        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\n\t        A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\n\t            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\n\t            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\n\t            s = b * A * (sigma - deltaSigma);\n\t\n\t        //s = s.toFixed(3);\n\t        return s;\n\t    },\n\t\n\t    _vfi: function _vfi(fi, a, b) {\n\t        return [-Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a), Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a), -Math.sin(fi) * Math.cos(b)];\n\t    },\n\t\n\t    getCircleLatLngs: function getCircleLatLngs(latlng, r) {\n\t        // Get latlngs for circle\n\t        var x = 0,\n\t            y = 0;\n\t        if (latlng instanceof L.LatLng) {\n\t            x = latlng.lng;\n\t            y = latlng.lat;\n\t        } else if (L.Util.isArray(latlng)) {\n\t            x = latlng[1];\n\t            y = latlng[0];\n\t        } else {\n\t            return null;\n\t        }\n\t\n\t        var rad = Math.PI / 180,\n\t            a = x * rad,\n\t\n\t        //долгота центра окружности в радианах\n\t        b = y * rad,\n\t\n\t        //широта центра окружности в радианах\n\t        R = gmxAPIutils.rMajor,\n\t            d = R * Math.sin(r / R),\n\t            Rd = R * Math.cos(r / R),\n\t            VR = [Rd * Math.cos(b) * Math.cos(a), Rd * Math.cos(b) * Math.sin(a), Rd * Math.sin(b)],\n\t            latlngs = [];\n\t\n\t        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\n\t            var v = gmxAPIutils._vfi(fi, a, b),\n\t                circle = [];\n\t            for (var i = 0; i < 3; i++) {\n\t                circle[i] = VR[i] + d * v[i];\n\t            }\n\t\n\t            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\n\t            if (circle[1] < 0) {\n\t                t2 = -t2;\n\t            }\n\t\n\t            if (t2 < x - 180) {\n\t                t2 += 360;\n\t            } else if (t2 > x + 180) {\n\t                t2 -= 360;\n\t            }\n\t            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\n\t        }\n\t        return latlngs;\n\t    },\n\t\n\t    /** Get point coordinates from string\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} text - point coordinates in following formats:\r\n\t         <br/><i>55.74312, 37.61558</i>\r\n\t         <br/><i>55°44'35\" N, 37°36'56\" E</i>\r\n\t         <br/><i>4187347, 7472103</i>\r\n\t         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n\t         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n\t     * @return {Array} [lat, lng] or null\r\n\t    */\n\t    parseCoordinates: function parseCoordinates(text) {\n\t        var crs = null,\n\t            regex = /\\(EPSG:(\\d+)\\)/g,\n\t            t = regex.exec(text);\n\t\n\t        if (t) {\n\t            crs = t[1];\n\t            text = text.replace(regex, '');\n\t        }\n\t\n\t        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\n\t            return null;\n\t        }\n\t\n\t        //there should be a separator in the string (exclude strings like \"11E11\")\n\t        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\n\t            return null;\n\t        }\n\t\n\t        if (text.indexOf(' ') !== -1) {\n\t            text = text.replace(/,/g, '.');\n\t        }\n\t        var results = [];\n\t        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\n\t        t = regex.exec(text);\n\t        while (t) {\n\t            results.push(t[1]);\n\t            t = regex.exec(text);\n\t        }\n\t        if (results.length < 2) {\n\t            return null;\n\t        }\n\t        var ii = Math.floor(results.length / 2),\n\t            y = 0,\n\t            mul = 1,\n\t            i;\n\t        for (i = 0; i < ii; i++) {\n\t            y += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t        var x = 0;\n\t        mul = 1;\n\t        for (i = ii; i < results.length; i++) {\n\t            x += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t\n\t        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\n\t            t = x;\n\t            x = y;\n\t            y = t;\n\t        }\n\t\n\t        var pos;\n\t        if (crs === '3857') {\n\t            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\n\t            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t\n\t        if (text.indexOf('W') !== -1) {\n\t            x = -x;\n\t        }\n\t\n\t        if (text.indexOf('S') !== -1) {\n\t            y = -y;\n\t        }\n\t        return [y, x];\n\t    },\n\t\n\t    pad2: function pad2(t) {\n\t        return t >= 0 && t < 10 ? '0' + t : '' + t;\n\t    },\n\t\n\t    trunc: function trunc(x) {\n\t        return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\n\t    },\n\t\n\t    formatDegrees: function formatDegrees(angle, format) {\n\t        angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\n\t        var a1 = Math.floor(angle),\n\t            a2 = Math.floor(60 * (angle - a1)),\n\t            a3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\n\t            st = gmxAPIutils.pad2(a1) + '°';\n\t\n\t        if (format === undefined) {\n\t            format = 2;\n\t        }\n\t        if (format > 0) {\n\t            st += gmxAPIutils.pad2(a2) + '\\'';\n\t        }\n\t        if (format > 1) {\n\t            st += gmxAPIutils.pad2(a3) + '\"';\n\t        }\n\t        return st;\n\t    },\n\t\n\t    /** Get point coordinates in string format with degrees\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format with degrees\r\n\t    */\n\t    latLonFormatCoordinates: function latLonFormatCoordinates(x, y) {\n\t        x %= 360;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        } else if (x < -180) {\n\t            x += 360;\n\t        }\n\t        return gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t\n\t    formatCoordinates: function formatCoordinates(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates(x, y);\n\t    },\n\t\n\t    /** Get point coordinates in string format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format\r\n\t    */\n\t    latLonFormatCoordinates2: function latLonFormatCoordinates2(x, y) {\n\t        return gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t    formatCoordinates2: function formatCoordinates2(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates2(x, y);\n\t    },\n\t\n\t    getPixelScale: function getPixelScale(zoom) {\n\t        return 256 / gmxAPIutils.tileSizes[zoom];\n\t    },\n\t\n\t    forEachPoint: function forEachPoint(coords, callback) {\n\t        if (!coords || coords.length === 0) {\n\t            return [];\n\t        }\n\t        var i,\n\t            len,\n\t            ret = [];\n\t        if (!coords[0].length) {\n\t            if (coords.length === 2) {\n\t                return callback(coords);\n\t            } else {\n\t                for (i = 0, len = coords.length / 2; i < len; i++) {\n\t                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\n\t                }\n\t            }\n\t        } else {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                if (typeof coords[i] !== 'string') {\n\t                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    },\n\t    /*\r\n\t    \tgetQuicklookPoints: function(coord) { // получить 4 точки привязки снимка\r\n\t    \t\tvar d1 = Number.MAX_VALUE;\r\n\t    \t\tvar d2 = Number.MAX_VALUE;\r\n\t    \t\tvar d3 = Number.MAX_VALUE;\r\n\t    \t\tvar d4 = Number.MAX_VALUE;\r\n\t    \t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t    \t\tthis.forEachPoint(coord, function(p) {\r\n\t    \t\t\tvar x = p[0];\r\n\t    \t\t\tvar y = p[1];\r\n\t    \t\t\tif ((x - y) < d1) {\r\n\t    \t\t\t\td1 = x - y;\r\n\t    \t\t\t\tx1 = p[0];\r\n\t    \t\t\t\ty1 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x - y) < d2) {\r\n\t    \t\t\t\td2 = -x - y;\r\n\t    \t\t\t\tx2 = p[0];\r\n\t    \t\t\t\ty2 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x + y) < d3) {\r\n\t    \t\t\t\td3 = -x + y;\r\n\t    \t\t\t\tx3 = p[0];\r\n\t    \t\t\t\ty3 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((x + y) < d4) {\r\n\t    \t\t\t\td4 = x + y;\r\n\t    \t\t\t\tx4 = p[0];\r\n\t    \t\t\t\ty4 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t});\r\n\t    \t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t    \t},\r\n\t    */\n\t    getItemCenter: function getItemCenter(item, geoItems) {\n\t        var bounds = item.bounds,\n\t            min = bounds.min,\n\t            max = bounds.max,\n\t            type = item.type,\n\t            isPoint = type === 'POINT' || type === 'MULTIPOINT',\n\t            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t\n\t        if (type === 'MULTIPOLYGON') {\n\t            return center;\n\t        } else if (type === 'POLYGON') {\n\t            for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                var it = geoItems[i],\n\t                    geom = it.geo,\n\t                    coords = geom.coordinates,\n\t                    dataOption = it.dataOption,\n\t                    bbox = dataOption.bounds;\n\t\n\t                if (bbox.contains(center)) {\n\t                    if (geom.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                    }\n\t                    for (var j = 0, len1 = coords.length; j < len1; j++) {\n\t                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\n\t                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\n\t                            if (pt) {\n\t                                return pt.max.center;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'MULTIPOINT') {\n\t            return center;\n\t        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\n\t            return center;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    getHSegmentsInPolygon: function getHSegmentsInPolygon(y, poly) {\n\t        var s = [],\n\t            i,\n\t            len,\n\t            out,\n\t            vectorSize = 1,\n\t            p1 = poly[0];\n\t\n\t        if (typeof poly[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [poly[0], poly[1]];\n\t        }\n\t        var isGt1 = y > p1[1];\n\t        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\n\t                isGt2 = y > p2[1];\n\t            if (isGt1 !== isGt2) {\n\t                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\n\t            }\n\t            p1 = p2;\n\t            isGt1 = isGt2;\n\t        }\n\t        len = s.length;\n\t        if (len) {\n\t            s = s.sort();\n\t            var max = 0,\n\t                index = -1;\n\t            for (i = 1; i < len; i += 2) {\n\t                var j = i - 1,\n\t                    d = Math.abs(s[i] - s[j]);\n\t                if (d > max) {\n\t                    max = d;\n\t                    index = j;\n\t                }\n\t            }\n\t            out = {\n\t                y: y,\n\t                segArr: s,\n\t                max: {\n\t                    width: max,\n\t                    center: [(s[index] + s[index + 1]) / 2, y]\n\t                }\n\t            };\n\t        }\n\t        return out;\n\t    },\n\t\n\t    isPointInPolygonArr: function isPointInPolygonArr(chkPoint, coords) {\n\t        // Проверка точки на принадлежность полигону в виде массива\n\t        var isIn = false,\n\t            x = chkPoint[0],\n\t            y = chkPoint[1],\n\t            vectorSize = 1,\n\t            p1 = coords[0];\n\t\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [coords[0], coords[1]];\n\t        }\n\t\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                xmin = Math.min(p1[0], p2[0]),\n\t                xmax = Math.max(p1[0], p2[0]),\n\t                ymax = Math.max(p1[1], p2[1]);\n\t            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\n\t                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\n\t                if (p1[1] === p2[1] || y <= xinters) {\n\t                    isIn = !isIn;\n\t                }\n\t            }\n\t            p1 = p2;\n\t        }\n\t        return isIn;\n\t    },\n\t\n\t    /** Is point in polygon with holes\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {chkPoint} chkPoint - point in [x, y] format\r\n\t     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if polygon contain chkPoint\r\n\t    */\n\t    isPointInPolygonWithHoles: function isPointInPolygonWithHoles(chkPoint, coords) {\n\t        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) {\n\t            return false;\n\t        }\n\t        for (var j = 1, len = coords.length; j < len; j++) {\n\t            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /** Is polygon clockwise\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {ring} ring - ring from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if ring is clockwise\r\n\t    */\n\t    isClockwise: function isClockwise(ring) {\n\t        var area = 0;\n\t        for (var i = 0, j, len = ring.length; i < len; i++) {\n\t            j = (i + 1) % len;\n\t            area += ring[i][0] * ring[j][1];\n\t            area -= ring[j][0] * ring[i][1];\n\t        }\n\t        return area < 0;\n\t    },\n\t\n\t    isPointInPolyLine: function isPointInPolyLine(chkPoint, lineHeight, coords, hiddenLines) {\n\t        // Проверка точки(с учетом размеров) на принадлежность линии\n\t        var dx = chkPoint[0],\n\t            dy = chkPoint[1],\n\t            nullPoint = { x: dx, y: dy },\n\t            minx = dx - lineHeight,\n\t            maxx = dx + lineHeight,\n\t            miny = dy - lineHeight,\n\t            maxy = dy + lineHeight,\n\t            cntHide = 0;\n\t\n\t        lineHeight *= lineHeight;\n\t        for (var i = 1, len = coords.length; i < len; i++) {\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                cntHide++;\n\t            } else {\n\t                var p1 = coords[i - 1],\n\t                    p2 = coords[i],\n\t                    x1 = p1[0],\n\t                    y1 = p1[1],\n\t                    x2 = p2[0],\n\t                    y2 = p2[1];\n\t\n\t                if (!(Math.max(x1, x2) < minx || Math.min(x1, x2) > maxx || Math.max(y1, y2) < miny || Math.min(y1, y2) > maxy)) {\n\t                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, { x: x1, y: y1 }, { x: x2, y: y2 }, true);\n\t                    if (sqDist < lineHeight) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    isPointInLines: function isPointInLines(attr) {\n\t        var arr = attr.coords,\n\t            point = attr.point,\n\t            delta = attr.delta,\n\t            boundsArr = attr.boundsArr,\n\t            hidden = attr.hidden;\n\t        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\n\t            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\n\t            if (flag && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /** Get length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} latlngs array\r\n\t     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n\t     * @return {Number} length\r\n\t    */\n\t    getLength: function getLength(latlngs, isMerc) {\n\t        var length = 0;\n\t        if (latlngs && latlngs.length) {\n\t            var lng = false,\n\t                lat = false;\n\t\n\t            isMerc = isMerc === undefined || isMerc;\n\t            latlngs.forEach(function (latlng) {\n\t                if (L.Util.isArray(latlng)) {\n\t                    if (L.Util.isArray(latlng[0])) {\n\t                        length += gmxAPIutils.getLength(latlng, isMerc);\n\t                        return length;\n\t                    } else if (isMerc) {\n\t                        // From Mercator array\n\t                        latlng = L.Projection.Mercator.unproject({ x: latlng[0], y: latlng[1] });\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\n\t                }\n\t                lng = latlng.lng;\n\t                lat = latlng.lat;\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get prettify length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area\r\n\t     * @param {String} type: ('km', 'm', 'nm')\r\n\t     * @return {String} prettify length\r\n\t    */\n\t    prettifyDistance: function prettifyDistance(length, type) {\n\t        var km = ' ' + L.gmxLocale.getText('units.km');\n\t        if (type === 'nm') {\n\t            return Math.round(0.539956803 * length) / 1000 + ' ' + L.gmxLocale.getText('units.nm');\n\t        } else if (type === 'km') {\n\t            return Math.round(length) / 1000 + km;\n\t        } else if (length < 2000 || type === 'm') {\n\t            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\n\t        } else if (length < 200000) {\n\t            return Math.round(length / 10) / 100 + km;\n\t        }\n\t        return Math.round(length / 1000) + km;\n\t    },\n\t\n\t    /** Get geoJSON length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} length\r\n\t    */\n\t    geoJSONGetLength: function geoJSONGetLength(geoJSON) {\n\t        var out = 0,\n\t            i,\n\t            j,\n\t            len,\n\t            len1,\n\t            coords;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\n\t        }if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'LineString') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingLength(coords[i]);\n\t            }\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                for (j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    out += gmxAPIutils.getRingLength(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getRingLength: function getRingLength(coords) {\n\t        var length = 0;\n\t        if (coords && coords.length) {\n\t            var lng = false,\n\t                lat = false;\n\t            coords.forEach(function (lnglat) {\n\t                if (L.Util.isArray(lnglat)) {\n\t                    if (lnglat.length > 2) {\n\t                        length += gmxAPIutils.getRingLength(lnglat);\n\t                        return length;\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\n\t                }\n\t                lng = lnglat[0];\n\t                lat = lnglat[1];\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get geoJSON area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoJSONGetArea: function geoJSONGetArea(geoJSON) {\n\t        var out = 0;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            var coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingArea(coords[i][0]);\n\t                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\n\t                    out -= gmxAPIutils.getRingArea(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    geoJSONGetLatLng: function geoJSONGetLatLng(geoJSON) {\n\t        if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'Point') {\n\t            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\n\t        } else {\n\t            throw new Error('cannot get ' + geoJSON.type + ' latLng');\n\t        }\n\t    },\n\t\n\t    getRingArea: function getRingArea(coords) {\n\t        var area = 0;\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = coords[i],\n\t                p2 = coords[ipp];\n\t            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\n\t        }\n\t        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t        return out;\n\t    },\n\t\n\t    /** Get area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} L.latLng array\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    getArea: function getArea(arr) {\n\t        var area = 0;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = arr[i],\n\t                p2 = arr[ipp];\n\t            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\n\t        }\n\t        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t    },\n\t\n\t    /** Get prettified size of area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area in square meters\r\n\t     * @param {String} type: ('km2', 'ha', 'm2')\r\n\t     * @return {String} prettified area\r\n\t    */\n\t    prettifyArea: function prettifyArea(area, type) {\n\t        var km2 = ' ' + L.gmxLocale.getText('units.km2');\n\t\n\t        if (type === 'km2') {\n\t            return '' + Math.round(area / 100) / 10000 + km2;\n\t        } else if (type === 'ha') {\n\t            return '' + Math.round(area / 100) / 100 + ' ' + L.gmxLocale.getText('units.ha');\n\t        } else if (area < 100000 || type === 'm2') {\n\t            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\n\t        } else if (area < 3000000) {\n\t            return ('' + Math.round(area / 1000) / 1000).replace('.', ',') + km2;\n\t        } else if (area < 30000000) {\n\t            return ('' + Math.round(area / 10000) / 100).replace('.', ',') + km2;\n\t        } else if (area < 300000000) {\n\t            return ('' + Math.round(area / 100000) / 10).replace('.', ',') + km2;\n\t        }\n\t        return Math.round(area / 1000000) + km2;\n\t    },\n\t\n\t    geoLength: function geoLength(geom) {\n\t        var ret = 0,\n\t            type = geom.type;\n\t        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoLength({ type: 'LINESTRING', coordinates: geom.coordinates[i] });\n\t            }\n\t            return ret;\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            ret = gmxAPIutils.getLength(geom.coordinates);\n\t        }\n\t        return ret;\n\t    },\n\t\n\t    /** Converts Geomixer geometry to geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - Geomixer geometry\r\n\t     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n\t     * @return {Object} geoJSON geometry\r\n\t    */\n\t    geometryToGeoJSON: function geometryToGeoJSON(geom, mercFlag) {\n\t        if (!geom) {\n\t            return null;\n\t        }\n\t\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    convertGeometry: function convertGeometry(geom, fromMerc) {\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (fromMerc) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        } else {\n\t            coords = gmxAPIutils.coordsToMercator(type, coords);\n\t        }\n\t        return {\n\t            type: geom.type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    /** Converts GeoJSON object into GeoMixer format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - GeoJSON object\r\n\t     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n\t     * @return {Object} Geometry in GeoMixer format\r\n\t    */\n\t    geoJSONtoGeometry: function geoJSONtoGeometry(geoJSON, mercFlag) {\n\t        if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        }\n\t\n\t        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON' : geoJSON.type === 'Polygon' ? 'POLYGON' : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING' : geoJSON.type === 'LineString' ? 'LINESTRING' : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT' : geoJSON.type === 'Point' ? 'POINT' : geoJSON.type,\n\t            coords = geoJSON.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    _coordsConvert: function _coordsConvert(type, coords, toMerc) {\n\t        var i,\n\t            len,\n\t            p,\n\t            resCoords = [];\n\t        if (type === 'Point') {\n\t            if (toMerc) {\n\t                p = L.Projection.Mercator.project({ lat: coords[1], lng: coords[0] });\n\t                resCoords = [p.x, p.y];\n\t            } else {\n\t                p = L.Projection.Mercator.unproject({ y: coords[1], x: coords[0] });\n\t                resCoords = [p.lng, p.lat];\n\t            }\n\t        } else if (type === 'LineString' || type === 'MultiPoint') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'Polygon' || type === 'MultiLineString') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'MultiPolygon') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\n\t            }\n\t        }\n\t        return resCoords;\n\t    },\n\t\n\t    coordsFromMercator: function coordsFromMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, false);\n\t    },\n\t\n\t    coordsToMercator: function coordsToMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, true);\n\t    },\n\t\n\t    transformGeometry: function transformGeometry(geom, callback) {\n\t        return !geom ? geom : {\n\t            type: geom.type,\n\t            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function (p) {\n\t                return callback(p);\n\t            })\n\t        };\n\t    },\n\t\n\t    /** Get area for geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry\r\n\t     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoArea: function geoArea(geom, isMerc) {\n\t        var i,\n\t            len,\n\t            ret = 0,\n\t            type = geom.type || '';\n\t        isMerc = isMerc === undefined || isMerc;\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            for (i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoArea({ type: 'POLYGON', coordinates: geom.coordinates[i] }, isMerc);\n\t            }\n\t            return ret;\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\n\t            for (i = 1, len = geom.coordinates.length; i < len; i++) {\n\t                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\n\t            }\n\t            return ret;\n\t        } else if (geom.length) {\n\t            var latlngs = [],\n\t                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\n\t\n\t            for (i = 0, len = geom.length; i < len; i += vectorSize) {\n\t                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\n\t                latlngs.push(isMerc ? L.Projection.Mercator.unproject({ y: p[1], x: p[0] }) : { lat: p[1], lng: p[0] });\n\t            }\n\t            return gmxAPIutils.getArea(latlngs);\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    /** Get summary for geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON geometry\r\n\t     * @param {Object} unitOptions {\r\n\t     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n\t     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n\t     *               }\r\n\t     * @return {String} Summary string for geometry\r\n\t    */\n\t    getGeoJSONSummary: function getGeoJSONSummary(geom, unitOptions) {\n\t        var type = geom.type,\n\t            units = unitOptions || {},\n\t            out = 0,\n\t            i,\n\t            len,\n\t            coords;\n\t        if (type === 'Point') {\n\t            coords = geom.coordinates;\n\t            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\n\t        } else if (type === 'Polygon') {\n\t            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\n\t        } else if (type === 'MultiPolygon') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoArea({ type: 'Polygon', coordinates: coords[i] }, false);\n\t            }\n\t            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\n\t        } else if (type === 'LineString') {\n\t            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\n\t        } else if (type === 'MultiLineString') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoJSONGetLength({ type: 'LineString', coordinates: coords[i] });\n\t            }\n\t            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for point\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {latlng} point\r\n\t     * @param {num} format number:\r\n\t     *         0: 62°52'30.68\" N, 22°48'27.42\" E\r\n\t     *         1: 62.875188 N, 22.807617 E\r\n\t     *         2: 2538932, 9031643 (EPSG:3395)\r\n\t     *         3: 2538932, 9069712 (EPSG:3857)\r\n\t     * @return {String} Summary string for LatLng point\r\n\t    */\n\t    getCoordinatesString: function getCoordinatesString(latlng, num) {\n\t        var x = latlng.lng,\n\t            y = latlng.lat,\n\t            formats = ['', '', ' (EPSG:3395)', ' (EPSG:3857)'],\n\t            len = formats.length,\n\t            merc,\n\t            out = '';\n\t        num = num || 0;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        }\n\t        if (x < -180) {\n\t            x += 360;\n\t        }\n\t        if (num % len === 0) {\n\t            out = gmxAPIutils.formatCoordinates2(x, y);\n\t        } else if (num % len === 1) {\n\t            out = gmxAPIutils.formatCoordinates(x, y);\n\t        } else if (num % len === 2) {\n\t            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\n\t        } else {\n\t            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for geometries array\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} geometries array in Geomixer format\r\n\t     * @param {Object} units Options for length and area\r\n\t     * @return {String} Summary string for geometries array\r\n\t    */\n\t    getGeometriesSummary: function getGeometriesSummary(arr, unitOptions) {\n\t        var out = '',\n\t            type = '',\n\t            res = 0;\n\t        if (!unitOptions) {\n\t            unitOptions = {};\n\t        }\n\t        if (arr) {\n\t            arr.forEach(function (geom) {\n\t                if (geom) {\n\t                    type = geom.type.toUpperCase();\n\t                    if (type.indexOf('POINT') !== -1) {\n\t                        var latlng = L.Projection.Mercator.unproject({ y: geom.coordinates[1], x: geom.coordinates[0] });\n\t                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: ' + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\n\t                    } else if (type.indexOf('LINESTRING') !== -1) {\n\t                        res += gmxAPIutils.geoLength(geom);\n\t                    } else if (type.indexOf('POLYGON') !== -1) {\n\t                        res += gmxAPIutils.geoArea(geom);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        if (!out) {\n\t            if (type.indexOf('LINESTRING') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: ' + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\n\t            } else if (type.indexOf('POLYGON') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: ' + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getGeometrySummary: function getGeometrySummary(geom, unitOptions) {\n\t        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\n\t    },\n\t\n\t    chkOnEdge: function chkOnEdge(p1, p2, ext) {\n\t        // отрезок на границе\n\t        if (p1[0] < ext.min.x && p2[0] < ext.min.x || p1[0] > ext.max.x && p2[0] > ext.max.x) {\n\t            return true;\n\t        }\n\t        if (p1[1] < ext.min.y && p2[1] < ext.min.y || p1[1] > ext.max.y && p2[1] > ext.max.y) {\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getHidden: function getHidden(coords, tb) {\n\t        // массив точек на границах тайлов\n\t        var hiddenLines = [],\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            prev = null;\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\n\t                hiddenLines.push(i);\n\t            }\n\t            prev = p;\n\t        }\n\t        return hiddenLines;\n\t    },\n\t\n\t    getNormalizeBounds: function getNormalizeBounds(screenBounds, mercDeltaY) {\n\t        // get bounds array from -180 180 lng\n\t        var northWest = screenBounds.getNorthWest(),\n\t            southEast = screenBounds.getSouthEast(),\n\t            minX = northWest.lng,\n\t            maxX = southEast.lng,\n\t            w = (maxX - minX) / 2,\n\t            minX1 = null,\n\t            maxX1 = null,\n\t            out = [];\n\t\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = { x: minX, y: southEast.lat },\n\t            m2 = { x: maxX, y: northWest.lat };\n\t\n\t        if (mercDeltaY !== undefined) {\n\t            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\n\t            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\n\t            m1.y -= mercDeltaY;\n\t            m2.y -= mercDeltaY;\n\t        }\n\t        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\n\t\n\t        if (minX1) {\n\t            var m11 = { x: minX1, y: southEast.lat },\n\t                m12 = { x: maxX1, y: northWest.lat };\n\t            if (mercDeltaY !== undefined) {\n\t                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\n\t                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\n\t                m11.y -= mercDeltaY;\n\t                m12.y -= mercDeltaY;\n\t            }\n\t            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\n\t        }\n\t        return out;\n\t    },\n\t\n\t    toPrecision: function toPrecision(x, prec) {\n\t        var zn = Math.pow(10, prec ? prec : 4);\n\t        return Math.round(zn * x) / zn;\n\t    },\n\t\n\t    getTileBounds: function getTileBounds(x, y, z) {\n\t        //x, y, z - GeoMixer tile coordinates\n\t        var tileSize = gmxAPIutils.tileSizes[z],\n\t            minx = x * tileSize,\n\t            miny = y * tileSize;\n\t        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\n\t    },\n\t\n\t    parseTemplate: function parseTemplate(str, properties) {\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = key in properties ? properties[key] : '';\n\t\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    getDefaultBalloonTemplate: function getDefaultBalloonTemplate(properties, tileAttributeTypes) {\n\t        var str = '';\n\t        for (var key in properties) {\n\t            if (!tileAttributeTypes || key in tileAttributeTypes) {\n\t                str += '<b>' + key + ':</b> [' + key + ']<br />';\n\t            }\n\t        }\n\t        str += '<br />[SUMMARY]<br />';\n\t        return str;\n\t    },\n\t\n\t    parseBalloonTemplate: function parseBalloonTemplate(str, options) {\n\t        var properties = options.properties;\n\t\n\t        if (!str) {\n\t            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\n\t        }\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            var tileAttributeTypes = options.tileAttributeTypes,\n\t                unitOptions = options.unitOptions,\n\t                geometries = options.geometries;\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = '';\n\t\n\t                if (key in properties) {\n\t                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\n\t                } else if (key === 'SUMMARY') {\n\t                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    styleKeys: {\n\t        marker: {\n\t            server: ['image', 'angle', 'scale', 'minScale', 'maxScale', 'size', 'circle', 'center', 'color'],\n\t            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\n\t        },\n\t        outline: {\n\t            server: ['color', 'opacity', 'thickness', 'dashes'],\n\t            client: ['color', 'opacity', 'weight', 'dashArray']\n\t        },\n\t        fill: {\n\t            server: ['color', 'opacity', 'image', 'pattern', 'radialGradient', 'linearGradient'],\n\t            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\n\t        },\n\t        label: {\n\t            server: ['text', 'field', 'template', 'color', 'haloColor', 'size', 'spacing', 'align'],\n\t            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\n\t        }\n\t    },\n\t    styleFuncKeys: {\n\t        iconSize: 'iconSizeFunction',\n\t        iconAngle: 'rotateFunction',\n\t        iconScale: 'scaleFunction',\n\t        iconColor: 'iconColorFunction',\n\t        opacity: 'opacityFunction',\n\t        fillOpacity: 'fillOpacityFunction',\n\t        color: 'colorFunction',\n\t        fillColor: 'fillColorFunction'\n\t    },\n\t    styleFuncError: {\n\t        iconSize: function iconSize() {\n\t            return 8;\n\t        },\n\t        iconAngle: function iconAngle() {\n\t            return 0;\n\t        },\n\t        iconScale: function iconScale() {\n\t            return 1;\n\t        },\n\t        iconColor: function iconColor() {\n\t            return 0xFF;\n\t        },\n\t        opacity: function opacity() {\n\t            return 1;\n\t        },\n\t        fillOpacity: function fillOpacity() {\n\t            return 0.5;\n\t        },\n\t        color: function color() {\n\t            return 0xFF;\n\t        },\n\t        fillColor: function fillColor() {\n\t            return 0xFF;\n\t        }\n\t    },\n\t    defaultStyles: {\n\t        MinZoom: 1,\n\t        MaxZoom: 21,\n\t        Filter: '',\n\t        Balloon: '',\n\t        DisableBalloonOnMouseMove: true,\n\t        DisableBalloonOnClick: false,\n\t        RenderStyle: {\n\t            point: { // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\n\t                color: 0xFF,\n\t                weight: 1,\n\t                iconSize: 8\n\t            },\n\t            linestring: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            },\n\t            polygon: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            }\n\t        }\n\t    },\n\t\n\t    getDefaultStyle: function getDefaultStyle(type) {\n\t        var from = gmxAPIutils.defaultStyles,\n\t            out = L.extend({}, from);\n\t        out.RenderStyle = from.RenderStyle[type];\n\t        return out;\n\t    },\n\t\n\t    toServerStyle: function toServerStyle(style) {\n\t        // Style leaflet->Scanex\n\t        var out = {};\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (var i = 0, len = keys.client.length; i < len; i++) {\n\t                var key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    if (!out[key]) {\n\t                        out[key] = {};\n\t                    }\n\t                    var zn = style[key1];\n\t                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\n\t                        zn *= 100;\n\t                    }\n\t                    out[key][keys.server[i]] = zn;\n\t                }\n\t            }\n\t        }\n\t        if ('iconAnchor' in style) {\n\t            if (!out.marker) {\n\t                out.marker = {};\n\t            }\n\t            out.marker.dx = -style.iconAnchor[0];\n\t            out.marker.dy = -style.iconAnchor[1];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    fromServerStyle: function fromServerStyle(style) {\n\t        // Style Scanex->leaflet\n\t        var st,\n\t            i,\n\t            len,\n\t            key1,\n\t            out = {\n\t            type: '' // 'polygon', 'line', 'circle', 'square', 'image'\n\t        };\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (i = 0, len = keys.client.length; i < len; i++) {\n\t                key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    out[key1] = style[key1];\n\t                }\n\t            }\n\t            st = style[key];\n\t            if (st && (typeof st === 'undefined' ? 'undefined' : _typeof(st)) === 'object') {\n\t                for (i = 0, len = keys.server.length; i < len; i++) {\n\t                    key1 = keys.server[i];\n\t                    if (key1 in st) {\n\t                        var newKey = keys.client[i],\n\t                            zn = st[key1];\n\t                        if (typeof zn === 'string') {\n\t                            if (gmxAPIutils.styleFuncKeys[newKey]) {\n\t                                if (zn.match(/[^\\d\\.]/) === null) {\n\t                                    zn = Number(zn);\n\t                                } else {\n\t                                    var func = L.gmx.Parsers.parseExpression(zn);\n\t                                    if (func === null) {\n\t                                        zn = gmxAPIutils.styleFuncError[newKey]();\n\t                                    } else {\n\t                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\n\t                                    }\n\t                                }\n\t                            }\n\t                        } else if (key1 === 'opacity') {\n\t                            zn /= 100;\n\t                        }\n\t                        out[newKey] = zn;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (style.marker) {\n\t            st = style.marker;\n\t            if ('dx' in st || 'dy' in st) {\n\t                var dx = st.dx || 0,\n\t                    dy = st.dy || 0;\n\t                out.iconAnchor = [-dx, -dy]; // For leaflet type iconAnchor\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getUnixTimeFromStr: function getUnixTimeFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        return Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\n\t    },\n\t\n\t    getDateFromStr: function getDateFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        var dt = new Date(arr[0], arr[1] - 1, arr[2]);\n\t        return dt;\n\t    },\n\t\n\t    getUTCdate: function getUTCdate(utime) {\n\t        var dt = new Date(utime * 1000);\n\t\n\t        return [dt.getUTCFullYear(), gmxAPIutils.pad2(dt.getUTCMonth() + 1), gmxAPIutils.pad2(dt.getUTCDate())].join('.');\n\t    },\n\t\n\t    getUTCtime: function getUTCtime(utime) {\n\t        var h = Math.floor(utime / 3600),\n\t            m = Math.floor((utime - h * 3600) / 60),\n\t            s = Math.floor(utime - h * 3600 - m * 60);\n\t\n\t        return [\n\t        //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\n\t        gmxAPIutils.pad2(h), gmxAPIutils.pad2(m), gmxAPIutils.pad2(s)].join(':');\n\t    },\n\t\n\t    getUTCdateTime: function getUTCdateTime(utime) {\n\t        var time = utime % (3600 * 24);\n\t\n\t        if (time) {\n\t            return [gmxAPIutils.getUTCdate(utime), gmxAPIutils.getUTCtime(utime % (3600 * 24))].join(' ');\n\t        } else {\n\t            return gmxAPIutils.getUTCdate(utime);\n\t        }\n\t    },\n\t\n\t    attrToString: function attrToString(type, value) {\n\t        if (type === 'date') {\n\t            return value ? L.gmxUtil.getUTCdate(value) : value;\n\t        } else if (type === 'time') {\n\t            return value ? L.gmxUtil.getUTCtime(value) : value;\n\t        } else if (type === 'datetime') {\n\t            return value ? L.gmxUtil.getUTCdateTime(value) : value;\n\t        } else {\n\t            return value;\n\t        }\n\t    },\n\t\n\t    getTileAttributes: function getTileAttributes(prop) {\n\t        var tileAttributeIndexes = {},\n\t            tileAttributeTypes = {};\n\t        if (prop.attributes) {\n\t            var attrs = prop.attributes,\n\t                attrTypes = prop.attrTypes || null;\n\t            if (prop.identityField) {\n\t                tileAttributeIndexes[prop.identityField] = 0;\n\t            }\n\t            for (var a = 0; a < attrs.length; a++) {\n\t                var key = attrs[a];\n\t                tileAttributeIndexes[key] = a + 1;\n\t                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\n\t            }\n\t        }\n\t        return {\n\t            tileAttributeTypes: tileAttributeTypes,\n\t            tileAttributeIndexes: tileAttributeIndexes\n\t        };\n\t    }\n\t};\n\t\n\tgmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0); // 111319.5;\n\tgmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI; // 6335440.712613423;\n\t\n\t(function () {\n\t    //pre-calculate tile sizes\n\t    for (var z = 0; z < 30; z++) {\n\t        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\n\t    }\n\t})();\n\t\n\tgmxAPIutils.Bounds = function (arr) {\n\t    this.min = {\n\t        x: Number.MAX_VALUE,\n\t        y: Number.MAX_VALUE\n\t    };\n\t    this.max = {\n\t        x: -Number.MAX_VALUE,\n\t        y: -Number.MAX_VALUE\n\t    };\n\t    this.extendArray(arr);\n\t};\n\tgmxAPIutils.Bounds.prototype = {\n\t    extend: function extend(x, y) {\n\t        if (x < this.min.x) {\n\t            this.min.x = x;\n\t        }\n\t        if (x > this.max.x) {\n\t            this.max.x = x;\n\t        }\n\t        if (y < this.min.y) {\n\t            this.min.y = y;\n\t        }\n\t        if (y > this.max.y) {\n\t            this.max.y = y;\n\t        }\n\t        return this;\n\t    },\n\t    extendBounds: function extendBounds(bounds) {\n\t        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\n\t    },\n\t    extendArray: function extendArray(arr) {\n\t        if (!arr || !arr.length) {\n\t            return this;\n\t        }\n\t        var i, len;\n\t        if (typeof arr[0] === 'number') {\n\t            for (i = 0, len = arr.length; i < len; i += 2) {\n\t                this.extend(arr[i], arr[i + 1]);\n\t            }\n\t        } else {\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                this.extend(arr[i][0], arr[i][1]);\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t    addBuffer: function addBuffer(dxmin, dymin, dxmax, dymax) {\n\t        this.min.x -= dxmin;\n\t        this.min.y -= dymin || dxmin;\n\t        this.max.x += dxmax || dxmin;\n\t        this.max.y += dymax || dymin || dxmin;\n\t        return this;\n\t    },\n\t    contains: function contains(point) {\n\t        // ([x, y]) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = point[0],\n\t            y = point[1];\n\t        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\n\t    },\n\t    getCenter: function getCenter() {\n\t        var min = this.min,\n\t            max = this.max;\n\t        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t    },\n\t    addOffset: function addOffset(offset) {\n\t        this.min.x += offset[0];this.max.x += offset[0];\n\t        this.min.y += offset[1];this.max.y += offset[1];\n\t        return this;\n\t    },\n\t    intersects: function intersects(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\n\t    },\n\t    intersectsWithDelta: function intersectsWithDelta(bounds, dx, dy) {\n\t        // (Bounds, dx, dy) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = dx || 0,\n\t            y = dy || 0,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\n\t    },\n\t    isEqual: function isEqual(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\n\t    },\n\t    isNodeIntersect: function isNodeIntersect(coords) {\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            if (this.contains(coords[i])) {\n\t                return {\n\t                    num: i,\n\t                    point: coords[i]\n\t                };\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t    clipPolygon: function clipPolygon(coords) {\n\t        // (coords) -> clip coords\n\t        var min = this.min,\n\t            max = this.max,\n\t            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\n\t            cp1,\n\t            cp2,\n\t            s,\n\t            e,\n\t            inside = function inside(p) {\n\t            return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\n\t        },\n\t            intersection = function intersection() {\n\t            var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\n\t                dp = [s[0] - e[0], s[1] - e[1]],\n\t                n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n\t                n2 = s[0] * e[1] - s[1] * e[0],\n\t                n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n\t            return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\n\t        };\n\t\n\t        var outputList = coords;\n\t        cp1 = clip[3];\n\t        for (var j = 0; j < 4; j++) {\n\t            cp2 = clip[j];\n\t            var inputList = outputList,\n\t                len = inputList.length;\n\t            outputList = [];\n\t            s = inputList[len - 1]; //last on the input list\n\t            for (var i = 0; i < len; i++) {\n\t                e = inputList[i];\n\t                if (inside(e)) {\n\t                    if (!inside(s)) {\n\t                        outputList.push(intersection());\n\t                    }\n\t                    outputList.push(e);\n\t                } else if (inside(s)) {\n\t                    outputList.push(intersection());\n\t                }\n\t                s = e;\n\t            }\n\t            cp1 = cp2;\n\t        }\n\t        return outputList;\n\t    },\n\t    clipPolyLine: function clipPolyLine(coords, angleFlag, delta) {\n\t        // (coords) -> clip coords\n\t        delta = delta || 0;\n\t        var min = this.min,\n\t            max = this.max,\n\t            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\n\t            bitCode = function bitCode(p) {\n\t            var code = 0;\n\t\n\t            if (p[0] < bbox[0]) code |= 1; // left\n\t            else if (p[0] > bbox[2]) code |= 2; // right\n\t\n\t            if (p[1] < bbox[1]) code |= 4; // bottom\n\t            else if (p[1] > bbox[3]) code |= 8; // top\n\t\n\t            return code;\n\t        },\n\t            getAngle = function getAngle(a, b) {\n\t            return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\n\t        },\n\t            intersect = function intersect(a, b, edge) {\n\t            return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\n\t            edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\n\t            edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\n\t            edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\n\t            null;\n\t        },\n\t            result = [],\n\t            len = coords.length,\n\t            codeA = bitCode(coords[0], bbox),\n\t            part = [],\n\t            i,\n\t            a,\n\t            b,\n\t            c,\n\t            codeB,\n\t            lastCode;\n\t\n\t        for (i = 1; i < len; i++) {\n\t            a = coords[i - 1];\n\t            b = coords[i];\n\t            if (a[0] === b[0] && a[1] === b[1]) {\n\t                continue;\n\t            }\n\t            codeB = lastCode = bitCode(b, bbox);\n\t\n\t            while (true) {\n\t\n\t                if (!(codeA | codeB)) {\n\t                    // accept\n\t                    if (angleFlag) {\n\t                        a[2] = getAngle(a, b);\n\t                        c = coords[i + 1];\n\t                        b[2] = c ? getAngle(b, c) : a[2];\n\t                    }\n\t                    part.push(a);\n\t\n\t                    if (codeB !== lastCode) {\n\t                        // segment went outside\n\t                        part.push(b);\n\t\n\t                        if (i < len - 1) {\n\t                            // start a new line\n\t                            result.push(part);\n\t                            part = [];\n\t                        }\n\t                    } else if (i === len - 1) {\n\t                        part.push(b);\n\t                    }\n\t                    break;\n\t                } else if (codeA & codeB) {\n\t                    // trivial reject\n\t                    break;\n\t                } else if (codeA) {\n\t                    // a outside, intersect with clip edge\n\t                    a = intersect(a, b, codeA, bbox);\n\t                    codeA = bitCode(a, bbox);\n\t                } else {\n\t                    // b outside\n\t                    b = intersect(a, b, codeB, bbox);\n\t                    codeB = bitCode(b, bbox);\n\t                }\n\t            }\n\t\n\t            codeA = lastCode;\n\t        }\n\t\n\t        if (part.length) result.push(part);\n\t\n\t        return result;\n\t    }\n\t};\n\t\n\tgmxAPIutils.bounds = function (arr) {\n\t    return new gmxAPIutils.Bounds(arr);\n\t};\n\t\n\t//скопирована из API для обеспечения независимости от него\n\tgmxAPIutils.parseUri = function (str) {\n\t    var o = gmxAPIutils.parseUri.options,\n\t        m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\n\t        uri = {},\n\t        i = 14;\n\t\n\t    while (i--) {\n\t        uri[o.key[i]] = m[i] || '';\n\t    }\n\t\n\t    uri[o.q.name] = {};\n\t    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n\t        if ($1) {\n\t            uri[o.q.name][$1] = $2;\n\t        }\n\t    });\n\t\n\t    uri.hostOnly = uri.host;\n\t    uri.host = uri.authority; // HACK\n\t\n\t    return uri;\n\t};\n\t\n\tgmxAPIutils.parseUri.options = {\n\t    strictMode: false,\n\t    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n\t    q: {\n\t        name: 'queryKey',\n\t        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n\t    },\n\t    parser: {\n\t        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n\t        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n\t    }\n\t};\n\t\n\tif (!L.gmxUtil) {\n\t    L.gmxUtil = {};\n\t}\n\t\n\t//public interface\n\tL.extend(L.gmxUtil, {\n\t    newId: gmxAPIutils.newId,\n\t    loaderStatus: function loaderStatus() {},\n\t    isIE9: gmxAPIutils.isIE(9),\n\t    isIE10: gmxAPIutils.isIE(10),\n\t    isIE11: gmxAPIutils.isIE(11),\n\t    gtIE11: gmxAPIutils.gtIE(11),\n\t    getFormData: gmxAPIutils.getFormData,\n\t    requestJSONP: gmxAPIutils.requestJSONP,\n\t    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\n\t    request: gmxAPIutils.request,\n\t    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\n\t    fromServerStyle: gmxAPIutils.fromServerStyle,\n\t    toServerStyle: gmxAPIutils.toServerStyle,\n\t    getDefaultStyle: gmxAPIutils.getDefaultStyle,\n\t    bounds: gmxAPIutils.bounds,\n\t    getGeometryBounds: gmxAPIutils.getGeometryBounds,\n\t    tileSizes: gmxAPIutils.tileSizes,\n\t    getDateFromStr: gmxAPIutils.getDateFromStr,\n\t    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\n\t    getUTCdate: gmxAPIutils.getUTCdate,\n\t    getUTCtime: gmxAPIutils.getUTCtime,\n\t    getUTCdateTime: gmxAPIutils.getUTCdateTime,\n\t    attrToString: gmxAPIutils.attrToString,\n\t    getTileAttributes: gmxAPIutils.getTileAttributes,\n\t    formatCoordinates: function formatCoordinates(latlng, type) {\n\t        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\n\t    },\n\t    formatDegrees: gmxAPIutils.formatDegrees,\n\t    pad2: gmxAPIutils.pad2,\n\t    dec2hex: gmxAPIutils.dec2hex,\n\t    dec2rgba: gmxAPIutils.dec2rgba,\n\t    trunc: gmxAPIutils.trunc,\n\t    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\n\t    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\n\t    getLength: gmxAPIutils.getLength,\n\t    geoLength: gmxAPIutils.geoLength,\n\t    prettifyDistance: gmxAPIutils.prettifyDistance,\n\t    getArea: gmxAPIutils.getArea,\n\t    prettifyArea: gmxAPIutils.prettifyArea,\n\t    geoArea: gmxAPIutils.geoArea,\n\t    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\n\t    getSVGIcon: gmxAPIutils.getSVGIcon,\n\t    getCoordinatesString: gmxAPIutils.getCoordinatesString,\n\t    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\n\t    getGeometrySummary: gmxAPIutils.getGeometrySummary,\n\t    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\n\t    getPropertiesHash: gmxAPIutils.getPropertiesHash,\n\t    distVincenty: gmxAPIutils.distVincenty,\n\t    parseCoordinates: gmxAPIutils.parseCoordinates,\n\t    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\n\t    convertGeometry: gmxAPIutils.convertGeometry,\n\t    transformGeometry: gmxAPIutils.transformGeometry,\n\t    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\n\t    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\n\t    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\n\t    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\n\t    parseUri: gmxAPIutils.parseUri,\n\t    isRectangle: gmxAPIutils.isRectangle,\n\t    isClockwise: gmxAPIutils.isClockwise,\n\t    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\n\t    getPatternIcon: gmxAPIutils.getPatternIcon,\n\t    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\n\t    normalizeHostname: gmxAPIutils.normalizeHostname,\n\t    getTileBounds: gmxAPIutils.getTileBounds,\n\t    parseTemplate: gmxAPIutils.parseTemplate\n\t});\n\t\n\t(function () {\n\t    var requests = {};\n\t    var lastRequestId = 0;\n\t\n\t    var processMessage = function processMessage(e) {\n\t\n\t        if (!(e.origin in requests)) {\n\t            return;\n\t        }\n\t\n\t        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\n\t        try {\n\t            var dataObj = JSON.parse(dataStr);\n\t        } catch (ev) {\n\t            console.log({ Status: 'error', ErrorInfo: { ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr } });\n\t        }\n\t        var request = requests[e.origin][dataObj.CallbackName];\n\t        if (!request) {\n\t            return; // message от других запросов\n\t        }\n\t\n\t        delete requests[e.origin][dataObj.CallbackName];\n\t        delete dataObj.CallbackName;\n\t\n\t        if (request.iframe.parentNode) {\n\t            request.iframe.parentNode.removeChild(request.iframe);\n\t        }\n\t        if ('callback' in request) {\n\t            request.callback(dataObj);\n\t        }\n\t    };\n\t\n\t    L.DomEvent.on(window, 'message', processMessage);\n\t\n\t    function createPostIframe2(id, callback, url) {\n\t        var uniqueId = 'gmxAPIutils_id' + lastRequestId++,\n\t            iframe = L.DomUtil.create('iframe');\n\t\n\t        iframe.style.display = 'none';\n\t        iframe.setAttribute('id', id);\n\t        iframe.setAttribute('name', id); /*eslint-disable no-script-url */\n\t        iframe.src = 'javascript:true'; /*eslint-enable */\n\t        iframe.callbackName = uniqueId;\n\t\n\t        var parsedURL = gmxAPIutils.parseUri(url);\n\t        var origin = (parsedURL.protocol ? parsedURL.protocol + ':' : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\n\t\n\t        requests[origin] = requests[origin] || {};\n\t        requests[origin][uniqueId] = { callback: callback, iframe: iframe };\n\t\n\t        return iframe;\n\t    }\n\t\n\t    //расширяем namespace\n\t    gmxAPIutils.createPostIframe2 = createPostIframe2;\n\t})();\n\t\n\t// кроссдоменный POST запрос\n\t(function () {\n\t    /** Посылает кроссдоменный POST запрос\r\n\t    * @namespace L.gmxUtil\r\n\t       * @ignore\r\n\t    * @function\r\n\t    *\r\n\t    * @param url {string} - URL запроса\r\n\t    * @param params {object} - хэш параметров-запросов\r\n\t    * @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные\r\n\t    * @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл.\r\n\t    *                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.\r\n\t    */\n\t    function sendCrossDomainPostRequest(url, params, callback, baseForm) {\n\t        var form,\n\t            id = '$$iframe_' + gmxAPIutils.newId();\n\t\n\t        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\n\t            originalFormAction;\n\t\n\t        if (baseForm) {\n\t            form = baseForm;\n\t            originalFormAction = form.getAttribute('action');\n\t            form.setAttribute('action', url);\n\t            form.target = id;\n\t        } else if (L.Browser.ielt9) {\n\t            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\n\t            form = document.createElement(str);\n\t        } else {\n\t            form = document.createElement('form');\n\t            form.style.display = 'none';\n\t            form.setAttribute('enctype', 'multipart/form-data');\n\t            form.target = id;\n\t            form.setAttribute('method', 'POST');\n\t            form.setAttribute('action', url);\n\t            form.id = id;\n\t        }\n\t\n\t        var hiddenParamsDiv = document.createElement('div');\n\t        hiddenParamsDiv.style.display = 'none';\n\t\n\t        if (params.WrapStyle === 'window') {\n\t            params.WrapStyle = 'message';\n\t        }\n\t\n\t        if (params.WrapStyle === 'message') {\n\t            params.CallbackName = iframe.callbackName;\n\t        }\n\t\n\t        for (var paramName in params) {\n\t            var input = document.createElement('input');\n\t            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\n\t            input.setAttribute('type', 'hidden');\n\t            input.setAttribute('name', paramName);\n\t            input.setAttribute('value', value);\n\t            hiddenParamsDiv.appendChild(input);\n\t        }\n\t\n\t        form.appendChild(hiddenParamsDiv);\n\t\n\t        if (!baseForm) {\n\t            document.body.appendChild(form);\n\t        }\n\t        document.body.appendChild(iframe);\n\t\n\t        form.submit();\n\t\n\t        if (baseForm) {\n\t            form.removeChild(hiddenParamsDiv);\n\t            if (originalFormAction !== null) {\n\t                form.setAttribute('action', originalFormAction);\n\t            } else {\n\t                form.removeAttribute('action');\n\t            }\n\t        } else {\n\t            form.parentNode.removeChild(form);\n\t        }\n\t    }\n\t    //расширяем namespace\n\t    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\n\t})();\n\texports.gmxAPIutils = gmxAPIutils;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\n\t    styleCanvasKeysLen = styleCanvasKeys.length;\n\t\n\tvar setCanvasStyle = function setCanvasStyle(prop, indexes, ctx, style) {\n\t    for (var i = 0; i < styleCanvasKeysLen; i++) {\n\t        var key = styleCanvasKeys[i],\n\t            valKey = style[key];\n\t        if (valKey !== ctx[key]) {\n\t            ctx[key] = valKey;\n\t        }\n\t    }\n\t    if (style.dashArray) {\n\t        var dashes = style.dashArray,\n\t            dashOffset = style.dashOffset || 0;\n\t        if ('setLineDash' in ctx) {\n\t            ctx.setLineDash(dashes);\n\t            if (ctx.lineDashOffset !== dashOffset) {\n\t                ctx.lineDashOffset = dashOffset;\n\t            }\n\t        }\n\t    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t        ctx.setLineDash([]);\n\t    }\n\t    if (ctx.lineCap !== 'round') {\n\t        ctx.lineCap = 'round';\n\t    }\n\t    if (ctx.lineJoin !== 'round') {\n\t        ctx.lineJoin = 'round';\n\t    }\n\t\n\t    if (style.canvasPattern) {\n\t        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\n\t    } else if (style.fillLinearGradient) {\n\t        var rgr = style.fillLinearGradient,\n\t            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\n\t            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\n\t        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\n\t            var arr1 = rgr.addColorStop[j],\n\t                arrFunc = rgr.addColorStopFunctions[j],\n\t                p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0],\n\t                p2 = arr1.length < 3 ? 100 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2],\n\t                p1 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\n\t            lineargrad.addColorStop(p0, p1);\n\t        }\n\t        ctx.fillStyle = style.fillStyle = lineargrad;\n\t    }\n\t};\n\t\n\t/*\r\n\tgeoItem\r\n\t     properties: объект (в формате векторного тайла)\r\n\t     dataOption: дополнительные свойства объекта\r\n\titem\r\n\t     skipRasters: скрыть растр\r\n\t     currentStyle: текущий canvas стиль объекта\r\n\t     parsedStyleKeys: стиль прошедший парсинг\r\n\toptions\r\n\t     ctx: canvas context\r\n\t     tbounds: tile bounds\r\n\t     tpx: X смещение тайла\r\n\t     tpy: Y смещение тайла\r\n\t     gmx: ссылка на layer._gmx\r\n\t        gmx.currentZoom\r\n\t        gmx.lastHover\r\n\t        gmx.tileAttributeIndexes\r\n\t     bgImage: растр для background\r\n\t     rasters: растры по объектам для background\r\n\tcurrentStyle\r\n\t    текущий стиль\r\n\tstyle\r\n\t    стиль в новом формате\r\n\t    style.image - для type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n\t*/\n\tL.gmxUtil.drawGeoItem = function (geoItem, item, options, currentStyle, style) {\n\t    var propsArr = geoItem.properties,\n\t        idr = propsArr[0],\n\t        i,\n\t        len,\n\t        j,\n\t        len1,\n\t        gmx = options.gmx,\n\t        ctx = options.ctx,\n\t        geom = propsArr[propsArr.length - 1],\n\t        coords = null,\n\t        dataOption = geoItem.dataOption,\n\t        rasters = options.rasters || {},\n\t        tbounds = options.tbounds;\n\t\n\t    item.currentStyle = L.extend({}, currentStyle);\n\t    if (style) {\n\t        if (gmx.styleHook) {\n\t            if (!geoItem.styleExtend) {\n\t                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\n\t            }\n\t            if (geoItem.styleExtend) {\n\t                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\n\t            } else {\n\t                return false;\n\t            }\n\t        }\n\t        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\n\t    } else {\n\t        style = {};\n\t    }\n\t\n\t    var geoType = geom.type,\n\t        dattr = {\n\t        gmx: gmx,\n\t        item: item,\n\t        style: style,\n\t        styleExtend: geoItem.styleExtend || {},\n\t        ctx: ctx,\n\t        tpx: options.tpx,\n\t        tpy: options.tpy\n\t    };\n\t    if (geoType === 'POINT') {\n\t        dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, geom.coordinates);\n\t        if (!dattr.pointAttr) {\n\t            return false;\n\t        } // point not in canvas tile\n\t    }\n\t    if (geoType === 'POINT' || geoType === 'MULTIPOINT') {\n\t        // Отрисовка геометрии точек\n\t        coords = geom.coordinates;\n\t        if ('iconColor' in style && style.image) {\n\t            if (style.lastImage !== style.image) {\n\t                style.lastImage = style.image;\n\t                style.lastImageData = _Utils.gmxAPIutils.getImageData(style.image);\n\t            }\n\t            dattr.imageData = style.lastImageData;\n\t        }\n\t\n\t        if (geoType === 'MULTIPOINT') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                dattr.coords = coords[i];\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            dattr.coords = coords;\n\t            _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t        }\n\t    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\n\t        if (style.image) {\n\t            // set MULTIPOLYGON as marker\n\t            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\n\t            dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, dattr.coords);\n\t            if (dattr.pointAttr) {\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            coords = geom.coordinates;\n\t            if (geoType === 'POLYGON') {\n\t                coords = [coords];\n\t            }\n\t\n\t            var hiddenLines = dataOption.hiddenLines || [],\n\t                pixelsMap = dataOption.pixels,\n\t                flagPixels = true;\n\t\n\t            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\n\t                pixelsMap = dataOption.pixels = _Utils.gmxAPIutils.getCoordsPixels({\n\t                    gmx: gmx,\n\t                    coords: coords,\n\t                    tpx: options.tpx,\n\t                    tpy: options.tpy,\n\t                    hiddenLines: hiddenLines\n\t                });\n\t            }\n\t\n\t            var coordsToCanvas = function coordsToCanvas(func, flagFill) {\n\t                coords = pixelsMap.coords;\n\t                hiddenLines = pixelsMap.hidden || [];\n\t                dattr.flagPixels = flagPixels;\n\t                for (i = 0, len = coords.length; i < len; i++) {\n\t                    var coords1 = coords[i];\n\t                    var hiddenLines1 = hiddenLines[i] || [];\n\t                    ctx.beginPath();\n\t                    for (j = 0, len1 = coords1.length; j < len1; j++) {\n\t                        dattr.coords = coords1[j];\n\t                        dattr.hiddenLines = hiddenLines1[j] || [];\n\t                        func(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    if (flagFill) {\n\t                        ctx.fill();\n\t                    }\n\t                }\n\t            };\n\t            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\n\t                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\n\t            if (strokeStyle && lineWidth) {\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvas);\n\t            }\n\t            if (options.bgImage) {\n\t                dattr.bgImage = options.bgImage;\n\t            } else if (rasters[idr]) {\n\t                dattr.bgImage = rasters[idr];\n\t            }\n\t            if (dattr.styleExtend.skipRasters || item.skipRasters) {\n\t                delete dattr.bgImage;\n\t            }\n\t            if (style.imagePattern) {\n\t                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\n\t            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                if (_Utils.gmxAPIutils.isPatternNode(dattr.bgImage)) {\n\t                    if ('rasterOpacity' in gmx) {\n\t                        ctx.globalAlpha = gmx.rasterOpacity;\n\t                    }\n\t                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\n\t                    style.bgImage = true;\n\t                }\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t                ctx.globalAlpha = 1;\n\t            }\n\t            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\n\t                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t            }\n\t        }\n\t    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\n\t        coords = geom.coordinates;\n\t        if (geoType === 'LINESTRING') {\n\t            coords = [coords];\n\t        }\n\t        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\n\t        for (i = 0, len = coords.length; i < len; i++) {\n\t            var arr = tbounds.clipPolyLine(coords[i], true, size);\n\t            for (j = 0, len1 = arr.length; j < len1; j++) {\n\t                dattr.coords = arr[j];\n\t                var pixels = _Utils.gmxAPIutils.lineToCanvas(dattr);\n\t                if (pixels) {\n\t                    ctx.save();\n\t                    _Utils.gmxAPIutils.lineToCanvasAsIcon(pixels, dattr);\n\t                    ctx.restore();\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return true;\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n\t*/\n\tvar gmxSessionManager = {\n\t    APIKEY_PARAM: 'key',\n\t    SCRIPT_REGEXP: [/\\bleaflet-geomixer(-\\w*)?\\.js\\b/, /\\bgeomixer(-\\w*)?\\.js\\b/],\n\t    _scriptSearched: false,\n\t    _scriptAPIKey: null,\n\t    _searchScriptAPIKey: function _searchScriptAPIKey() {\n\t        var _this = this;\n\t        if (this._scriptSearched) {\n\t            return this._scriptAPIKey;\n\t        }\n\t\n\t        var scripts = document.getElementsByTagName('script');\n\t        for (var i = 0; i < scripts.length; i++) {\n\t            var src = scripts[i].getAttribute('src'),\n\t                arr = this.SCRIPT_REGEXP;\n\t            for (var j = 0, len = arr.length; j < len; j++) {\n\t                if (arr[j].exec(src)) {\n\t                    var query = src.split('?')[1];\n\t\n\t                    if (query) {\n\t                        var params = query.split('&');\n\t                        for (var p = 0; p < params.length; p++) {\n\t                            var parsedParam = params[p].split('=');\n\t                            if (parsedParam[0] === _this.APIKEY_PARAM) {\n\t                                _this._scriptAPIKey = parsedParam[1];\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t            if (_this._scriptAPIKey) {\n\t                break;\n\t            }\n\t        }\n\t        this._scriptSearched = true;\n\t        return this._scriptAPIKey;\n\t    },\n\t\n\t    //we will search apiKey in script tags iff apiKey parameter is undefined.\n\t    //if it is defined as falsy (null, '', etc), we won't send any requests to server\n\t    requestSessionKey: function requestSessionKey(serverHost, apiKey) {\n\t        var keys = this._sessionKeys;\n\t\n\t        if (!(serverHost in keys)) {\n\t            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\n\t            keys[serverHost] = new L.gmx.Deferred();\n\t            if (apiKey) {\n\t                gmxAPIutils.requestJSONP('http://' + serverHost + '/ApiKey.ashx', {\n\t                    WrapStyle: 'func',\n\t                    Key: apiKey\n\t                }).then(function (response) {\n\t                    if (response && response.Status === 'ok') {\n\t                        keys[serverHost].resolve(response.Result.Key);\n\t                    } else {\n\t                        keys[serverHost].reject();\n\t                    }\n\t                }, keys[serverHost].reject);\n\t            } else {\n\t                keys[serverHost].resolve('');\n\t            }\n\t        }\n\t        return keys[serverHost];\n\t    },\n\t\n\t    //get already received session key\n\t    getSessionKey: function getSessionKey(serverHost) {\n\t        var keyPromise = this._sessionKeys[serverHost];\n\t\n\t        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\n\t    },\n\t    _sessionKeys: {} //deferred for each host\n\t};\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxSessionManager = gmxSessionManager;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.gmxMapManager = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxMapManager = {\n\t    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\n\t    getMap: function getMap(serverHost, apiKey, mapName, skipTiles) {\n\t        var maps = this._maps;\n\t        if (!maps[serverHost] || !maps[serverHost][mapName]) {\n\t            var def = new L.gmx.Deferred();\n\t            maps[serverHost] = maps[serverHost] || {};\n\t            maps[serverHost][mapName] = { promise: def };\n\t\n\t            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function (sessionKey) {\n\t                _Utils.gmxAPIutils.requestJSONP('http://' + serverHost + '/TileSender.ashx', {\n\t                    WrapStyle: 'func',\n\t                    skipTiles: skipTiles || 'None', // All, NotVisible, None\n\t                    key: sessionKey,\n\t                    MapName: mapName,\n\t                    ModeKey: 'map'\n\t                }).then(function (json) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        json.Result.properties.hostName = serverHost;\n\t                        def.resolve(json.Result);\n\t                    } else {\n\t                        def.reject(json);\n\t                    }\n\t                }, def.reject);\n\t            }, def.reject);\n\t        }\n\t        return maps[serverHost][mapName].promise;\n\t    },\n\t\n\t    syncParams: {},\n\t    // установка дополнительных параметров для серверных запросов\n\t    setSyncParams: function setSyncParams(hash) {\n\t        this.syncParams = hash;\n\t    },\n\t    getSyncParams: function getSyncParams(stringFlag) {\n\t        var res = this.syncParams;\n\t        if (stringFlag) {\n\t            var arr = [];\n\t            for (var key in res) {\n\t                arr.push(key + '=' + res[key]);\n\t            }\n\t            res = arr.join('&');\n\t        }\n\t        return res;\n\t    },\n\t\n\t    //we will (lazy) create index by layer name to speed up multiple function calls\n\t    findLayerInfo: function findLayerInfo(serverHost, mapID, layerID) {\n\t        var hostMaps = this._maps[serverHost],\n\t            mapInfo = hostMaps && hostMaps[mapID];\n\t\n\t        if (!mapInfo) {\n\t            return null;\n\t        }\n\t\n\t        if (mapInfo.layers) {\n\t            return mapInfo.layers[layerID];\n\t        }\n\t\n\t        var serverData = mapInfo.promise.getFulfilledData();\n\t\n\t        if (!serverData) {\n\t            return null;\n\t        }\n\t\n\t        mapInfo.layers = {};\n\t\n\t        //create index by layer name\n\t        gmxMapManager.iterateLayers(serverData[0], function (layerInfo) {\n\t            mapInfo.layers[layerInfo.properties.name] = layerInfo;\n\t        });\n\t\n\t        return mapInfo.layers[layerID];\n\t    },\n\t    iterateLayers: function iterateLayers(treeInfo, callback) {\n\t        var iterate = function iterate(arr) {\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var layer = arr[i];\n\t\n\t                if (layer.type === 'group') {\n\t                    iterate(layer.content.children);\n\t                } else if (layer.type === 'layer') {\n\t                    callback(layer.content);\n\t                }\n\t            }\n\t        };\n\t\n\t        treeInfo && iterate(treeInfo.children);\n\t    },\n\t    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\n\t}; /** Asynchronously request information about map given server host and map name\r\n\t   */\n\texports.gmxMapManager = gmxMapManager;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//Helper class, that represents layers of single Geomixer's map\n\t//Creates layers from given map description\n\tvar gmxMap = L.Class.extend({\n\t\tincludes: L.Mixin.Events,\n\t\n\t\tinitialize: function initialize(mapInfo, commonLayerOptions) {\n\t\t\tthis.layers = [];\n\t\t\tthis.layersByTitle = {};\n\t\t\tthis.layersByID = {};\n\t\t\tthis.dataManagers = {};\n\t\n\t\t\tvar _this = this;\n\t\n\t\t\tthis.properties = L.extend({}, mapInfo.properties);\n\t\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\n\t\t\tthis.rawTree = mapInfo;\n\t\n\t\t\tthis.layersCreated = new L.gmx.Deferred();\n\t\n\t\t\tvar missingLayerTypes = {},\n\t\t\t    dataSources = {};\n\t\n\t\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function (layerInfo) {\n\t\t\t\tvar props = layerInfo.properties,\n\t\t\t\t    meta = props.MetaProperties || {},\n\t\t\t\t    options = {\n\t\t\t\t\tmapID: mapInfo.properties.name,\n\t\t\t\t\tlayerID: props.name\n\t\t\t\t};\n\t\n\t\t\t\tprops.hostName = mapInfo.properties.hostName;\n\t\n\t\t\t\tvar type = props.ContentID || props.type,\n\t\t\t\t    layerOptions = L.extend(options, commonLayerOptions);\n\t\n\t\t\t\tif (props.dataSource || 'parentLayer' in meta) {\n\t\t\t\t\t// Set dataSource layer\n\t\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\n\t\t\t\t\tif ('parentLayer' in meta) {\n\t\t\t\t\t\t// todo удалить после изменений вов вьювере\n\t\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\n\t\t\t\t\t}\n\t\t\t\t\tdataSources[options.layerID] = {\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t};\n\t\t\t\t} else if (type in L.gmx._layerClasses) {\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\n\t\t\t\t} else {\n\t\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\n\t\t\t\t\tmissingLayerTypes[type].push({\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t//load missing layer types\n\t\t\tvar loaders = [];\n\t\t\tfor (var type in missingLayerTypes) {\n\t\t\t\tloaders.push(L.gmx._loadLayerClass(type).then( /*eslint-disable no-loop-func */function (type) {\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t\tvar it = missingLayerTypes[type];\n\t\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\n\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\n\t\t\t\t\t}\n\t\t\t\t}.bind(null, type)));\n\t\t\t}\n\t\t\tvar hosts = {},\n\t\t\t    host,\n\t\t\t    id,\n\t\t\t    it;\n\t\t\tfor (id in dataSources) {\n\t\t\t\tit = dataSources[id];\n\t\t\t\tvar opt = it.options,\n\t\t\t\t    pId = opt.parentLayer,\n\t\t\t\t    pLayer = this.layersByID[pId];\n\t\t\t\tif (pLayer) {\n\t\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\n\t\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);\n\t\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\n\t\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\n\t\t\t\t} else {\n\t\t\t\t\thost = opt.hostName;\n\t\t\t\t\tif (!hosts[host]) {\n\t\t\t\t\t\thosts[host] = {};\n\t\t\t\t\t}\n\t\t\t\t\tif (!hosts[host][pId]) {\n\t\t\t\t\t\thosts[host][pId] = [];\n\t\t\t\t\t}\n\t\t\t\t\thosts[host][pId].push(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (host in hosts) {\n\t\t\t\tvar arr = [],\n\t\t\t\t    prefix = 'http://' + host;\n\t\t\t\tfor (id in hosts[host]) {\n\t\t\t\t\tarr.push({ Layer: id });\n\t\t\t\t}\n\t\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx', {\n\t\t\t\t\tWrapStyle: 'func',\n\t\t\t\t\tLayers: JSON.stringify(arr)\n\t\t\t\t}, {\n\t\t\t\t\tids: hosts[host]\n\t\t\t\t}).then(function (json, opt) {\n\t\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\n\t\t\t\t\t\tjson.Result.forEach(function (it) {\n\t\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\n\t\t\t\t\t\t\t    props = it.properties,\n\t\t\t\t\t\t\t    pId = props.name;\n\t\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\tvar pt = dataSources[id];\n\t\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\n\t\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\n\t\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\n\t\t\t\t\t\tif (opt && opt.ids) {\n\t\t\t\t\t\t\tfor (var pId in opt.ids) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\n\t\t},\n\t\n\t\taddDataManager: function addDataManager(it) {\n\t\t\tvar pid = it.properties.name;\n\t\t\tif (!this.dataManagers[pid]) {\n\t\t\t\tthis.dataManagers[pid] = new DataManager(it.properties);\n\t\t\t}\n\t\t\treturn this.dataManagers[pid];\n\t\t},\n\t\tgetDataManager: function getDataManager(id) {\n\t\t\treturn this.dataManagers[id];\n\t\t},\n\t\n\t\taddLayer: function addLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tthis.layers.push(layer);\n\t\t\tthis.layersByTitle[props.title] = layer;\n\t\t\tthis.layersByID[props.name] = layer;\n\t\t\tthis.fire('layeradd', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveLayer: function removeLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tfor (var i = 0; i < this.layers.length; i++) {\n\t\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\n\t\t\t\t\tthis.layers.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tdelete this.layersByTitle[props.title];\n\t\t\tdelete this.layersByID[props.name];\n\t\t\tthis.fire('layerremove', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\taddLayersToMap: function addLayersToMap(leafletMap) {\n\t\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\n\t\t\t\tvar layer = this.layers[l];\n\t\t\t\tif (layer.getGmxProperties().visible) {\n\t\t\t\t\tleafletMap.addLayer(layer);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t});\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxMap = gmxMap;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * gmxEventsManager - handlers manager\r\n\t */\n\tvar GmxEventsManager = L.Handler.extend({\n\t    options: {},\n\t\n\t    initialize: function initialize(map) {\n\t        this._map = map;\n\t        this._layers = {};\n\t        this._lastLayer = null;\n\t        this._lastId = null;\n\t        var _this = this;\n\t        this._drawstart = null;\n\t        this._lastCursor = '';\n\t\n\t        var isDrawing = function isDrawing() {\n\t            if (_this._drawstart) {\n\t                return true;\n\t            } else if (_this._drawstart === null) {\n\t                if (map.gmxControlsManager) {\n\t                    var drawingControl = map.gmxControlsManager.get('drawing');\n\t                    if (drawingControl) {\n\t                        drawingControl.on('activechange', function (ev) {\n\t                            _this._drawstart = ev.activeIcon;\n\t                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\n\t                        });\n\t                    }\n\t                }\n\t                _this._drawstart = false;\n\t            }\n\t            return false;\n\t        };\n\t\n\t        var getDomIndex = function getDomIndex(layer) {\n\t            var container = layer._container;\n\t            if (container) {\n\t                var arr = container.parentNode.childNodes;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    if (container === arr[i]) {\n\t                        return i;\n\t                    }\n\t                }\n\t            }\n\t            return 0;\n\t        };\n\t\n\t        var skipNodeName = {\n\t            IMG: true,\n\t            DIV: true,\n\t            path: true\n\t        };\n\t\n\t        var clearLastHover = function clearLastHover() {\n\t            if (_this._lastLayer) {\n\t                _this._lastLayer.gmxEventCheck({ type: 'mousemove' }, true);\n\t                _this._lastLayer = null;\n\t            }\n\t        };\n\t\n\t        var eventCheck = function eventCheck(ev) {\n\t            var type = ev.type,\n\t                map = _this._map,\n\t                skipNode = false;\n\t            if (ev.originalEvent) {\n\t                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\n\t                var target = ev.originalEvent.target;\n\t                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\n\t            }\n\t            if (map._animatingZoom || isDrawing() || skipNode || type === 'click' && map._skipClick || // from drawing\n\t            type === 'mousemove' && map.gmxMouseDown) {\n\t                clearLastHover();\n\t                map._skipClick = false;\n\t                return;\n\t            }\n\t            if (ev.layerPoint) {\n\t                map._gmxMouseLatLng = ev.latlng;\n\t                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\n\t            }\n\t\n\t            var arr = Object.keys(_this._layers).sort(function (a, b) {\n\t                var la = map._layers[a],\n\t                    lb = map._layers[b];\n\t                if (la && lb) {\n\t                    var oa = la.options,\n\t                        ob = lb.options,\n\t                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\n\t                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\n\t                        delta = zb - za;\n\t                    return delta ? delta : _this._layers[b] - _this._layers[a];\n\t                }\n\t                return 0;\n\t            });\n\t\n\t            var layer,\n\t                foundLayer = null,\n\t                cursor = '';\n\t\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var id = arr[i];\n\t                layer = map._layers[id];\n\t                if (layer && layer._map && !layer._animating && layer.options.clickable) {\n\t                    if (layer.gmxEventCheck(ev)) {\n\t                        if (layer.hasEventListeners('mouseover')) {\n\t                            cursor = 'pointer';\n\t                        }\n\t                        foundLayer = layer;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            if (_this._lastCursor !== cursor && !isDrawing()) {\n\t                map._container.style.cursor = cursor;\n\t            }\n\t            _this._lastCursor = cursor;\n\t\n\t            if (type !== 'zoomend') {\n\t                if (foundLayer) {\n\t                    if (_this._lastLayer !== foundLayer) {\n\t                        clearLastHover();\n\t                    }\n\t                    _this._lastLayer = foundLayer;\n\t                } else {\n\t                    clearLastHover();\n\t                }\n\t            }\n\t        };\n\t\n\t        map.on({\n\t            zoomend: function zoomend() {\n\t                if (map._gmxMouseLatLng) {\n\t                    setTimeout(function () {\n\t                        eventCheck({ type: 'mousemove', latlng: map._gmxMouseLatLng });\n\t                    }, 0);\n\t                }\n\t            },\n\t            click: eventCheck,\n\t            dblclick: eventCheck,\n\t            mousedown: eventCheck,\n\t            mouseup: eventCheck,\n\t            mousemove: eventCheck,\n\t            contextmenu: eventCheck,\n\t            layeradd: function layeradd(ev) {\n\t                var layer = ev.layer;\n\t                if ('gmxEventCheck' in layer && layer.options.clickable) {\n\t                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\n\t                }\n\t            },\n\t            layerremove: function layerremove(ev) {\n\t                var id = ev.layer._leaflet_id;\n\t                delete _this._layers[id];\n\t                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\n\t                    _this._lastLayer = null;\n\t                    _this._lastId = 0;\n\t                }\n\t            }\n\t        }, this);\n\t    }\n\t});\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if handler has already been initialized.\n\t    if (!this._gmxEventsManager) {\n\t        this._gmxEventsManager = new GmxEventsManager(this);\n\t        this.isGmxDrawing = function () {\n\t            return this._gmxEventsManager._drawstart;\n\t        };\n\t\n\t        this.on('remove', function () {\n\t            if (this._gmxEventsManager) {\n\t                this._gmxEventsManager.removeHooks();\n\t            }\n\t        });\n\t    }\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var DEFAULT_LANGUAGE = 'rus',\n\t        _setKeyText = function _setKeyText(lang, key, item, hash) {\n\t        if (!hash[lang]) {\n\t            hash[lang] = {};\n\t        }\n\t        hash[lang][key] = item;\n\t    };\n\t    L.gmxLocale = {\n\t\n\t        setLanguage: function setLanguage(lang) {\n\t            this._language = lang;\n\t        },\n\t\n\t        getLanguage: function getLanguage() {\n\t            return window.language || this._language || DEFAULT_LANGUAGE;\n\t        }\n\t    };\n\t\n\t    L.gmxLocaleMixin = {\n\t        addText: function addText() {\n\t            var lang = arguments[0],\n\t                newHash = arguments[1];\n\t            if (arguments.length === 1) {\n\t                newHash = lang;\n\t                lang = null;\n\t            }\n\t            for (var k in newHash) {\n\t                if (lang === null) {\n\t                    for (var k1 in newHash[k]) {\n\t                        _setKeyText(k, k1, newHash[k][k1], this);\n\t                    }\n\t                } else {\n\t                    _setKeyText(lang, k, newHash[k], this);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getText: function getText(key) {\n\t            var lang = L.gmxLocale.getLanguage(),\n\t                locale = this[lang] || {};\n\t\n\t            var keyArr = key ? key.split(/\\./) : [];\n\t            for (var i = 0, len = keyArr.length; i < len; i++) {\n\t                if (!locale) {\n\t                    break;\n\t                }\n\t                locale = locale[keyArr[i]];\n\t            }\n\t            return locale;\n\t        }\n\t    };\n\t    L.extend(L.gmxLocale, L.gmxLocaleMixin);\n\t})();\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    rus: {\n\t        Coordinates: 'Координаты',\n\t        Length: 'Длина',\n\t        nodeLength: 'Длина от начала',\n\t        edgeLength: 'Длина сегмента',\n\t        Area: 'Площадь',\n\t        Perimeter: 'Периметр',\n\t        units: {\n\t            m: 'м',\n\t            nm: 'м.мили',\n\t            km: 'км',\n\t            m2: 'кв. м',\n\t            km2: 'кв. км',\n\t            ha: 'га',\n\t            m2html: 'м<sup>2',\n\t            km2html: 'км<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    eng: {\n\t        Coordinates: 'Coordinates',\n\t        Length: 'Length',\n\t        nodeLength: 'From start point',\n\t        edgeLength: 'Segment length',\n\t        Area: 'Area',\n\t        Perimeter: 'Perimeter',\n\t        units: {\n\t            m: 'm',\n\t            nm: 'nmi',\n\t            km: 'km',\n\t            m2: 'sq. m',\n\t            km2: 'sq. km',\n\t            ha: 'ha',\n\t            m2html: 'm<sup>2',\n\t            km2html: 'km<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.gmxVectorTileLoader = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxVectorTileLoader = {\n\t    _loadedTiles: {},\n\t    _getKey: function _getKey(ti) {\n\t        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\n\t    },\n\t    load: function load(tileSenderPrefix, tileInfo) {\n\t        var key = gmxVectorTileLoader._getKey(tileInfo);\n\t\n\t        if (!this._loadedTiles[key]) {\n\t            var def = new L.gmx.Deferred();\n\t            this._loadedTiles[key] = def;\n\t\n\t            var requestParams = {\n\t                ModeKey: 'tile',\n\t                r: 'j',\n\t                LayerName: tileInfo.layerID,\n\t                z: tileInfo.z,\n\t                x: tileInfo.x,\n\t                y: tileInfo.y,\n\t                v: tileInfo.v\n\t            };\n\t\n\t            if (tileInfo.d !== -1) {\n\t                requestParams.Level = tileInfo.d;\n\t                requestParams.Span = tileInfo.s;\n\t            }\n\t\n\t            _Utils.gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, { callbackParamName: null }).then(null, function () {\n\t                def.reject();\n\t            });\n\t        }\n\t\n\t        return this._loadedTiles[key];\n\t    }\n\t};\n\t\n\twindow.gmxAPI = window.gmxAPI || {};\n\twindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function (data) {\n\t    var key = gmxVectorTileLoader._getKey({\n\t        layerID: data.LayerName,\n\t        x: data.x,\n\t        y: data.y,\n\t        z: data.z,\n\t        d: data.level,\n\t        s: data.span,\n\t        v: data.v\n\t    });\n\t\n\t    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\n\t};\n\texports.gmxVectorTileLoader = gmxVectorTileLoader;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.VectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t//Single vector tile, received from GeoMixer server\n\t//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\n\t//      - {Object[]} data - information about vector objects in tile\n\t//      - {Number[4]} [bbox] - optional bbox of objects in tile\n\t//  options:\n\t//      x, y, z, v, s, d: GeoMixer vector tile point\n\t//      dateZero: zero Date for temporal layers\n\t//      isGeneralized: flag for generalized tile\n\tvar VectorTile = function VectorTile(dataProvider, options) {\n\t    this.dataProvider = dataProvider;\n\t    this.loadDef = new L.gmx.Deferred();\n\t    this.data = null;\n\t    this.dataOptions = null;\n\t\n\t    this.x = options.x;\n\t    this.y = options.y;\n\t    this.z = options.z;\n\t    this.v = options.v;\n\t    this.s = options.s || -1;\n\t    this.d = options.d || -1;\n\t    this.isGeneralized = options.isGeneralized;\n\t    this.isFlatten = options.isFlatten;\n\t    this.bounds = _Utils.gmxAPIutils.getTileBounds(this.x, this.y, this.z);\n\t    this.gmxTilePoint = { x: this.x, y: this.y, z: this.z, s: this.s, d: this.d };\n\t    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\n\t\n\t    if (this.s >= 0 && options.dateZero) {\n\t        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t    }\n\t\n\t    this.state = 'notLoaded'; //notLoaded, loading, loaded\n\t};\n\t\n\tVectorTile.prototype = {\n\t    addData: function addData(data, keys) {\n\t\n\t        if (keys) {\n\t            this.removeData(keys, true);\n\t        }\n\t\n\t        var len = data.length,\n\t            dataOptions = new Array(len),\n\t            dataBounds = _Utils.gmxAPIutils.bounds();\n\t        for (var i = 0; i < len; i++) {\n\t            var dataOption = this._parseItem(data[i]);\n\t            dataOptions[i] = dataOption;\n\t            dataBounds.extendBounds(dataOption.bounds);\n\t        }\n\t\n\t        if (!this.data) {\n\t            this.data = data;\n\t            this.dataOptions = dataOptions;\n\t        } else {\n\t            this.data = this.data.concat(data);\n\t            this.dataOptions = this.dataOptions.concat(dataOptions);\n\t        }\n\t\n\t        this.state = 'loaded';\n\t\n\t        this.loadDef.resolve(this.data);\n\t        return dataBounds;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\n\t            if (keys[arr[i][0]]) {\n\t                arr.splice(i, 1);\n\t                if (this.dataOptions) {\n\t                    this.dataOptions.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    load: function load() {\n\t        if (this.state === 'notLoaded') {\n\t            this.state = 'loading';\n\t            var _this = this;\n\t            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function (data, bbox) {\n\t                _this.bbox = bbox;\n\t                _this.addData(data);\n\t            });\n\t        }\n\t\n\t        return this.loadDef;\n\t    },\n\t\n\t    clear: function clear() {\n\t        this.state = 'notLoaded';\n\t        this.data = null;\n\t        this.dataOptions = null;\n\t\n\t        this.loadDef = new L.gmx.Deferred();\n\t    },\n\t\n\t    _parseItem: function _parseItem(it) {\n\t        var len = it.length,\n\t            i;\n\t\n\t        // TODO: old properties null = ''\n\t        for (i = 0; i < len; i++) {\n\t            if (it[i] === null) {\n\t                it[i] = '';\n\t            }\n\t        }\n\t\n\t        var geo = it[len - 1],\n\t            needFlatten = this.isFlatten,\n\t            type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates,\n\t            hiddenLines = [],\n\t            bounds = null,\n\t            boundsArr = [];\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            var edgeBounds = _Utils.gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\n\t                hiddenFlag = false;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr = [],\n\t                    hiddenLines1 = [];\n\t\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\n\t                        coords[i][j] = _Utils.gmxAPIutils.flattenRing(coords[i][j]);\n\t                    }\n\t                    var b = _Utils.gmxAPIutils.bounds(coords[i][j]);\n\t                    arr.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                    // EdgeLines calc\n\t                    var edgeArr = _Utils.gmxAPIutils.getHidden(coords[i][j], edgeBounds);\n\t                    hiddenLines1.push(edgeArr);\n\t                    if (edgeArr.length) {\n\t                        hiddenFlag = true;\n\t                    }\n\t                }\n\t                boundsArr.push(arr);\n\t                hiddenLines.push(hiddenLines1);\n\t            }\n\t            if (!hiddenFlag) {\n\t                hiddenLines = null;\n\t            }\n\t            if (isPolygon) {\n\t                boundsArr = boundsArr[0];\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = _Utils.gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds([coords[i]]));\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds(coords);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds(coords[i]));\n\t            }\n\t        }\n\t        var dataOption = {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t        if (hiddenLines) {\n\t            dataOption.hiddenLines = hiddenLines;\n\t        }\n\t        return dataOption;\n\t    }\n\t};\n\t//class methods\n\t\n\tVectorTile.makeTileKey = function (x, y, z, v, s, d) {\n\t    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\n\t};\n\t\n\tVectorTile.createTileKey = function (opt) {\n\t    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\n\t};\n\t\n\tVectorTile.parseTileKey = function (gmxTileKey) {\n\t    var p = gmxTileKey.split('_').map(function (it) {\n\t        return Number(it);\n\t    });\n\t    return { z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5] };\n\t};\n\t\n\tVectorTile.boundsFromTileKey = function (gmxTileKey) {\n\t    var p = VectorTile.parseTileKey(gmxTileKey);\n\t    return _Utils.gmxAPIutils.getTileBounds(p.x, p.y, p.z);\n\t};\n\texports.VectorTile = VectorTile;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Observer = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar Observer = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    /* options : {\r\n\t            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n\t                                        // `update` - send only changed data\r\n\t            callback: Func,             // will be called when layer's data for this observer is changed\r\n\t            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n\t            bbox: bbox,                 // bbox to observe on Mercator\r\n\t            filters: [String]           // filter keys array\r\n\t            active: [Boolean=true]      // is this observer active\r\n\t            targetZoom: [Number]        // for zoom generalized type default(null)\r\n\t        }\r\n\t    */\n\t    initialize: function initialize(options) {\n\t        this.type = options.type || 'update';\n\t        this._callback = options.callback;\n\t        this._items = null;\n\t        this.bbox = options.bbox; // set bbox by Mercator bounds\n\t        this.filters = options.filters || [];\n\t        this.targetZoom = options.targetZoom || null;\n\t        this.active = 'active' in options ? options.active : true;\n\t\n\t        if (options.bounds) {\n\t            // set bbox by LatLngBounds\n\t            this.setBounds(options.bounds);\n\t        }\n\t\n\t        var w = _Utils.gmxAPIutils.worldWidthMerc,\n\t            dx;\n\t        if (!this.bbox) {\n\t            this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t            this.world = true;\n\t        } else if (this.bbox.max.x > w) {\n\t            dx = this.bbox.max.x - w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\n\t        } else if (this.bbox.min.x < -w) {\n\t            dx = this.bbox.min.x + w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\n\t        }\n\t\n\t        if (options.dateInterval) {\n\t            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\n\t        }\n\t    },\n\t\n\t    hasFilter: function hasFilter(filterName) {\n\t        for (var i = 0, len = this.filters.length; i < len; i++) {\n\t            if (this.filters[i] === filterName) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    activate: function activate() {\n\t        if (!this.active) {\n\t            this.active = true;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    deactivate: function deactivate() {\n\t        if (this.active) {\n\t            this.active = false;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    toggleActive: function toggleActive(isActive) {\n\t        return isActive ? this.activate() : this.deactivate();\n\t    },\n\t\n\t    isActive: function isActive() {\n\t        return this.active;\n\t    },\n\t\n\t    updateData: function updateData(data) {\n\t        var len = data.length,\n\t            out = { count: len };\n\t\n\t        if (this.type === 'update') {\n\t            //calculate difference with previous data\n\t            if (!this._items) {\n\t                this._items = {};\n\t            }\n\t            var prevItems = this._items,\n\t                newItems = {},\n\t                added = [],\n\t                removed = [],\n\t                key;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                var it = data[i];\n\t\n\t                key = it.id + '_' + it.tileKey;\n\t\n\t                newItems[key] = it;\n\t\n\t                if (!prevItems[key]) {\n\t                    added.push(it);\n\t                }\n\t            }\n\t\n\t            for (key in prevItems) {\n\t                if (!newItems[key]) {\n\t                    removed.push(prevItems[key]);\n\t                }\n\t            }\n\t\n\t            if (added.length) {\n\t                out.added = added;\n\t            }\n\t            if (removed.length) {\n\t                out.removed = removed;\n\t            }\n\t\n\t            this._items = newItems;\n\t        } else {\n\t            out.added = data;\n\t        }\n\t        this._callback(out);\n\t        out = null;\n\t        data = null;\n\t\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        if (this.type !== 'update' || !this._items) {\n\t            return this;\n\t        }\n\t\n\t        var items = this._items,\n\t            removed = [];\n\t\n\t        for (var id in keys) {\n\t            if (items[id]) {\n\t                removed.push(items[id]);\n\t                delete items[id];\n\t            }\n\t        }\n\t\n\t        if (removed.length) {\n\t            this._callback({ removed: removed });\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    /*setFilter: function (func) {\r\n\t        this._filters.userFilter = func;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },\r\n\t      removeFilter: function () {\r\n\t        delete this._filters.userFilter;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },*/\n\t\n\t    setBounds: function setBounds(bounds) {\n\t        var w;\n\t        if (!bounds) {\n\t            if (!this.world) {\n\t                w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t                this.bbox1 = null;\n\t                this.world = true;\n\t                this.fire('update');\n\t            }\n\t            return this;\n\t        }\n\t\n\t        var min = bounds.min,\n\t            max = bounds.max;\n\t        if (!min || !max) {\n\t            var latLngBounds = L.latLngBounds(bounds),\n\t                sw = latLngBounds.getSouthWest(),\n\t                ne = latLngBounds.getNorthEast();\n\t            min = { x: sw.lng, y: sw.lat };\n\t            max = { x: ne.lng, y: ne.lat };\n\t        }\n\t        var minX = min.x,\n\t            maxX = max.x,\n\t            minY = min.y,\n\t            maxY = max.y,\n\t            minX1 = null,\n\t            maxX1 = null;\n\t\n\t        this.world = false;\n\t        w = (maxX - minX) / 2;\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t            this.world = true;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        this.bbox1 = null;\n\t        if (minX1) {\n\t            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        }\n\t\n\t        this.fire('update');\n\t        return this;\n\t    },\n\t\n\t    intersects: function intersects(bounds) {\n\t        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\n\t    },\n\t\n\t    intersectsWithTile: function intersectsWithTile(tile) {\n\t        if (this.targetZoom) {\n\t            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\n\t            if (tile.isGeneralized && tile.z !== z || tile.z > z) {\n\t                return false;\n\t            }\n\t        }\n\t        var di = this.dateInterval;\n\t        return this.intersects(tile.bounds) && (!tile.beginDate || di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate);\n\t    },\n\t\n\t    _setDateInterval: function _setDateInterval(beginDate, endDate) {\n\t        if (beginDate && endDate) {\n\t            // var beginValue = beginDate.valueOf(),\n\t            // endValue = endDate.valueOf();\n\t            this.dateInterval = {\n\t                beginDate: beginDate,\n\t                endDate: endDate\n\t            };\n\t        } else {\n\t            this.dateInterval = null;\n\t        }\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var isValid = beginDate && endDate;\n\t\n\t        if (!this.dateInterval !== !isValid || isValid && (this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() || this.dateInterval.endDate.valueOf() !== endDate.valueOf())) {\n\t            this._setDateInterval(beginDate, endDate);\n\t            this.fire('update', { temporalFilter: true });\n\t        }\n\t        return this;\n\t    }\n\t}); //Single observer with vector data\n\texports.Observer = Observer;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    //tree for fast tiles selection inside temporal interval\n\t    //  options:\n\t    //      TemporalTiles: tilePoints array\n\t    //      TemporalVers: tiles version array\n\t    //      TemporalPeriods: periods\n\t    //      ZeroDate: start Date\n\t    var TilesTree = function TilesTree(options) {\n\t        var _rootNodes = [],\n\t            tiles = options.TemporalTiles || [],\n\t            vers = options.TemporalVers || [],\n\t            periods = options.TemporalPeriods || [],\n\t            maxPeriod = periods[periods.length - 1],\n\t            smin = Number.MAX_VALUE,\n\t            arr = options.ZeroDate.split('.'),\n\t            zn = new Date(arr.length > 2 ? arr[2] : 2008, arr.length > 1 ? arr[1] - 1 : 0, arr.length > 0 ? arr[0] : 1),\n\t            dateZero = new Date(zn.getTime() - zn.getTimezoneOffset() * 60000),\n\t            zeroUT = dateZero.getTime() / 1000;\n\t\n\t        this.dateZero = dateZero;\n\t\n\t        var addTile = function addTile(node, tile, key) {\n\t            var d = node.d;\n\t            if (tile.d === periods[d]) {\n\t                node.count++;\n\t                node.tiles.push(key);\n\t                return;\n\t            }\n\t\n\t            var pd = periods[d - 1],\n\t                childrenCount = periods[d] / pd;\n\t\n\t            if (!('children' in node)) {\n\t                node.children = new Array(childrenCount);\n\t            }\n\t\n\t            var sChild = Math.floor(tile.s * tile.d / pd),\n\t                ds = sChild - node.s * childrenCount;\n\t\n\t            if (!node.children[ds]) {\n\t                var pdOneDay = pd * gmxAPIutils.oneDay,\n\t                    t1 = sChild * pdOneDay + zeroUT;\n\t                node.children[ds] = {\n\t                    d: d - 1,\n\t                    s: sChild,\n\t                    t1: t1,\n\t                    t2: t1 + pdOneDay,\n\t                    count: 0,\n\t                    children: [],\n\t                    tiles: []\n\t                };\n\t            }\n\t\n\t            addTile(node.children[ds], tile, key);\n\t        };\n\t\n\t        var dmax = periods.length - 1,\n\t            dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\n\t            i,\n\t            len;\n\t\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var s = Number(arr[1]),\n\t                d = Number(arr[0]);\n\t\n\t            if (d === maxPeriod) {\n\t                smin = Math.min(smin, s);\n\t            }\n\t        }\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var t = {\n\t                x: Number(arr[2]),\n\t                y: Number(arr[3]),\n\t                z: Number(arr[4]),\n\t                v: Number(vers[i]),\n\t                s: Number(arr[1]),\n\t                d: Number(arr[0])\n\t            };\n\t            if (t.d < 0) {\n\t                continue;\n\t            }\n\t\n\t            var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\n\t                cs = ds + smin;\n\t\n\t            _rootNodes[ds] = _rootNodes[ds] || {\n\t                d: dmax,\n\t                s: cs,\n\t                t1: cs * dmaxOneDay + zeroUT,\n\t                t2: (cs + 1) * dmaxOneDay + zeroUT,\n\t                count: 0,\n\t                tiles: []\n\t            };\n\t            var key = VectorTile.createTileKey(t);\n\t\n\t            addTile(_rootNodes[ds], t, key);\n\t        }\n\t        tiles = vers = null;\n\t\n\t        //options: bounds (in mercator projection)\n\t        this.selectTiles = function (t1, t2, options) {\n\t\n\t            options = options || {};\n\t\n\t            var t1Val = t1.valueOf() / 1000,\n\t                t2Val = t2.valueOf() / 1000;\n\t\n\t            // We will restrict tile levels by the nearest two levels to target date interval length\n\t            // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\n\t            var minLevel = 0,\n\t                dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\n\t\n\t            for (var i = 0; i < periods.length; i++) {\n\t                if (periods[i] > dateIntervalLength) {\n\t                    minLevel = Math.max(0, i - 1);\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (periods[periods.length - 1] <= dateIntervalLength) {\n\t                minLevel = periods.length - 1;\n\t            }\n\t\n\t            var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\n\t\n\t            var getCountOfIntersected = function getCountOfIntersected(tileBounds, bounds) {\n\t                var count = 0;\n\t                for (var t = 0; t < tileBounds.length; t++) {\n\t                    if (tileBounds[t].intersects(bounds)) {\n\t                        count++;\n\t                    }\n\t                }\n\t\n\t                return count;\n\t            };\n\t\n\t            // --------------------\n\t            var selectTilesForNode = function selectTilesForNode(node, t1, t2) {\n\t                if (t1 >= node.t2 || t2 <= node.t1) {\n\t                    return { count: 0, tiles: [], nodes: [] };\n\t                }\n\t\n\t                if (options.bounds && !node.tileBounds) {\n\t                    node.tileBounds = node.tiles.map(function (it) {\n\t                        return VectorTile.boundsFromTileKey(it);\n\t                    });\n\t                }\n\t\n\t                if (node.d === minLevel) {\n\t                    var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: count,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t\n\t                var childrenCount = 0,\n\t\n\t                //number of tiles if we use shorter intervals\n\t                childrenRes = [],\n\t                    len = node.children ? node.children.length : 0,\n\t                    ds;\n\t\n\t                for (ds = 0; ds < len; ds++) {\n\t                    if (node.children[ds]) {\n\t                        childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\n\t                    } else {\n\t                        childrenRes[ds] = { count: 0, tiles: [], nodes: [] };\n\t                    }\n\t                    childrenCount += childrenRes[ds].count;\n\t                }\n\t\n\t                var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t\n\t                if (node.d > maxLevel || childrenCount < intersectCount) {\n\t                    var resTilesArr = [],\n\t                        resNodesArr = [];\n\t                    for (ds = 0; ds < childrenRes.length; ds++) {\n\t                        resNodesArr.push(childrenRes[ds].nodes);\n\t                        resTilesArr.push(childrenRes[ds].tiles);\n\t                    }\n\t\n\t                    return {\n\t                        tiles: [].concat.apply([], resTilesArr),\n\t                        count: childrenCount,\n\t                        nodes: [].concat.apply([], resNodesArr)\n\t                    };\n\t                } else {\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: intersectCount,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t            };\n\t\n\t            var resTiles = [];\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                if (_rootNodes[ds]) {\n\t                    var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\n\t                    if (nodeSelection.tiles.length) {\n\t                        resTiles = resTiles.concat(nodeSelection.tiles);\n\t                    }\n\t                }\n\t            }\n\t\n\t            var resTilesHash = {};\n\t            for (var t = 0; t < resTiles.length; t++) {\n\t                resTilesHash[resTiles[t]] = true;\n\t            }\n\t\n\t            return { tiles: resTilesHash };\n\t        };\n\t\n\t        this.getNode = function (d, s) {\n\t            if (d < 0 || s < 0) {\n\t                return null;\n\t            }\n\t\n\t            var findNode = function findNode(node, d, s) {\n\t                if (!node) {\n\t                    return null;\n\t                }\n\t\n\t                if (periods[node.d] === d) {\n\t                    return node.s === s ? node : null;\n\t                }\n\t\n\t                var childrenCount = periods[node.d] / periods[node.d - 1];\n\t                var sChild = Math.floor(s * d / periods[node.d - 1]);\n\t                var ds = sChild - node.s * childrenCount;\n\t\n\t                return node.children[ds] ? findNode(node.children[ds], d, s) : null;\n\t            };\n\t\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                var node = findNode(_rootNodes[ds], d, s);\n\t                if (node) {\n\t                    return node;\n\t                }\n\t            }\n\t\n\t            return null;\n\t        };\n\t    };\n\t    L.gmx.tilesTree = function (options) {\n\t        return new TilesTree(options);\n\t    };\n\t})();\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.DataManager = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _VectorTile = __webpack_require__(14);\n\t\n\tvar _VectorTileLoader = __webpack_require__(13);\n\t\n\tvar ObserverTileLoader = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    initialize: function initialize(dataManager) {\n\t        this._dataManager = dataManager;\n\t        this._observerData = {};\n\t        this._tileData = {};\n\t    },\n\t\n\t    addObserver: function addObserver(observer) {\n\t        this._observerData[observer.id] = {\n\t            observer: observer,\n\t            tiles: {},\n\t            leftToLoad: 0,\n\t            loadingState: false //are we loading any tiles for this observer?\n\t        };\n\t\n\t        observer.on('update', this._updateObserver.bind(this, observer));\n\t\n\t        this._updateObserver(observer);\n\t\n\t        return this;\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        var obsTiles = this._observerData[id].tiles;\n\t\n\t        for (var tileId in obsTiles) {\n\t            delete this._tileData[tileId].observers[id];\n\t        }\n\t\n\t        delete this._observerData[id];\n\t\n\t        return this;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\n\t        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\n\t\n\t        var tileObservers = {};\n\t\n\t        for (var key in this._observerData) {\n\t            var obsInfo = this._observerData[key];\n\t\n\t            if (obsInfo.observer.intersectsWithTile(tile)) {\n\t                obsInfo.tiles[tile.vectorTileKey] = true;\n\t                obsInfo.leftToLoad += leftToLoadDelta;\n\t                tileObservers[key] = true;\n\t            }\n\t        }\n\t\n\t        this._tileData[tile.vectorTileKey] = {\n\t            observers: tileObservers,\n\t            tile: tile\n\t        };\n\t\n\t        return this;\n\t    },\n\t\n\t    removeTile: function removeTile(tileId) {\n\t        var tileData = this._tileData[tileId],\n\t            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\n\t\n\t        for (var id in tileData.observers) {\n\t            var observerData = this._observerData[id];\n\t            observerData.leftToLoad -= leftToLoadDelta;\n\t            delete observerData.tiles[tileId];\n\t        }\n\t\n\t        delete this._tileData[tileId];\n\t\n\t        return this;\n\t    },\n\t\n\t    startLoadTiles: function startLoadTiles(observer) {\n\t\n\t        //force active tile list update\n\t        this._dataManager._getActiveTileKeys();\n\t\n\t        var obsData = this._observerData[observer.id];\n\t        if (obsData.leftToLoad === 0) {\n\t            this.fire('observertileload', { observer: observer });\n\t            return this;\n\t        }\n\t\n\t        if (!obsData.loadingState) {\n\t            obsData.loadingState = true;\n\t            observer.fire('startLoadingTiles');\n\t        }\n\t\n\t        for (var tileId in obsData.tiles) {\n\t            this._tileData[tileId].tile.load();\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getTileObservers: function getTileObservers(tileId) {\n\t        return this._tileData[tileId].observers;\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerData[observer.id].loadingState;\n\t    },\n\t\n\t    _updateObserver: function _updateObserver(observer) {\n\t        var obsData = this._observerData[observer.id],\n\t            newObserverTiles = {},\n\t            leftToLoad = 0,\n\t            key;\n\t\n\t        for (key in this._tileData) {\n\t            var tile = this._tileData[key].tile;\n\t            if (observer.intersectsWithTile(tile)) {\n\t                newObserverTiles[key] = true;\n\t                if (tile.state !== 'loaded') {\n\t                    leftToLoad++;\n\t                }\n\t                this._tileData[key].observers[observer.id] = true;\n\t            }\n\t        }\n\t\n\t        for (key in obsData.tiles) {\n\t            if (!(key in newObserverTiles)) {\n\t                delete this._tileData[key].observers[observer.id];\n\t            }\n\t        }\n\t\n\t        obsData.tiles = newObserverTiles;\n\t        obsData.leftToLoad = leftToLoad;\n\t    },\n\t\n\t    _tileLoadedCallback: function _tileLoadedCallback(tile) {\n\t        this.fire('tileload', { tile: tile });\n\t\n\t        if (!(tile.vectorTileKey in this._tileData)) {\n\t            return;\n\t        }\n\t\n\t        var tileObservers = this._tileData[tile.vectorTileKey].observers;\n\t        for (var id in tileObservers) {\n\t            var obsData = this._observerData[id];\n\t            obsData.leftToLoad--;\n\t\n\t            if (obsData.leftToLoad === 0) {\n\t                if (obsData.loadingState) {\n\t                    obsData.loadingState = false;\n\t                    obsData.observer.fire('stopLoadingTiles');\n\t                }\n\t                this.fire('observertileload', { observer: obsData.observer });\n\t            }\n\t        }\n\t    }\n\t});\n\t\n\tvar DataManager = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t\n\t    options: {\n\t        name: null, // layer ID\n\t        identityField: '', // attribute name for identity items\n\t        attributes: [], // attributes names\n\t        attrTypes: [], // attributes types\n\t        tiles: null, // tiles array for nontemporal data\n\t        tilesVers: null, // tiles version array for nontemporal data\n\t        LayerVersion: -1, // layer version\n\t        GeoProcessing: null, // processing data\n\t        Temporal: false, // only for temporal data\n\t        TemporalColumnName: '', // temporal attribute name\n\t        ZeroDate: '01.01.2008', // 0 date string\n\t        TemporalPeriods: [], // temporal periods\n\t        TemporalTiles: [], // temporal tiles array\n\t        TemporalVers: [], // temporal version array\n\t        hostName: 'maps.kosmosnimki.ru', // default hostName\n\t        sessionKey: '', // session key\n\t        isGeneralized: false, // flag for use generalized tiles\n\t        isFlatten: false // flag for flatten geometry\n\t    },\n\t\n\t    setOptions: function setOptions(options) {\n\t        this._clearProcessing();\n\t        if (options.GeoProcessing) {\n\t            this.processingTile = this.addData([]);\n\t            this._chkProcessing(options.GeoProcessing);\n\t        }\n\t        L.setOptions(this, options);\n\t        this.optionsLink = options;\n\t\n\t        this._isTemporalLayer = this.options.Temporal;\n\t\n\t        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\n\t        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\n\t        var hostName = this.options.hostName,\n\t            sessionKey = this.options.sessionKey;\n\t        if (!sessionKey) {\n\t            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\n\t        }\n\t        this.tileSenderPrefix = 'http://' + hostName + '/' + 'TileSender.ashx?WrapStyle=None' + '&key=' + encodeURIComponent(sessionKey);\n\t\n\t        this._needCheckActiveTiles = true;\n\t    },\n\t\n\t    _vectorTileDataProviderLoad: function _vectorTileDataProviderLoad(x, y, z, v, s, d, callback) {\n\t        var _this = this;\n\t        _VectorTileLoader.gmxVectorTileLoader.load(_this.tileSenderPrefix, { x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name }).then(callback, function () {\n\t            console.log('Error loading vector tile');\n\t            callback([]);\n\t            _this.fire('chkLayerUpdate', { dataProvider: _this }); //TODO: do we really need event here?\n\t        });\n\t    },\n\t\n\t    initialize: function initialize(options, clearVersion) {\n\t        this._tilesTree = null;\n\t        this._activeTileKeys = {};\n\t        this._endDate = null;\n\t        this._beginDate = null;\n\t\n\t        this._tiles = {};\n\t        this._filters = {};\n\t        this._freeSubscrID = 0;\n\t        this._items = {};\n\t        this._observers = {};\n\t\n\t        this._needCheckDateInterval = false;\n\t        this._needCheckActiveTiles = true;\n\t\n\t        var _this = this;\n\t        this._vectorTileDataProvider = {\n\t            load: this._vectorTileDataProviderLoad.bind(this)\n\t        };\n\t\n\t        this._observerTileLoader = new ObserverTileLoader(this);\n\t        this._observerTileLoader.on('tileload', function (event) {\n\t            var tile = event.tile;\n\t            _this._updateItemsFromTile(tile);\n\t\n\t            if (_this._tilesTree) {\n\t                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\n\t                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\n\t            }\n\t        });\n\t\n\t        this._observerTileLoader.on('observertileload', function (event) {\n\t            var observer = event.observer;\n\t            if (observer.isActive()) {\n\t                observer.needRefresh = false;\n\t                observer.updateData(_this.getItems(observer.id));\n\t            }\n\t        });\n\t        this.setOptions(options);\n\t        if (clearVersion) {\n\t            this.options.LayerVersion = -1;\n\t        }\n\t        if (this._isTemporalLayer) {\n\t            this.addFilter('TemporalFilter', function (item, tile, observer) {\n\t                var unixTimeStamp = item.options.unixTimeStamp,\n\t                    dates = observer.dateInterval;\n\t                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\n\t            });\n\t        }\n\t    },\n\t\n\t    _getActiveTileKeys: function _getActiveTileKeys() {\n\t\n\t        this._chkMaxDateInterval();\n\t        if (!this._needCheckActiveTiles) {\n\t            return this._activeTileKeys;\n\t        }\n\t\n\t        this._needCheckActiveTiles = false;\n\t\n\t        if (this._isTemporalLayer) {\n\t            var newTileKeys = {};\n\t            if (this._beginDate && this._endDate) {\n\t                if (!this._tilesTree) {\n\t                    this.initTilesTree();\n\t                }\n\t\n\t                /*var commonBounds = L.gmxUtil.bounds();\r\n\t                for (var obs in this._observers) {\r\n\t                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n\t                }*/\n\t\n\t                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\n\t            }\n\t            this._updateActiveTilesList(newTileKeys);\n\t        } else {\n\t            this.initTilesList();\n\t        }\n\t\n\t        return this._activeTileKeys;\n\t    },\n\t\n\t    _getObserversByFilterName: function _getObserversByFilterName(filterName) {\n\t        var oKeys = {};\n\t        for (var id in this._observers) {\n\t            if (this._observers[id].hasFilter(filterName)) {\n\t                oKeys[id] = true;\n\t            }\n\t        }\n\t        return oKeys;\n\t    },\n\t\n\t    addFilter: function addFilter(filterName, filterFunc) {\n\t        this._filters[filterName] = filterFunc;\n\t        this._triggerObservers(this._getObserversByFilterName(filterName));\n\t    },\n\t\n\t    removeFilter: function removeFilter(filterName) {\n\t        if (this._filters[filterName]) {\n\t            var oKeys = this._getObserversByFilterName(filterName);\n\t            delete this._filters[filterName];\n\t            this._triggerObservers(oKeys);\n\t        }\n\t    },\n\t\n\t    getItems: function getItems(oId) {\n\t        var resItems = [],\n\t            observer = this._observers[oId];\n\t\n\t        if (!observer) {\n\t            return [];\n\t        }\n\t\n\t        //add internal filters\n\t        var filters = observer.filters.concat('processingFilter');\n\t        this._isTemporalLayer && filters.push('TemporalFilter');\n\t\n\t        filters = filters.filter(function (filter) {\n\t            return filter in this._filters;\n\t        }.bind(this));\n\t\n\t        var _this = this,\n\t            putData = function putData(tile) {\n\t            var data = tile.data;\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var dataOption = tile.dataOptions[i];\n\t                if (!observer.intersects(dataOption.bounds)) {\n\t                    continue;\n\t                }\n\t\n\t                var it = data[i],\n\t                    id = it[0],\n\t                    item = _this.getItem(id);\n\t\n\t                var geom = it[it.length - 1],\n\t                    isFiltered = false;\n\t\n\t                for (var f = 0; f < filters.length; f++) {\n\t                    var filterFunc = _this._filters[filters[f]];\n\t                    if (!filterFunc(item, tile, observer, geom, dataOption)) {\n\t                        isFiltered = true;\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (!isFiltered) {\n\t                    resItems.push({\n\t                        id: id,\n\t                        properties: it,\n\t                        item: item,\n\t                        dataOption: dataOption,\n\t                        tileKey: tile.vectorTileKey\n\t                    });\n\t                }\n\t            }\n\t        };\n\t        var activeTileKeys = this._getActiveTileKeys();\n\t        for (var tkey in activeTileKeys) {\n\t            var tile = _this._tiles[tkey].tile;\n\t            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\n\t                putData(tile);\n\t            }\n\t        }\n\t\n\t        return resItems;\n\t    },\n\t\n\t    _updateItemsFromTile: function _updateItemsFromTile(tile) {\n\t        var vectorTileKey = tile.vectorTileKey,\n\t            data = tile.data || [],\n\t            len = data.length,\n\t            geomIndex = data[0] && data[0].length - 1;\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            var it = data[i],\n\t                geom = it[geomIndex],\n\t                id = it[0],\n\t                item = this._items[id];\n\t            if (item) {\n\t                if (!item.processing) {\n\t                    item.properties = it;\n\t                    if (item.type.indexOf('MULTI') === -1) {\n\t                        item.type = 'MULTI' + item.type;\n\t                    }\n\t                } else {\n\t                    tile.data[i] = item.properties;\n\t                }\n\t                delete item.bounds;\n\t                item.currentFilter = null;\n\t            } else {\n\t                item = {\n\t                    id: id,\n\t                    type: geom.type,\n\t                    properties: it,\n\t                    options: {\n\t                        fromTiles: {}\n\t                    }\n\t                };\n\t                this._items[id] = item;\n\t            }\n\t            item.options.fromTiles[vectorTileKey] = i;\n\t            if (tile.isGeneralized) {\n\t                item.options.isGeneralized = true;\n\t            }\n\t\n\t            if (this.options.TemporalColumnName) {\n\t                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\n\t                item.options.unixTimeStamp = zn * 1000;\n\t            }\n\t        }\n\t        return len;\n\t    },\n\t\n\t    getMaxDateInterval: function getMaxDateInterval() {\n\t        this._chkMaxDateInterval();\n\t        return {\n\t            beginDate: this._beginDate,\n\t            endDate: this._endDate\n\t        };\n\t    },\n\t\n\t    _chkMaxDateInterval: function _chkMaxDateInterval() {\n\t        if (this._isTemporalLayer && this._needCheckDateInterval) {\n\t            this._needCheckDateInterval = false;\n\t            var observers = this._observers,\n\t                newBeginDate = null,\n\t                newEndDate = null;\n\t            for (var oId in observers) {\n\t                var observer = observers[oId],\n\t                    dateInterval = observer.dateInterval;\n\t\n\t                if (!dateInterval) {\n\t                    continue;\n\t                }\n\t\n\t                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\n\t                    newBeginDate = dateInterval.beginDate;\n\t                }\n\t\n\t                if (!newEndDate || dateInterval.endDate > newEndDate) {\n\t                    newEndDate = dateInterval.endDate;\n\t                }\n\t            }\n\t            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\n\t                this._beginDate = newBeginDate;\n\t                this._endDate = newEndDate;\n\t                this._needCheckActiveTiles = true;\n\t            }\n\t        }\n\t    },\n\t\n\t    addObserver: function addObserver(options, id) {\n\t        id = id || 's' + ++this._freeSubscrID;\n\t        var _this = this,\n\t            observer = L.gmx.observer(options);\n\t\n\t        observer.id = id;\n\t        observer.needRefresh = true;\n\t        this._observerTileLoader.addObserver(observer);\n\t\n\t        observer.on('update', function (ev) {\n\t            observer.needRefresh = true;\n\t            if (ev.temporalFilter) {\n\t                _this._needCheckDateInterval = true;\n\t            }\n\t\n\t            _this._waitCheckObservers();\n\t        }).on('activate', function () {\n\t            _this.fire('observeractivate');\n\t            _this.checkObserver(observer);\n\t        });\n\t\n\t        _this._needCheckDateInterval = true;\n\t        this._observers[id] = observer;\n\t        this._waitCheckObservers();\n\t\n\t        if (observer.isActive()) {\n\t            this.fire('observeractivate');\n\t        }\n\t\n\t        return observer;\n\t    },\n\t\n\t    getActiveObserversCount: function getActiveObserversCount() {\n\t        var count = 0;\n\t        for (var k in this._observers) {\n\t            if (this._observers[k].isActive()) {\n\t                count++;\n\t            }\n\t        }\n\t        return count;\n\t    },\n\t\n\t    getObserver: function getObserver(id) {\n\t        return this._observers[id];\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        if (this._observers[id]) {\n\t            this._observerTileLoader.removeObserver(id);\n\t            var isActive = this._observers[id].isActive();\n\t\n\t            delete this._observers[id];\n\t\n\t            if (isActive) {\n\t                this.fire('observeractivate');\n\t            }\n\t        }\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerTileLoader.getObserverLoadingState(observer);\n\t    },\n\t\n\t    getItemsBounds: function getItemsBounds() {\n\t        if (!this._itemsBounds) {\n\t            this._itemsBounds = _Utils.gmxAPIutils.bounds();\n\t            for (var id in this._items) {\n\t                var item = this.getItem(id);\n\t                this._itemsBounds.extendBounds(item.bounds);\n\t            }\n\t        }\n\t        return this._itemsBounds;\n\t    },\n\t\n\t    //combine and return all parts of geometry\n\t    getItem: function getItem(id) {\n\t        var item = this._items[id];\n\t        if (item && !item.bounds) {\n\t            var fromTiles = item.options.fromTiles,\n\t                arr = [];\n\t            for (var key in fromTiles) {\n\t                // get full object bounds\n\t                if (this._tiles[key]) {\n\t                    var num = fromTiles[key],\n\t                        tile = this._tiles[key].tile;\n\t                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\n\t                        arr.push(tile.dataOptions[num].bounds);\n\t                    } else {\n\t                        delete fromTiles[key];\n\t                    }\n\t                }\n\t            }\n\t            if (arr.length === 1) {\n\t                item.bounds = arr[0];\n\t            } else {\n\t                item.bounds = _Utils.gmxAPIutils.bounds();\n\t                var w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var it = arr[i];\n\t                    if (item.bounds.max.x - it.min.x > w) {\n\t                        it = _Utils.gmxAPIutils.bounds([[it.min.x + 2 * w, it.min.y], [it.max.x + 2 * w, it.max.y]]);\n\t                    }\n\t                    item.bounds.extendBounds(it);\n\t                }\n\t            }\n\t        }\n\t        return item;\n\t    },\n\t\n\t    getItemMembers: function getItemMembers(id) {\n\t        var fromTiles = this._items[id].options.fromTiles,\n\t            members = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key]) {\n\t                var tile = this._tiles[key].tile;\n\t                if (tile.data) {\n\t                    var objIndex = fromTiles[key],\n\t                        props = tile.data[objIndex],\n\t                        dataOption = tile.dataOptions[objIndex],\n\t                        bbox = dataOption.bounds;\n\t\n\t                    members.push({\n\t                        geo: props[props.length - 1],\n\t                        width: bbox.max.x - bbox.min.x,\n\t                        dataOption: dataOption\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        return members.sort(function (a, b) {\n\t            return b.width - a.width;\n\t        });\n\t    },\n\t\n\t    getItemGeometries: function getItemGeometries(id) {\n\t        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\n\t            geomItems = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key] && this._tiles[key].tile.data) {\n\t                var tileData = this._tiles[key].tile.data,\n\t                    props = tileData[fromTiles[key]];\n\t\n\t                geomItems.push(_Utils.gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\n\t            }\n\t        }\n\t        return geomItems;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        this._tiles[tile.vectorTileKey] = { tile: tile };\n\t        this._getActiveTileKeys()[tile.vectorTileKey] = true;\n\t        this._observerTileLoader.addTile(tile);\n\t        this.checkObservers();\n\t    },\n\t\n\t    checkObserver: function checkObserver(observer) {\n\t        if (observer.needRefresh && observer.isActive()) {\n\t            this._observerTileLoader.startLoadTiles(observer);\n\t        }\n\t    },\n\t\n\t    checkObservers: function checkObservers() {\n\t        var observers = this._observers;\n\t        for (var id in this._observers) {\n\t            this.checkObserver(observers[id]);\n\t        }\n\t    },\n\t\n\t    _waitCheckObservers: function _waitCheckObservers() {\n\t        //TODO: refactor\n\t        if (this._checkObserversTimer) {\n\t            clearTimeout(this._checkObserversTimer);\n\t        }\n\t\n\t        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\n\t    },\n\t\n\t    _triggerObservers: function _triggerObservers(oKeys) {\n\t        var keys = oKeys || this._observers;\n\t\n\t        for (var id in keys) {\n\t            if (this._observers[id]) {\n\t                this._observers[id].needRefresh = true;\n\t            }\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    _removeDataFromObservers: function _removeDataFromObservers(data) {\n\t        var keys = this._observers;\n\t        for (var id in keys) {\n\t            this._observers[id].removeData(data);\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    preloadTiles: function preloadTiles(dateBegin, dateEnd, bounds) {\n\t        var tileKeys = {};\n\t        if (this._isTemporalLayer) {\n\t            if (!this._tilesTree) {\n\t                this.initTilesTree();\n\t            }\n\t            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\n\t        } else {\n\t            this._needCheckActiveTiles = true;\n\t            tileKeys = this._getActiveTileKeys();\n\t        }\n\t\n\t        var loadingDefs = [];\n\t        for (var key in tileKeys) {\n\t            var tile = this._getVectorTile(key, true).tile;\n\t\n\t            if (tile.state !== 'notLoaded') {\n\t                continue;\n\t            }\n\t\n\t            if (bounds && !bounds.intersects(tile.bounds)) {\n\t                continue;\n\t            }\n\t\n\t            var loadDef = tile.load();\n\t            loadingDefs.push(loadDef);\n\t        }\n\t\n\t        return Deferred.all.apply(null, loadingDefs);\n\t    },\n\t\n\t    _updateActiveTilesList: function _updateActiveTilesList(newTilesList) {\n\t\n\t        if (this._tileFilteringHook) {\n\t            var filteredTilesList = {};\n\t            for (var tk in newTilesList) {\n\t                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\n\t                    filteredTilesList[tk] = true;\n\t                }\n\t            }\n\t            newTilesList = filteredTilesList;\n\t        }\n\t\n\t        var oldTilesList = this._activeTileKeys || {};\n\t\n\t        var observersToUpdate = {},\n\t            _this = this,\n\t            key;\n\t\n\t        if (this.processingTile) {\n\t            newTilesList[this.processingTile.vectorTileKey] = true;\n\t        }\n\t        if (this._rasterVectorTile) {\n\t            key = this._rasterVectorTile.vectorTileKey;\n\t            newTilesList[key] = true;\n\t            this._tiles[key] = { tile: this._rasterVectorTile };\n\t        }\n\t\n\t        var checkSubscription = function checkSubscription(vKey) {\n\t            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\n\t            for (var sid in observerIds) {\n\t                observersToUpdate[sid] = true;\n\t            }\n\t        };\n\t\n\t        for (key in newTilesList) {\n\t            if (!oldTilesList[key]) {\n\t                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\n\t                checkSubscription(key);\n\t            }\n\t        }\n\t\n\t        for (key in oldTilesList) {\n\t            if (!newTilesList[key]) {\n\t                checkSubscription(key);\n\t                this._observerTileLoader.removeTile(key);\n\t            }\n\t        }\n\t\n\t        this._activeTileKeys = newTilesList;\n\t\n\t        this._triggerObservers(observersToUpdate);\n\t    },\n\t\n\t    _propertiesToArray: function _propertiesToArray(it) {\n\t        var prop = it.properties,\n\t            indexes = this.tileAttributeIndexes,\n\t            arr = [];\n\t\n\t        for (var key in indexes) {\n\t            arr[indexes[key]] = prop[key];\n\t        }arr[arr.length] = it.geometry;\n\t        arr[0] = it.id;\n\t        return arr;\n\t    },\n\t\n\t    _clearProcessing: function _clearProcessing() {\n\t        if (this.processingTile) {\n\t            var _items = this._items,\n\t                tile = this.processingTile,\n\t                vKey = tile.vectorTileKey,\n\t                data = tile.data || [];\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i][0];\n\t                if (_items[id]) {\n\t                    var item = _items[id];\n\t                    item.processing = null;\n\t                    item.currentFilter = null;\n\t                    delete item.options.fromTiles[vKey];\n\t                    delete item.fromServerProps;\n\t                    delete item.geometry;\n\t                }\n\t            }\n\t            tile.clear();\n\t        }\n\t    },\n\t\n\t    _chkProcessing: function _chkProcessing(processing) {\n\t        var _items = this._items,\n\t            needProcessingFilter = false,\n\t            skip = {},\n\t            id,\n\t            i,\n\t            len,\n\t            it,\n\t            data;\n\t\n\t        if (processing) {\n\t            if (processing.Deleted) {\n\t                for (i = 0, len = processing.Deleted.length; i < len; i++) {\n\t                    id = processing.Deleted[i];\n\t                    skip[id] = true;\n\t                    if (_items[id]) {\n\t                        _items[id].processing = true;\n\t                        _items[id].currentFilter = null;\n\t                    }\n\t                    if (len > 0) {\n\t                        needProcessingFilter = true;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var out = {};\n\t            if (processing.Inserted) {\n\t                for (i = 0, len = processing.Inserted.length; i < len; i++) {\n\t                    it = processing.Inserted[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (processing.Updated) {\n\t                for (i = 0, len = processing.Updated.length; i < len; i++) {\n\t                    it = processing.Updated[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t                if (!needProcessingFilter && len > 0) {\n\t                    needProcessingFilter = true;\n\t                }\n\t            }\n\t\n\t            data = [];\n\t            for (id in out) {\n\t                if (this._items[id]) {\n\t                    this._items[id].properties = out[id];\n\t                    this._items[id].processing = true;\n\t                    this._items[id].currentFilter = null;\n\t                }\n\t                data.push(out[id]);\n\t            }\n\t\n\t            if (data.length > 0) {\n\t                this.processingTile = this.addData(data);\n\t            }\n\t        }\n\t        if (needProcessingFilter) {\n\t            this.addFilter('processingFilter', function (item, tile) {\n\t                return tile.z === 0 || !item.processing;\n\t            });\n\t        } else {\n\t            this.removeFilter('processingFilter');\n\t        }\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    _resetTilesTree: function _resetTilesTree() {\n\t        this._tilesTree = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    updateVersion: function updateVersion(options) {\n\t        if (options) {\n\t            this.setOptions(options);\n\t        }\n\t        this._resetTilesTree();\n\t        // this.fire('versionchange');\n\t    },\n\t\n\t    _getDataKeys: function _getDataKeys(data) {\n\t        var chkKeys = {};\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            chkKeys[data[i][0]] = true;\n\t        }\n\t        return chkKeys;\n\t    },\n\t\n\t    _getProcessingTile: function _getProcessingTile() {\n\t        if (!this.processingTile) {\n\t            var x = -0.5,\n\t                y = -0.5,\n\t                z = 0,\n\t                v = 0,\n\t                s = -1,\n\t                d = -1,\n\t                isFlatten = this.options.isFlatten;\n\t\n\t            this.processingTile = new _VectorTile.VectorTile({ load: function load(x, y, z, v, s, d, callback) {\n\t                    callback([]);\n\t                } }, { x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten });\n\t\n\t            this.addTile(this.processingTile);\n\t        }\n\t        return this.processingTile;\n\t    },\n\t\n\t    addData: function addData(data) {\n\t        if (!data) {\n\t            data = [];\n\t        }\n\t        var vTile = this._getProcessingTile(),\n\t            chkKeys = this._getDataKeys(data),\n\t            dataBounds = vTile.addData(data, chkKeys);\n\t\n\t        if (this._itemsBounds) {\n\t            this._itemsBounds.extendBounds(dataBounds);\n\t        }\n\t        this._updateItemsFromTile(vTile);\n\t        this._triggerObservers();\n\t        return vTile;\n\t    },\n\t\n\t    removeData: function removeData(data) {\n\t        this._itemsBounds = null;\n\t        var vTile = this.processingTile;\n\t        if (vTile) {\n\t            var chkKeys = {};\n\t\n\t            if (!data || !data.length) {\n\t                return vTile;\n\t            }\n\t\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i];\n\t                chkKeys[id] = true;\n\t                delete this._items[id];\n\t            }\n\t            this._removeDataFromObservers(chkKeys);\n\t            vTile.removeData(chkKeys, true);\n\t            this._updateItemsFromTile(vTile);\n\t\n\t            this._triggerObservers();\n\t        }\n\t\n\t        return vTile;\n\t    },\n\t\n\t    initTilesTree: function initTilesTree() {\n\t        this._tilesTree = L.gmx.tilesTree(this.options);\n\t        this.options.TemporalTiles = this.options.TemporalVers = null;\n\t\n\t        if ('TemporalTiles' in this.optionsLink) {\n\t            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\n\t        }\n\t        this.dateZero = this._tilesTree.dateZero;\n\t        if (this.processingTile) {\n\t            this._tiles[this.processingTile.vectorTileKey] = {\n\t                tile: this.processingTile\n\t            };\n\t        }\n\t    },\n\t\n\t    _getVectorTile: function _getVectorTile(vKey, createFlag) {\n\t        if (!this._tiles[vKey] && createFlag) {\n\t            var info = _VectorTile.VectorTile.parseTileKey(vKey);\n\t            info.dateZero = this.dateZero;\n\t            this._addVectorTile(info);\n\t        }\n\t        return this._tiles[vKey];\n\t    },\n\t\n\t    _addVectorTile: function _addVectorTile(info) {\n\t        info.isFlatten = this.options.isFlatten;\n\t        var tile = new _VectorTile.VectorTile(this._vectorTileDataProvider, info),\n\t            vKey = tile.vectorTileKey;\n\t\n\t        this._tiles[vKey] = { tile: tile };\n\t        return vKey;\n\t    },\n\t\n\t    _getGeneralizedTileKeys: function _getGeneralizedTileKeys(vTilePoint) {\n\t        var dz = vTilePoint.z % 2 ? 1 : 2,\n\t            pz = Math.pow(2, dz),\n\t            z = vTilePoint.z - dz,\n\t            x = Math.floor(vTilePoint.x / pz),\n\t            y = Math.floor(vTilePoint.y / pz),\n\t            temp = { v: vTilePoint.v, s: -1, d: -1, isGeneralized: true },\n\t            keys = {};\n\t\n\t        while (z > 1) {\n\t            var gKey = [z, x, y].join('_');\n\t            keys[gKey] = L.extend({}, temp, { x: x, y: y, z: z });\n\t            z -= 2;\n\t            x = Math.floor(x / 4);\n\t            y = Math.floor(y / 4);\n\t        }\n\t        return keys;\n\t    },\n\t\n\t    initTilesList: function initTilesList() {\n\t        // For non temporal layers we create all Vector tiles\n\t        var newActiveTileKeys = {};\n\t        if (this.options.tiles) {\n\t            var arr = this.options.tiles || [],\n\t                vers = this.options.tilesVers,\n\t                generalizedKeys = this.options.isGeneralized ? {} : null,\n\t                newTiles = {},\n\t                gKey,\n\t                tKey,\n\t                info,\n\t                tHash;\n\t\n\t            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\n\t                info = {\n\t                    x: Number(arr[i]),\n\t                    y: Number(arr[i + 1]),\n\t                    z: Number(arr[i + 2]),\n\t                    v: Number(vers[cnt]),\n\t                    s: -1,\n\t                    d: -1\n\t                };\n\t\n\t                tHash = this._getVectorTile(_VectorTile.VectorTile.createTileKey(info), true);\n\t                tKey = tHash.tile.vectorTileKey;\n\t                newTiles[tKey] = tHash;\n\t                newActiveTileKeys[tKey] = true;\n\t                if (generalizedKeys) {\n\t                    var gKeys = this._getGeneralizedTileKeys(info);\n\t                    for (gKey in gKeys) {\n\t                        var gPoint = gKeys[gKey];\n\t                        if (generalizedKeys[gKey]) {\n\t                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\n\t                        } else {\n\t                            generalizedKeys[gKey] = gPoint;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if (generalizedKeys) {\n\t                for (gKey in generalizedKeys) {\n\t                    info = generalizedKeys[gKey];\n\t                    tKey = _VectorTile.VectorTile.createTileKey(info);\n\t                    if (!newTiles[tKey]) {\n\t                        if (!this._tiles[tKey]) {\n\t                            this._addVectorTile(info);\n\t                        }\n\t                        newTiles[tKey] = this._tiles[tKey];\n\t                        newActiveTileKeys[tKey] = true;\n\t                    }\n\t                }\n\t            }\n\t            this._tiles = newTiles;\n\t            if (this.processingTile) {\n\t                this._tiles[this.processingTile.vectorTileKey] = {\n\t                    tile: this.processingTile\n\t                };\n\t            }\n\t        }\n\t        this._updateActiveTilesList(newActiveTileKeys);\n\t    },\n\t\n\t    //Tile filtering hook filters out active vector tiles.\n\t    //Can be used to prevent loading data from some spatial-temporal region\n\t    setTileFilteringHook: function setTileFilteringHook(filteringHook) {\n\t        this._tileFilteringHook = filteringHook;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    removeTileFilteringHook: function removeTileFilteringHook() {\n\t        this._tileFilteringHook = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    }\n\t\n\t});\n\texports.DataManager = DataManager;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _StyleManager = __webpack_require__(19);\n\t\n\tvar _ScreenVectorTile = __webpack_require__(20);\n\t\n\tL.gmx.VectorLayer = L.TileLayer.Canvas.extend({\n\t    options: {\n\t        openPopups: [],\n\t        minZoom: 1,\n\t        zIndexOffset: 0,\n\t        isGeneralized: true,\n\t        isFlatten: false,\n\t        useWebGL: false,\n\t        clickable: true\n\t    },\n\t\n\t    initialize: function initialize(options) {\n\t        options = L.setOptions(this, options);\n\t\n\t        this.initPromise = new L.gmx.Deferred();\n\t\n\t        this._drawQueue = [];\n\t        this._drawQueueHash = {};\n\t\n\t        this._drawInProgress = {};\n\t\n\t        this._anyDrawings = false; //are we drawing something?\n\t        this.repaintObservers = {}; // external observers like screen\n\t\n\t        var _this = this;\n\t\n\t        this._gmx = {\n\t            hostName: _Utils.gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\n\t            mapName: options.mapID,\n\t            useWebGL: options.useWebGL,\n\t            layerID: options.layerID,\n\t            beginDate: options.beginDate,\n\t            endDate: options.endDate,\n\t            sortItems: options.sortItems || null,\n\t            styles: options.styles || [],\n\t            tileSubscriptions: {},\n\t            _tilesToLoad: 0,\n\t            shiftXlayer: 0,\n\t            shiftYlayer: 0,\n\t            renderHooks: [],\n\t            preRenderHooks: [],\n\t            _needPopups: {}\n\t        };\n\t        if (options.crossOrigin) {\n\t            this._gmx.crossOrigin = options.crossOrigin;\n\t        }\n\t\n\t        this.on('tileunload', function (e) {\n\t            _this._clearTileSubscription(e.tile.zKey);\n\t        });\n\t    },\n\t\n\t    // extended from L.TileLayer.Canvas\n\t    _removeTile: function _removeTile(zKey) {\n\t        var tileLink = this._tiles[zKey];\n\t        if (tileLink) {\n\t            var tile = tileLink.el;\n\t            if (tile && tile.parentNode) {\n\t                tile.parentNode.removeChild(tile);\n\t            }\n\t\n\t            delete this._tiles[zKey];\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\n\t            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\n\t        }\n\t        var gmx = this._gmx;\n\t\n\t        gmx.shiftY = 0;\n\t        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\n\t        gmx.currentZoom = map.getZoom();\n\t        gmx.styleManager.initStyles();\n\t\n\t        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\n\t\n\t        map.on('zoomstart', this._zoomStart, this);\n\t        map.on('zoomend', this._zoomEnd, this);\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.on('moveend', this._moveEnd, this);\n\t        }\n\t        if (this.options.clickable === false) {\n\t            this._container.style.pointerEvents = 'none';\n\t        }\n\t        if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        this.on('stylechange', this._onStyleChange, this);\n\t        this.on('versionchange', this._onVersionChange, this);\n\t\n\t        // this._zIndexOffsetCheck();\n\t        L.gmx.layersVersion.add(this);\n\t        this.fire('add');\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._container) {\n\t            this._container.parentNode.removeChild(this._container);\n\t        }\n\t\n\t        map.off({\n\t            'viewreset': this._reset,\n\t            'moveend': this._update\n\t        }, this);\n\t\n\t        if (this._animated) {\n\t            map.off({\n\t                'zoomanim': this._animateZoom,\n\t                'zoomend': this._endZoomAnim\n\t            }, this);\n\t        }\n\t\n\t        if (!this.options.updateWhenIdle) {\n\t            map.off('move', this._limitedUpdate, this);\n\t        }\n\t        this._container = null;\n\t        this._map = null;\n\t\n\t        this._clearAllSubscriptions();\n\t        map.off('zoomstart', this._zoomStart, this);\n\t        map.off('zoomend', this._zoomEnd, this);\n\t        this.off('stylechange', this._onStyleChange, this);\n\t\n\t        var gmx = this._gmx;\n\t\n\t        delete gmx.map;\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.off('moveend', this._moveEnd, this);\n\t        }\n\t        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\n\t            L.gmx.layersVersion.remove(this);\n\t        }\n\t        this.fire('remove');\n\t    },\n\t\n\t    _initContainer: function _initContainer() {\n\t        L.TileLayer.Canvas.prototype._initContainer.call(this);\n\t        this._prpZoomData();\n\t        this.setZIndexOffset();\n\t    },\n\t\n\t    _updateZIndex: function _updateZIndex() {\n\t        if (this._container) {\n\t            var options = this.options,\n\t                zIndex = options.zIndex || 0,\n\t                zIndexOffset = options.zIndexOffset || 0;\n\t\n\t            this._container.style.zIndex = zIndexOffset + zIndex;\n\t        }\n\t    },\n\t\n\t    _update: function _update() {\n\t        if (!this._map || this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\n\t        ) {\n\t                this._clearAllSubscriptions();\n\t                return;\n\t            }\n\t        this._gmx.styleManager.deferred.then(this.__update.bind(this));\n\t    },\n\t\n\t    _addTile: function _addTile(tilePoint) {\n\t        var myLayer = this,\n\t            zoom = this._map._zoom,\n\t            gmx = this._gmx;\n\t\n\t        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\n\t            this._tileLoaded();\n\t            return;\n\t        }\n\t\n\t        var zKey = this._tileCoordsToKey(tilePoint, zoom);\n\t        if (!gmx.tileSubscriptions[zKey]) {\n\t            gmx._tilesToLoad++;\n\t            var isDrawnFirstTime = false,\n\t                gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\n\t                done = function done() {\n\t                if (!isDrawnFirstTime) {\n\t                    gmx._tilesToLoad--;\n\t                    myLayer._tileLoaded();\n\t                    isDrawnFirstTime = true;\n\t                }\n\t            },\n\t                attr = {\n\t                type: 'resend',\n\t                active: false,\n\t                bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                callback: function callback(data) {\n\t                    myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\n\t                }\n\t            };\n\t            if (this.options.isGeneralized) {\n\t                attr.targetZoom = zoom;\n\t            }\n\t            if (gmx.layerType === 'VectorTemporal') {\n\t                attr.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t\n\t            var observer = gmx.dataManager.addObserver(attr, zKey);\n\t            observer.on('activate', function () {\n\t                //if observer is deactivated before drawing,\n\t                //we can consider corresponding tile as already drawn\n\t                if (!observer.isActive()) {\n\t                    done();\n\t                }\n\t            });\n\t\n\t            observer.on('startLoadingTiles', this._chkDrawingState, this);\n\t\n\t            gmx.tileSubscriptions[zKey] = {\n\t                z: zoom,\n\t                x: tilePoint.x,\n\t                y: tilePoint.y,\n\t                px: 256 * gmxTilePoint.x,\n\t                py: 256 * (1 + gmxTilePoint.y)\n\t            };\n\t            observer.activate();\n\t        }\n\t    },\n\t\n\t    _chkDrawingState: function _chkDrawingState() {\n\t        var gmx = this._gmx,\n\t            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\n\t\n\t        if (!isDrawing) {\n\t            for (var key in gmx.tileSubscriptions) {\n\t                var observer = gmx.dataManager.getObserver(key);\n\t                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\n\t                    isDrawing = true;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (!isDrawing && this._anyDrawings) {\n\t            this.fire('doneDraw');\n\t        } else if (isDrawing && !this._anyDrawings) {\n\t            this.fire('startDraw');\n\t        }\n\t\n\t        this._anyDrawings = isDrawing;\n\t    },\n\t\n\t    _getLoadedTilesPercentage: function _getLoadedTilesPercentage(container) {\n\t        if (!container) {\n\t            return 0;\n\t        }\n\t        var len = 0,\n\t            count = 0;\n\t        var arr = ['img', 'canvas'];\n\t        for (var key in arr) {\n\t            var tiles = container.getElementsByTagName(arr[key]);\n\t            if (tiles && tiles.length > 0) {\n\t                len += tiles.length;\n\t                for (var i = 0, len1 = tiles.length; i < len1; i++) {\n\t                    if (tiles[i]._tileComplete) {\n\t                        count++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (len < 1) {\n\t            return 0;\n\t        }\n\t        return count / len;\n\t    },\n\t\n\t    _tileLoaded: function _tileLoaded() {\n\t        if (this._animated) {\n\t            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\n\t        }\n\t        if (this._gmx._tilesToLoad === 0) {\n\t            this.fire('load');\n\t\n\t            if (this._animated) {\n\t                // clear scaled tiles after all new tiles are loaded (for performance)\n\t                this._setClearBgBuffer(0);\n\t            }\n\t        }\n\t    },\n\t\n\t    _tileOnLoad: function _tileOnLoad(tile) {\n\t        if (tile) {\n\t            L.DomUtil.addClass(tile, 'leaflet-tile-loaded');\n\t        }\n\t        this._tileLoaded();\n\t    },\n\t\n\t    _tileOnError: function _tileOnError() {},\n\t\n\t    tileDrawn: function tileDrawn(tile) {\n\t        this._tileOnLoad(tile);\n\t    },\n\t\n\t    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\n\t    // converts tile coordinates to key for the tile cache\n\t    _tileCoordsToKey: function _tileCoordsToKey(coords, zoom) {\n\t        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\n\t    },\n\t\n\t    _getTiledPixelBounds: function _getTiledPixelBounds(center) {\n\t        var map = this._map,\n\t            gmx = this._gmx,\n\t            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\n\t            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\n\t            halfSize = map.getSize().divideBy(2);\n\t\n\t        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n\t    },\n\t\n\t    _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {\n\t        var tileSize = this.options.tileSize;\n\t        return new L.Bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._round());\n\t    },\n\t\n\t    // original for L.gmx.VectorLayer\n\t\n\t    //public interface\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var gmx = this._gmx;\n\t\n\t        gmx.properties = ph.properties;\n\t        gmx.geometry = ph.geometry;\n\t\n\t        if (gmx.properties._initDone) {\n\t            // need delete tiles key\n\t            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\n\t        }\n\t        gmx.properties._initDone = true;\n\t\n\t        if (!gmx.geometry) {\n\t            var worldSize = _Utils.gmxAPIutils.tileSizes[1];\n\t            gmx.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        // Original properties from the server.\n\t        // Descendant classes can override this property\n\t        // Not so good solution, but it works\n\t        gmx.rawProperties = ph.rawProperties || ph.properties;\n\t\n\t        this._updateProperties(ph.properties);\n\t\n\t        ph.properties.isGeneralized = this.options.isGeneralized;\n\t        ph.properties.isFlatten = this.options.isFlatten;\n\t\n\t        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\n\t\n\t        if (this.options.parentOptions) {\n\t            if (!ph.properties.styles) {\n\t                ph.properties.styles = this.options.parentOptions.styles;\n\t            }\n\t            gmx.dataManager.on('versionchange', this._onVersionChange, this);\n\t        }\n\t\n\t        gmx.styleManager = new _StyleManager.StyleManager(gmx);\n\t        this.options.minZoom = gmx.styleManager.minZoom;\n\t        this.options.maxZoom = gmx.styleManager.maxZoom;\n\t\n\t        gmx.dataManager.on('observeractivate', function () {\n\t            if (gmx.dataManager.getActiveObserversCount()) {\n\t                L.gmx.layersVersion.add(this);\n\t            } else {\n\t                L.gmx.layersVersion.remove(this);\n\t            }\n\t        }, this);\n\t\n\t        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\n\t            this.options.chkUpdate = true; //Check updates for vector layers by default\n\t        }\n\t        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\n\t            this._objectsReorderInit(this);\n\t        }\n\t\n\t        if (gmx.clusters) {\n\t            this.bindClusters(JSON.parse(gmx.clusters));\n\t        }\n\t        if (gmx.filter) {\n\t            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (func) {\n\t                gmx.dataManager.addFilter('userFilter_' + gmx.layerID, function (item) {\n\t                    return gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\n\t                }.bind(this));\n\t            }\n\t        }\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\n\t        }\n\t\n\t        this.initPromise.resolve();\n\t        return this;\n\t    },\n\t\n\t    getDataManager: function getDataManager() {\n\t        return this._gmx.dataManager;\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.enableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.disableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    setRasterOpacity: function setRasterOpacity(opacity) {\n\t        var _this = this;\n\t        if (this._gmx.rasterOpacity !== opacity) {\n\t            this._gmx.rasterOpacity = opacity;\n\t            this.initPromise.then(function () {\n\t                _this.repaint();\n\t            });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        return this._gmx.styleManager.getStyles();\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        this._gmx.styleManager.getIcons(callback);\n\t        return this;\n\t    },\n\t\n\t    setStyles: function setStyles(styles) {\n\t        var _this = this;\n\t\n\t        this.initPromise.then(function () {\n\t            _this._gmx.styleManager.clearStyles();\n\t            if (styles) {\n\t                styles.forEach(function (it, i) {\n\t                    _this.setStyle(it, i, true);\n\t                });\n\t            } else {\n\t                _this.fire('stylechange');\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    getStyle: function getStyle(num) {\n\t        return this.getStyles()[num];\n\t    },\n\t\n\t    setStyle: function setStyle(style, num, createFlag) {\n\t        var _this = this,\n\t            gmx = this._gmx;\n\t        this.initPromise.then(function () {\n\t            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\n\t                _this.fire('stylechange', { num: num || 0 });\n\t            });\n\t        });\n\t        return this;\n\t    },\n\t\n\t    setStyleHook: function setStyleHook(func) {\n\t        this._gmx.styleHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeStyleHook: function removeStyleHook() {\n\t        this._gmx.styleHook = null;\n\t        return this;\n\t    },\n\t\n\t    setRasterHook: function setRasterHook(func) {\n\t        this._gmx.rasterProcessingHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeRasterHook: function removeRasterHook() {\n\t        this._gmx.rasterProcessingHook = null;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    setFilter: function setFilter(func) {\n\t        var gmx = this._gmx;\n\t        gmx.dataManager.addFilter('userFilter', function (item) {\n\t            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\n\t        }.bind(this));\n\t        return this;\n\t    },\n\t\n\t    removeFilter: function removeFilter() {\n\t        this._gmx.dataManager.removeFilter('userFilter');\n\t        return this;\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var gmx = this._gmx;\n\t\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            beginDate = gmx.dateBegin;\n\t            endDate = gmx.dateEnd;\n\t        }\n\t\n\t        //check that something changed\n\t        if (!gmx.beginDate !== !beginDate || !gmx.endDate !== !endDate || beginDate && gmx.beginDate.valueOf() !== beginDate.valueOf() || endDate && gmx.endDate.valueOf() !== endDate.valueOf()) {\n\t            if (gmx.rawProperties.maxShownPeriod && beginDate) {\n\t                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\n\t                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\n\t            }\n\t\n\t            gmx.beginDate = beginDate;\n\t            gmx.endDate = endDate;\n\t\n\t            var observer = null,\n\t                dataManager = gmx.dataManager;\n\t            for (var key in gmx.tileSubscriptions) {\n\t                observer = dataManager.getObserver(key);\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            observer = dataManager.getObserver('_Labels');\n\t            if (observer) {\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            if (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\n\t                gmx.properties.LayerVersion = -1;\n\t                dataManager.setOptions({ LayerVersion: -1 });\n\t                if (this._map) {\n\t                    L.gmx.layersVersion.now();\n\t                }\n\t            }\n\t            this.fire('dateIntervalChanged');\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getDateInterval: function getDateInterval() {\n\t        return {\n\t            beginDate: this._gmx.beginDate,\n\t            endDate: this._gmx.endDate\n\t        };\n\t    },\n\t\n\t    addObserver: function addObserver(options) {\n\t        return this._gmx.dataManager.addObserver(options);\n\t    },\n\t\n\t    removeObserver: function removeObserver(observer) {\n\t        return this._gmx.dataManager.removeObserver(observer.id);\n\t    },\n\t\n\t    setPositionOffset: function setPositionOffset(dx, dy) {\n\t        var gmx = this._gmx;\n\t        gmx.shiftXlayer = dx;\n\t        gmx.shiftYlayer = dy;\n\t        this._update();\n\t        return this;\n\t    },\n\t\n\t    getPositionOffset: function getPositionOffset() {\n\t        var gmx = this._gmx;\n\t        return { shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer };\n\t    },\n\t\n\t    setZIndexOffset: function setZIndexOffset(offset) {\n\t        if (arguments.length) {\n\t            this.options.zIndexOffset = offset;\n\t        }\n\t        this._updateZIndex();\n\t        return this;\n\t    },\n\t\n\t    repaint: function repaint(zKeys) {\n\t        if (this._map) {\n\t            if (!zKeys) {\n\t                zKeys = {};\n\t                for (var key in this._gmx.tileSubscriptions) {\n\t                    zKeys[key] = true;\n\t                }\n\t                L.extend(zKeys, this.repaintObservers);\n\t            }\n\t            this._gmx.dataManager._triggerObservers(zKeys);\n\t        }\n\t    },\n\t\n\t    redrawItem: function redrawItem(id) {\n\t        if (this._map) {\n\t            var item = this._gmx.dataManager.getItem(id),\n\t                gmxTiles = this._getTilesByBounds(item.bounds);\n\t\n\t            this.repaint(gmxTiles);\n\t        }\n\t    },\n\t\n\t    gmxGetCanvasTile: function gmxGetCanvasTile(tilePoint) {\n\t        var zKey = this._tileCoordsToKey(tilePoint);\n\t\n\t        if (zKey in this._tiles) {\n\t            return this._tiles[zKey];\n\t        }\n\t        // save tile in cache\n\t        var tile = this._getTile();\n\t        this._tiles[zKey] = {\n\t            el: tile,\n\t            coords: tilePoint,\n\t            current: true\n\t        };\n\t\n\t        // tile._zKey = zKey;\n\t        tile._zoom = this._map._zoom;\n\t        tile._tileComplete = true;\n\t        tile._tilePoint = tilePoint;\n\t        this.tileDrawn(tile);\n\t        return this._tiles[zKey];\n\t    },\n\t\n\t    appendTileToContainer: function appendTileToContainer(tile) {\n\t        this._tileContainer.appendChild(tile);\n\t        var tilePos = this._getTilePos(tile._tilePoint);\n\t        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\n\t    },\n\t\n\t    addData: function addData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.addData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.removeData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStylesByProperties: function getStylesByProperties(propArray, zoom) {\n\t        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\n\t    },\n\t\n\t    getItemStyle: function getItemStyle(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        return gmx.styleManager.getObjStyle(item);\n\t    },\n\t\n\t    getTileAttributeTypes: function getTileAttributeTypes() {\n\t        return this._gmx.tileAttributeTypes;\n\t    },\n\t\n\t    getTileAttributeIndexes: function getTileAttributeIndexes() {\n\t        return this._gmx.tileAttributeIndexes;\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id),\n\t            styles = this.getStyles(),\n\t            out = '';\n\t\n\t        if (item && styles[item.currentFilter]) {\n\t            var propsArr = item.properties;\n\t            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\n\t                properties: this.getItemProperties(propsArr),\n\t                geometries: [propsArr[propsArr.length - 1]],\n\t                tileAttributeTypes: gmx.tileAttributeTypes,\n\t                unitOptions: this._map ? this._map.options : {}\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getItemProperties: function getItemProperties(propArray) {\n\t        var properties = {},\n\t            indexes = this._gmx.tileAttributeIndexes;\n\t        for (var key in indexes) {\n\t            properties[key] = propArray[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    addPreRenderHook: function addPreRenderHook(renderHook) {\n\t        this._gmx.preRenderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removePreRenderHook: function removePreRenderHook(hook) {\n\t        var arr = this._gmx.preRenderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    addRenderHook: function addRenderHook(renderHook) {\n\t        this._gmx.renderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removeRenderHook: function removeRenderHook(hook) {\n\t        var arr = this._gmx.renderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    //get original properties from the server\n\t    getGmxProperties: function getGmxProperties() {\n\t        return this._gmx.rawProperties;\n\t    },\n\t\n\t    //returns L.LatLngBounds\n\t    getBounds: function getBounds() {\n\t        var proj = L.Projection.Mercator,\n\t            gmxBounds = this._gmx.layerID ? _Utils.gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\n\t\n\t        if (gmxBounds) {\n\t            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\n\t        } else {\n\t            return new L.LatLngBounds();\n\t        }\n\t    },\n\t\n\t    getGeometry: function getGeometry() {\n\t        if (!this._gmx.latLngGeometry) {\n\t            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\n\t        }\n\t\n\t        return this._gmx.latLngGeometry;\n\t    },\n\t\n\t    // internal methods\n\t    _clearTileSubscription: function _clearTileSubscription(zKey) {\n\t        var gmx = this._gmx;\n\t\n\t        if (zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            delete gmx.tileSubscriptions[zKey];\n\t            this._removeTile(zKey);\n\t\n\t            if (this._anyDrawings) {\n\t                this._chkDrawingState();\n\t            }\n\t        }\n\t\n\t        if (zKey in this._drawQueueHash) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t    },\n\t\n\t    _clearAllSubscriptions: function _clearAllSubscriptions() {\n\t        while (this._drawQueue.length) {\n\t            this._drawQueue[0].def.cancel();\n\t        }\n\t\n\t        var gmx = this._gmx;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            gmx.dataManager.removeObserver(zKey);\n\t            delete gmx.tileSubscriptions[zKey];\n\t            delete this._tiles[zKey];\n\t        }\n\t\n\t        if (this._anyDrawings) {\n\t            this._chkDrawingState();\n\t        }\n\t\n\t        gmx._tilesToLoad = 0;\n\t    },\n\t\n\t    _zoomStart: function _zoomStart() {\n\t        this._gmx.zoomstart = true;\n\t    },\n\t\n\t    _zoomEnd: function _zoomEnd() {\n\t        this._gmx.zoomstart = false;\n\t        this.setCurrentZoom(this._map);\n\t        // this._zIndexOffsetCheck();\n\t    },\n\t\n\t    _moveEnd: function _moveEnd() {\n\t        if ('dataManager' in this._gmx) {\n\t            this._gmx.dataManager.fire('moveend');\n\t        }\n\t    },\n\t\n\t    _onStyleChange: function _onStyleChange() {\n\t        var gmx = this._gmx;\n\t        if (!gmx.balloonEnable && this._popup) {\n\t            this.unbindPopup();\n\t        } else if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        if (this._map) {\n\t            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\n\t                this.options.minZoom = gmx.styleManager.minZoom;\n\t                this.options.maxZoom = gmx.styleManager.maxZoom;\n\t                this._map._updateZoomLevels();\n\t            }\n\t            if (gmx.labelsLayer) {\n\t                this._map._labelsLayer.add(this);\n\t            } else if (!gmx.labelsLayer) {\n\t                this._map._labelsLayer.remove(this);\n\t            }\n\t            if (Object.keys(gmx.tileSubscriptions).length > 0) {\n\t                for (var key in gmx.tileSubscriptions) {\n\t                    // recheck bbox on screen observers\n\t                    var observer = gmx.dataManager.getObserver(key),\n\t                        parsedKey = gmx.tileSubscriptions[key],\n\t                        gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\n\t                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\n\t                    if (!observer.bbox.isEqual(bbox)) {\n\t                        var proj = L.Projection.Mercator;\n\t                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\n\t                    }\n\t                }\n\t            } else {\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    _removeInProgressDrawing: function _removeInProgressDrawing(zKey) {\n\t        delete this._drawInProgress[zKey];\n\t        this._chkDrawingState();\n\t    },\n\t\n\t    _drawTileAsync: function _drawTileAsync(tilePoint, zoom, data) {\n\t        var queue = this._drawQueue,\n\t            isEmpty = queue.length === 0,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            _this = this;\n\t\n\t        if (this._drawQueueHash[zKey]) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t\n\t        var drawNextTile = function drawNextTile() {\n\t            _this._chkDrawingState();\n\t\n\t            if (!queue.length) {\n\t                return;\n\t            }\n\t\n\t            var queueItem = queue.shift();\n\t            delete _this._drawQueueHash[queueItem.zKey];\n\t            if (_this._map && queueItem.z === _this._map._zoom) {\n\t                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\n\t\n\t                _this._drawInProgress[queueItem.zKey] = true;\n\t\n\t                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\n\t\n\t                queueItem.drawDef.then(queueItem.def.resolve.bind(queueItem.def, queueItem.data), queueItem.def.reject);\n\t            } else {\n\t                queueItem.def.reject();\n\t            }\n\t            setTimeout(drawNextTile, 0);\n\t        };\n\t\n\t        var gtp = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\n\t        var queueItem = { gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data };\n\t        var def = queueItem.def = new L.gmx.Deferred(function () {\n\t            queueItem.drawDef && queueItem.drawDef.cancel();\n\t\n\t            _this._removeInProgressDrawing(zKey);\n\t\n\t            delete _this._drawQueueHash[zKey];\n\t            for (var i = queue.length - 1; i >= 0; i--) {\n\t                var elem = queue[i];\n\t                if (elem.zKey === zKey) {\n\t                    queue.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        queue.push(queueItem);\n\t\n\t        this._drawQueueHash[zKey] = def;\n\t\n\t        if (isEmpty) {\n\t            setTimeout(drawNextTile, 0);\n\t        }\n\t\n\t        return def;\n\t    },\n\t\n\t    _updateShiftY: function _updateShiftY() {\n\t        var gmx = this._gmx,\n\t            map = this._map,\n\t            deltaY = 0;\n\t\n\t        if (map) {\n\t            var pos = map.getCenter();\n\t            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\n\t        }\n\t\n\t        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\n\t        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\n\t        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY); // Сдвиг слоя\n\t\n\t        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\n\t    },\n\t\n\t    _prpZoomData: function _prpZoomData() {\n\t        this.setCurrentZoom(this._map);\n\t        // this.repaint();\n\t    },\n\t\n\t    setCurrentZoom: function setCurrentZoom(map) {\n\t        var gmx = this._gmx;\n\t        gmx.currentZoom = map._zoom;\n\t        gmx.tileSize = _Utils.gmxAPIutils.tileSizes[gmx.currentZoom];\n\t        gmx.mInPixel = 256 / gmx.tileSize;\n\t    },\n\t\n\t    // _zIndexOffsetCheck: function() {\n\t    // var gmx = this._gmx;\n\t    // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\n\t    // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\n\t    // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\n\t    // if (zIndexOffset !== this.options.zIndexOffset) {\n\t    // this.setZIndexOffset(zIndexOffset);\n\t    // }\n\t    // }\n\t    // },\n\t\n\t    _setClearBgBuffer: function _setClearBgBuffer(zd) {\n\t        if (this._clearBgBufferTimer) {\n\t            clearTimeout(this._clearBgBufferTimer);\n\t        }\n\t        var _this = this;\n\t        this._clearBgBufferTimer = setTimeout(function () {\n\t            if (_this._bgBuffer) {\n\t                _this._clearBgBuffer();\n\t            }\n\t        }, zd || 0);\n\t    },\n\t\n\t    _getNeedPopups: function _getNeedPopups() {\n\t        var out = {},\n\t            openPopups = this.options.openPopups;\n\t        for (var i = 0, len = openPopups.length; i < len; i++) {\n\t            out[openPopups[i]] = false;\n\t        }\n\t        return out;\n\t    },\n\t\n\t    __update: function __update() {\n\t        var map = this._map;\n\t        if (!map) {\n\t            return;\n\t        }\n\t        var zoom = map.getZoom(),\n\t            center = map.getCenter();\n\t\n\t        if (this._gmx.applyShift) {\n\t            this._updateShiftY();\n\t        }\n\t        this._tileZoom = zoom;\n\t        if (this.options.openPopups.length) {\n\t            this._gmx._needPopups = this._getNeedPopups();\n\t            this.options.openPopups = [];\n\t        }\n\t\n\t        var pixelBounds = this._getTiledPixelBounds(center),\n\t            tileRange = this._pxBoundsToTileRange(pixelBounds),\n\t            limit = this._getWrapTileNum();\n\t\n\t        if (tileRange.min.y < 0) {\n\t            tileRange.min.y = 0;\n\t        }\n\t        if (tileRange.max.y >= limit.y) {\n\t            tileRange.max.y = limit.y - 1;\n\t        }\n\t\n\t        this._chkTileSubscriptions(zoom, tileRange);\n\t\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            this._setClearBgBuffer(500);\n\t            return;\n\t        }\n\t\n\t        // create a queue of coordinates to load tiles from\n\t        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n\t            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n\t                var coords = new L.Point(i, j);\n\t                coords.z = this._tileZoom;\n\t\n\t                if (!this._tiles[this._tileCoordsToKey(coords)]) {\n\t                    this._addTile(coords);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkTileSubscriptions: function _chkTileSubscriptions(zoom, tileRange) {\n\t        //L.TileVector will remove all tiles from other zooms.\n\t        //But it will not remove subscriptions without tiles - we should do it ourself\n\t        var gmx = this._gmx,\n\t            min = tileRange.min,\n\t            max = tileRange.max;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.z !== zoom || subscription.x < min.x || subscription.x > max.x || subscription.y < min.y || subscription.y > max.y) {\n\t                this._clearTileSubscription(zKey);\n\t            }\n\t        }\n\t    },\n\t\n\t    _getScreenTile: function _getScreenTile(tilePoint, zoom) {\n\t        var gmx = this._gmx,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            subscription = gmx.tileSubscriptions[zKey],\n\t            screenTile = null;\n\t        if (subscription) {\n\t            if (subscription.screenTile) {\n\t                screenTile = subscription.screenTile;\n\t            } else {\n\t                subscription.screenTile = screenTile = new _ScreenVectorTile.ScreenVectorTile(this, tilePoint, zoom);\n\t            }\n\t        }\n\t        return screenTile;\n\t    },\n\t\n\t    _gmxDrawTile: function _gmxDrawTile(tilePoint, zoom, data) {\n\t        var gmx = this._gmx,\n\t            cancelled = false,\n\t            screenTileDrawPromise = null,\n\t            def = new L.gmx.Deferred(function () {\n\t            cancelled = true;\n\t            screenTileDrawPromise && screenTileDrawPromise.cancel();\n\t        });\n\t\n\t        if (!this._map) {\n\t            def.reject();\n\t            return def;\n\t        }\n\t        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\n\t        if (screenTile) {\n\t            gmx.styleManager.deferred.then(function () {\n\t                if (!cancelled) {\n\t                    screenTileDrawPromise = screenTile.drawTile(data);\n\t                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\n\t                }\n\t            });\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _getTilesByBounds: function _getTilesByBounds(bounds) {\n\t        // Получить список gmxTiles по bounds\n\t        var gmx = this._gmx,\n\t            zoom = this._map._zoom,\n\t            shiftX = gmx.shiftX || 0,\n\t\n\t        // Сдвиг слоя\n\t        shiftY = gmx.shiftY || 0,\n\t\n\t        // Сдвиг слоя + OSM\n\t        minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\n\t            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\n\t            screenBounds = this._map.getBounds(),\n\t            sw = screenBounds.getSouthWest(),\n\t            ne = screenBounds.getNorthEast(),\n\t            dx = 0;\n\t\n\t        if (ne.lng - sw.lng < 360) {\n\t            if (maxLatLng.lng < sw.lng) {\n\t                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\n\t            } else if (minLatLng.lng > ne.lng) {\n\t                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\n\t            }\n\t        }\n\t        minLatLng.lng += dx;\n\t        maxLatLng.lng += dx;\n\t\n\t        var pixelBounds = this._map.getPixelBounds(),\n\t            minPoint = this._map.project(minLatLng),\n\t            maxPoint = this._map.project(maxLatLng);\n\t\n\t        var minY, maxY, minX, maxX;\n\t        if (pixelBounds) {\n\t            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\n\t            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\n\t            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\n\t            minX = Math.floor((minX + shiftX) / 256);\n\t            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\n\t            maxX = Math.floor((maxX + shiftX) / 256);\n\t        } else {\n\t            minY = Math.floor((maxPoint.y + shiftY) / 256);\n\t            maxY = Math.floor((minPoint.y + shiftY) / 256);\n\t            minX = Math.floor((minPoint.x + shiftX) / 256);\n\t            maxX = Math.floor((maxPoint.x + shiftX) / 256);\n\t        }\n\t        var gmxTiles = {};\n\t        for (var x = minX; x <= maxX; x++) {\n\t            for (var y = minY; y <= maxY; y++) {\n\t                var zKey = this._tileCoordsToKey({ x: x, y: y }, zoom);\n\t                gmxTiles[zKey] = true;\n\t            }\n\t        }\n\t        return gmxTiles;\n\t    },\n\t\n\t    _updateProperties: function _updateProperties(prop) {\n\t        var gmx = this._gmx,\n\t            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\n\t\n\t        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\n\t\n\t        if (this.options.parentOptions) {\n\t            prop = this.options.parentOptions;\n\t        }\n\t\n\t        gmx.identityField = prop.identityField; // ogc_fid\n\t        gmx.GeometryType = (prop.GeometryType || '').toLowerCase(); // тип геометрий обьектов в слое\n\t        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1; // мин. zoom для растров\n\t        gmx.minZoomQuicklooks = gmx.minZoomRasters; // по умолчанию minZoom для квиклуков и КР равны\n\t\n\t        var type = prop.type || 'Vector';\n\t        if (prop.Temporal) {\n\t            type += 'Temporal';\n\t        }\n\t        gmx.layerType = type; // VectorTemporal Vector\n\t        gmx.items = {};\n\t\n\t        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\n\t        if (gmx.dataManager) {\n\t            gmx.dataManager.setOptions(prop);\n\t        }\n\t        if ('ZIndexField' in prop) {\n\t            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\n\t                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField]; // sort field index\n\t            }\n\t        }\n\t        if (this._objectsReorder) {\n\t            this._objectsReorder.initialize();\n\t        }\n\t\n\t        // if ('clusters' in prop) {\n\t        // gmx.clusters = prop.clusters;\n\t        // }\n\t\n\t        gmx.filter = prop.filter; // for dataSource attr\n\t        gmx.dateBegin = prop.dateBegin;\n\t        gmx.dateEnd = prop.dateEnd;\n\t        gmx.dataSource = prop.dataSource;\n\t        if ('MetaProperties' in gmx.rawProperties) {\n\t            var meta = gmx.rawProperties.MetaProperties;\n\t            if ('parentLayer' in meta) {\n\t                // фильтр слоя\t\t// todo удалить после изменений вов вьювере\n\t                gmx.dataSource = meta.parentLayer.Value || '';\n\t            }\n\t            if ('filter' in meta) {\n\t                // фильтр слоя\n\t                gmx.filter = meta.filter.Value || '';\n\t            }\n\t            if ('dateBegin' in meta) {\n\t                // фильтр для мультивременного слоя\n\t                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\n\t            }\n\t            if ('dateEnd' in meta) {\n\t                // фильтр для мультивременного слоя\n\t                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\n\t            }\n\t            if ('shiftX' in meta || 'shiftY' in meta) {\n\t                // сдвиг всего слоя\n\t                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\n\t                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\n\t            }\n\t            if ('shiftXfield' in meta || 'shiftYfield' in meta) {\n\t                // поля сдвига растров объектов слоя\n\t                if (meta.shiftXfield) {\n\t                    gmx.shiftXfield = meta.shiftXfield.Value;\n\t                }\n\t                if (meta.shiftYfield) {\n\t                    gmx.shiftYfield = meta.shiftYfield.Value;\n\t                }\n\t            }\n\t            if ('quicklookPlatform' in meta) {\n\t                // тип спутника\n\t                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\n\t                if (gmx.quicklookPlatform === 'image') {\n\t                    delete gmx.quicklookPlatform;\n\t                }\n\t            }\n\t            if ('quicklookX1' in meta) {\n\t                gmx.quicklookX1 = meta.quicklookX1.Value;\n\t            }\n\t            if ('quicklookY1' in meta) {\n\t                gmx.quicklookY1 = meta.quicklookY1.Value;\n\t            }\n\t            if ('quicklookX2' in meta) {\n\t                gmx.quicklookX2 = meta.quicklookX2.Value;\n\t            }\n\t            if ('quicklookY2' in meta) {\n\t                gmx.quicklookY2 = meta.quicklookY2.Value;\n\t            }\n\t            if ('quicklookX3' in meta) {\n\t                gmx.quicklookX3 = meta.quicklookX3.Value;\n\t            }\n\t            if ('quicklookY3' in meta) {\n\t                gmx.quicklookY3 = meta.quicklookY3.Value;\n\t            }\n\t            if ('quicklookX4' in meta) {\n\t                gmx.quicklookX4 = meta.quicklookX4.Value;\n\t            }\n\t            if ('quicklookY4' in meta) {\n\t                gmx.quicklookY4 = meta.quicklookY4.Value;\n\t            }\n\t\n\t            if ('multiFilters' in meta) {\n\t                // проверка всех фильтров для обьектов слоя\n\t                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\n\t            }\n\t            if ('isGeneralized' in meta) {\n\t                // Set generalization\n\t                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\n\t            }\n\t            if ('isFlatten' in meta) {\n\t                // Set flatten geometry\n\t                this.options.isFlatten = meta.isFlatten.Value !== 'false';\n\t            }\n\t        }\n\t        if (prop.Temporal) {\n\t            // Clear generalization flag for Temporal layers\n\t            this.options.isGeneralized = false;\n\t        }\n\t\n\t        if (prop.IsRasterCatalog) {\n\t            gmx.IsRasterCatalog = prop.IsRasterCatalog;\n\t            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\n\t            if (layerLink) {\n\t                gmx.rasterBGfunc = function (x, y, z, item) {\n\t                    var properties = item.properties;\n\t                    return 'http://' + gmx.hostName + '/TileSender.ashx?ModeKey=tile' + '&x=' + x + '&y=' + y + '&z=' + z + '&LayerName=' + properties[layerLink] + '&key=' + encodeURIComponent(gmx.sessionKey);\n\t                };\n\t            }\n\t        }\n\t        if (prop.Quicklook) {\n\t            var quicklookParams;\n\t\n\t            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом\n\t            if (prop.Quicklook[0] === '{') {\n\t                quicklookParams = JSON.parse(prop.Quicklook);\n\t            } else {\n\t                quicklookParams = {\n\t                    minZoom: gmx.minZoomRasters,\n\t                    template: prop.Quicklook\n\t                };\n\t            }\n\t\n\t            if ('X1' in quicklookParams) {\n\t                gmx.quicklookX1 = quicklookParams.X1;\n\t            }\n\t            if ('Y1' in quicklookParams) {\n\t                gmx.quicklookY1 = quicklookParams.Y1;\n\t            }\n\t            if ('X2' in quicklookParams) {\n\t                gmx.quicklookX2 = quicklookParams.X2;\n\t            }\n\t            if ('Y2' in quicklookParams) {\n\t                gmx.quicklookY2 = quicklookParams.Y2;\n\t            }\n\t            if ('X3' in quicklookParams) {\n\t                gmx.quicklookX3 = quicklookParams.X3;\n\t            }\n\t            if ('Y3' in quicklookParams) {\n\t                gmx.quicklookY3 = quicklookParams.Y3;\n\t            }\n\t            if ('X4' in quicklookParams) {\n\t                gmx.quicklookX4 = quicklookParams.X4;\n\t            }\n\t            if ('Y4' in quicklookParams) {\n\t                gmx.quicklookY4 = quicklookParams.Y4;\n\t            }\n\t\n\t            var template = gmx.Quicklook = quicklookParams.template;\n\t            if ('minZoom' in quicklookParams) {\n\t                gmx.minZoomQuicklooks = quicklookParams.minZoom;\n\t            }\n\t            gmx.quicklookBGfunc = function (item) {\n\t                var url = template,\n\t                    reg = /\\[([^\\]]+)\\]/,\n\t                    matches = reg.exec(url);\n\t                while (matches && matches.length > 1) {\n\t                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\n\t                    matches = reg.exec(url);\n\t                }\n\t                return url;\n\t            };\n\t            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\n\t        }\n\t        this.options.attribution = prop.Copyright || '';\n\t    },\n\t\n\t    _onVersionChange: function _onVersionChange() {\n\t        this._updateProperties(this._gmx.rawProperties);\n\t    },\n\t\n\t    getViewRasters: function getViewRasters() {\n\t        var gmx = this._gmx,\n\t            hash = {},\n\t            out = [];\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey],\n\t                screenTile = subscription.screenTile;\n\t            if (screenTile) {\n\t                screenTile.itemsView.forEach(function (it) {\n\t                    hash[it.id] = true;\n\t                });\n\t            }\n\t        }\n\t        for (var id in hash) {\n\t            out.push(id);\n\t        }\n\t\n\t        return out;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, propArr) {\n\t        return _Utils.gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\n\t    }\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.StyleManager = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar StyleManager = function StyleManager(gmx) {\n\t    this.gmx = gmx;\n\t    this.deferred = new L.gmx.Deferred();\n\t\n\t    this._maxVersion = 0;\n\t    this._maxStyleSize = 0;\n\t    this._styles = [];\n\t    this._deferredIcons = [];\n\t    this._parserFunctions = {};\n\t    this._serverStylesParsed = false;\n\t\n\t    var minZoom = Infinity,\n\t        maxZoom = -Infinity,\n\t        arr = gmx.properties.styles || [];\n\t\n\t    for (var i = 0, len = arr.length; i < len; i++) {\n\t        var st = arr[i];\n\t        minZoom = Math.min(minZoom, st.MinZoom);\n\t        maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t    }\n\t    this.minZoom = minZoom === Infinity ? 0 : minZoom;\n\t    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\n\t};\n\tStyleManager.prototype = {\n\t    _getMaxStyleSize: function _getMaxStyleSize(zoom) {\n\t        // estimete style size for arbitrary object\n\t        var maxSize = 0;\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom > style.MaxZoom || zoom < style.MinZoom) {\n\t                continue;\n\t            }\n\t            var RenderStyle = style.RenderStyle;\n\t            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\n\t            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\n\t                maxSize = StyleManager.MAX_STYLE_SIZE;\n\t                break;\n\t            }\n\t            var maxShift = 0;\n\t            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\n\t                maxShift = Math.max(Math.abs(RenderStyle.iconAnchor[0]), Math.abs(RenderStyle.iconAnchor[1]));\n\t            }\n\t            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\n\t        }\n\t        return maxSize;\n\t    },\n\t\n\t    getStyleBounds: function getStyleBounds(gmxTilePoint) {\n\t        if (!gmxTilePoint) {\n\t            return _Utils.gmxAPIutils.bounds();\n\t        }\n\t\n\t        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\n\t\n\t        var mercSize = 2 * this._maxStyleSize * _Utils.gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\n\t        return _Utils.gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\n\t    },\n\t\n\t    //is any style is visible at given zoom?\n\t    isVisibleAtZoom: function isVisibleAtZoom(zoom) {\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        var _this = this;\n\t        this.deferred.then(function () {\n\t            var out = [];\n\t            for (var i = 0, len = _this._styles.length; i < len; i++) {\n\t                var style = _this._styles[i],\n\t                    pt = {};\n\t                if (style.RenderStyle) {\n\t                    pt.RenderStyle = { image: style.RenderStyle.image };\n\t                }\n\t                if (style.HoverStyle) {\n\t                    pt.HoverStyle = { image: style.HoverStyle.image };\n\t                }\n\t                out.push(pt);\n\t            }\n\t            if (callback) {\n\t                callback(out);\n\t            }\n\t        });\n\t        this.initStyles();\n\t    },\n\t\n\t    _chkReady: function _chkReady() {\n\t        if (this._needLoadIcons < 1) {\n\t            var _this = this;\n\t            if (this.gmx.dataManager) {\n\t                this.gmx.dataManager.addFilter('styleFilter', function (it) {\n\t                    return _this._chkStyleFilter(it);\n\t                });\n\t            }\n\t            this.deferred.resolve();\n\t        }\n\t    },\n\t\n\t    initStyles: function initStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\n\t            this._getImageSize(this._deferredIcons[i]);\n\t        }\n\t        this._deferredIcons = [];\n\t        this._chkReady();\n\t        return this.deferred;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        var out = [];\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = L.extend({}, this._styles[i]);\n\t            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\n\t            if (style.HoverStyle) {\n\t                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\n\t            }\n\t            delete style.filterFunction;\n\t            delete style.version;\n\t            delete style.common;\n\t            delete style.type;\n\t            out.push(style);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    clearStyles: function clearStyles() {\n\t        this._styles = [];\n\t        this.gmx.balloonEnable = false;\n\t        this.gmx.labelsLayer = false;\n\t    },\n\t\n\t    _changeStylesVersion: function _changeStylesVersion() {\n\t        var _this = this;\n\t        this._styles.map(function (it) {\n\t            it.version = ++_this._maxVersion;\n\t        });\n\t    },\n\t\n\t    setStyle: function setStyle(st, num, createFlag) {\n\t        num = num || 0;\n\t        if (num < this._styles.length || createFlag) {\n\t            var style = this._styles[num];\n\t            if (!style) {\n\t                style = this._prepareItem({});\n\t                this._styles[num] = style;\n\t            }\n\t            this.deferred = new L.gmx.Deferred();\n\t            style.version = ++this._maxVersion;\n\t            if ('Filter' in st) {\n\t                style.Filter = st.Filter;\n\t                var type = _typeof(st.Filter);\n\t                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"')) : type === 'function' ? style.Filter : null;\n\t\n\t                this._changeStylesVersion();\n\t            }\n\t            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\n\t                var key = StyleManager.DEFAULT_KEYS[i];\n\t                if (key in st) {\n\t                    style[key] = st[key];\n\t                }\n\t            }\n\t            if (st.RenderStyle) {\n\t                style.RenderStyle = this._parseStyle(st.RenderStyle);\n\t            }\n\t            if (st.HoverStyle) {\n\t                style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle);\n\t            }\n\t            this._checkStyles();\n\t        }\n\t        return this.initStyles();\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var item = this.gmx.dataManager.getItem(id),\n\t            currentFilter = item ? item.currentFilter : 0,\n\t            style = this._styles[currentFilter];\n\t        return style ? {\n\t            DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\n\t            DisableBalloonOnClick: style.DisableBalloonOnClick || false,\n\t            templateBalloon: style.Balloon || null,\n\t            isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\n\t        } : null;\n\t    },\n\t\n\t    // apply styleHook func\n\t    // applyStyleHook: function(item, hoverFlag) {\n\t    // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\n\t    // },\n\t\n\t    getObjStyle: function getObjStyle(item) {\n\t        this._chkStyleFilter(item);\n\t        var style = this._styles[item.currentFilter],\n\t            version;\n\t\n\t        if (!style) {\n\t            return null;\n\t        }\n\t        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\n\t            if (style.HoverStyle) {\n\t                version = style.HoverStyle.version || -1;\n\t                if (version !== item.styleVersion) {\n\t                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\n\t                }\n\t                return style.HoverStyle;\n\t            } else {\n\t                delete item.parsedStyleHover;\n\t            }\n\t            return null;\n\t        }\n\t        version = style.version || -1;\n\t        if (version !== item.styleVersion) {\n\t            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\n\t        }\n\t        return style.RenderStyle;\n\t    },\n\t\n\t    _needLoadIcons: 0,\n\t    _getImageSize: function _getImageSize(pt) {\n\t        // check image size\n\t        var url = pt.iconUrl || pt.fillIconUrl,\n\t            opt = pt.iconAngle || pt.iconScale ? { crossOrigin: 'anonymous' } : {},\n\t            _this = this;\n\t\n\t        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t            opt = {}; // skip bug in IE11\n\t        }\n\t        opt.layerID = this.gmx.layerID;\n\t        ++this._needLoadIcons;\n\t        L.gmx.imageLoader.unshift(url, opt).def.then(function (it) {\n\t            pt.version = ++_this._maxVersion;\n\t            if (pt.fillIconUrl) {\n\t                pt.imagePattern = it;\n\t            } else {\n\t                var w = it.width,\n\t                    h = it.height;\n\t                if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t                    // skip bug in IE11\n\t                    document.body.appendChild(it);\n\t                    w = it.offsetWidth;\n\t                    h = it.offsetHeight;\n\t                    document.body.removeChild(it);\n\t                }\n\t                pt.sx = w;\n\t                pt.sy = h;\n\t                pt.image = it;\n\t                var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\n\t                if (!pt.scaleFunction && !pt.rotateFunction) {\n\t                    if (pt.iconScale || pt.iconScale === 1) {\n\t                        maxSize *= pt.iconScale;\n\t                    }\n\t                    pt.common = true;\n\t                }\n\t                pt.maxSize = Number(maxSize.toFixed());\n\t            }\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t        }, function () {\n\t            pt.version = ++_this._maxVersion;\n\t            pt.sx = 1;\n\t            pt.sy = 0;\n\t            pt.image = null;\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t            console.log({ url: url, func: '_getImageSize', Error: 'image not found' });\n\t        });\n\t    },\n\t\n\t    getCurrentFilters: function getCurrentFilters(propArray, zoom) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            types = gmx.tileAttributeTypes,\n\t            z = zoom || 1,\n\t            out = [];\n\t\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t            if (z > st.MaxZoom || z < st.MinZoom || st.filterFunction && !st.filterFunction(propArray, indexes, types)) {\n\t                continue;\n\t            }\n\t            out.push(i);\n\t            if (!gmx.multiFilters) {\n\t                break;\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    _chkStyleFilter: function _chkStyleFilter(item) {\n\t        var gmx = this.gmx,\n\t            zoom = gmx.currentZoom,\n\t            fnum = gmx.multiFilters ? -1 : item.currentFilter,\n\t            curr = this._styles[fnum],\n\t            needParse = !curr || curr.version !== item.styleVersion;\n\t\n\t        if (needParse || item._lastZoom !== zoom) {\n\t            item.currentFilter = -1;\n\t            item.multiFilters = [];\n\t            var filters = this.getCurrentFilters(item.properties, zoom);\n\t            for (var i = 0, len = filters.length; i < len; i++) {\n\t                var num = filters[i],\n\t                    st = this._styles[num];\n\t                item.hoverDiff = st.hoverDiff;\n\t                item.currentFilter = num;\n\t                if (needParse || fnum !== num) {\n\t                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\n\t                        parsedHover = null;\n\t\n\t                    item.parsedStyleKeys = parsed;\n\t                    if (st.HoverStyle) {\n\t                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\n\t                        item.parsedStyleHover = parsedHover;\n\t                    }\n\t                    if (gmx.multiFilters) {\n\t                        item.multiFilters.push({\n\t                            style: st.RenderStyle,\n\t                            styleHover: st.HoverStyle,\n\t                            parsedStyle: parsed,\n\t                            parsedStyleHover: parsedHover\n\t                        });\n\t                    }\n\t                }\n\t                item.styleVersion = st.version;\n\t                if (!gmx.multiFilters) {\n\t                    break;\n\t                }\n\t            }\n\t            item._lastZoom = zoom;\n\t        }\n\t        if (this._styles[item.currentFilter]) {\n\t            return true;\n\t        } else {\n\t            item.currentFilter = -1;\n\t            return false;\n\t        }\n\t    },\n\t\n\t    _parseServerStyles: function _parseServerStyles() {\n\t        var gmx = this.gmx,\n\t            props = gmx.properties,\n\t            arr = props.styles || [{ MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE }],\n\t            len = Math.max(arr.length, gmx.styles.length);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            if (!this._styles[i]) {\n\t                var gmxStyle = gmx.styles[i] || arr[i];\n\t                if (!gmxStyle.RenderStyle) {\n\t                    gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE;\n\t                }\n\t                if (gmxStyle.HoverStyle === undefined) {\n\t                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\n\t                    if (hoveredStyle.outline) {\n\t                        hoveredStyle.outline.thickness += 1;\n\t                    }\n\t                    gmxStyle.HoverStyle = hoveredStyle;\n\t                } else if (gmxStyle.HoverStyle === null) {\n\t                    delete gmxStyle.HoverStyle;\n\t                }\n\t                var pt = this._prepareItem(gmxStyle);\n\t                this._styles.push(pt);\n\t                if (this._isLabel(pt.RenderStyle)) {\n\t                    gmx.labelsLayer = true;\n\t                }\n\t            }\n\t        }\n\t        this._checkStyles();\n\t        this._serverStylesParsed = true;\n\t    },\n\t\n\t    _checkStyles: function _checkStyles() {\n\t        var minZoom = Infinity,\n\t            maxZoom = -Infinity,\n\t            balloonEnable = false,\n\t            labelsLayer = false;\n\t\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t\n\t            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\n\t            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\n\t            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\n\t                balloonEnable = true;\n\t                st.BalloonEnable = true;\n\t            }\n\t            st.hoverDiff = null;\n\t            st.common = {};\n\t            if (st.RenderStyle) {\n\t                if (!labelsLayer) {\n\t                    if (this._isLabel(st.RenderStyle)) {\n\t                        labelsLayer = true;\n\t                    }\n\t                }\n\t                if (st.RenderStyle.common) {\n\t                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\n\t                }\n\t                if (st.HoverStyle) {\n\t                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\n\t                }\n\t            }\n\t            if (st.HoverStyle && st.HoverStyle.common) {\n\t                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\n\t            }\n\t            minZoom = Math.min(minZoom, st.MinZoom);\n\t            maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t        }\n\t        if (this.minZoom !== Infinity) {\n\t            this.minZoom = minZoom;\n\t        }\n\t        if (this.maxZoom !== -Infinity) {\n\t            this.maxZoom = maxZoom;\n\t        }\n\t        this.gmx.balloonEnable = balloonEnable;\n\t        this.gmx.labelsLayer = labelsLayer;\n\t    },\n\t\n\t    _parseStyle: function _parseStyle(st, renderStyle) {\n\t        if (st) {\n\t            st.common = true;\n\t            for (var key in st) {\n\t                if (_Utils.gmxAPIutils.styleFuncKeys[key]) {\n\t                    var fkey = _Utils.gmxAPIutils.styleFuncKeys[key],\n\t                        val = st[key];\n\t                    if (typeof val === 'string') {\n\t                        st.common = false;\n\t                        if (renderStyle && renderStyle[key] === val) {\n\t                            st[fkey] = renderStyle[fkey];\n\t                        } else {\n\t                            if (!this._parserFunctions[val]) {\n\t                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\n\t                            }\n\t                            st[fkey] = this._parserFunctions[val];\n\t                        }\n\t                    } else if (typeof val === 'function') {\n\t                        st.common = false;\n\t                        st[fkey] = val;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var type = '';\n\t            if ('iconUrl' in st) {\n\t                type = 'image';\n\t                if (st.iconUrl) {\n\t                    st.maxSize = 256;\n\t                    this._deferredIcons.push(st);\n\t                }\n\t            } else if (st.fillIconUrl) {\n\t                type = 'square';\n\t                this._deferredIcons.push(st);\n\t            } else if (st.fillPattern) {\n\t                type = 'square';\n\t                st.common = StyleManager.parsePattern(st.fillPattern);\n\t                st.canvasPattern = _Utils.gmxAPIutils.getPatternIcon(null, st);\n\t            } else if (st.iconCircle) {\n\t                type = 'circle';\n\t                if (!('iconSize' in st)) {\n\t                    st.iconSize = 4;\n\t                }\n\t            } else if (st.iconPath) {\n\t                type = 'iconPath';\n\t                var iconSize = 0,\n\t                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\n\t                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function (it, i) {\n\t                    var z = arr[i] || it;\n\t                    iconSize = Math.max(iconSize, z);\n\t                    return z;\n\t                });\n\t                st.iconSize = 2 * iconSize;\n\t            } else if (st.fillRadialGradient) {\n\t                type = 'circle';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\n\t                if (size === null) {\n\t                    st.common = false;\n\t                } else {\n\t                    st.iconSize = size;\n\t                }\n\t            } else if (st.fillLinearGradient) {\n\t                type = 'square';\n\t                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\n\t            } else if (st.iconSize) {\n\t                type = 'square';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t            }\n\t            st.type = type;\n\t            if (st.common && !st.maxSize) {\n\t                st.maxSize = st.iconSize || 0;\n\t                st.maxSize += st.weight ? st.weight : 0;\n\t                if ('iconScale' in st) {\n\t                    st.maxSize *= st.iconScale;\n\t                }\n\t            }\n\t        }\n\t        return st;\n\t    },\n\t\n\t    _prepareItem: function _prepareItem(style) {\n\t        // Style Scanex->leaflet\n\t        var pt = {\n\t            MinZoom: style.MinZoom || 0,\n\t            MaxZoom: style.MaxZoom || 18,\n\t            Filter: style.Filter || null,\n\t            Balloon: style.Balloon || '',\n\t            RenderStyle: style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {},\n\t            version: ++this._maxVersion\n\t        };\n\t        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\n\t        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\n\t        if (style.HoverStyle) {\n\t            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\n\t        }\n\t\n\t        if ('Filter' in style) {\n\t            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (ph) {\n\t                pt.filterFunction = ph;\n\t            }\n\t        }\n\t        return pt;\n\t    },\n\t\n\t    _isLabel: function _isLabel(st) {\n\t        var indexes = this.gmx.tileAttributeIndexes;\n\t        return st && (st.labelTemplate || st.labelField && st.labelField in indexes);\n\t    },\n\t\n\t    _itemStyleParser: function _itemStyleParser(item, pt) {\n\t        pt = pt || {};\n\t        var out = {},\n\t            arr,\n\t            i,\n\t            len,\n\t            indexes = this.gmx.tileAttributeIndexes,\n\t            prop = item.properties || {},\n\t            itemType = item.type,\n\t            type = pt.type,\n\t            color = 'color' in pt ? pt.color : 255,\n\t            opacity = 'opacity' in pt ? pt.opacity : 1;\n\t\n\t        out.sx = pt.sx;\n\t        out.sy = pt.sy;\n\t        if (pt.maxSize) {\n\t            out.maxSize = pt.maxSize;\n\t        }\n\t        if (pt.iconAngle) {\n\t            var rotateRes = pt.iconAngle || 0;\n\t            if (rotateRes && typeof rotateRes === 'string') {\n\t                rotateRes = pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0;\n\t            }\n\t            out.rotate = rotateRes || 0;\n\t        }\n\t        if ('iconColor' in pt) {\n\t            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\n\t        }\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if (type === 'image') {\n\t            out.type = type;\n\t            if (pt.iconUrl) {\n\t                out.iconUrl = pt.iconUrl;\n\t            }\n\t            if (pt.image) {\n\t                out.image = pt.image;\n\t            }\n\t        } else if (pt.fillRadialGradient) {\n\t            var rgr = pt.fillRadialGradient,\n\t                r1 = rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1,\n\t                r2 = rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2,\n\t                x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t                y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t                x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t                y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2;\n\t            if (rgr.r2max) {\n\t                r2 = Math.min(r2, rgr.r2max);\n\t            }\n\t            var colorStop = [];\n\t            len = rgr.addColorStop.length;\n\t            if (!rgr.addColorStopFunctions) {\n\t                rgr.addColorStopFunctions = new Array(len);\n\t            }\n\t            for (i = 0; i < len; i++) {\n\t                arr = rgr.addColorStop[i];\n\t                var arrFunc = rgr.addColorStopFunctions[i] || [],\n\t                    p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0],\n\t                    p3 = arr[3];\n\t                if (arr.length < 4) {\n\t                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\n\t                    p3 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\n\t                }\n\t                colorStop.push([p0, p3]);\n\t            }\n\t            out.maxSize = out.sx = out.sy = out.iconSize = r2;\n\t            out.fillRadialGradient = {\n\t                x1: x1, y1: y1, r1: r1, x2: x2, y2: y2, r2: r2,\n\t                addColorStop: colorStop\n\t            };\n\t            out._radialGradientParsed = {\n\t                create: [x1, y1, r1, x2, y2, r2],\n\t                colorStop: colorStop\n\t            };\n\t        } else if (pt.fillLinearGradient) {\n\t            out.fillLinearGradient = pt.fillLinearGradient;\n\t        } else {\n\t            if (pt.fillPattern) {\n\t                out.canvasPattern = pt.canvasPattern ? pt.canvasPattern : _Utils.gmxAPIutils.getPatternIcon(item, pt, indexes);\n\t            }\n\t\n\t            if (type === 'iconPath') {\n\t                out.type = type;\n\t                out.iconPath = pt.iconPath;\n\t            }\n\t\n\t            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\n\t                type = 'polygon';\n\t            }\n\t            if (pt.iconSize) {\n\t                var iconSize = 'sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize;\n\t                out.sx = out.sy = iconSize;\n\t                // iconSize += pt.weight ? pt.weight : 0;\n\t                out.iconSize = iconSize;\n\t                if ('iconScale' in pt) {\n\t                    out.iconSize *= pt.iconScale;\n\t                }\n\t                out.maxSize = iconSize;\n\t            }\n\t            out.stroke = true;\n\t            if ('colorFunction' in pt || 'opacityFunction' in pt) {\n\t                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\n\t                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\n\t            }\n\t            out.strokeStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            out.lineWidth = 'weight' in pt ? pt.weight : 1;\n\t        }\n\t\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if ('iconAnchor' in pt) {\n\t            out.iconAnchor = pt.iconAnchor;\n\t        }\n\t        if ('iconCenter' in pt) {\n\t            out.iconCenter = pt.iconCenter;\n\t        }\n\t\n\t        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\n\t            out.type = type;\n\t            var fop = pt.fillOpacity,\n\t                fc = pt.fillColor,\n\t                fcDec = typeof fc === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\n\t\n\t            if ('fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, 1);\n\t            }\n\t            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\n\t                color = 'fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255;\n\t                opacity = 'fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1;\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, fop);\n\t            }\n\t        }\n\t\n\t        if ('dashArray' in pt) {\n\t            out.dashArray = pt.dashArray;\n\t        }\n\t        if ('dashOffset' in pt) {\n\t            out.dashOffset = pt.dashOffset;\n\t        }\n\t\n\t        if (this.gmx.labelsLayer) {\n\t            arr = _Utils.gmxAPIutils.styleKeys.label.client;\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i];\n\t                if (it in pt) {\n\t                    if (it === 'labelField') {\n\t                        if (!indexes[pt[it]]) {\n\t                            continue;\n\t                        }\n\t                    } else if (it === 'labelTemplate') {\n\t                        var properties = _Utils.gmxAPIutils.getPropertiesHash(prop, indexes);\n\t                        out.labelText = _Utils.gmxAPIutils.parseTemplate(pt[it], properties);\n\t                    }\n\t                    out[it] = pt[it];\n\t                }\n\t            }\n\t            if ('labelAnchor' in pt) {\n\t                out.labelAnchor = pt.labelAnchor;\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t};\n\tStyleManager.MAX_STYLE_SIZE = 256;\n\t//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\n\tStyleManager.DEFAULT_STYLE = { outline: { color: 255, thickness: 1 }, marker: { size: 8 } };\n\tStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\n\tStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10]; // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\n\t\n\tStyleManager.parsePattern = function (pattern) {\n\t    var common = true,\n\t        parsers = L.gmx.Parsers;\n\t    if ('step' in pattern && typeof pattern.step === 'string') {\n\t        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\n\t        common = false;\n\t    }\n\t    if ('width' in pattern && typeof pattern.width === 'string') {\n\t        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\n\t        common = false;\n\t    }\n\t    if ('colors' in pattern) {\n\t        var arr = [];\n\t        for (var i = 0, len = pattern.colors.length; i < len; i++) {\n\t            var rt = pattern.colors[i];\n\t            if (typeof rt === 'string') {\n\t                arr.push(parsers.parseExpression(rt));\n\t                common = false;\n\t            } else {\n\t                arr.push(null);\n\t            }\n\t        }\n\t        pattern.patternColorsFunction = arr;\n\t    }\n\t    return common;\n\t};\n\t\n\tStyleManager.getStyleKeys = function (style) {\n\t    var out = {};\n\t    for (var key in _Utils.gmxAPIutils.styleKeys) {\n\t        var keys = _Utils.gmxAPIutils.styleKeys[key];\n\t        for (var i = 0, len = keys.client.length; i < len; i++) {\n\t            var key1 = keys.client[i];\n\t            if (key1 in style) {\n\t                if (style[key1] !== undefined) {\n\t                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\n\t                }\n\t                if (key1 === 'fillPattern') {\n\t                    delete out[key1].patternColorsFunction;\n\t                } else if (key1 === 'fillLinearGradient') {\n\t                    delete out[key1].addColorStopFunctions;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if ('iconAnchor' in style) {\n\t        out.iconAnchor = style.iconAnchor;\n\t    }\n\t    if ('labelAnchor' in style) {\n\t        out.labelAnchor = style.labelAnchor;\n\t    }\n\t    return out;\n\t};\n\t\n\tStyleManager.checkDiff = function (st, st1) {\n\t    for (var key in st) {\n\t        if (st[key] !== st1[key]) {\n\t            return key;\n\t        }\n\t    }\n\t    return null;\n\t};\n\t\n\tStyleManager.parseRadialGradient = function (rg) {\n\t    //\tx1,y1,r1 — координаты центра и радиус первой окружности;\n\t    //\tx2,y2,r2 — координаты центра и радиус второй окружности.\n\t    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\n\t    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\n\t    //\t\tcolor — код цвета или формула.\n\t    //\t\topacity — прозрачность\n\t    //\t\tcanvasStyleColor — результрующий цвет в формате canvas\n\t    var common = true,\n\t        parsers = L.gmx.Parsers,\n\t        i = 0,\n\t        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (!rg[it]) {\n\t            rg[it] = 0;\n\t        }\n\t        if (typeof rg[it] === 'string') {\n\t            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\n\t            common = false;\n\t        }\n\t    }\n\t\n\t    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\n\t    rg.addColorStopFunctions = [];\n\t    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\n\t        arr = rg.addColorStop[i];\n\t        var resFunc = [typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null];\n\t        rg.addColorStopFunctions.push(resFunc);\n\t        if (resFunc[1] === null && resFunc[2] === null) {\n\t            arr[3] = _Utils.gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\n\t        } else {\n\t            common = false;\n\t        }\n\t    }\n\t    if ('r2Function' in rg) {\n\t        common = false;\n\t    }\n\t    return common ? Math.max(rg.r1, rg.r2) : null;\n\t};\n\t\n\tStyleManager.parseLinearGradient = function (lg) {\n\t    var common = true;\n\t    //\tx1,y1 — координаты начальной точки\n\t    //\tx2,y2 — координаты конечной точки\n\t    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\n\t    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\n\t    //\t\tcolor — код цвета или формула.\n\t    //\t\topacity — прозрачность\n\t    var i = 0,\n\t        parsers = L.gmx.Parsers,\n\t        arr = ['x1', 'y1', 'x2', 'y2'],\n\t        def = [0, 0, 0, 256],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (it in lg) {\n\t            if (typeof lg[it] === 'string') {\n\t                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\n\t                common = false;\n\t            }\n\t        } else {\n\t            lg[it] = def[i];\n\t        }\n\t    }\n\t\n\t    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\n\t    lg.addColorStopFunctions = [];\n\t    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\n\t        arr = lg.addColorStop[i];\n\t        lg.addColorStopFunctions.push([typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null]);\n\t    }\n\t    return common;\n\t};\n\texports.StyleManager = StyleManager;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ScreenVectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t// Single tile on screen with vector data\n\tfunction ScreenVectorTile(layer, tilePoint, zoom) {\n\t    this.layer = layer;\n\t    this.tilePoint = tilePoint;\n\t    this.zoom = zoom;\n\t    this.gmx = layer._gmx;\n\t    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\n\t    var utils = _Utils.gmxAPIutils;\n\t    this.worldWidthMerc = utils.worldWidthMerc;\n\t    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\n\t    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\n\t    this.tpx = 256 * gmxTilePoint.x;\n\t    this.tpy = 256 * (1 + gmxTilePoint.y);\n\t    this.gmxTilePoint = gmxTilePoint;\n\t\n\t    this.showRaster = zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx || zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx;\n\t    this.rasters = {}; //combined and processed canvases for each vector item in tile\n\t    this.rasterRequests = {}; // all cached raster requests\n\t    this.itemsView = []; // items on screen tile + todo: without not visible\n\t    this._uniqueID = 0; // draw attempt id\n\t    this.gmx.badTiles = this.gmx.badTiles || {};\n\t}\n\t\n\tScreenVectorTile.prototype = {\n\t\n\t    //return promise, which resolves with object {gtp, image}\n\t    _loadTileRecursive: function _loadTileRecursive(gtp, urlFunction) {\n\t        var gmx = this.gmx,\n\t            _this = this,\n\t            requestPromise = null,\n\t            currentUrl,\n\t            def = new L.gmx.Deferred(function () {\n\t            if (requestPromise) {\n\t                //don't store cancelled requests in request cache\n\t                delete _this.rasterRequests[currentUrl];\n\t                requestPromise.cancel();\n\t            }\n\t        });\n\t\n\t        var tryLoad = function tryLoad(gtp, crossOrigin) {\n\t            var rUrl = urlFunction(gtp);\n\t\n\t            var tryHigherLevelTile = function tryHigherLevelTile() {\n\t                if (gtp.z > 1) {\n\t                    tryLoad({\n\t                        x: Math.floor(gtp.x / 2),\n\t                        y: Math.floor(gtp.y / 2),\n\t                        z: gtp.z - 1\n\t                    }, ''); // 'anonymous' 'use-credentials'\n\t                } else {\n\t                    def.reject();\n\t                }\n\t            };\n\t\n\t            if (gmx.badTiles[rUrl] || gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z) {\n\t                tryHigherLevelTile();\n\t                return;\n\t            }\n\t            var request = _this.rasterRequests[rUrl];\n\t            if (!request) {\n\t                if (gmx.rasterProcessingHook) {\n\t                    crossOrigin = 'anonymous';\n\t                }\n\t                request = L.gmx.imageLoader.push(rUrl, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    zoom: _this.zoom,\n\t                    cache: true,\n\t                    crossOrigin: crossOrigin || ''\n\t                });\n\t                _this.rasterRequests[rUrl] = request;\n\t            } else {\n\t                request.options.tileRastersId = _this._uniqueID;\n\t            }\n\t            currentUrl = rUrl;\n\t            requestPromise = request.def;\n\t\n\t            requestPromise.then(function (imageObj) {\n\t                def.resolve({ gtp: gtp, image: imageObj });\n\t            }, function () {\n\t                gmx.badTiles[rUrl] = true;\n\t                tryHigherLevelTile();\n\t            });\n\t        };\n\t\n\t        tryLoad(gtp);\n\t        return def;\n\t    },\n\t\n\t    _rasterHook: function _rasterHook(attr) {\n\t        var source = attr.sourceTilePoint || attr.destinationTilePoint,\n\t            info = {\n\t            geoItem: attr.geoItem,\n\t            destination: {\n\t                z: attr.destinationTilePoint.z,\n\t                x: attr.destinationTilePoint.x,\n\t                y: attr.destinationTilePoint.y\n\t            },\n\t            source: {\n\t                z: source.z,\n\t                x: source.x,\n\t                y: source.y\n\t            }\n\t        };\n\t        if (attr.url) {\n\t            info.quicklook = attr.url;\n\t        }\n\t        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(attr.res, attr.image, attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256, attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256, info);\n\t    },\n\t\n\t    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\n\t    _defaultRasterHook: function _defaultRasterHook(res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\n\t        var ptx = res.getContext('2d');\n\t        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n\t    },\n\t\n\t    // get pixels parameters for shifted object\n\t    _getShiftPixels: function _getShiftPixels(it) {\n\t        var w = it.dx + (it.dx < 0 ? 256 : 0),\n\t            h = it.dy + (it.dy < 0 ? 256 : 0),\n\t            sx = 0,\n\t            sw = 256 - w,\n\t            dx = w,\n\t            dw = sw;\n\t        if (it.tx > it.x) {\n\t            sx = sw;sw = w;dx = 0;dw = sw;\n\t        }\n\t        if (sx === 256 || sw < 1) {\n\t            return null;\n\t        }\n\t\n\t        var sy = h,\n\t            sh = 256 - h,\n\t            dy = 0,\n\t            dh = sh;\n\t        if (it.ty > it.y) {\n\t            sy = 0;dy = sh;sh = h;dh = sh;\n\t        }\n\t        if (sy === 256 || sh < 1) {\n\t            return null;\n\t        }\n\t\n\t        return {\n\t            sx: sx, sy: sy, sw: sw, sh: sh,\n\t            dx: dx, dy: dy, dw: dw, dh: dh\n\t        };\n\t    },\n\t\n\t    // get tiles parameters for shifted object\n\t    _getShiftTilesArray: function _getShiftTilesArray(bounds, shiftX, shiftY) {\n\t        var mInPixel = this.gmx.mInPixel,\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            px = shiftX * mInPixel,\n\t            py = shiftY * mInPixel,\n\t            deltaX = Math.floor(0.5 + px % 256),\n\t\n\t        // shift on tile in pixel\n\t        deltaY = Math.floor(0.5 + py % 256),\n\t            tileSize = 256 / mInPixel,\n\t            tminX = gmxTilePoint.x - shiftX / tileSize,\n\t\n\t        // by screen tile\n\t        tminY = gmxTilePoint.y - shiftY / tileSize,\n\t            rminX = Math.floor(tminX),\n\t            rmaxX = rminX + (tminX === rminX ? 0 : 1),\n\t            rminY = Math.floor(tminY),\n\t            rmaxY = rminY + (tminY === rminY ? 0 : 1),\n\t            minX = Math.floor((bounds.min.x - shiftX) / tileSize),\n\t\n\t        // by geometry bounds\n\t        maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\n\t            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\n\t            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\n\t\n\t        if (rminX < minX) {\n\t            rminX = minX;\n\t        }\n\t        if (rmaxX > maxX) {\n\t            rmaxX = maxX;\n\t        }\n\t        if (rminY < minY) {\n\t            rminY = minY;\n\t        }\n\t        if (rmaxY > maxY) {\n\t            rmaxY = maxY;\n\t        }\n\t\n\t        var arr = [];\n\t        for (var j = rminY; j <= rmaxY; j++) {\n\t            for (var i = rminX; i <= rmaxX; i++) {\n\t                arr.push({\n\t                    z: gmxTilePoint.z,\n\t                    x: i,\n\t                    y: j,\n\t                    dx: deltaX,\n\t                    dy: deltaY,\n\t                    tx: tminX,\n\t                    ty: tminY\n\t                });\n\t            }\n\t        }\n\t        return arr;\n\t    },\n\t\n\t    // Loads missing rasters for single item and combines them in canvas.\n\t    // Stores resulting canvas in this.rasters\n\t    _getItemRasters: function _getItemRasters(geo) {\n\t        var properties = geo.properties,\n\t            idr = properties[0],\n\t            _this = this,\n\t            gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            rasters = this.rasters,\n\t            mainRasterLoader = null,\n\t            recursiveLoaders,\n\t            shiftX = Number(gmx.shiftXfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\n\t            shiftY = Number(gmx.shiftYfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\n\t            isShift = shiftX || shiftY,\n\t            urlBG = _Utils.gmxAPIutils.getPropItem('urlBG', properties, indexes),\n\t            url = '',\n\t            itemImageProcessingHook = null,\n\t            isTiles = false,\n\t            item = gmx.dataManager.getItem(idr),\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            resCanvas = null,\n\t            imageItem = null;\n\t\n\t        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || _Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\n\t            isTiles = true; // Raster Layer\n\t        } else if (gmx.quicklookBGfunc) {\n\t            url = gmx.quicklookBGfunc(item); // Quicklook\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        } else if (urlBG) {\n\t            url = urlBG; // Image urlBG from properties\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        }\n\t        if (isTiles) {\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                recursiveLoaders.forEach(function (it) {\n\t                    it.cancel();\n\t                });\n\t                recursiveLoaders = null;\n\t            });\n\t        } else {\n\t            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey; //  for browser cache from another tabs\n\t            var request = this.rasterRequests[url];\n\t            if (!request) {\n\t                request = L.gmx.imageLoader.push(url, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    crossOrigin: gmx.crossOrigin || 'anonymous'\n\t                });\n\t                this.rasterRequests[url] = request;\n\t            } else {\n\t                request.options.tileRastersId = this._uniqueID;\n\t            }\n\t\n\t            // in fact, we want to return request.def, but need to do additional action during cancellation.\n\t            // so, we consctruct new promise and add pipe it with request.def\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                //don't cache cancelled requests\n\t                delete _this.rasterRequests[url];\n\t                request.def.cancel();\n\t            });\n\t            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\n\t        }\n\t        var itemRasterPromise = new L.gmx.Deferred(function () {\n\t            if (mainRasterLoader) {\n\t                mainRasterLoader.cancel();\n\t                mainRasterLoader = null;\n\t            }\n\t        });\n\t\n\t        if (isTiles) {\n\t            var dataOption = geo.dataOption || {},\n\t                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\n\t                cnt = tileToLoadPoints.length,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (cnt < 1) {\n\t                    mainRasterLoader.resolve();\n\t                }\n\t            },\n\t                skipRasterFunc = function skipRasterFunc() {\n\t                cnt--;\n\t                chkReadyRasters();\n\t            },\n\t                urlFunction = function urlFunction(gtp) {\n\t                return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\n\t            },\n\t                onLoadFunction = function onLoadFunction(gtp, p, img) {\n\t                item.skipRasters = false;\n\t                var isImage = true;\n\t\n\t                if (itemImageProcessingHook) {\n\t                    img = itemImageProcessingHook(img, {\n\t                        gmx: gmx,\n\t                        geoItem: geo,\n\t                        item: item,\n\t                        gmxTilePoint: gtp\n\t                    });\n\t                    isImage = false;\n\t                }\n\t\n\t                var info = {\n\t                    geoItem: geo,\n\t                    image: img,\n\t                    destinationTilePoint: gmxTilePoint,\n\t                    sourceTilePoint: gtp,\n\t                    sx: 0, sy: 0, sw: 256, sh: 256,\n\t                    dx: 0, dy: 0, dw: 256, dh: 256\n\t                };\n\t\n\t                if (isShift) {\n\t                    var pos = _this._getShiftPixels(p);\n\t                    if (pos === null) {\n\t                        skipRasterFunc();\n\t                        return;\n\t                    }\n\t                    L.extend(info, pos);\n\t                    isImage = false;\n\t                }\n\t\n\t                if (gtp.z !== gmxTilePoint.z) {\n\t                    var posInfo = _Utils.gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\n\t                    if (posInfo.size < 1 / 256) {\n\t                        // меньше 1px\n\t                        chkReadyRasters();\n\t                        return;\n\t                    }\n\t                    isImage = false;\n\t                    info.sx = Math.floor(posInfo.x);\n\t                    info.sy = Math.floor(posInfo.y);\n\t                    info.sw = info.sh = posInfo.size;\n\t                    if (isShift) {\n\t                        var sw = Math.floor(info.dw / posInfo.zDelta);\n\t                        info.sx = (info.dx === 0 ? info.sw : 256) - sw;\n\t                        info.sw = sw;\n\t\n\t                        var sh = Math.floor(info.dh / posInfo.zDelta);\n\t                        info.sy = (info.dy === 0 ? info.sh : 256) - sh;\n\t                        info.sh = sh;\n\t                    }\n\t                }\n\t                if (isImage && !gmx.rasterProcessingHook) {\n\t                    cnt--;\n\t                    resCanvas = img;\n\t                    chkReadyRasters();\n\t                } else {\n\t                    if (!resCanvas) {\n\t                        resCanvas = document.createElement('canvas');\n\t                        resCanvas.width = resCanvas.height = 256;\n\t                    }\n\t                    info.res = resCanvas;\n\t                    var hookResult = _this._rasterHook(info),\n\t                        then = function then() {\n\t                        cnt--;\n\t                        p.resImage = resCanvas;\n\t                        chkReadyRasters();\n\t                    };\n\t\n\t                    if (hookResult) {\n\t                        if (hookResult instanceof L.gmx.Deferred) {\n\t                            hookResult.then(then);\n\t                        }\n\t                    } else if (hookResult === null) {\n\t                        item.skipRasters = true;\n\t                        skipRasterFunc();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                }\n\t            };\n\t            recursiveLoaders = tileToLoadPoints.map(function (it) {\n\t                var loader = _this._loadTileRecursive(it, urlFunction);\n\t                loader.then(function (loadResult) {\n\t                    onLoadFunction(loadResult.gtp, it, loadResult.image);\n\t                }, skipRasterFunc);\n\t                return loader;\n\t            });\n\t\n\t            mainRasterLoader.then(function () {\n\t                rasters[idr] = resCanvas;\n\t                itemRasterPromise.resolve();\n\t            });\n\t        } else {\n\t            // for quicklook\n\t            item.skipRasters = false;\n\t            var imageLoaded = function imageLoaded(img) {\n\t                var imgAttr = {\n\t                    gmx: gmx,\n\t                    geoItem: geo,\n\t                    item: item,\n\t                    gmxTilePoint: gmxTilePoint\n\t                };\n\t                if (!resCanvas) {\n\t                    resCanvas = document.createElement('canvas');\n\t                    resCanvas.width = resCanvas.height = 256;\n\t                }\n\t                var prepareItem = function prepareItem(imageElement) {\n\t                    var promise = _this._rasterHook({\n\t                        geoItem: geo,\n\t                        res: resCanvas,\n\t                        image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\n\t                        destinationTilePoint: gmxTilePoint,\n\t                        url: url\n\t                    }),\n\t                        then = function then() {\n\t                        rasters[idr] = resCanvas;\n\t                        itemRasterPromise.resolve();\n\t                    };\n\t                    if (promise) {\n\t                        if (promise instanceof L.gmx.Deferred) {\n\t                            promise.then(then);\n\t                        }\n\t                    } else if (promise === null) {\n\t                        item.skipRasters = true;\n\t                        itemRasterPromise.resolve();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                };\n\t                prepareItem(img);\n\t                delete _this.rasterRequests[url];\n\t            };\n\t            if (imageItem) {\n\t                imageLoaded(imageItem);\n\t            } else {\n\t                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\n\t            }\n\t        }\n\t        itemRasterPromise.always(function () {\n\t            mainRasterLoader = null;\n\t            if (recursiveLoaders) {\n\t                recursiveLoaders = null;\n\t            }\n\t        });\n\t        return itemRasterPromise;\n\t    },\n\t\n\t    _getVisibleItems: function _getVisibleItems(geoItems) {\n\t        if (geoItems.length < 2) {\n\t            this.itemsView = geoItems;\n\t            return geoItems;\n\t        }\n\t        if (!_Utils.gmxAPIutils._tileCanvas) {\n\t            _Utils.gmxAPIutils._tileCanvas = document.createElement('canvas');\n\t            _Utils.gmxAPIutils._tileCanvas.width = _Utils.gmxAPIutils._tileCanvas.height = 256;\n\t        }\n\t        var i,\n\t            len,\n\t            gmx = this.gmx,\n\t            dm = gmx.dataManager,\n\t            canvas = _Utils.gmxAPIutils._tileCanvas,\n\t            ctx = canvas.getContext('2d'),\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.imageSmoothingEnabled = false;\n\t        for (i = 0, len = geoItems.length; i < len; i++) {\n\t            ctx.fillStyle = _Utils.gmxAPIutils.dec2rgba(i + 1, 1);\n\t            var geoItem = geoItems[i];\n\t            L.gmxUtil.drawGeoItem(geoItem, dm.getItem(geoItem.properties[0]), dattr, { fillStyle: ctx.fillStyle });\n\t        }\n\t        var items = {},\n\t            data = ctx.getImageData(0, 0, 256, 256).data;\n\t\n\t        for (i = 0, len = data.length; i < len; i += 4) {\n\t            if (data[i + 3] === 255) {\n\t                var color = data[i + 2];\n\t                if (data[i + 1]) {\n\t                    color += data[i + 1] << 8;\n\t                }\n\t                if (data[i]) {\n\t                    color += data[i] << 16;\n\t                }\n\t                if (color) {\n\t                    items[color] = true;\n\t                }\n\t            }\n\t        }\n\t        var out = [];\n\t        for (var num in items) {\n\t            var it = geoItems[Number(num) - 1];\n\t            if (it) {\n\t                out.push(it);\n\t            }\n\t        }\n\t        this.itemsView = out;\n\t        return out;\n\t    },\n\t\n\t    _getNeedRasterItems: function _getNeedRasterItems(geoItems) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            tbounds = this.tbounds,\n\t            out = [];\n\t        for (var i = 0, len = geoItems.length; i < len; i++) {\n\t            var geo = geoItems[i],\n\t                properties = geo.properties,\n\t                idr = properties[0],\n\t                dataOption = geo.dataOption || {},\n\t                skipRasters = false;\n\t\n\t            if (gmx.quicklookBGfunc && !_Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\n\t                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) {\n\t                    continue;\n\t                }\n\t                var platform = _Utils.gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\n\t                if ((!platform || platform === 'imageMercator') && !_Utils.gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)) {\n\t                    continue;\n\t                }\n\t            }\n\t\n\t            if (gmx.styleHook) {\n\t                geo.styleExtend = gmx.styleHook(gmx.dataManager.getItem(idr), gmx.lastHover && idr === gmx.lastHover.id);\n\t                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\n\t            }\n\t            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                out.push(geo);\n\t            }\n\t        }\n\t        return this._getVisibleItems(out);\n\t    },\n\t\n\t    _getTileRasters: function _getTileRasters(geoItems) {\n\t        //load all missing rasters for items we are going to render\n\t        var itemPromises = [],\n\t            def = new L.gmx.Deferred(function () {\n\t            itemPromises.forEach(function (promise) {\n\t                promise.cancel();\n\t            });\n\t            itemPromises = null;\n\t        }),\n\t            itemRasters = this._getNeedRasterItems(geoItems),\n\t            needLoadRasters = itemRasters.length;\n\t\n\t        if (needLoadRasters) {\n\t            var _this = this,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (needLoadRasters < 1) {\n\t                    def.resolve();\n\t                }\n\t            };\n\t            itemRasters.forEach(function (geo) {\n\t                var itemRasterPromise = _this._getItemRasters(geo);\n\t                itemRasterPromise.then(function () {\n\t                    needLoadRasters--;\n\t                    chkReadyRasters();\n\t                });\n\t                itemPromises.push(itemRasterPromise);\n\t            });\n\t        } else {\n\t            def.resolve();\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _chkItems: function _chkItems(data) {\n\t        var layer = this.layer;\n\t        if (!layer._map) {\n\t            return null;\n\t        }\n\t        var items = data && data.added && data.added.length ? data.added : null;\n\t\n\t        if (!items) {\n\t            var tLink = layer._tiles[this.zKey];\n\t            if (tLink && tLink.el) {\n\t                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\n\t            }\n\t            return null;\n\t        }\n\t        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\n\t    },\n\t\n\t    _cancelRastersPromise: function _cancelRastersPromise() {\n\t        if (this.rastersPromise) {\n\t            this.rastersPromise.cancel();\n\t            this.rastersPromise = null;\n\t        }\n\t    },\n\t\n\t    drawTile: function drawTile(data) {\n\t        var drawPromise = this.currentDrawPromise,\n\t            _this = this;\n\t\n\t        this._uniqueID++; // count draw attempt\n\t\n\t        if (drawPromise) {\n\t            this._cancelRastersPromise();\n\t            if (this._preRenderPromise) {\n\t                this._preRenderPromise.cancel(); // cancel preRenderHooks chain if exists\n\t            }\n\t            if (this._renderPromise) {\n\t                this._renderPromise.cancel(); // cancel renderHooks chain if exists\n\t            }\n\t            drawPromise.reject();\n\t        }\n\t        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\n\t        drawPromise.always(function () {\n\t            _this._drawDone();\n\t            _this.currentDrawPromise = null;\n\t            _this.rastersPromise = null;\n\t            _this._preRenderPromise = null;\n\t            _this._renderPromise = null;\n\t        });\n\t\n\t        this.currentDrawPromise = drawPromise;\n\t\n\t        var geoItems = this._chkItems(data);\n\t        if (!geoItems) {\n\t            drawPromise.resolve();\n\t            return drawPromise;\n\t        }\n\t        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\n\t            tile = tileLink.el,\n\t            ctx = tile.getContext('2d'),\n\t            gmx = this.gmx,\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            rasters: this.rasters,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        tile.zKey = tileLink.el._zKey = this.zKey;\n\t\n\t        var doDraw = function doDraw() {\n\t            ctx.clearRect(0, 0, 256, 256);\n\t            var hookInfo = {\n\t                tpx: _this.tpx,\n\t                tpy: _this.tpy,\n\t                x: _this.tilePoint.x,\n\t                y: _this.tilePoint.y,\n\t                z: _this.zoom\n\t            },\n\t                bgImage = null;\n\t\n\t            _this._preRenderPromise = new L.gmx.Deferred();\n\t            _this._preRenderPromise.resolve(bgImage);\n\t\n\t            gmx.preRenderHooks.forEach(function (f) {\n\t                _this._preRenderPromise = _this._preRenderPromise.then(function (hookBgImage) {\n\t\n\t                    //in-place modifications are possible\n\t                    bgImage = hookBgImage || bgImage;\n\t\n\t                    if (!bgImage) {\n\t                        bgImage = document.createElement('canvas');\n\t                        bgImage.width = bgImage.height = 256;\n\t                    }\n\t                    return f(bgImage, hookInfo);\n\t                });\n\t            });\n\t            _this._preRenderPromise.then(function (hookBgImage) {\n\t                bgImage = hookBgImage || bgImage;\n\t                if (bgImage) {\n\t                    dattr.bgImage = bgImage;\n\t                }\n\t                //ctx.save();\n\t                for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                    var geoItem = geoItems[i],\n\t                        id = geoItem.id,\n\t                        item = gmx.dataManager.getItem(id);\n\t                    if (item) {\n\t                        // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\n\t                        var style = gmx.styleManager.getObjStyle(item),\n\t                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\n\t\n\t                        if (gmx.multiFilters) {\n\t                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                                var it = item.multiFilters[j];\n\t                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\n\t                            }\n\t                        } else {\n\t                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\n\t                        }\n\t                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\n\t                            gmx._needPopups[id] = true;\n\t                        }\n\t                    }\n\t                }\n\t                //ctx.restore();\n\t                _this.rasters = {}; // clear rasters\n\t                if (_this.layer._map && !tile.parentNode) {\n\t                    _this.layer.appendTileToContainer(tile);\n\t                }\n\t                //async chain\n\t                _this._renderPromise = new L.gmx.Deferred();\n\t                _this._renderPromise.resolve(tile);\n\t                gmx.renderHooks.forEach(function (f) {\n\t                    _this._renderPromise = _this._renderPromise.then(function (hookTile) {\n\t                        tile = hookTile || tile;\n\t                        return f(tile, hookInfo);\n\t                    });\n\t                });\n\t                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\n\t            }, drawPromise.reject);\n\t        };\n\t\n\t        if (this.showRaster) {\n\t            this.rastersPromise = this._getTileRasters(geoItems);\n\t            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\n\t        } else {\n\t            doDraw();\n\t        }\n\t\n\t        return drawPromise;\n\t    },\n\t\n\t    destructor: function destructor() {\n\t        this._cancelRastersPromise();\n\t        this._clearCache();\n\t\n\t        this.currentDrawPromise && this.currentDrawPromise.reject();\n\t    },\n\t\n\t    _drawDone: function _drawDone() {\n\t        for (var url in this.rasterRequests) {\n\t            var req = this.rasterRequests[url];\n\t            if (this._uniqueID !== req.options.tileRastersId) {\n\t                req.remove();\n\t                delete this.rasterRequests[url];\n\t            }\n\t        }\n\t        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\n\t    },\n\t\n\t    _clearCache: function _clearCache() {\n\t        for (var url in this.rasterRequests) {\n\t            this.rasterRequests[url].remove();\n\t        }\n\t        this.rasterRequests = {};\n\t    }\n\t};\n\texports.ScreenVectorTile = ScreenVectorTile;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * ObjectsReorder  - Reorder objects in Gemixer layer\r\n\t */\n\t(function () {\n\t\n\t    var MAX = 1000000,\n\t        ObjectsReorder = function ObjectsReorder(layer) {\n\t        this.all = {};\n\t        this.userSetSortFunc = false; // user sort func flag\n\t        this.sortFunc = null;\n\t        this.count = 0;\n\t        this.disabled = false;\n\t        this.layer = layer;\n\t        layer.on('add', this.onAdd, this);\n\t        layer.on('remove', this.onRemove, this);\n\t    };\n\t    ObjectsReorder.prototype = {\n\t        addToReorder: function addToReorder(id, bottomFlag) {\n\t            ++this.count;\n\t            this.all[id] = bottomFlag ? -this.count : this.count;\n\t        },\n\t        clickFunc: function clickFunc(ev) {\n\t            if (!this.disabled) {\n\t                var id = ev.gmx.id;\n\t                this.addToReorder(id, ev.originalEvent.ctrlKey);\n\t                this.layer.redrawItem(id);\n\t            }\n\t        },\n\t        sortItems: function sortItems(a, b) {\n\t            // layer context\n\t            var reorder = this._objectsReorder;\n\t            if (reorder.count > 0) {\n\t                var ap = reorder.all[a.id],\n\t                    bp = reorder.all[b.id];\n\t\n\t                if (ap || bp) {\n\t                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\n\t                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\n\t                    return ap - bp;\n\t                }\n\t            }\n\t            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\n\t        },\n\t        resetSortFunc: function resetSortFunc() {\n\t            var layer = this.layer,\n\t                gmx = layer._gmx,\n\t                zIndexField = gmx.zIndexField;\n\t            gmx.sortItems = this.sortItems;\n\t            this.sortFunc = zIndexField && !this.userSetSortFunc ? function (a, b) {\n\t                // layer context\n\t                var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\n\t                return res ? res : a.id - b.id;\n\t            } : function (a, b) {\n\t                return a.id - b.id;\n\t            };\n\t        },\n\t        initialize: function initialize() {\n\t            var gmx = this.layer._gmx;\n\t            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\n\t                this.resetSortFunc();\n\t            }\n\t        },\n\t        onAdd: function onAdd() {\n\t            this.initialize();\n\t            this.layer.on('click', this.clickFunc, this);\n\t        },\n\t        onRemove: function onRemove() {\n\t            this.layer.off('click', this.clickFunc, this);\n\t        }\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t        _objectsReorder: null,\n\t\n\t        _objectsReorderInit: function _objectsReorderInit() {\n\t            if (!this._objectsReorder) {\n\t                this._objectsReorder = new ObjectsReorder(this);\n\t            }\n\t        },\n\t\n\t        getReorderArrays: function getReorderArrays() {\n\t            var out = { top: [], bottom: [] };\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder,\n\t                    arr = Object.keys(reorder.all).sort(function (a, b) {\n\t                    return reorder.all[a] - reorder.all[b];\n\t                });\n\t\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var id = arr[i];\n\t                    if (reorder.all[id] > 0) {\n\t                        out.top.push(id);\n\t                    } else {\n\t                        out.bottom.push(id);\n\t                    }\n\t                }\n\t            }\n\t            return out;\n\t        },\n\t\n\t        bringToTopItem: function bringToTopItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        bringToBottomItem: function bringToBottomItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id, true);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        clearReorderArrays: function clearReorderArrays() {\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder;\n\t                reorder.all = {};\n\t                reorder.count = 0;\n\t                this.repaint();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        setReorderArrays: function setReorderArrays(top, bottom) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.all = {};\n\t            reorder.count = 0;\n\t            bottom.forEach(function (id) {\n\t                reorder.addToReorder(id, true);\n\t            });\n\t            top.forEach(function (id) {\n\t                reorder.addToReorder(id);\n\t            });\n\t            this.repaint();\n\t            return this;\n\t        },\n\t\n\t        getSortedItems: function getSortedItems(arr) {\n\t            this._objectsReorderInit();\n\t            return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\n\t        },\n\t\n\t        setSortFunc: function setSortFunc(func) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.sortFunc = func;\n\t            reorder.userSetSortFunc = func ? true : false;\n\t            this._gmx.sortItems = reorder.sortItems;\n\t            this.repaint();\n\t            return this;\n\t        },\n\t        disableFlip: function disableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = true;\n\t            return this;\n\t        },\n\t        enableFlip: function enableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = false;\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.VectorLayer.include({\n\t    bindPopup: function bindPopup(content, options) {\n\t        var popupOptions = L.extend({ maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID }, options);\n\t\n\t        if (this._popup) {\n\t            this.unbindPopup();\n\t        }\n\t        if (content instanceof L.Popup) {\n\t            this._popup = content;\n\t        } else {\n\t            if (!this._popup || options) {\n\t                this._popup = new L.Popup(popupOptions);\n\t            }\n\t            this._popup.setContent(content);\n\t        }\n\t        this._popup._initContent = content;\n\t        this._popup._state = '';\n\t\n\t        if (!this._popupHandlersAdded) {\n\t            this.on('click', this._openClickPopup, this).on('mousemove', this._movePopup, this).on('mouseover', this._overPopup, this).on('mouseout', this._outPopup, this).on('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupHandlersAdded = true;\n\t        }\n\t        if (popupOptions && popupOptions.popupopen) {\n\t            this._popupopen = popupOptions.popupopen;\n\t        }\n\t\n\t        this._popup.updateLayout = this._popup._updateLayout;\n\t\n\t        return this;\n\t    },\n\t\n\t    unbindPopup: function unbindPopup() {\n\t        if (this._popup) {\n\t            this._popup = null;\n\t            this.off('click', this._openClickPopup, this).off('mousemove', this._movePopup, this).off('mouseover', this._overPopup, this).off('mouseout', this._outPopup, this).off('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupopen = null;\n\t            this._popupHandlersAdded = false;\n\t        }\n\t        this._gmx.balloonEnable = false;\n\t        return this;\n\t    },\n\t\n\t    _chkNeedOpenPopup: function _chkNeedOpenPopup() {\n\t        for (var id in this._gmx._needPopups) {\n\t            if (this._gmx._needPopups[id]) {\n\t                this.addPopup(id);\n\t                delete this._gmx._needPopups[id];\n\t            }\n\t        }\n\t    },\n\t\n\t    disablePopup: function disablePopup() {\n\t        this._popupDisabled = true;\n\t        return this;\n\t    },\n\t\n\t    enablePopup: function enablePopup() {\n\t        this._popupDisabled = false;\n\t        return this;\n\t    },\n\t\n\t    openPopup: function openPopup(latlng, options) {\n\t\n\t        if (this._popup) {\n\t            // open the popup from one of the path's points if not specified\n\t            latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];\n\t\n\t            options = options || {};\n\t            options.latlng = latlng;\n\t            this._openPopup(options);\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    closePopup: function closePopup() {\n\t        if (this._popup) {\n\t            this._popup._close();\n\t            this.fire('popupclose', { popup: this._popup });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _movePopup: function _movePopup(options) {\n\t        if (this._popup._state === 'mouseover') {\n\t            var id = this._popup.options._gmxID || -1;\n\t            if (id !== options.gmx.id) {\n\t                this._setPopupContent(options);\n\t            }\n\t            this._popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _overPopup: function _overPopup(options) {\n\t        var _popup = this._popup;\n\t        if (!_popup._map) {\n\t            this._openPopup(options);\n\t        } else {\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: this._setPopupContent(options, _popup)\n\t            });\n\t        }\n\t        if (_popup._state === 'mouseover') {\n\t            _popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _outPopup: function _outPopup(ev) {\n\t        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\n\t            this.closePopup();\n\t        }\n\t    },\n\t\n\t    _callBalloonHook: function _callBalloonHook(props, div) {\n\t\n\t        var spans = div.getElementsByTagName('span'),\n\t            hooksCount = {},\n\t            key,\n\t            i,\n\t            len;\n\t        for (key in this._balloonHook) {\n\t            // collect hook counts\n\t            var hookID = this._balloonHook[key].hookID;\n\t            hooksCount[key] = 0;\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                if (spans[i].id === hookID) {\n\t                    hooksCount[key]++;\n\t                }\n\t            }\n\t        }\n\t\n\t        for (key in this._balloonHook) {\n\t            var hook = this._balloonHook[key],\n\t                fid = hook.hookID,\n\t                notFound = true;\n\t\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                var node = spans[i];\n\t                if (node.id === fid) {\n\t                    notFound = false;\n\t                    node.id += '_' + i;\n\t                    hook.callback(props, div, node, hooksCount);\n\t                }\n\t            }\n\t            if (notFound) {\n\t                hook.callback(props, div, null, hooksCount);\n\t            }\n\t        }\n\t    },\n\t\n\t    _setPopupContent: function _setPopupContent(options, _popup) {\n\t        if (!_popup) {\n\t            _popup = this._popup;\n\t        }\n\t        var gmx = options.gmx || {},\n\t            balloonData = gmx.balloonData || {},\n\t            properties = L.extend({}, gmx.properties),\n\t            target = gmx.target || {},\n\t            geometry = target.geometry || {},\n\t            offset = target.offset,\n\t            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\n\t            type = options.type,\n\t            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\n\t            outItem = {\n\t            id: gmx.id,\n\t            type: type,\n\t            nodePoint: gmx.nodePoint,\n\t            latlng: options.latlng,\n\t            properties: properties,\n\t            templateBalloon: templateBalloon\n\t        };\n\t\n\t        if (geometry.type === 'POINT') {\n\t            var coord = geometry.coordinates;\n\t            outItem.latlng = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t        }\n\t        if (offset) {\n\t            var protoOffset = L.Popup.prototype.options.offset;\n\t            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\n\t        }\n\t\n\t        if (this._popupopen) {\n\t            this._popupopen({\n\t                popup: _popup,\n\t                latlng: outItem.latlng,\n\t                layerPoint: options.layerPoint,\n\t                contentNode: _popup._contentNode,\n\t                containerPoint: options.containerPoint,\n\t                originalEvent: options.originalEvent,\n\t                gmx: outItem\n\t            });\n\t        } else if (!(templateBalloon instanceof L.Popup)) {\n\t            if (!(templateBalloon instanceof HTMLElement)) {\n\t                var geometries,\n\t                    summary = '',\n\t                    unitOptions = this._map ? this._map.options : {};\n\t\n\t                if (!skipSummary) {\n\t                    geometries = target.geometry ? [target.geometry] : gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || [];\n\t                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                if (this._balloonHook) {\n\t                    if (!templateBalloon) {\n\t                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\n\t                    }\n\t                    for (var key in this._balloonHook) {\n\t                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\n\t                    }\n\t                }\n\t                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: this._gmx.tileAttributeTypes,\n\t                    unitOptions: unitOptions,\n\t                    summary: summary,\n\t                    geometries: geometries\n\t                });\n\t            }\n\t\n\t            var contentDiv = L.DomUtil.create('div', '');\n\t            contentDiv.innerHTML = templateBalloon;\n\t            _popup.setContent(contentDiv);\n\t            if (this._balloonHook) {\n\t                this._callBalloonHook(gmx.properties, _popup.getContent());\n\t            }\n\t            //outItem.templateBalloon = templateBalloon;\n\t        }\n\t        _popup.options._gmxID = gmx.id;\n\t        return outItem;\n\t    },\n\t\n\t    _openClickPopup: function _openClickPopup(options) {\n\t        var originalEvent = options.originalEvent || {},\n\t            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                gmx = options.gmx,\n\t                balloonData = gmx.balloonData,\n\t                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\n\t                item = gmx.target;\n\t\n\t            if (flag && item.options.isGeneralized && !item.geometry) {\n\t                var layerProp = gmx.layer.getGmxProperties();\n\t                gmxAPIutils.getLayerItemFromServer({\n\t                    options: options,\n\t                    layerID: layerProp.name,\n\t                    value: item.id,\n\t                    field: layerProp.identityField\n\t                }).then(function (json, params) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        var pArr = json.Result.values[0];\n\t                        params.options.gmx.target.fromServerProps = pArr;\n\t                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\n\t                        this._openPopup(params.options);\n\t                    }\n\t                }.bind(this));\n\t            } else {\n\t                this._openPopup(options);\n\t            }\n\t        }\n\t    },\n\t\n\t    _openPopup: function _openPopup(options, notSkip) {\n\t        var map = this._map,\n\t            originalEvent = options.originalEvent || {},\n\t            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                _popup = this._popup,\n\t                gmx = options.gmx || {},\n\t                balloonData = gmx.balloonData || {};\n\t\n\t            if (type === 'click') {\n\t                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) {\n\t                    return;\n\t                }\n\t\n\t                if (!('_gmxPopups' in map)) {\n\t                    map._gmxPopups = [];\n\t                }\n\t                if (!('maxPopupCount' in map.options)) {\n\t                    map.options.maxPopupCount = 1;\n\t                }\n\t                if (!this._gmx._gmxPopupsInit) {\n\t                    this._gmx._gmxPopupsInit = true;\n\t                    map.on({\n\t                        layerremove: function layerremove(ev) {\n\t                            if (ev.layer instanceof L.Popup) {\n\t                                this._clearPopup(ev.layer);\n\t                            } else if (ev.layer === this) {\n\t                                if (map._gmxPopups) {\n\t                                    var layerId = this._gmx.layerID;\n\t                                    map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                                        if (c._map) {\n\t                                            if (c.options.layerId === layerId) {\n\t                                                c._map.removeLayer(c);\n\t                                            } else {\n\t                                                p.push(c);\n\t                                            }\n\t                                        }\n\t                                        return p;\n\t                                    }, []);\n\t                                }\n\t                                this.closePopup();\n\t                            }\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                this._clearPopup(gmx.id);\n\t                var opt = this._popup ? this._popup.options : { maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID };\n\t                _popup = new L.Popup(L.extend({}, opt, { closeOnClick: map.options.maxPopupCount === 1, autoPan: true }));\n\t            } else if (type === 'mouseover') {\n\t                if (balloonData.DisableBalloonOnMouseMove) {\n\t                    _popup._state = '';\n\t                    return;\n\t                }\n\t                _popup.options.autoPan = false;\n\t            } else {\n\t                return;\n\t            }\n\t            _popup.options.objectId = gmx.id;\n\t            _popup._state = type;\n\t            var outItem = this._setPopupContent(options, _popup);\n\t            _popup.setLatLng(outItem.latlng);\n\t\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: outItem\n\t            });\n\t            if (type === 'click') {\n\t                if (map._gmxPopups.length >= map.options.maxPopupCount) {\n\t                    map.removeLayer(map._gmxPopups.shift());\n\t                }\n\t                map._gmxPopups.push(_popup);\n\t            }\n\t            _popup.addTo(map); // this._map.openPopup(_popup);\n\t\n\t            if (_popup._closeButton) {\n\t                var closeStyle = _popup._closeButton.style;\n\t                if (type === 'mouseover' && closeStyle !== 'hidden') {\n\t                    closeStyle.visibility = 'hidden';\n\t                    _popup._container.style.marginBottom = '7px';\n\t                    _popup._container.style.pointerEvents = 'none';\n\t                } else if (type === 'click' && closeStyle !== 'inherit') {\n\t                    closeStyle.visibility = 'inherit';\n\t                    _popup._container.style.marginBottom = '';\n\t                    _popup._container.style.pointerEvents = '';\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _clearPopup: function _clearPopup(item /* <L.Popup> or objectId */) {\n\t        var map = this._map;\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID,\n\t                flagPopup = item instanceof L.Popup;\n\t            map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                if (c._map) {\n\t                    if (flagPopup && c === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else if (c.options.layerId === layerId && c.options.objectId === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else {\n\t                        p.push(c);\n\t                    }\n\t                }\n\t                return p;\n\t            }, []);\n\t        }\n\t    },\n\t\n\t    getPopups: function getPopups(flag) {\n\t        var map = this._map,\n\t            out = [];\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID;\n\t            map._gmxPopups.reduce(function (p, c) {\n\t                if (c.options.layerId === layerId) {\n\t                    p.push(flag ? c : c.options.objectId);\n\t                }\n\t                return p;\n\t            }, out);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    addPopup: function addPopup(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        if (!item || !this._map) {\n\t            gmx._needPopups[id] = false;\n\t        } else {\n\t            var center = item.bounds.getCenter(),\n\t                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\n\t            this._openPopup({\n\t                type: 'click',\n\t                latlng: latlng,\n\t                gmx: this.getHoverOption(item)\n\t            }, true);\n\t            delete gmx._needPopups[id];\n\t        }\n\t        return this;\n\t    },\n\t\n\t    addPopupHook: function addPopupHook(key, callback) {\n\t        if (!this._balloonHook) {\n\t            this._balloonHook = {};\n\t        }\n\t        if (!this._balloonHook[key]) {\n\t            var hookID = '_' + L.stamp({});\n\t            this._balloonHook[key] = {\n\t                key: key,\n\t                hookID: hookID,\n\t                resStr: '<span id=\"' + hookID + '\"></span>',\n\t                callback: callback\n\t            };\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removePopupHook: function removePopupHook(key) {\n\t        if (this._balloonHook) {\n\t            delete this._balloonHook[key];\n\t        }\n\t        return this;\n\t    }\n\t});\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx.VectorLayer.include({\n\t    _gmxFirstObjectsByPoint: function _gmxFirstObjectsByPoint(geoItems, mercPoint, bounds) {\n\t        // Получить верхний объект по координатам mouseClick\n\t        var gmx = this._gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            j,\n\t            len;\n\t\n\t        for (var i = geoItems.length - 1; i >= 0; i--) {\n\t            var geoItem = geoItems[i].properties,\n\t                idr = geoItem[0],\n\t                dataOption = geoItems[i].dataOption || {},\n\t                item = gmx.dataManager.getItem(idr),\n\t                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t                iconScale = currentStyle.iconScale || 1,\n\t                iconCenter = currentStyle.iconCenter,\n\t                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\n\t                parsedStyle = gmx.styleManager.getObjStyle(item),\n\t                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\n\t                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\n\t                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\n\t                offset = [iconScale * sx / 2, iconScale * sy / 2],\n\t                point = mercPoint,\n\t                geom = geoItem[geoItem.length - 1],\n\t                type = geom.type;\n\t\n\t            if (type === 'POINT' && parsedStyle.type === 'circle') {\n\t                offset[0] *= 2;\n\t                offset[1] *= 2;\n\t            }\n\t            var radius = offset[0],\n\t                objBounds = _Utils.gmxAPIutils.bounds().extendBounds(dataOption.bounds).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t            if (iconAnchor) {\n\t                offset = [iconAnchor[0] - offset[0], iconAnchor[1] - offset[1]];\n\t                point = [mercPoint[0] + offset[0] / mInPixel, mercPoint[1] - offset[1] / mInPixel];\n\t            }\n\t            if (!objBounds.contains(point)) {\n\t                continue;\n\t            }\n\t\n\t            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\n\t                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\n\t                chktype = type,\n\t                hiddenLines = dataOption.hiddenLines || [],\n\t                boundsArr = dataOption.boundsArr,\n\t                coords = geom.coordinates,\n\t                nodePoint = null,\n\t                ph = {\n\t                point: mercPoint,\n\t                bounds: bounds,\n\t                coords: coords,\n\t                boundsArr: boundsArr\n\t            };\n\t\n\t            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\n\t                if (marker) {\n\t                    chktype = 'POINT';\n\t                } else if (!fill) {\n\t                    if (type === 'POLYGON') {\n\t                        chktype = 'MULTILINESTRING';\n\t                        hiddenLines = hiddenLines[0];\n\t                    } else {\n\t                        chktype = 'LIKEMULTILINESTRING';\n\t                    }\n\t                    ph.hidden = hiddenLines;\n\t                }\n\t            }\n\t\n\t            if (chktype === 'LINESTRING') {\n\t                if (!_Utils.gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\n\t                    nodePoint = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'LIKEMULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                var flag = false;\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    ph.coords = coords[j];\n\t                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\n\t                    ph.boundsArr = boundsArr[j];\n\t                    if (_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                        flag = true;\n\t                        break;\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'MULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                ph.hidden = hiddenLines;\n\t                if (!_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                    var pBounds = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t                    for (j = 0, len = coords.length; j < len; j++) {\n\t                        nodePoint = pBounds.isNodeIntersect(coords[j]);\n\t                        if (nodePoint !== null) {\n\t                            nodePoint.ring = j;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\n\t                var chkPoint = mercPoint;\n\t                flag = false;\n\t                if (chktype === 'POLYGON') {\n\t                    coords = [geom.coordinates];\n\t                    boundsArr = [dataOption.boundsArr];\n\t                }\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    var arr = coords[j],\n\t                        bbox = boundsArr[j];\n\t                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\n\t                        var b = bbox[j1];\n\t                        if (b.intersects(bounds)) {\n\t                            if (_Utils.gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\n\t                                flag = j1 === 0 ? true : false;\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'POINT') {\n\t                if (parsedStyle.type === 'circle') {\n\t                    var x = (coords[0] - point[0]) * mInPixel,\n\t                        y = (coords[1] - point[1]) * mInPixel;\n\t                    if (x * x + y * y > radius * radius) {\n\t                        continue;\n\t                    }\n\t                }\n\t            }\n\t            if (!this.isPointInClipPolygons(mercPoint)) {\n\t                continue;\n\t            }\n\t\n\t            return {\n\t                id: idr,\n\t                properties: item.properties,\n\t                geometry: geom,\n\t                bounds: item.bounds,\n\t                nodePoint: nodePoint,\n\t                offset: iconAnchor ? offset : null,\n\t                parsedStyle: parsedStyle\n\t            };\n\t        }\n\t        return null;\n\t    },\n\t\n\t    gmxEventCheck: function gmxEventCheck(ev, skipOver) {\n\t        if (!this._map) {\n\t            return 0;\n\t        }\n\t        var layer = this,\n\t            gmx = layer._gmx,\n\t            type = ev.type,\n\t            lastHover = gmx.lastHover,\n\t            chkHover = function chkHover(evType) {\n\t            if (lastHover && type === 'mousemove') {\n\t                if (evType && layer.hasEventListeners(evType)) {\n\t                    ev.gmx = lastHover;\n\t                    layer.fire(evType, ev);\n\t                }\n\t                if (lastHover.hoverDiff) {\n\t                    layer.redrawItem(lastHover.id);\n\t                }\n\t            }\n\t        };\n\t\n\t        var zoom = this._map.getZoom();\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            skipOver = true;\n\t        }\n\t        if (skipOver) {\n\t            if (lastHover) {\n\t                lastHover.prevId = null;\n\t            }\n\t            chkHover('mouseout');\n\t            gmx.lastHover = null;\n\t        } else if (this.hasEventListeners('mouseover') || this.hasEventListeners('mouseout') || this.hasEventListeners(type) || type === 'mousemove' && gmx.properties.fromType !== 'Raster') {\n\t\n\t            var lng = ev.latlng.lng % 360,\n\t                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : lng > 180 ? -360 : 0)),\n\t                point = L.Projection.Mercator.project(latlng)._subtract({ x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0 }),\n\t                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\n\t                mercatorPoint = [point.x, point.y];\n\t\n\t            //создаём observer только для того, чтобы сделать выборку данных вокруг курсора\n\t            var observerOptions = {\n\t                type: 'resend',\n\t                bbox: _Utils.gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\n\t                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                active: false //делаем его неактивным, так как потом будем явно выбирать данные\n\t            };\n\t            if (this.options.isGeneralized) {\n\t                observerOptions.targetZoom = zoom;\n\t            }\n\t\n\t            gmx.dataManager.addObserver(observerOptions, 'hover');\n\t\n\t            var geoItems = gmx.dataManager.getItems('hover');\n\t\n\t            gmx.dataManager.removeObserver('hover');\n\t\n\t            if (geoItems && geoItems.length) {\n\t                if (geoItems.length > 1 && gmx.sortItems) {\n\t                    geoItems = this.getSortedItems(geoItems);\n\t                }\n\t\n\t                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\n\t                if (target) {\n\t                    var idr = target.id,\n\t                        item = gmx.dataManager.getItem(idr),\n\t                        prevId = lastHover ? lastHover.id : null,\n\t                        changed = !lastHover || lastHover.id !== idr;\n\t                    if (type === 'mousemove' && lastHover) {\n\t                        if (!changed) {\n\t                            ev.gmx = lastHover;\n\t                            this.fire(type, ev);\n\t                            return idr;\n\t                        }\n\t                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\n\t                        gmx.lastHover = null;\n\t                    }\n\t\n\t                    ev.gmx = L.extend(this.getHoverOption(item), {\n\t                        targets: geoItems,\n\t                        nodePoint: target.nodePoint,\n\t                        prevId: prevId,\n\t                        hoverDiff: item.hoverDiff\n\t                    });\n\t                    if (this.hasEventListeners(type)) {\n\t                        this.fire(type, ev);\n\t                    }\n\t                    if (type === 'mousemove' && changed) {\n\t                        lastHover = gmx.lastHover = ev.gmx;\n\t                        chkHover('mouseover');\n\t                        gmx.lastMouseover = gmx.lastHover;\n\t                    }\n\t                    this._map.doubleClickZoom.disable();\n\t                    return idr;\n\t                }\n\t            }\n\t        }\n\t        if (this._map) {\n\t            this._map.doubleClickZoom.enable();\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    getHoverOption: function getHoverOption(item) {\n\t        return {\n\t            layer: this,\n\t            target: item,\n\t            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\n\t            properties: this.getItemProperties(item.properties),\n\t            currentFilter: item.currentFilter || 0,\n\t            id: item.id\n\t        };\n\t    }\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t(function () {\n\t    var delay = 20000,\n\t        layers = {},\n\t        dataManagersLinks = {},\n\t        script = '/Layer/CheckVersion.ashx',\n\t        intervalID = null,\n\t        timeoutID = null,\n\t        lastLayersStr = '';\n\t\n\t    var isExistsTiles = function isExistsTiles(prop) {\n\t        var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\n\t        return tilesKey in prop;\n\t    };\n\t    var getParams = function getParams(prop, dm, layerDateInterval) {\n\t        var pt = {\n\t            Name: prop.name,\n\t            Version: isExistsTiles(prop) ? prop.LayerVersion : -1\n\t        };\n\t        if (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\n\t            var maxDateInterval = dm.getMaxDateInterval(),\n\t                beginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\n\t                endDate = maxDateInterval.endDate || layerDateInterval.endDate;\n\t            if (beginDate) {\n\t                pt.dateBegin = Math.floor(beginDate.getTime() / 1000);\n\t            }\n\t            if (endDate) {\n\t                pt.dateEnd = Math.floor(endDate.getTime() / 1000);\n\t            }\n\t        }\n\t        return pt;\n\t    };\n\t    var getRequestParams = function getRequestParams(layer) {\n\t        var hosts = {},\n\t            prop,\n\t            hostName,\n\t            dm,\n\t            layerDateInterval;\n\t        if (layer) {\n\t            if (layer instanceof L.gmx.DataManager) {\n\t                dm = layer;\n\t                prop = dm.options;\n\t            } else {\n\t                prop = layer._gmx.properties;\n\t                dm = layer._gmx.dataManager;\n\t                layerDateInterval = layer._gmx;\n\t            }\n\t            hostName = prop.hostName || layer._gmx.hostName;\n\t            hosts[hostName] = [getParams(prop, dm, layerDateInterval)];\n\t        } else {\n\t            var skipItems = {};\n\t            for (var id in layers) {\n\t                var obj = layers[id],\n\t                    isDataManager = obj instanceof L.gmx.DataManager;\n\t                if (obj.options.chkUpdate || isDataManager) {\n\t                    dm = isDataManager ? obj : obj._gmx.dataManager;\n\t                    prop = isDataManager ? obj.options : obj._gmx.properties;\n\t                    layerDateInterval = isDataManager ? obj : obj._gmx;\n\t                    hostName = prop.hostName || obj._gmx.hostName;\n\t                    var pt = getParams(prop, dm, layerDateInterval),\n\t                        key = pt.Name + pt.Version;\n\t                    if (!skipItems[key]) {\n\t                        if (hosts[hostName]) {\n\t                            hosts[hostName].push(pt);\n\t                        } else {\n\t                            hosts[hostName] = [pt];\n\t                        }\n\t                    }\n\t                    skipItems[key] = true;\n\t                }\n\t            }\n\t        }\n\t        return hosts;\n\t    };\n\t\n\t    var chkVersion = function chkVersion(layer, callback) {\n\t        var processResponse = function processResponse(res) {\n\t            if (res && res.Status === 'ok' && res.Result) {\n\t                for (var i = 0, len = res.Result.length; i < len; i++) {\n\t                    var item = res.Result[i],\n\t                        id = item.properties.name;\n\t\n\t                    if (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) {\n\t                        layer.updateVersion(item);\n\t                    }\n\t                    for (var key in layers) {\n\t                        var curLayer = layers[key];\n\t                        if (layer && layer === curLayer) {\n\t                            continue;\n\t                        }\n\t                        if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\n\t                            // слои\n\t                            curLayer.updateVersion(item);\n\t                        } else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\n\t                            // источники данных\n\t                            curLayer.updateVersion(item.properties);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            lastLayersStr = '';\n\t            if (callback) {\n\t                callback(res);\n\t            }\n\t        };\n\t\n\t        if (document.body && !_Utils.gmxAPIutils.isPageHidden()) {\n\t            var hosts = getRequestParams(layer),\n\t                chkHost = function chkHost(hostName) {\n\t                var url = 'http://' + hostName + script,\n\t                    layersStr = JSON.stringify(hosts[hostName]);\n\t\n\t                if (lastLayersStr !== layersStr) {\n\t                    lastLayersStr = layersStr;\n\t                    if ('FormData' in window) {\n\t                        _Utils.gmxAPIutils.request({\n\t                            url: url,\n\t                            async: true,\n\t                            headers: {\n\t                                'Content-type': 'application/x-www-form-urlencoded'\n\t                            },\n\t                            type: 'POST',\n\t                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\n\t                            withCredentials: true,\n\t                            callback: function callback(response) {\n\t                                processResponse(JSON.parse(response));\n\t                            },\n\t                            onError: function onError(response) {\n\t                                console.log('Error: LayerVersion ', response);\n\t                            }\n\t                        });\n\t                    } else {\n\t                        _Utils.gmxAPIutils.sendCrossDomainPostRequest(url, {\n\t                            WrapStyle: 'message',\n\t                            layers: layersStr\n\t                        }, processResponse);\n\t                    }\n\t                    var timeStamp = Date.now();\n\t                    for (var key in layers) {\n\t                        var it = layers[key];\n\t                        var options = it._gmx || it.options;\n\t                        if (options.hostName === hostName) {\n\t                            options._stampVersionRequest = timeStamp;\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t            for (var hostName in hosts) {\n\t                chkHost(hostName);\n\t            }\n\t        }\n\t    };\n\t\n\t    var layersVersion = {\n\t\n\t        addDataManager: function addDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t            dataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\n\t            layers[id] = dataManager;\n\t        },\n\t\n\t        removeDataManager: function removeDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                dataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\n\t                delete layers[id];\n\t            }\n\t        },\n\t\n\t        remove: function remove(layer) {\n\t            delete layers[layer._leaflet_id];\n\t            var _gmx = layer._gmx,\n\t                pOptions = layer.options.parentOptions;\n\t            if (pOptions) {\n\t                var pId = pOptions.name;\n\t                if (dataManagersLinks[pId]) {\n\t                    delete dataManagersLinks[pId][_gmx.properties.name];\n\t                    if (!Object.keys(dataManagersLinks[pId]).length) {\n\t                        layersVersion.removeDataManager(_gmx.dataManager);\n\t                        delete dataManagersLinks[pId];\n\t                    }\n\t                }\n\t            } else {\n\t                _gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\n\t            }\n\t        },\n\t\n\t        add: function add(layer) {\n\t            var id = layer._leaflet_id;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t\n\t            var _gmx = layer._gmx,\n\t                prop = _gmx.properties;\n\t            if ('LayerVersion' in prop) {\n\t                layers[id] = layer;\n\t                _gmx._chkVersion = function () {\n\t                    chkVersion(layer);\n\t                };\n\t                _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\n\t                var pOptions = layer.options.parentOptions;\n\t                if (pOptions) {\n\t                    var pId = pOptions.name;\n\t                    layersVersion.addDataManager(_gmx.dataManager);\n\t                    if (!dataManagersLinks[pId]) {\n\t                        dataManagersLinks[pId] = {};\n\t                    }\n\t                    dataManagersLinks[pId][prop.name] = layer;\n\t                }\n\t\n\t                layersVersion.start();\n\t                if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\n\t                    layersVersion.now();\n\t                }\n\t            }\n\t        },\n\t\n\t        chkVersion: chkVersion,\n\t\n\t        now: function now() {\n\t            if (timeoutID) {\n\t                clearTimeout(timeoutID);\n\t            }\n\t            timeoutID = setTimeout(chkVersion, 0);\n\t        },\n\t\n\t        stop: function stop() {\n\t            if (intervalID) {\n\t                clearInterval(intervalID);\n\t            }\n\t            intervalID = null;\n\t        },\n\t\n\t        start: function start(msec) {\n\t            if (msec) {\n\t                delay = msec;\n\t            }\n\t            layersVersion.stop();\n\t            intervalID = setInterval(chkVersion, delay);\n\t        }\n\t    };\n\t\n\t    if (!L.gmx) {\n\t        L.gmx = {};\n\t    }\n\t    L.gmx.layersVersion = layersVersion;\n\t\n\t    L.gmx.VectorLayer.include({\n\t        updateVersion: function updateVersion(layerDescription) {\n\t            if (layerDescription) {\n\t                var gmx = this._gmx;\n\t                if (layerDescription.geometry) {\n\t                    gmx.geometry = layerDescription.geometry;\n\t                }\n\t                if (layerDescription.properties) {\n\t                    L.extend(gmx.properties, layerDescription.properties);\n\t                    gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\n\t                    gmx.rawProperties = gmx.properties;\n\t                    this.fire('versionchange');\n\t                    if (!gmx.dataSource) {\n\t                        gmx.dataManager.updateVersion(gmx.rawProperties);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//Raster layer is just vector layer with the single object and special background tiles\n\tL.gmx.RasterLayer = L.gmx.VectorLayer.extend({\n\t    options: {\n\t        isGeneralized: false,\n\t        zIndexOffset: 0\n\t        //clickable: false\n\t    },\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var props = ph.properties,\n\t            styles = props.styles[0] || { MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21 },\n\t            vectorProperties = {\n\t            type: 'Vector',\n\t            fromType: props.type,\n\t            identityField: 'ogc_fid',\n\t            GeometryType: 'POLYGON',\n\t            IsRasterCatalog: true,\n\t            Copyright: props.Copyright || '',\n\t            RCMinZoomForRasters: styles.MinZoom,\n\t            visible: props.visible,\n\t            styles: [{\n\t                DisableBalloonOnClick: true,\n\t                MinZoom: styles.MinZoom,\n\t                MaxZoom: styles.MaxZoom,\n\t                RenderStyle: { outline: { thickness: 0 }, fill: { opacity: 100 } },\n\t                HoverStyle: null\n\t            }]\n\t        },\n\t            gmx = this._gmx,\n\t            worldSize = gmxAPIutils.tileSizes[1];\n\t\n\t        if (props.MaxZoom) {\n\t            gmx.maxNativeZoom = props.MaxZoom;\n\t        }\n\t        if (!ph.geometry) {\n\t            ph.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        L.gmx.VectorLayer.prototype.initFromDescription.call(this, { geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties });\n\t\n\t        gmx.rasterBGfunc = function (x, y, z) {\n\t            return 'http://' + gmx.hostName + '/' + 'TileSender.ashx?ModeKey=tile' + '&key=' + encodeURIComponent(gmx.sessionKey) + '&LayerName=' + gmx.layerID + '&z=' + z + '&x=' + x + '&y=' + y;\n\t        };\n\t\n\t        var vectorDataProvider = { load: function load(x, y, z, v, s, d, callback) {\n\t                var objects = [[777, ph.geometry]],\n\t                    itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\n\t                    bounds = itemBounds.bounds;\n\t\n\t                if (bounds.max.x > worldSize) {\n\t                    // for old layers geometry\n\t                    var ww2 = 2 * worldSize,\n\t                        id = 777,\n\t                        coords = ph.geometry.coordinates,\n\t                        bboxArr = itemBounds.boundsArr;\n\t\n\t                    objects = [];\n\t                    if (ph.geometry.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                        bboxArr = [bboxArr];\n\t                    }\n\t\n\t                    for (var i = 0, len = coords.length; i < len; i++) {\n\t                        var it = coords[i],\n\t                            bbox = bboxArr[i][0],\n\t                            arr = it;\n\t                        objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        if (bbox.max.x > worldSize) {\n\t                            arr = [];\n\t                            for (var j = 0, len1 = it.length; j < len1; j++) {\n\t                                var it1 = it[j];\n\t                                for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\n\t                                    var it2 = it1[j1];\n\t                                    arr1.push([it2[0] - ww2, it2[1]]);\n\t                                }\n\t                                arr.push(arr1);\n\t                            }\n\t                            objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        }\n\t                    }\n\t                }\n\t                callback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\n\t            } };\n\t        gmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, { x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2 });\n\t        gmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\n\t\n\t        return this;\n\t    },\n\t\n\t    setZoomBounds: function setZoomBounds(minZoom, maxZoom) {\n\t        var styles = this.getStyles().slice(0);\n\t        styles[0] = L.extend({}, styles[0]);\n\t        styles[0].MinZoom = minZoom;\n\t        styles[0].MaxZoom = maxZoom;\n\t        this.setStyles(styles);\n\t    }\n\t});\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.LabelsLayer = L.Class.extend({\n\t\n\t    options: {\n\t        pane: 'overlayPane'\n\t    },\n\t\n\t    initialize: function initialize(map, options) {\n\t        L.setOptions(this, options);\n\t        this._observers = {};\n\t        this._styleManagers = {};\n\t        this._labels = {};\n\t        var _this = this;\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds();\n\t\n\t        var chkData = function chkData(data, layer) {\n\t            if (!data.added && !data.removed) {\n\t                return;\n\t            }\n\t\n\t            var opt = layer.options,\n\t                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\n\t                layerId = '_' + layer._leaflet_id,\n\t                gmx = layer._gmx,\n\t                labels = {};\n\t\n\t            for (var i = 0, len = added.length; i < len; i++) {\n\t                var item = added[i].item,\n\t                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\n\t                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\n\t\n\t                if (gmx.styleHook) {\n\t                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\n\t                    if (styleExtend) {\n\t                        currentStyle = L.extend({}, currentStyle, styleExtend);\n\t                    } else {\n\t                        continue;\n\t                    }\n\t                }\n\t                if (item.multiFilters) {\n\t                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                        var st = item.multiFilters[j].parsedStyle;\n\t                        if ('labelField' in st || 'labelText' in st) {\n\t                            currentStyle = st;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var style = gmx.styleManager.getObjStyle(item) || {},\n\t                    labelText = currentStyle.labelText || style.labelText,\n\t                    labelField = currentStyle.labelField || style.labelField,\n\t                    fieldType = gmx.tileAttributeTypes[labelField],\n\t                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\n\t\n\t                if (style.labelTemplate) {\n\t                    var reg = /\\[([^\\]]*)\\]/g,\n\t                        match;\n\t                    txt = style.labelTemplate;\n\t\n\t                    while (match = reg.exec(style.labelTemplate)) {\n\t                        if (match.length === 2) {\n\t                            labelField = match[1];\n\t                            fieldType = gmx.tileAttributeTypes[labelField];\n\t                            var val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\n\t                            txt = txt.replace(match[0], val);\n\t                        }\n\t                    }\n\t                }\n\t                if (txt || txt === 0) {\n\t                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\n\t                        id = '_' + item.id,\n\t                        changed = true,\n\t                        width = 0,\n\t                        arrTxtWidth,\n\t                        options = item.options,\n\t                        labelStyle = {\n\t                        font: fontSize + 'px \"Arial\"',\n\t                        labelHaloColor: 'labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : 'labelHaloColor' in style ? style.labelHaloColor : 0xffffff,\n\t                        labelColor: currentStyle.labelColor || style.labelColor,\n\t                        labelAlign: currentStyle.labelAlign || style.labelAlign,\n\t                        labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\n\t                        labelFontSize: fontSize\n\t                    };\n\t                    if (options) {\n\t                        if (!('center' in options)) {\n\t                            var center = _Utils.gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\n\t                            if (!center) {\n\t                                continue;\n\t                            }\n\t                            options.center = center;\n\t                        }\n\t                        if (options.label) {\n\t                            width = options.label.width;\n\t                            arrTxtWidth = options.label.arrTxtWidth;\n\t                            var pstyle = options.label.style;\n\t                            changed = options.label.txt !== txt || pstyle.labelHaloColor !== labelStyle.labelHaloColor || pstyle.labelColor !== labelStyle.labelColor || pstyle.labelAlign !== labelStyle.labelAlign || pstyle.labelAnchor !== labelStyle.labelAnchor || pstyle.labelFontSize !== labelStyle.labelFontSize;\n\t                        }\n\t                    }\n\t                    if (changed) {\n\t                        width = 0;\n\t                        arrTxtWidth = _Utils.gmxAPIutils.getLabelWidth(txt, labelStyle);\n\t                        if (arrTxtWidth) {\n\t                            arrTxtWidth.forEach(function (it) {\n\t                                width = Math.max(width, it[1]);\n\t                            });\n\t                        }\n\t\n\t                        if (!width) {\n\t                            delete labels[id];\n\t                            continue;\n\t                        }\n\t                        width += 4;\n\t                        item.options.labelStyle = null;\n\t                    }\n\t                    options.label = {\n\t                        isPoint: isPoint,\n\t                        width: width,\n\t                        sx: style.sx || 0,\n\t                        txt: txt,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        style: labelStyle\n\t                    };\n\t                    labels[id] = item;\n\t                }\n\t            }\n\t            _this._labels[layerId] = labels;\n\t        };\n\t\n\t        var addObserver = function addObserver(layer) {\n\t            var gmx = layer._gmx,\n\t                filters = ['styleFilter', 'userFilter'],\n\t                options = {\n\t                type: 'resend',\n\t                bbox: _this.bbox,\n\t                filters: filters,\n\t                callback: function callback(data) {\n\t                    chkData(data, layer);\n\t                    _this.redraw();\n\t                }\n\t            };\n\t            if (gmx.beginDate && gmx.endDate) {\n\t                options.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t            return gmx.dataManager.addObserver(options, '_Labels');\n\t        };\n\t        this.add = function (layer) {\n\t            var id = layer._leaflet_id,\n\t                gmx = layer._gmx;\n\t\n\t            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\n\t                gmx.styleManager.deferred.then(function () {\n\t                    var observer = addObserver(layer),\n\t                        _zoom = _this._map._zoom;\n\t                    if (layer.options.isGeneralized) {\n\t                        observer.targetZoom = _zoom; //need update to current zoom\n\t                    }\n\t                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\n\t                        observer.deactivate();\n\t                    }\n\t                    _this._observers[id] = observer;\n\t                    _this._styleManagers[id] = gmx.styleManager;\n\t\n\t                    _this._labels['_' + id] = {};\n\t                    _this._updateBbox();\n\t                });\n\t            }\n\t        };\n\t        this.remove = function (layer) {\n\t            var id = layer._leaflet_id;\n\t            if (_this._observers[id]) {\n\t                var gmx = layer._gmx,\n\t                    dataManager = gmx.dataManager;\n\t                dataManager.removeObserver(_this._observers[id].id);\n\t                delete _this._observers[id];\n\t                delete _this._styleManagers[id];\n\t                delete _this._labels['_' + id];\n\t                _this.redraw();\n\t            }\n\t        };\n\t        this._layeradd = function (ev) {\n\t            _this.add(ev.layer);\n\t        };\n\t        this._layerremove = function (ev) {\n\t            _this.remove(ev.layer);\n\t        };\n\t    },\n\t\n\t    redraw: function redraw() {\n\t        if (!this._frame && !this._map._animating) {\n\t            this._frame = L.Util.requestAnimFrame(this._redraw, this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _addToPane: function _addToPane() {\n\t        var pane = this._map.getPanes()[this.options.pane];\n\t        if (pane) {\n\t            pane.insertBefore(this._canvas, pane.firstChild);\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        this._map = map;\n\t\n\t        if (!this._canvas) {\n\t            this._initCanvas();\n\t        }\n\t        // this._addToPane();\n\t\n\t        map.on('moveend', this._reset, this);\n\t        map.on({\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        });\n\t        if (map.options.zoomAnimation && L.Browser.any3d) {\n\t            map.on('zoomanim', this._animateZoom, this);\n\t        }\n\t\n\t        this._reset();\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._canvas.parentNode) {\n\t            this._canvas.parentNode.removeChild(this._canvas);\n\t        }\n\t\n\t        map.off('moveend', this._reset, this);\n\t        map.off('layeradd', this._layeradd);\n\t        map.off('layerremove', this._layerremove);\n\t\n\t        if (map.options.zoomAnimation) {\n\t            map.off('zoomanim', this._animateZoom, this);\n\t        }\n\t    },\n\t\n\t    addTo: function addTo(map) {\n\t        map.addLayer(this);\n\t        return this;\n\t    },\n\t\n\t    _initCanvas: function _initCanvas() {\n\t        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\n\t            size = this._map.getSize();\n\t        canvas.width = size.x;canvas.height = size.y;\n\t        canvas.style.pointerEvents = 'none';\n\t        this._canvas = canvas;\n\t\n\t        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n\t        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        var _map = this._map,\n\t            screenBounds = _map.getBounds(),\n\t            southWest = screenBounds.getSouthWest(),\n\t            northEast = screenBounds.getNorthEast(),\n\t            m1 = L.Projection.Mercator.project(southWest),\n\t            m2 = L.Projection.Mercator.project(northEast),\n\t            _zoom = _map.getZoom();\n\t\n\t        this.mInPixel = _Utils.gmxAPIutils.getPixelScale(_zoom);\n\t        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (observer.targetZoom) {\n\t                observer.targetZoom = _zoom;\n\t            }\n\t            observer.setBounds({\n\t                min: { x: southWest.lng, y: southWest.lat },\n\t                max: { x: northEast.lng, y: northEast.lat }\n\t            });\n\t        }\n\t    },\n\t\n\t    _reset: function _reset() {\n\t        this._updateBbox();\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (!observer.isActive() && this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())) {\n\t                observer.activate();\n\t            }\n\t            observer.fire('update');\n\t        }\n\t    },\n\t\n\t    _redraw: function _redraw() {\n\t        var out = [],\n\t            _map = this._map,\n\t            mapSize = _map.getSize(),\n\t            _canvas = this._canvas,\n\t            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\n\t            topLeft = _map.containerPointToLayerPoint(offset);\n\t\n\t        _canvas.width = mapSize.x;_canvas.height = mapSize.y;\n\t        L.DomUtil.setPosition(_canvas, topLeft);\n\t\n\t        var w2 = 2 * this.mInPixel * _Utils.gmxAPIutils.worldWidthMerc,\n\t            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\n\t            ctx = _canvas.getContext('2d'),\n\t            i,\n\t            len,\n\t            it;\n\t\n\t        for (var layerId in this._labels) {\n\t            var labels = this._labels[layerId];\n\t            for (var id in labels) {\n\t                it = labels[id];\n\t                var options = it.options,\n\t                    label = options.label,\n\t                    style = label.style,\n\t                    labelAlign = style.labelAlign || 'center',\n\t                    arrTxtWidth = label.arrTxtWidth,\n\t                    count = arrTxtWidth.length || 1,\n\t                    width = label.width,\n\t                    width2 = width / 2,\n\t                    size = style.labelFontSize || 12,\n\t                    size2 = size / 2,\n\t                    center = options.center,\n\t                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\n\t                    isFiltered = false;\n\t\n\t                if (label.isPoint) {\n\t                    var delta = label.sx;\n\t                    if (labelAlign === 'left') {\n\t                        pos[0] += width2 + delta;\n\t                    } else if (labelAlign === 'right') {\n\t                        pos[0] -= width + delta;\n\t                    }\n\t                }\n\t                pos[0] -= width2 + this._ctxShift[0];\n\t                pos[1] = -size2 - pos[1] + this._ctxShift[1];\n\t                size2 *= count;\n\t                if (style.labelAnchor) {\n\t                    pos[0] += style.labelAnchor[0];\n\t                    pos[1] += style.labelAnchor[1];\n\t                }\n\t\n\t                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\n\t                    var coord = [Math.floor(tx), Math.floor(pos[1])],\n\t                        bbox = _Utils.gmxAPIutils.bounds([[coord[0] - width2, coord[1] - size2], [coord[0] + width2, coord[1] + size2]]);\n\t                    for (i = 0, len = out.length; i < len; i++) {\n\t                        if (bbox.intersects(out[i].bbox)) {\n\t                            isFiltered = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (isFiltered) {\n\t                        continue;\n\t                    }\n\t\n\t                    if (!options.labelStyle) {\n\t                        options.labelStyle = {\n\t                            font: size + 'px \"Arial\"',\n\t                            fillStyle: _Utils.gmxAPIutils.dec2color(style.labelColor || 0, 1),\n\t                            shadowBlur: 4\n\t                        };\n\t                        if (style.labelHaloColor !== -1) {\n\t                            options.labelStyle.strokeStyle = options.labelStyle.shadowColor = _Utils.gmxAPIutils.dec2color(style.labelHaloColor, 1);\n\t                        }\n\t                    }\n\t                    out.push({\n\t                        arr: it.properties,\n\t                        bbox: bbox,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        width2: labelAlign === 'center' ? width2 : 0,\n\t                        txt: label.txt,\n\t                        style: options.labelStyle,\n\t                        size: size,\n\t                        coord: coord\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        if (out.length) {\n\t            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\n\t            for (i = 0, len = out.length; i < len; i++) {\n\t                it = out[i];\n\t                it.arrTxtWidth.forEach(function (pt, nm) {\n\t                    var coord = [it.coord[0] + it.width2 - pt[1] / 2, it.coord[1] + nm * it.size];\n\t                    _Utils.gmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\n\t                });\n\t            }\n\t            if (!_canvas.parentNode) {\n\t                this._addToPane();\n\t            }\n\t        } else if (_canvas.parentNode) {\n\t            _canvas.parentNode.removeChild(_canvas);\n\t        }\n\t\n\t        this._frame = null;\n\t    },\n\t\n\t    _animateZoom: function _animateZoom(e) {\n\t        var scale = this._map.getZoomScale(e.zoom),\n\t            pixelBoundsMin = this._map.getPixelBounds().min;\n\t\n\t        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\n\t        if (pixelBoundsMin.y < 0) {\n\t            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\n\t        }\n\t\n\t        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\n\t    }\n\t}); /*\r\n\t     (c) 2014, Sergey Alekseev\r\n\t     Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n\t    */\n\t\n\t\n\tL.labelsLayer = function (map, options) {\n\t    return new L.LabelsLayer(map, options);\n\t};\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if Labels has already been initialized.\n\t    if (!this._labelsLayer) {\n\t        this._labelsLayer = new L.LabelsLayer(this);\n\t        this._labelsLayer.addTo(this);\n\t    }\n\t});\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var isBoundsIntersects = function isBoundsIntersects(bounds, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].intersects(bounds)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    var isObserverIntersects = function isObserverIntersects(observer, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (observer.intersects(bbox[j1])) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var _isPointInClipPolygons = function _isPointInClipPolygons(chkPoint, clipPolygons) {\n\t        if (!clipPolygons || Object.keys(clipPolygons).length === 0) {\n\t            return true;\n\t        }\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].contains(chkPoint)) {\n\t                            var coords = it.geometry.coordinates,\n\t                                isIn = false;\n\t                            if (type === 'Polygon') {\n\t                                coords = [coords];\n\t                            }\n\t                            for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\n\t                                if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\n\t                                    isIn = true;\n\t                                    break;\n\t                                }\n\t                            }\n\t                            if (isIn) {\n\t                                return true;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var getClipPolygonItem = function getClipPolygonItem(geo) {\n\t        var geometry = gmxAPIutils.convertGeometry(geo),\n\t            bboxArr = gmxAPIutils.geoItemBounds(geometry);\n\t        bboxArr.geometry = geometry;\n\t        return bboxArr;\n\t    };\n\t\n\t    var clipTileByPolygon = function clipTileByPolygon(dattr) {\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = canvas.height = 256;\n\t        var ctx = canvas.getContext('2d'),\n\t            clipPolygons = dattr.clipPolygons;\n\t\n\t        dattr.ctx = ctx;\n\t        ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\n\t\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var geo = arr[i].geometry,\n\t                    coords = geo.coordinates;\n\t                if (geo.type === 'Polygon') {\n\t                    coords = [coords];\n\t                }\n\t                for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\n\t                    var coords1 = coords[i1];\n\t                    ctx.beginPath();\n\t                    for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\n\t                        dattr.coords = coords1[j1];\n\t                        var pixels = gmxAPIutils.getRingPixels(dattr);\n\t                        dattr.coords = pixels.coords;\n\t                        gmxAPIutils.polygonToCanvasFill(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    ctx.fill();\n\t                }\n\t            }\n\t        }\n\t        ctx = dattr.tile.getContext('2d');\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.drawImage(canvas, 0, 0);\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t\n\t        isPointInClipPolygons: function isPointInClipPolygons(point) {\n\t            // point [x, y] in Mercator\n\t            return _isPointInClipPolygons(point, this._gmx._clipPolygons);\n\t        },\n\t\n\t        addClipPolygon: function addClipPolygon(polygon) {\n\t            // (L.Polygon) or (L.GeoJSON with Polygons)\n\t            var item = [],\n\t                i,\n\t                len;\n\t\n\t            if ('coordinates' in polygon && 'type' in polygon) {\n\t                item.push(getClipPolygonItem(polygon));\n\t            } else if (polygon instanceof L.Polygon) {\n\t                item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\n\t            } else if (polygon instanceof L.GeoJSON) {\n\t                var layers = polygon.getLayers();\n\t                for (i = 0, len = layers.length; i < len; i++) {\n\t                    var layer = layers[i];\n\t                    if (layer instanceof L.Polygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    } else if (layer instanceof L.MultiPolygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    }\n\t                }\n\t            }\n\t            if (item.length) {\n\t                var gmx = this._gmx,\n\t                    dataManager = gmx.dataManager,\n\t                    _this = this,\n\t                    id = L.stamp(polygon);\n\t\n\t                if (!this._gmx._clipPolygons) {\n\t                    this._gmx._clipPolygons = {};\n\t                }\n\t                this._gmx._clipPolygons[id] = item;\n\t                dataManager.setTileFilteringHook(function (tile) {\n\t                    return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipFilter', function (item, tile, observer) {\n\t                    return isObserverIntersects(observer, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipPointsFilter', function (item) {\n\t                    if (item.type === 'POINT') {\n\t                        var propArr = item.properties,\n\t                            geom = propArr[propArr.length - 1];\n\t                        return _isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\n\t                    }\n\t                    return true;\n\t                });\n\t                if (Object.keys(this._gmx._clipPolygons).length === 1) {\n\t                    gmx.renderHooks.unshift(function (tile, hookInfo) {\n\t                        if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\n\t                            clipTileByPolygon({\n\t                                tile: tile,\n\t                                tpx: hookInfo.tpx,\n\t                                tpy: hookInfo.tpy,\n\t                                gmx: { mInPixel: gmx.mInPixel },\n\t                                clipPolygons: _this._gmx._clipPolygons\n\t                            });\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        removeClipPolygon: function removeClipPolygon(polygon) {\n\t            var id = L.stamp(polygon);\n\t            if (this._gmx._clipPolygons) {\n\t                delete this._gmx._clipPolygons[id];\n\t                if (Object.keys(this._gmx._clipPolygons).length === 0) {\n\t                    this._gmx.dataManager.removeTileFilteringHook();\n\t                    this._gmx.dataManager.removeFilter('clipFilter');\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.gmxImageTransform = function (img, hash) {\n\t    var gmx = hash.gmx,\n\t        gmxTilePoint = hash.gmxTilePoint,\n\t        mInPixel = gmx.mInPixel,\n\t        geoItem = hash.geoItem,\n\t        properties = geoItem.properties,\n\t        dataOption = geoItem.dataOption || {},\n\t\n\t\n\t    // geom = properties[properties.length - 1],\n\t    // coord = geom.coordinates[0],\n\t    indexes = gmx.tileAttributeIndexes,\n\t        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\n\t        points = {};\n\t\n\t    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\n\t    if (quicklookPlatform === 'LANDSAT8') {\n\t        points.x1 = dataOption.bounds.min.x;points.y1 = dataOption.bounds.max.y;\n\t        points.x2 = dataOption.bounds.max.x;points.y2 = dataOption.bounds.max.y;\n\t        points.x3 = dataOption.bounds.max.x;points.y3 = dataOption.bounds.min.y;\n\t        points.x4 = dataOption.bounds.min.x;points.y4 = dataOption.bounds.min.y;\n\t    } else {\n\t        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\n\t    }\n\t\n\t    var x1 = mInPixel * points.x1,\n\t        y1 = mInPixel * points.y1,\n\t        x2 = mInPixel * points.x2,\n\t        y2 = mInPixel * points.y2,\n\t        x3 = mInPixel * points.x3,\n\t        y3 = mInPixel * points.y3,\n\t        x4 = mInPixel * points.x4,\n\t        y4 = mInPixel * points.y4,\n\t        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\n\t        ww = Math.round(boundsP.max.x - boundsP.min.x),\n\t        hh = Math.round(boundsP.max.y - boundsP.min.y),\n\t        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\n\t        itbounds = geoItem.item.bounds,\n\t        wMerc = gmxAPIutils.worldWidthMerc,\n\t        tpx = gmxTilePoint.x;\n\t\n\t    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\n\t        // For points intersects 180 deg\n\t        tpx += Math.round(wMerc * mInPixel / 128);\n\t    }\n\t    var dx = boundsP.min.x - 256 * tpx;\n\t\n\t    x1 -= boundsP.min.x;y1 = boundsP.max.y - y1;\n\t    x2 -= boundsP.min.x;y2 = boundsP.max.y - y2;\n\t    x3 -= boundsP.min.x;y3 = boundsP.max.y - y3;\n\t    x4 -= boundsP.min.x;y4 = boundsP.max.y - y4;\n\t\n\t    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\n\t\n\t    if (!gmx.ProjectiveImage) {\n\t        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\n\t    }\n\t    var pt = gmx.ProjectiveImage.getCanvas({\n\t        imageObj: img,\n\t        points: shiftPoints,\n\t        wView: ww,\n\t        hView: hh,\n\t        deltaX: dx,\n\t        deltaY: dy\n\t    });\n\t    return pt.canvas;\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var ProjectiveImageWebGL = L.Class.extend({\n\t        options: {\n\t            antialias: true,\n\t            depth: false,\n\t            preserveDrawingBuffer: true,\n\t            shaderVS: 'attribute vec2 aVertCoord;\\\r\n\t            uniform mat4 uTransformMatrix;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            void main(void) {\\\r\n\t                vTextureCoord = aVertCoord;\\\r\n\t                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n\t            }\\\r\n\t        ',\n\t            shaderFS: 'precision mediump float;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            uniform sampler2D uSampler;\\\r\n\t            void main(void) {\\\r\n\t                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n\t            }\\\r\n\t        '\n\t        },\n\t\n\t        setOptions: function setOptions(options) {\n\t            L.setOptions(this, options);\n\t        },\n\t\n\t        initialize: function initialize(options) {\n\t            this.setOptions(options);\n\t\n\t            var canvas = document.createElement('canvas'),\n\t                glOpts = {\n\t                antialias: this.options.antialias,\n\t                depth: this.options.depth,\n\t                preserveDrawingBuffer: this.options.preserveDrawingBuffer\n\t            },\n\t                gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\n\t            if (!gl) {\n\t                return;\n\t            }\n\t            var glResources = this._setupGlContext(gl);\n\t            if (!glResources) {\n\t                return;\n\t            }\n\t\n\t            canvas.width = canvas.height = 256;\n\t            glResources.canvas = canvas;\n\t\n\t            this.glResources = glResources;\n\t            this.canvas = canvas;\n\t            this.gl = gl;\n\t        },\n\t\n\t        _getShader: function _getShader(type, source, gl) {\n\t            var shader = gl.createShader(type);\n\t\n\t            gl.shaderSource(shader, source);\n\t            gl.compileShader(shader);\n\t\n\t            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t                gl.deleteShader(shader);\n\t                return null;\n\t            }\n\t            return shader;\n\t        },\n\t\n\t        _setupGlContext: function _setupGlContext(gl) {\n\t            // Store return values here\n\t            var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\n\t                fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\n\t\n\t            if (vertexShader && fragmentShader) {\n\t                // Compile the program\n\t                var shaderProgram = gl.createProgram();\n\t                gl.attachShader(shaderProgram, vertexShader);\n\t                gl.attachShader(shaderProgram, fragmentShader);\n\t                gl.linkProgram(shaderProgram);\n\t\n\t                if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n\t                    // Find and set up the uniforms and attributes\n\t                    gl.useProgram(shaderProgram);\n\t                    this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n\t                    var vertexBuffer = gl.createBuffer(),\n\t\n\t                    // Create a buffer to hold the vertices\n\t                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\n\t                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\t                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n\t\n\t                    // draw the triangles\n\t                    gl.enableVertexAttribArray(vertAttrib);\n\t                    gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\n\t                    return {\n\t                        transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\n\t                        samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\n\t                        screenTexture: gl.createTexture() // Create a texture to use for the screen image\n\t                    };\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        _bindTexture: function _bindTexture(gl, image, texture) {\n\t            gl.bindTexture(gl.TEXTURE_2D, texture);\n\t            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\n\t            // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t            // Prevents s-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t            // Prevents t-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t            gl.bindTexture(gl.TEXTURE_2D, null);\n\t        },\n\t\n\t        getCanvas: function getCanvas(attr) {\n\t            var p = attr.points,\n\t                deltaX = attr.deltaX,\n\t                deltaY = attr.deltaY,\n\t                dstPoints = new Float32Array([(p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128, (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128, (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128, (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128]);\n\t\n\t            var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\n\t                gl = this.gl,\n\t                glResources = this.glResources;\n\t\n\t            this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\n\t\n\t            gl.viewport(0, 0, 256, 256);\n\t            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // set background to full transparency\n\t\n\t            gl.uniformMatrix4fv(glResources.transMatUniform, false, [v[0], v[3], 0, v[6], v[1], v[4], 0, v[7], 0, 0, 1, 0, v[2], v[5], 0, 1]);\n\t\n\t            gl.activeTexture(gl.TEXTURE0);\n\t            gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\n\t            gl.uniform1i(glResources.samplerUniform, 0);\n\t\n\t            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t            return this;\n\t        }\n\t    });\n\t\n\t    function adj(m) {\n\t        // Compute the adjugate of m\n\t        return [m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4], m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5], m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]];\n\t    }\n\t\n\t    function multmm(a, b) {\n\t        // multiply two matrices\n\t        var c = Array(9);\n\t        for (var i = 0; i !== 3; ++i) {\n\t            for (var j = 0; j !== 3; ++j) {\n\t                var cij = 0;\n\t                for (var k = 0; k !== 3; ++k) {\n\t                    cij += a[3 * i + k] * b[3 * k + j];\n\t                }\n\t                c[3 * i + j] = cij;\n\t            }\n\t        }\n\t        return c;\n\t    }\n\t\n\t    function multmv(m, v) {\n\t        // multiply matrix and vector\n\t        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n\t    }\n\t\n\t    function basisToPoints(p) {\n\t        var m = [p[0], p[2], p[4], p[1], p[3], p[5], 1, 1, 1];\n\t        var v = multmv(adj(m), [p[6], p[7], 1]);\n\t        return multmm(m, [v[0], 0, 0, 0, v[1], 0, 0, 0, v[2]]);\n\t    }\n\t\n\t    ProjectiveImageWebGL.Utils = {\n\t        general2DProjection: function general2DProjection(from, to) {\n\t            var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\n\t            if (arr[8]) {\n\t                for (var i = 0; i !== 9; ++i) {\n\t                    arr[i] = arr[i] / arr[8];\n\t                }\n\t            }\n\t            return arr;\n\t        },\n\t\n\t        getWebGlResources: function getWebGlResources(options) {\n\t            var obj = new ProjectiveImageWebGL(options);\n\t            return obj.gl ? obj : null;\n\t        }\n\t    };\n\t    L.gmx.projectiveImageWebGL = function (options) {\n\t        var res = new ProjectiveImageWebGL(options);\n\t        return res.gl ? res : null;\n\t    };\n\t})();\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\t// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\n\t\tvar ProjectiveImage = function ProjectiveImage() {\n\t\t\tvar cnt = 0,\n\t\t\t    limit = 4,\n\t\t\t    patchSize = 64,\n\t\t\t    transform = null;\n\t\n\t\t\tvar allocate = function allocate(w, h) {\n\t\t\t\tvar values = [];\n\t\t\t\tfor (var i = 0; i < h; ++i) {\n\t\t\t\t\tvalues[i] = [];\n\t\t\t\t\tfor (var j = 0; j < w; ++j) {\n\t\t\t\t\t\tvalues[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t};\n\t\n\t\t\tvar Matrix = function Matrix(w, h, values) {\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.values = values || allocate(h);\n\t\t\t};\n\t\n\t\t\tvar cloneValues = function cloneValues(values) {\n\t\t\t\tvar clone = [];\n\t\t\t\tfor (var i = 0; i < values.length; ++i) {\n\t\t\t\t\tclone[i] = [].concat(values[i]);\n\t\t\t\t}\n\t\t\t\treturn clone;\n\t\t\t};\n\t\n\t\t\tMatrix.prototype = {\n\t\t\t\tadd: function add(operand) {\n\t\t\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix add size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (var x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] + operand.values[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t},\n\t\t\t\ttransformProjectiveVector: function transformProjectiveVector(operand) {\n\t\t\t\t\tvar out = [],\n\t\t\t\t\t    x,\n\t\t\t\t\t    y;\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tout[y] = 0;\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar zn = out[out.length - 1];\n\t\t\t\t\tif (zn) {\n\t\t\t\t\t\tvar iz = 1 / out[out.length - 1];\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tout[y] *= iz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn out;\n\t\t\t\t},\n\t\t\t\tmultiply: function multiply(operand) {\n\t\t\t\t\tvar values, x, y;\n\t\t\t\t\tif (+operand !== operand) {\n\t\t\t\t\t\t// Matrix mult\n\t\t\t\t\t\tif (operand.h !== this.w) {\n\t\t\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\n\t\t\t\t\t\t\t\tvar accum = 0;\n\t\t\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\n\t\t\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalues[y][x] = accum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(operand.w, this.h, values);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Scalar mult\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trowEchelon: function rowEchelon() {\n\t\t\t\t\tif (this.w <= this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = cloneValues(this.values);\n\t\n\t\t\t\t\t// Do Gauss-Jordan algorithm.\n\t\t\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\n\t\t\t\t\t\t// Look up pivot value.\n\t\t\t\t\t\tvar pivot = temp[yp][yp];\n\t\t\t\t\t\twhile (pivot === 0) {\n\t\t\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\n\t\t\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\n\t\t\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\n\t\t\t\t\t\t\t\t\t// Swap rows.\n\t\t\t\t\t\t\t\t\tvar tmpRow = temp[ys];\n\t\t\t\t\t\t\t\t\ttemp[ys] = temp[yp];\n\t\t\t\t\t\t\t\t\ttemp[yp] = tmpRow;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ys === this.h) {\n\t\t\t\t\t\t\t\t// No suitable pivot found. Abort.\n\t\t\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpivot = temp[yp][yp];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Normalize this row.\n\t\t\t\t\t\tvar scale = 1 / pivot;\n\t\t\t\t\t\tfor (var x = yp; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[yp][x] *= scale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Subtract this row from all other rows (scaled).\n\t\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tif (y === yp) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar factor = temp[y][yp];\n\t\t\t\t\t\t\ttemp[y][yp] = 0;\n\t\t\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\n\t\t\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t},\n\t\t\t\tinvert: function invert() {\n\t\t\t\t\tvar x, y;\n\t\n\t\t\t\t\tif (this.w !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix invert size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = allocate(this.w * 2, this.h);\n\t\n\t\t\t\t\t// Initialize augmented matrix\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[y][x] = this.values[y][x];\n\t\t\t\t\t\t\ttemp[y][x + this.w] = x === y ? 1 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\n\t\t\t\t\ttemp = temp.rowEchelon();\n\t\n\t\t\t\t\t// Extract right block matrix.\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (y = 0; y < this.w; ++y) {\n\t\t\t\t\t\t// @todo check if \"x < this.w;\" is mistake\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tvar getProjectiveTransform = function getProjectiveTransform(points) {\n\t\t\t\tvar eqMatrix = new Matrix(9, 8, [[1, 1, 1, 0, 0, 0, -points[2][0], -points[2][0], -points[2][0]], [0, 1, 1, 0, 0, 0, 0, -points[3][0], -points[3][0]], [1, 0, 1, 0, 0, 0, -points[1][0], 0, -points[1][0]], [0, 0, 1, 0, 0, 0, 0, 0, -points[0][0]], [0, 0, 0, -1, -1, -1, points[2][1], points[2][1], points[2][1]], [0, 0, 0, 0, -1, -1, 0, points[3][1], points[3][1]], [0, 0, 0, -1, 0, -1, points[1][1], 0, points[1][1]], [0, 0, 0, 0, 0, -1, 0, 0, points[0][1]]]);\n\t\n\t\t\t\tvar kernel = eqMatrix.rowEchelon().values;\n\t\t\t\tvar transform = new Matrix(3, 3, [[-kernel[0][8], -kernel[1][8], -kernel[2][8]], [-kernel[3][8], -kernel[4][8], -kernel[5][8]], [-kernel[6][8], -kernel[7][8], 1]]);\n\t\t\t\treturn transform;\n\t\t\t};\n\t\n\t\t\tvar divide = function divide(u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\n\t\t\t\tif (limit) {\n\t\t\t\t\t// Measure patch non-affinity.\n\t\t\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\n\t\t\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\n\t\t\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\n\t\t\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\n\t\n\t\t\t\t\t// Measure patch area.\n\t\t\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\n\t\t\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\n\t\t\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\n\t\n\t\t\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\n\t\t\t\t\t// The non-affinity measure is used as a correction factor.\n\t\t\t\t\tif (u1 === 0 && u4 === 1 || (.25 + r * 5) * area > patchSize * patchSize) {\n\t\t\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\n\t\t\t\t\t\tvar umid = (u1 + u4) / 2;\n\t\t\t\t\t\tvar vmid = (v1 + v4) / 2;\n\t\t\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\n\t\t\t\t\t\tvar pt = transform.transformProjectiveVector([umid, v1, 1]);\n\t\t\t\t\t\tvar pb = transform.transformProjectiveVector([umid, v4, 1]);\n\t\t\t\t\t\tvar pl = transform.transformProjectiveVector([u1, vmid, 1]);\n\t\t\t\t\t\tvar pr = transform.transformProjectiveVector([u4, vmid, 1]);\n\t\n\t\t\t\t\t\t// Subdivide.\n\t\t\t\t\t\tlimit--;\n\t\t\t\t\t\tdivide.call(this, u1, v1, umid, vmid, p1, pt, pl, pmid, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, v1, u4, vmid, pt, p2, pmid, pr, limit, attr);\n\t\t\t\t\t\tdivide.call(this, u1, vmid, umid, v4, pl, pmid, p3, pb, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, vmid, u4, v4, pmid, pr, pb, p4, limit, attr);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar ctx = attr.ctx;\n\t\n\t\t\t\t// Get patch edge vectors.\n\t\t\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\n\t\t\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\n\t\t\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\n\t\t\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\n\t\n\t\t\t\t// Find the corner that encloses the most area\n\t\t\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\n\t\t\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\n\t\t\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\n\t\t\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\n\t\t\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\n\t\t\t\tvar dx = 0,\n\t\t\t\t    dy = 0,\n\t\t\t\t    padx = 0,\n\t\t\t\t    pady = 0;\n\t\n\t\t\t\t// Align the transform along this corner.\n\t\t\t\t// Calculate 1.05 pixel padding on vector basis.\n\t\t\t\tif (amax === a1) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t} else if (amax === a2) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], d24[0], d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t} else if (amax === a4) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t\tdy = -1;\n\t\t\t\t} else if (amax === a3) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdy = -1;\n\t\t\t\t}\n\t\n\t\t\t\t// Calculate image padding to match.\n\t\t\t\tvar du = u4 - u1;\n\t\t\t\tvar dv = v4 - v1;\n\t\t\t\tpadx++;\n\t\t\t\tpady++;\n\t\n\t\t\t\tvar iw = attr.imageObj.width,\n\t\t\t\t    ih = attr.imageObj.height,\n\t\t\t\t    sx = Math.floor(u1 * iw),\n\t\t\t\t    sy = Math.floor(v1 * ih),\n\t\t\t\t    sw = Math.floor(Math.min(padx * du, 1) * iw),\n\t\t\t\t    sh = Math.floor(Math.min(pady * dv, 1) * ih);\n\t\n\t\t\t\tcnt++;\n\t\t\t\tctx.drawImage(attr.imageObj, sx, sy, sw, sh, dx, dy, padx, pady);\n\t\t\t};\n\t\n\t\t\tthis.getCanvas = function (attr) {\n\t\t\t\tcnt = 0;\n\t\t\t\ttransform = getProjectiveTransform(attr.points);\n\t\t\t\t// Begin subdivision process.\n\t\n\t\t\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\n\t\t\t\t    ptr = transform.transformProjectiveVector([1, 0, 1]),\n\t\t\t\t    pbl = transform.transformProjectiveVector([0, 1, 1]),\n\t\t\t\t    pbr = transform.transformProjectiveVector([1, 1, 1]);\n\t\n\t\t\t\tvar canvas = document.createElement('canvas');\n\t\t\t\tcanvas.width = canvas.height = 256;\n\t\t\t\tattr.canvas = canvas;\n\t\t\t\tattr.ctx = canvas.getContext('2d');\n\t\n\t\t\t\tvar boundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\n\t\t\t\t    maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\n\t\n\t\t\t\tlimit = 'limit' in attr ? attr.limit : maxSize < 200 ? 1 : 4;\n\t\t\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log('Error: ProjectiveImage event:', e);\n\t\t\t\t\tcanvas = null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tptl: ptl,\n\t\t\t\t\tptr: ptr,\n\t\t\t\t\tpbl: pbl,\n\t\t\t\t\tpbr: pbr,\n\t\t\t\t\tcnt: cnt\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tL.gmx.projectiveImage = function () {\n\t\t\treturn new ProjectiveImage();\n\t\t};\n\t})();\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\n\t\n\tL.RotatedMarker = L.Marker.extend({\n\t    options: {\n\t        angle: 0\n\t    },\n\t\n\t    statics: {\n\t        TRANSFORM_ORIGIN: L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\n\t    },\n\t\n\t    _initIcon: function _initIcon() {\n\t        L.Marker.prototype._initIcon.call(this);\n\t\n\t        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\n\t    },\n\t\n\t    _getTransformOrigin: function _getTransformOrigin() {\n\t        var iconAnchor = this.options.icon.options.iconAnchor;\n\t\n\t        if (!iconAnchor) {\n\t            return '50% 50%';\n\t        }\n\t\n\t        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\n\t    },\n\t\n\t    _setPos: function _setPos(pos) {\n\t        L.Marker.prototype._setPos.call(this, pos);\n\t\n\t        if (L.DomUtil.TRANSFORM) {\n\t            // use the CSS transform rule if available\n\t            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\n\t        } else if (L.Browser.ie) {\n\t            // fallback for IE6, IE7, IE8\n\t            var rad = this.options.angle * (Math.PI / 180),\n\t                costheta = Math.cos(rad),\n\t                sintheta = Math.sin(rad);\n\t            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + costheta + ', M12=' + -sintheta + ', M21=' + sintheta + ', M22=' + costheta + ')';\n\t        }\n\t    },\n\t\n\t    setAngle: function setAngle(ang) {\n\t        this.options.angle = ang;\n\t    }\n\t});\n\t\n\tL.rotatedMarker = function (pos, options) {\n\t    return new L.RotatedMarker(pos, options);\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.ExternalLayer = L.Class.extend({\n\t    createExternalLayer: function createExternalLayer() {\n\t        // extend: must return <ILayer> or null = this.externalLayer\n\t        return null;\n\t    },\n\t\n\t    isExternalVisible: function isExternalVisible() /*zoom*/{\n\t        // extend: return true view this.externalLayer, return false view this.parentLayer\n\t        return true;\n\t    },\n\t\n\t    updateData: function updateData() /*data*/{// extend: for data update in this.externalLayer\n\t    },\n\t\n\t    setDateInterval: function setDateInterval() {\n\t        if (this._observer) {\n\t            var gmx = this.parentLayer._gmx;\n\t            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\n\t        }\n\t    },\n\t\n\t    options: {\n\t        useDataManager: true,\n\t        observerOptions: {\n\t            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\n\t        }\n\t    },\n\t\n\t    initialize: function initialize(options, layer) {\n\t        L.setOptions(this, options);\n\t        this.parentLayer = layer;\n\t        layer.on('add', this._addEvent, this).on('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this.options.useDataManager) {\n\t            this._addObserver(this.options.observerOptions);\n\t        }\n\t\n\t        this.externalLayer = this.createExternalLayer();\n\t\n\t        if (layer._map) {\n\t            this._addEvent({ target: { _map: layer._map } });\n\t            this._updateBbox();\n\t        }\n\t    },\n\t\n\t    _addObserver: function _addObserver(opt) {\n\t        this._items = {};\n\t        this._observer = this.parentLayer.addObserver(L.extend({\n\t            bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\n\t            callback: L.bind(this.updateData, this)\n\t        }, opt)).deactivate();\n\t    },\n\t\n\t    unbindLayer: function unbindLayer() {\n\t        this.parentLayer.off('add', this._addEvent, this).off('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this._observer) {\n\t            delete this.parentLayer.repaintObservers[this._observer.id];\n\t        }\n\t        var map = this._map || this.parentLayer._map;\n\t        this._onRemove(!map);\n\t        this._removeMapHandlers();\n\t    },\n\t\n\t    _addMapHandlers: function _addMapHandlers(map) {\n\t        this._map = map;\n\t        this._map.on({\n\t            moveend: this._updateBbox,\n\t            zoomend: this._chkZoom,\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        }, this);\n\t    },\n\t\n\t    _removeMapHandlers: function _removeMapHandlers() {\n\t        if (this._map) {\n\t            this._map.off({\n\t                moveend: this._updateBbox,\n\t                zoomend: this._chkZoom,\n\t                layeradd: this._layeradd,\n\t                layerremove: this._layerremove\n\t            }, this);\n\t        }\n\t        this._map = null;\n\t    },\n\t\n\t    _addEvent: function _addEvent(ev) {\n\t        this._addMapHandlers(ev.target._map);\n\t        this._updateBbox();\n\t        this._chkZoom();\n\t    },\n\t\n\t    _isParentLayer: function _isParentLayer(ev) {\n\t        var layer = ev.layer;\n\t        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\n\t    },\n\t\n\t    _layeradd: function _layeradd(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._chkZoom();\n\t        }\n\t    },\n\t\n\t    _layerremove: function _layerremove(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._onRemove(true);\n\t            this._removeMapHandlers();\n\t        }\n\t    },\n\t\n\t    _onRemove: function _onRemove(fromMapFlag) {\n\t        // remove external layer from parent layer\n\t        if (this._observer) {\n\t            this._observer.deactivate();\n\t        }\n\t        var map = this._map;\n\t        if (map) {\n\t            if (map.hasLayer(this.externalLayer)) {\n\t                this._chkZoom();\n\t                map.removeLayer(this.externalLayer);\n\t            }\n\t            if (!fromMapFlag) {\n\t                this.parentLayer.onAdd(map);\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkZoom: function _chkZoom() {\n\t        if (!this._map) {\n\t            return;\n\t        }\n\t\n\t        var layer = this.parentLayer,\n\t            observer = this._observer,\n\t            map = this._map,\n\t            isExtLayerOnMap = map.hasLayer(this.externalLayer);\n\t\n\t        layer.setCurrentZoom(map);\n\t        if (!this.isExternalVisible(map.getZoom())) {\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            if (!layer._map) {\n\t                if (isExtLayerOnMap) {\n\t                    map.removeLayer(this.externalLayer);\n\t                }\n\t                layer.onAdd(map);\n\t            }\n\t            layer.enablePopup();\n\t        } else if (layer._map) {\n\t            layer.onRemove(map);\n\t            if (!isExtLayerOnMap) {\n\t                map.addLayer(this.externalLayer);\n\t            }\n\t            this.setDateInterval();\n\t            if (observer) {\n\t                layer.getIcons(function () {\n\t                    observer.activate();\n\t                }.bind(this));\n\t            }\n\t            layer.disablePopup();\n\t        }\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        if (!this._map || !this._observer) {\n\t            return;\n\t        }\n\t\n\t        var screenBounds = this._map.getBounds(),\n\t            p1 = screenBounds.getNorthWest(),\n\t            p2 = screenBounds.getSouthEast(),\n\t            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\n\t        this._observer.setBounds(bbox);\n\t    }\n\t});\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var BindWMS = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minZoom: 1,\n\t            maxZoom: 6,\n\t            useDataManager: false,\n\t            format: 'png',\n\t            transparent: true\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var poptions = this.parentLayer.options,\n\t                opt = {\n\t                map: poptions.mapID,\n\t                layers: poptions.layerID,\n\t                format: this.options.format,\n\t                transparent: this.options.transparent\n\t            },\n\t                rawProperties = this.parentLayer.getGmxProperties();\n\t\n\t            if (rawProperties && rawProperties.Temporal) {\n\t                this._extendOptionsByDateInterval(opt);\n\t            }\n\t            if (this.options.apikey) {\n\t                opt.apikey = this.options.apikey;\n\t            }\n\t            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\n\t        },\n\t\n\t        _extendOptionsByDateInterval: function _extendOptionsByDateInterval(options) {\n\t            var dateInterval = this.parentLayer.getDateInterval(),\n\t                beginDate = dateInterval.beginDate,\n\t                endDate = dateInterval.endDate;\n\t            L.extend(options, {\n\t                StartDate: beginDate && beginDate.toLocaleDateString(),\n\t                EndDate: endDate && endDate.toLocaleDateString()\n\t            });\n\t        },\n\t\n\t        setDateInterval: function setDateInterval() {\n\t            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\n\t            this.externalLayer.redraw();\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindWMS: function bindWMS(options) {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t            }\n\t            this._layerWMS = new BindWMS(options, this);\n\t            this.isExternalVisible = this._layerWMS.isExternalVisible;\n\t            return this;\n\t        },\n\t\n\t        unbindWMS: function unbindWMS() {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t                this._layerWMS = null;\n\t                this.isExternalVisible = null;\n\t                this.enablePopup();\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var GmxHeatMap = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minHeatMapZoom: 1,\n\t            maxHeatMapZoom: 6,\n\t            intensityField: '',\n\t            intensityScale: 1,\n\t            observerOptions: {\n\t                type: 'resend'\n\t            }\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            return L.heatLayer([], L.extend({\n\t                // minOpacity: 0.05,\n\t                // maxZoom: 18,\n\t                // radius: 25,\n\t                // blur: 15,\n\t                // max: 1.0\n\t            }, this.options));\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            if (data.added) {\n\t                var latlngs = [],\n\t                    indexes = this.parentLayer.getTileAttributeIndexes(),\n\t                    altIndex = null,\n\t                    intensityField = this.options.intensityField || '',\n\t                    intensityScale = this.options.intensityScale || 1;\n\t\n\t                if (intensityField && intensityField in indexes) {\n\t                    altIndex = indexes[intensityField];\n\t                }\n\t                for (var i = 0, len = data.added.length; i < len; i++) {\n\t                    var it = data.added[i].properties,\n\t                        alt = altIndex !== null ? it[altIndex] : 1,\n\t                        geo = it[it.length - 1],\n\t                        coord = geo.coordinates,\n\t                        point = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t\n\t                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\n\t                }\n\t                this.externalLayer.setLatLngs(latlngs);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindHeatMap: function bindHeatMap(options) {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                }\n\t                this._heatmap = new GmxHeatMap(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindHeatMap: function unbindHeatMap() {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                    this._heatmap = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var _DEFAULTS = {\n\t        radiusFunc: function radiusFunc(count) {\n\t            var r = Math.floor(count / 15);\n\t            if (r > 40) {\n\t                r = 40;\n\t            } else if (r < 20) {\n\t                r = 20;\n\t            }\n\t            return r;\n\t        },\n\t        text: {\n\t            stroke: 'black',\n\t            'stroke-width': 1,\n\t            'text-anchor': 'middle',\n\t            fill: 'white'\n\t        }\n\t    };\n\t    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            observerOptions: {\n\t                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\n\t            },\n\t            spiderfyOnMaxZoom: true,\n\t            minZoom: 1,\n\t            maxZoom: 6\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var mOptions = L.extend({\n\t                showCoverageOnHover: false,\n\t                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\n\t            }, this.options);\n\t\n\t            if ('clusterIconOptions' in this.options) {\n\t                var opt = this.options.clusterIconOptions;\n\t                if ('radialGradient' in opt) {\n\t                    var radialGradient = opt.radialGradient,\n\t                        text = opt.text || _DEFAULTS.text;\n\t                    mOptions.iconCreateFunction = function (cluster) {\n\t                        var childCount = cluster.getChildCount();\n\t\n\t                        text.count = childCount;\n\t                        return L.gmxUtil.getSVGIcon({\n\t                            type: 'circle',\n\t                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\n\t                            text: text,\n\t                            fillRadialGradient: radialGradient\n\t                        });\n\t                    };\n\t                }\n\t            }\n\t\n\t            if (this.options.clusterclick) {\n\t                mOptions.clusterclick = this.options.clusterclick;\n\t                if (mOptions.clusterclick === true) {\n\t                    mOptions.zoomToBoundsOnClick = false;\n\t                }\n\t            }\n\t\n\t            this._popup = new L.Popup({ maxWidth: 10000, className: 'gmxPopup' });\n\t            var markers = new L.MarkerClusterGroup(mOptions);\n\t\n\t            // текущий развёрнутый кластер\n\t            var currentSpiderfiedCluster = null;\n\t\n\t            markers.on('click', function (ev) {\n\t                var propsArr = ev.layer.options.properties,\n\t                    properties = this.parentLayer.getItemProperties(propsArr),\n\t                    geometry = [propsArr[propsArr.length - 1]],\n\t                    id = propsArr[0];\n\t\n\t                if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\n\t                    currentSpiderfiedCluster.unspiderfy();\n\t                    markers.once('unspiderfied', function () {\n\t                        this._openPopup(propsArr, ev.latlng);\n\t                    }, this);\n\t                } else {\n\t                    this._openPopup(propsArr, ev.latlng);\n\t                }\n\t\n\t                this.parentLayer.fire('click', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'click',\n\t                    gmx: {\n\t                        id: id,\n\t                        layer: this.parentLayer,\n\t                        properties: properties,\n\t                        target: {\n\t                            id: id,\n\t                            properties: propsArr,\n\t                            geometry: geometry\n\t                        }\n\t                    }\n\t                }));\n\t            }, this).on('animationend', function () {\n\t                if (this._popup && this._popup._map) {\n\t                    this._popup._map.removeLayer(this._popup);\n\t                }\n\t            }, this).on('clusterclick', function (ev) {\n\t                this.parentLayer.fire('clusterclick', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'clusterclick'\n\t                }));\n\t            }, this).on('spiderfied', function (ev) {\n\t                currentSpiderfiedCluster = ev.cluster;\n\t            }, this).on('unspiderfied', function () {\n\t                currentSpiderfiedCluster = null;\n\t            }, this);\n\t\n\t            if (mOptions.clusterclick) {\n\t                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\n\t                    a.layer.spiderfy();\n\t                });\n\t            }\n\t\n\t            return markers;\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            var arr = [],\n\t                i,\n\t                len,\n\t                vectorTileItem,\n\t                id,\n\t                marker;\n\t            if (data.removed) {\n\t                for (i = 0, len = data.removed.length; i < len; i++) {\n\t                    vectorTileItem = data.removed[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    if (marker) {\n\t                        arr.push(marker);\n\t                    }\n\t                    delete this._items[id];\n\t                }\n\t                this.externalLayer.removeLayers(arr);\n\t                arr = [];\n\t            }\n\t            if (data.added) {\n\t                for (i = 0, len = data.added.length; i < len; i++) {\n\t                    vectorTileItem = data.added[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    var item = vectorTileItem.properties;\n\t                    if (marker && item.processing) {\n\t                        this.externalLayer.removeLayer(marker);\n\t                        marker = null;\n\t                    }\n\t                    if (!marker) {\n\t                        if (!vectorTileItem.item.parsedStyleKeys) {\n\t                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\n\t                        }\n\t                        var geo = item[item.length - 1],\n\t                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\n\t                            p = geo.coordinates,\n\t                            latlng = L.Projection.Mercator.unproject({ x: p[0], y: p[1] }),\n\t                            opt = {\n\t                            properties: vectorTileItem.properties,\n\t                            mPoint: p\n\t                        };\n\t\n\t                        if (this.options.notClusteredIcon) {\n\t                            var icon = this.options.notClusteredIcon;\n\t                            if (icon instanceof L.Icon) {\n\t                                opt.icon = icon;\n\t                            } else {\n\t                                opt.icon = L.icon(icon);\n\t                            }\n\t                        } else if (parsedStyle) {\n\t                            if (parsedStyle.iconUrl) {\n\t                                var iconAnchor = parsedStyle.iconAnchor;\n\t                                if (!iconAnchor) {\n\t                                    var style = this.parentLayer.getItemStyle(id);\n\t                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\n\t                                }\n\t                                opt.icon = L.icon({\n\t                                    iconAnchor: iconAnchor,\n\t                                    iconUrl: parsedStyle.iconUrl\n\t                                });\n\t                            } else {\n\t                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\n\t                            }\n\t                        }\n\t                        if (parsedStyle.rotate) {\n\t                            marker = L.rotatedMarker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        } else {\n\t                            marker = L.marker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        }\n\t                        this._items[id] = marker;\n\t                    }\n\t                    arr.push(marker);\n\t                }\n\t                this.externalLayer.addLayers(arr);\n\t            }\n\t        },\n\t\n\t        _openPopup: function _openPopup(propsArr, latlng) {\n\t            var gmx = this.parentLayer._gmx,\n\t                id = propsArr[0],\n\t                balloonData = gmx.styleManager.getItemBalloon(id),\n\t                properties = this.parentLayer.getItemProperties(propsArr),\n\t                geometry = [propsArr[propsArr.length - 1]];\n\t\n\t            if (balloonData && !balloonData.DisableBalloonOnClick) {\n\t                var style = this.parentLayer.getItemStyle(id);\n\t                if (style && style.iconAnchor) {\n\t                    var protoOffset = L.Popup.prototype.options.offset;\n\t                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2, protoOffset[1] - style.iconAnchor[1] + style.sy / 2];\n\t                }\n\t                this._popup.setLatLng(latlng).setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: gmx.tileAttributeTypes,\n\t                    unitOptions: this._map.options || {},\n\t                    geometries: geometry\n\t                })).openOn(this._map);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindClusters: function bindClusters(options) {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                }\n\t                this._clusters = new GmxMarkerCluster(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindClusters: function unbindClusters() {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                    this._clusters = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx = L.gmx || {};\n\t\n\t\n\tvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\n\tvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\n\t\n\t//Build in layer classes\n\tL.gmx._layerClasses = {\n\t    'Raster': L.gmx.RasterLayer,\n\t    'Vector': L.gmx.VectorLayer,\n\t    'VectorView': L.gmx.DummyLayer\n\t};\n\t\n\tL.gmx._loadingLayerClasses = {};\n\t\n\tL.gmx.addLayerClass = function (type, layerClass) {\n\t    L.gmx._layerClasses[type] = layerClass;\n\t};\n\t\n\tL.gmx._layerClassLoaders = [];\n\t\n\tL.gmx.addLayerClassLoader = function (layerClassLoader) {\n\t    L.gmx._layerClassLoaders.push(layerClassLoader);\n\t\n\t    //delete all loading promises to ensure that new loader will be invoked\n\t    L.gmx._loadingLayerClasses = {};\n\t};\n\t\n\tL.gmx._loadLayerClass = function (type) {\n\t    if (!L.gmx._loadingLayerClasses[type]) {\n\t        var promise = new L.gmx.Deferred();\n\t        promise.resolve();\n\t\n\t        L.gmx._layerClassLoaders.forEach(function (loader) {\n\t            promise = promise.then(function (layerClass) {\n\t                if (layerClass) {\n\t                    L.gmx._layerClasses[type] = layerClass;\n\t                    return layerClass;\n\t                }\n\t\n\t                return loader(type);\n\t            }, function () {\n\t                //just skip loader errors\n\t            });\n\t        });\n\t\n\t        promise = promise.then(function (layerClass) {\n\t            if (layerClass) {\n\t                L.gmx._layerClasses[type] = layerClass;\n\t                return layerClass;\n\t            }\n\t        }, function () {\n\t            //just skip loader errors\n\t        });\n\t\n\t        L.gmx._loadingLayerClasses[type] = promise;\n\t    }\n\t\n\t    return L.gmx._loadingLayerClasses[type];\n\t};\n\t\n\tL.gmx.loadLayer = function (mapID, layerID, options) {\n\t\n\t    var promise = new L.gmx.Deferred(),\n\t        layerParams = {\n\t        mapID: mapID,\n\t        layerID: layerID\n\t    };\n\t\n\t    options = options || {};\n\t\n\t    for (var p in options) {\n\t        layerParams[p] = options[p];\n\t    }\n\t\n\t    var hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t    layerParams.hostName = hostName;\n\t\n\t    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(function () {\n\t        var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\n\t\n\t        if (!layerInfo) {\n\t            promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\n\t            return;\n\t        }\n\t\n\t        //to know from what host the layer was loaded\n\t        layerInfo.properties.hostName = hostName;\n\t\n\t        var type = layerInfo.properties.ContentID || layerInfo.properties.type;\n\t\n\t        var doCreateLayer = function doCreateLayer() {\n\t            var layer = L.gmx.createLayer(layerInfo, layerParams);\n\t            if (layer) {\n\t                promise.resolve(layer);\n\t            } else {\n\t                promise.reject('Unknown type of layer ' + layerID);\n\t            }\n\t        };\n\t\n\t        if (type in L.gmx._layerClasses) {\n\t            doCreateLayer();\n\t        } else {\n\t            L.gmx._loadLayerClass(type).then(doCreateLayer);\n\t        }\n\t    }, function (response) {\n\t        promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\n\t    });\n\t\n\t    return promise;\n\t};\n\t\n\tL.gmx.loadLayers = function (layers, globalOptions) {\n\t    var defs = layers.map(function (layerInfo) {\n\t        var options = L.extend({}, globalOptions, layerInfo.options);\n\t        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\n\t    });\n\t\n\t    return L.gmx.Deferred.all.apply(null, defs);\n\t};\n\t\n\tL.gmx.loadMap = function (mapID, options) {\n\t    options = L.extend({}, options);\n\t    options.hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t\n\t    var def = new L.gmx.Deferred();\n\t\n\t    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function (mapInfo) {\n\t        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\n\t\n\t        loadedMap.layersCreated.then(function () {\n\t            if (options.leafletMap || options.setZIndex) {\n\t                var curZIndex = 0,\n\t                    layer,\n\t                    rawProperties;\n\t\n\t                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\n\t                    layer = loadedMap.layers[l];\n\t                    rawProperties = layer.getGmxProperties();\n\t                    if (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\n\t                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\n\t                    }\n\t                    if (options.setZIndex && layer.setZIndex) {\n\t                        layer.setZIndex(++curZIndex);\n\t                    }\n\t\n\t                    if (options.leafletMap && rawProperties.visible) {\n\t                        layer.addTo(options.leafletMap);\n\t                    }\n\t                }\n\t            }\n\t            def.resolve(loadedMap);\n\t        });\n\t    }, function (response) {\n\t        var errorMessage = response && response.ErrorInfo && response.ErrorInfo.ErrorMessage || 'Server error';\n\t        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\n\t    });\n\t    return def;\n\t};\n\t\n\tL.gmx.DummyLayer = function (props) {\n\t    this.onAdd = this.onRemove = function () {};\n\t    this.getGmxProperties = function () {\n\t        return props;\n\t    };\n\t};\n\t\n\tL.gmx.createLayer = function (layerInfo, options) {\n\t    if (!layerInfo) {\n\t        layerInfo = {};\n\t    }\n\t    if (!layerInfo.properties) {\n\t        layerInfo.properties = { type: 'Vector' };\n\t    }\n\t\n\t    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\n\t        layer;\n\t\n\t    if (type in L.gmx._layerClasses) {\n\t        try {\n\t            layer = new L.gmx._layerClasses[type](options);\n\t            layer = layer.initFromDescription(layerInfo);\n\t        } catch (e) {\n\t            layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t        }\n\t    } else {\n\t        layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t    }\n\t\n\t    return layer;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/geomixer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a47e3cc6244f5f8b025f","L.gmx = L.gmx || {};\r\n\r\n// import './commonjs.js';\r\nimport './Parsers.js';\r\nimport './Deferred.js';\r\nimport './ImageLoader.js';\r\nimport './Utils.js';\r\nimport './DrawCanvas.js';\r\nimport './SessionManager.js';\r\nimport {gmxMapManager} from './MapManager.js';\tL.gmx.gmxMapManager = gmxMapManager;\r\nimport './GeomixerMap.js';\r\nimport './EventsManager.js';\r\nimport './Locale.js';\r\nimport './lang_ru.js';\r\nimport './lang_en.js';\r\n\r\nimport './DataManager/VectorTileLoader.js';\r\nimport './DataManager/VectorTile.js';\r\nimport {Observer} from './DataManager/Observer.js';\tL.gmx.observer = function(options) { return new Observer(options); };\r\nimport './DataManager/TilesTree.js';\r\nimport {DataManager} from './DataManager/DataManager.js';\tL.gmx.DataManager = DataManager;\r\n\r\nimport './Layer/VectorLayer.js';\r\nimport './Layer/ScreenVectorTile.js';\r\nimport './Layer/ObjectsReorder.js';\r\nimport './Layer/StyleManager.js';\r\nimport './Layer/VectorLayer.Popup.js';\r\nimport './Layer/VectorLayer.Hover.js';\r\nimport './Layer/LayersVersion.js';\r\nimport './Layer/RasterLayer.js';\r\nimport './Layer/LabelsLayer.js';\r\nimport './Layer/ClipPolygon.js';\r\nimport './Layer/ImageTransform.js';\r\nimport './Layer/ProjectiveImageWebGL.js';\r\nimport './Layer/ProjectiveImage.js';\r\n\r\nimport './Layer/external/RotatedMarker.js';\r\nimport './Layer/external/ExternalLayer.js';\r\nimport './Layer/external/BindWMS.js';\r\nimport './Layer/external/HeatMap.js';\r\nimport './Layer/external/MarkerCluster.js';\r\n\r\nimport './LayerFactory.js';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/includes.js","/*\r\n   Single-pass recursive descent PEG parser library:\r\n      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n   Inspired by Chris Double's parser combinator library in JavaScript:\r\n      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t+ Добавлены функции: Math.floor\r\n*/\r\n(function() {\r\n    var regexExpression = /\\[(.+?)\\]/g,\r\n        regexMath = /(floor\\()/g;\r\n\tvar Parsers = {\t\t\t\t\t\t// Парсеры\r\n        functionFromExpression: function(s) {\r\n/*eslint-disable no-new-func*/\r\n            return new Function(\r\n/*eslint-enable */\r\n                'props',\r\n                'indexes',\r\n                'return ' +\r\n                    s\r\n                     .replace(regexExpression, 'props[indexes[\"$1\"]]')\r\n                     .replace(regexMath, 'Math.$1')\r\n                    + ';'\r\n            );\r\n        }\r\n    };\r\n\r\n\tvar makePair = function(t1, t2) {\r\n\t\treturn {head: t1, tail: t2};\r\n\t};\r\n\r\n// C-style linked list via recursive typedef.\r\n//   Used purely functionally to get shareable sublists.\r\n//typedef LinkedList = Pair<Dynamic, LinkedList>;\r\n\tvar LinkedList = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser state contains position in string and some accumulated data.\r\n//typedef ParserState = Pair<Int, LinkedList>;\r\n\tvar ParserState = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser accepts string and state, returns another state.\r\n//typedef Parser = String->ParserState->ParserState;\r\n\r\n\t// A parser state that indicates failure.\r\n\tvar fail = new ParserState(-1, null);\r\n\r\n\t// Check for failure.\r\n\tvar failed = function(state) {\r\n\t\treturn (state.head === -1);\r\n\t};\r\n\r\n\t// Advance a parser state by n characters.\r\n\tvar advance = function(state, n) {\r\n\t\treturn new ParserState(state.head + n, state.tail);\r\n\t};\r\n\r\n\t// Match a specified string.\r\n\tvar token = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len) === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a string without regard to case.\r\n\tvar caseInsensitiveToken = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\ttok = tok.toLowerCase();\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len).toLowerCase() === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a single character in a specified range.\r\n\tvar range = function(startChar, endChar) {\r\n\t\tvar startCode = startChar.charCodeAt(0);\r\n\t\tvar endCode = endChar.charCodeAt(0);\r\n\t\treturn function(s, state) {\r\n\t\t\tvar code = s.charCodeAt(state.head);\r\n\t\t\treturn ((code >= startCode) && (code <= endCode)) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match any character outside a certain set.\r\n\t//   This combinator is intended only for single character parsers.\r\n\tvar anythingExcept = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\treturn ((s.length > state.head) && failed(parser(s, state))) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, then thing2, ..., then thingN.\r\n\tvar sequence = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tstate = parsers[i](s, state);\r\n\t\t\t\tif (failed(state)) {\r\n\t\t\t\t\treturn fail;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn state;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, or thing2, ..., or thingN.\r\n\tvar choice = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tvar newState = parsers[i](s, state);\r\n\t\t\t\tif (!failed(newState)) {\r\n\t\t\t\t\treturn newState;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match immediately, without regard to what's in the string.\r\n\tvar nothing = function(s, state) {\r\n\t\treturn state;\r\n\t};\r\n\r\n\t// Match this thing or nothing.\r\n\tvar maybe = function(parser) {\r\n\t\treturn choice([parser, nothing]);\r\n\t};\r\n\r\n\t// Match minCount or more repetitions of this thing.\r\n\tvar repeat = function(minCount, parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar count = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar newState = parser(s, state);\r\n\t\t\t\tif (failed(newState)) {\r\n\t\t\t\t\treturn (count >= minCount) ? state : fail;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount += 1;\r\n\t\t\t\t\tstate = newState;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// return fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a list of minCount or more instances of thing1, separated by thing2.\r\n\tvar separatedList = function(minCount, parser, separator) {\r\n\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\r\n\t\treturn (minCount > 0) ? parser1 : choice([parser1, nothing]);\r\n\t};\r\n\r\n\tvar whitespace = repeat(0, choice([\r\n\t\ttoken(' '),\r\n\t\ttoken('\\t'),\r\n\t\ttoken('\\n')\r\n\t]));\r\n\r\n\t// Same as separatedList, but can have whitespace between items and separators.\r\n\tvar whitespaceSeparatedList = function(minCount, parser, separator) {\r\n\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\r\n\t};\r\n\r\n\t// Same as sequence, but can have whitespace between items.\r\n\tvar whitespaceSeparatedSequence = function(parsers) {\r\n\t\tvar newParsers = [];\r\n\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\tif (newParsers.length > 0) { newParsers.push(whitespace); }\r\n\t\t\tnewParsers.push(parsers[i]);\r\n\t\t}\r\n\t\treturn sequence(newParsers);\r\n\t};\r\n\r\n\t// This combinator captures the string that the parser matched\r\n\t//   and adds it to the current parser state, consing a new state.\r\n\tvar capture = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar newState = parser(s, state);\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// This combinator passes the accumulated parser state to a given\r\n\t//  function for processing. The result goes into the new state.\r\n\tvar action = function(parser, func) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar oldState = state;\r\n\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// Define a syntactic subset of SQL WHERE clauses.\r\n\tvar fieldName = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('а', 'я'),\r\n\t\trange('А', 'Я'),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_')\r\n\t])));\r\n\r\n\tvar fieldNameWithSpaces = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('а', 'я'),\r\n\t\trange('А', 'Я'),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_'),\r\n\t\ttoken(' ')\r\n\t])));\r\n\r\n\tvar quotedFieldName = choice([\r\n\t\tfieldName,\r\n\t\tsequence([token('\"'), fieldNameWithSpaces, token('\"')]),\r\n\t\tsequence([token('`'), fieldNameWithSpaces, token('`')])\r\n\t]);\r\n\r\n\tvar stringLiteral = sequence([\r\n\t\ttoken('\\''),\r\n\t\tcapture(repeat(0, anythingExcept(token('\\'')))),\r\n\t\ttoken('\\'')\r\n\t]);\r\n\r\n\tvar digits = repeat(1, range('0', '9'));\r\n\r\n\tvar numberLiteral = capture(sequence([\r\n\t\tmaybe(token('-')),\r\n\t\tdigits,\r\n\t\tmaybe(sequence([token('.'), digits]))\r\n\t]));\r\n\r\n\tvar literal = choice([numberLiteral, stringLiteral]);\r\n\r\n\tvar applyParser = function(s, parser) {\r\n\t\treturn parser(s, new ParserState(0, null));\r\n\t};\r\n\r\n\t// Order is important here: longer ops should be tried first.\r\n\tvar opTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcapture(choice([\r\n\t\t\t\ttoken('=='),\r\n\t\t\t\ttoken('!='),\r\n\t\t\t\ttoken('<>'),\r\n\t\t\t\ttoken('<='),\r\n\t\t\t\ttoken('>='),\r\n\t\t\t\ttoken('='),\r\n\t\t\t\ttoken('<'),\r\n\t\t\t\ttoken('>'),\r\n\t\t\t\tcaseInsensitiveToken('LIKE')\r\n\t\t\t])),\r\n            choice([literal, quotedFieldName])\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname, operation, value\r\n\t\t\t// (in reverse order).\r\n\r\n\t\t\tvar fieldName = state.tail.tail.head;\r\n\t\t\tvar op = state.tail.head;\r\n\t\t\tvar referenceValue = state.head;\r\n\r\n\t\t\tvar matchPattern = null;\r\n\t\t\tif (op.toUpperCase() === 'LIKE') {\r\n\t\t\t\tmatchPattern = function(fieldValue) {\r\n\t\t\t\t\tvar matchFrom = null;\r\n\t\t\t\t\tmatchFrom = function(referenceIdx, fieldIdx) {\r\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\r\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\r\n\t\t\t\t\t\tif (referenceChar === '') {\r\n\t\t\t\t\t\t\treturn (fieldChar === '');\r\n\t\t\t\t\t\t} else if (referenceChar === '%') {\r\n\t\t\t\t\t\t\treturn matchFrom(referenceIdx + 1, fieldIdx) || ((fieldChar !== '') && matchFrom(referenceIdx, fieldIdx + 1));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn (referenceChar === fieldChar) && matchFrom(referenceIdx + 1, fieldIdx + 1);\r\n                        }\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn matchFrom(0, 0);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\r\n                    rValue = referenceValue;\r\n                if (referenceValue in indexes) { rValue = props[indexes[rValue]]; }\r\n                if (types[fieldName] === 'date' && typeof rValue === 'string') { rValue = L.gmxUtil.getUnixTimeFromStr(rValue); }\r\n                if (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\r\n                    fieldValue = fieldValue ? 'True' : 'False';\r\n                }\r\n\t\t\t\tif (fieldValue === null) { return false; }\r\n\t\t\t\tif (matchPattern !== null) { return matchPattern(fieldValue);\r\n/*eslint-disable eqeqeq */\r\n                } else if ((op === '=') || (op === '==')) { return (fieldValue == rValue);\r\n\t\t\t\t} else if ((op === '!=') || (op === '<>')) { return (fieldValue != rValue);\r\n/*eslint-enable */\r\n                } else {\r\n                    var f1, f2;\r\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\r\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\r\n\t\t\t\t\t\tf2 = parseFloat(rValue);\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tf1 = fieldValue;\r\n\t\t\t\t\t\tf2 = rValue;\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar inTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcaseInsensitiveToken('IN'),\r\n\t\t\ttoken('('),\r\n\t\t\twhitespaceSeparatedList(0, literal, token(',')),\r\n\t\t\ttoken(')')\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname and multiple values\r\n\t\t\t//   (in reverse order).\r\n\r\n\t\t\tvar node = state;\r\n\t\t\twhile (node.tail != null) {\r\n\t\t\t\tnode = node.tail;\r\n\t\t\t}\r\n            var fieldName = node.head;\r\n\r\n\t\t\treturn function(props, indexes) {\r\n\t\t\t\tvar value = props[indexes[fieldName]];\r\n\t\t\t\tif (value == null) { return false; }\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node.tail !== null) {\r\n\t\t\t\t\tif (node.head === value) { return true; }\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Forward declarations to allow mutually recursive grammar definitions.\r\n\tvar term = function(s, state) { return term(s, state); };\r\n\tvar expression = function(s, state) { return expression(s, state); };\r\n\r\n\tvar notTerm = action(\r\n\t\twhitespaceSeparatedSequence([caseInsensitiveToken('NOT'), term]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains only processed inner term.\r\n\t\t\tvar innerTerm = state.head;\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\treturn !innerTerm(props, indexes, types);\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tterm = choice([\r\n\t\tnotTerm,\r\n\t\topTerm,\r\n\t\tinTerm,\r\n\t\twhitespaceSeparatedSequence([token('('), expression, token(')')])\r\n\t]);\r\n\r\n\t// AND and OR expressions must have at least 2 terms,\r\n\t//   to disambiguate them from a single term.\r\n\r\n\tvar andExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('AND')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = true;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar orExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('OR')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = false;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Order is important here: term should be tried last,\r\n\t//   because andExpression and orExpression start with it.\r\n\texpression = choice([\r\n\t\tandExpression,\r\n\t\torExpression,\r\n\t\tterm\r\n\t]);\r\n\r\n\tvar whereClause = sequence([whitespace, expression, whitespace]);\r\n\r\n\tParsers.parseSQL = function(str) {\r\n\t\tvar result = applyParser(str, whereClause);\r\n\t\treturn result.head === str.length ?\r\n\t\t\tresult.tail.head :\r\n            (applyParser(str, whitespace).head === str.length) ?\r\n\t\t\t\tfunction(/*props*/) { return true; } :\r\n\t\t\t\tnull;\r\n\t};\r\n\r\n\tvar additiveExpression = function(s, state) { return additiveExpression(s, state); };\r\n\tvar multiplicativeExpression = function(s, state) { return multiplicativeExpression(s, state); };\r\n\tadditiveExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeExpression,\r\n\t\t\tcapture(choice([token('+'), token('-')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types)\r\n\t\t\t{\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 0.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm += pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '-') { term = -term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar multiplicativeTerm = choice([\r\n\t\taction(\r\n\t\t\tnumberLiteral,\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(/*props, indexes, types*/) {\r\n\t\t\t\t\treturn parseFloat(state.head);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('floor('), additiveExpression, token(')')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\tvar res = state.head(props, indexes, types);\r\n\t\t\t\t\treturn Math.floor(res);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('['), fieldName, token(']')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes) {\r\n\t\t\t\t\treturn parseFloat(props[indexes[state.head]]);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\ttoken('('),\r\n\t\t\tadditiveExpression,\r\n\t\t\ttoken(')')\r\n\t\t])\r\n\t]);\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\tmultiplicativeExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeTerm,\r\n\t\t\tcapture(choice([token('*'), token('/')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 1.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '/') { term = 1.0 / term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\r\n\tvar arithmeticExpression = sequence([whitespace, additiveExpression, whitespace]);\r\n\tParsers.parseExpression = function(s) {\r\n\t\tvar result = applyParser(s, arithmeticExpression);\r\n        return result.head === s.length ? result.tail.head : null;\r\n        // return result.head === s.length ? Parsers.functionFromExpression(s) : null;\r\n\t};\r\n\r\n\tvar svgPath = action(\r\n\t\trepeat(0, choice([\r\n\t\t\tnumberLiteral,\r\n\t\t\ttoken(','),\r\n\t\t\ttoken('M'),\r\n\t\t\ttoken('C'),\r\n\t\t\trepeat(1, choice([\r\n\t\t\t\ttoken(' '),\r\n\t\t\t\ttoken('\\t'),\r\n\t\t\t\ttoken('\\r'),\r\n\t\t\t\ttoken('\\n')\r\n\t\t\t]))\r\n\t\t])),\r\n\t\tfunction(state) {\r\n\t\t\tvar coords = [];\r\n\t\t\twhile (state !== null) {\r\n\t\t\t\tcoords.push(parseFloat(state.head));\r\n\t\t\t\tstate = state.tail;\r\n\t\t\t}\r\n\t\t\tcoords.reverse();\r\n\t\t\treturn coords;\r\n\t\t}\r\n\t);\r\n\r\n\tParsers.parseSVGPath = function(s) {\r\n\t\tvar result = applyParser(s, svgPath);\r\n\t\tif (result.head === s.length) {\r\n\t\t\treturn result.tail.head;\r\n\t\t} else {\r\n\t\t\treturn [];\r\n        }\r\n\t};\r\n\r\n\t//extend L.gmx namespace\r\n    L.gmx = L.gmx || {};\r\n\tL.gmx.Parsers = Parsers;\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Parsers.js","//all the methods can be called without instance itself\r\n//For example:\r\n//\r\n// var def = new Deferred();\r\n// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\r\nvar Deferred = function(cancelFunc) {\r\n    var resolveCallbacks = [],\r\n        rejectCallbacks = [],\r\n        isFulfilled = false,\r\n        isResolved = false,\r\n        fulfilledData,\r\n        onceAdded = false,\r\n        isCancelled = false;\r\n\r\n    var fulfill = this._fulfill = function(resolved /*, data*/) {\r\n        if (isFulfilled) {\r\n            return;\r\n        }\r\n        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\r\n        fulfilledData = [].slice.call(arguments, 1);\r\n        isFulfilled = true;\r\n        isResolved = resolved;\r\n\r\n        callbacks.forEach(function(callback) { callback.apply(null, fulfilledData); });\r\n        resolveCallbacks = rejectCallbacks = [];\r\n    };\r\n\r\n    this.resolve = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    this.reject = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    var cancel = this.cancel = function() {\r\n        if (!isCancelled && !isFulfilled) {\r\n            isCancelled = true;\r\n            cancelFunc && cancelFunc();\r\n        }\r\n    };\r\n\r\n    var then = this.then = function(resolveCallback, rejectCallback) {\r\n        if (isCancelled) {\r\n            return null;\r\n        }\r\n\r\n        var userFuncDef = null;\r\n        var def = new Deferred(function() {\r\n            cancel();\r\n            userFuncDef && userFuncDef.cancel();\r\n        });\r\n\r\n        var fulfillFunc = function(func, resolved) {\r\n            return function(/*data*/) {\r\n                if (!func) {\r\n                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\r\n                } else {\r\n                    var res = func.apply(null, arguments);\r\n                    if (res instanceof Deferred) {\r\n                        userFuncDef = res;\r\n                        res.then(def.resolve, def.reject);\r\n                    } else {\r\n                        def.resolve(res);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        if (isFulfilled) {\r\n            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\r\n        } else {\r\n            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\r\n            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\r\n        }\r\n        return def;\r\n    };\r\n\r\n    this.once = function(onceResolveCallback) {\r\n        if (!onceAdded) {\r\n            onceAdded = true;\r\n            then(onceResolveCallback);\r\n        }\r\n    };\r\n\r\n    this.always = function(callback) {\r\n        then(callback, callback);\r\n    };\r\n\r\n    this.getFulfilledData = function() {\r\n        return fulfilledData;\r\n    };\r\n};\r\n\r\nDeferred.all = function() {\r\n    var defArray = [].slice.apply(arguments);\r\n    var resdef = new Deferred();\r\n    var left = defArray.length;\r\n    var results = new Array(defArray.length);\r\n\r\n    if (left) {\r\n        defArray.forEach(function(def, i) {\r\n            def.then(function(res) {\r\n                results[i] = res;\r\n                left--;\r\n                if (left === 0) {\r\n                    resdef.resolve.apply(resdef, results);\r\n                }\r\n            }, function() {\r\n                resdef.reject();\r\n            });\r\n        });\r\n    } else {\r\n        resdef.resolve();\r\n    }\r\n\r\n    return resdef;\r\n};\r\n\r\nL.gmx = L.gmx || {};\r\nL.gmx.Deferred = Deferred;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Deferred.js","(function() {\r\n\r\nvar ImageRequest = function(id, url, options) {\r\n    this._id = id;\r\n    this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\r\n    this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\r\n    this.url = url;\r\n    this.options = options || {};\r\n};\r\n\r\nvar GmxImageLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    statics: {\r\n        MAX_COUNT: 20 // max number of parallel requests\r\n    },\r\n\r\n    initialize: function() {\r\n        this.curCount = 0;        // number of currently processing requests (number of items in \"inProgress\")\r\n        this.requests = [];       // not yet processed image requests\r\n        this.inProgress = {};     // hash of in progress image loadings\r\n        this.requestsCache = {};  // for requests cache by uniqueID\r\n        this.uniqueID = 0;\r\n    },\r\n\r\n    _resolveRequest: function(request, image, canceled) {\r\n        var def = request.def;\r\n        if (image) {\r\n            if (!canceled && request.options.cache) {\r\n                var url = request.url,\r\n                    cacheItem = this.requestsCache[url],\r\n                    cacheKey = request._id;\r\n                if (!cacheItem) { cacheItem = this.requestsCache[url] = {image: image, requests:{}}; }\r\n                if (!cacheItem.requests[cacheKey]) { cacheItem.requests[cacheKey] = request; }\r\n            }\r\n            def.resolve(image);\r\n        } else if (!canceled) {\r\n            def.reject();\r\n        }\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _imageLoaded: function(url, image, canceled) {\r\n        if (url in this.inProgress) {\r\n            var resolveRequest = function(it) {\r\n                this._resolveRequest(it, image, canceled);\r\n            };\r\n            this.inProgress[url].requests.forEach(resolveRequest.bind(this));\r\n            --this.curCount;\r\n            delete this.inProgress[url];\r\n        }\r\n        L.gmxUtil.loaderStatus(url, true);\r\n        this.fire('imageloaded', {url: url});\r\n        this._nextLoad();\r\n    },\r\n\r\n    _nextLoad: function() {  // загрузка следующего\r\n        if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\r\n            return;\r\n        }\r\n\r\n        var request = this.requests.shift(),\r\n            url = request.url;\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            var requests = [request];\r\n            this.inProgress[url] = {requests: requests};\r\n            ++this.curCount;\r\n\r\n            for (var k = this.requests.length - 1; k >= 0; k--) {\r\n                if (this.requests[k].url === url) {\r\n                    requests.push(this.requests[k]);\r\n                    this.requests.splice(k, 1);\r\n                }\r\n            }\r\n\r\n            var image = this._loadImage(request);\r\n            if (!image.width) {\r\n                L.gmxUtil.loaderStatus(url);\r\n            }\r\n\r\n            //theoretically image loading can be synchronous operation\r\n            if (this.inProgress[url]) {\r\n                this.inProgress[url].image = image;\r\n            }\r\n        }\r\n    },\r\n\r\n    _loadImage: function(request) {\r\n        var imageObj = new Image(),\r\n            url = request.url,\r\n            _this = this;\r\n\r\n        if (request.options.crossOrigin) {\r\n            imageObj.crossOrigin = request.options.crossOrigin;\r\n        }\r\n\r\n        imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\r\n        imageObj.onerror = function() {\r\n            _this._imageLoaded(url);\r\n        };\r\n        imageObj.src = url;\r\n\r\n        this.fire('imageloadstart', {url: url});\r\n\r\n        return imageObj;\r\n    },\r\n\r\n    _cancelRequest: function(request) {\r\n        var id = request._id,\r\n            url = request.url,\r\n            i = 0, len;\r\n        if (url in this.inProgress) {\r\n            var loadingImg = this.inProgress[url],\r\n                requests = loadingImg.requests;\r\n\r\n            len = requests.length;\r\n            if (len === 1 && requests[0]._id === id) {\r\n                loadingImg.image.onload = L.Util.falseFn;\r\n                loadingImg.image.onerror = L.Util.falseFn;\r\n                loadingImg.image.src = L.Util.emptyImageUrl;\r\n                this._imageLoaded(url, null, true);\r\n            } else {\r\n                for (i = 0; i < len; i++) {\r\n                    if (requests[i]._id === id) {\r\n                        requests.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = this.requests.length; i < len; i++) {\r\n                if (this.requests[i]._id === id) {\r\n                    this.requests.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _removeRequestFromCache: function(request) {    // remove request from cache\r\n        this._cancelRequest(request);\r\n        this._clearCacheItem(request.url, request._id);\r\n    },\r\n\r\n    _clearCacheItem: function(url, cacheKey) {    // remove cache item\r\n        if (this.requestsCache[url]) {\r\n            var cacheItem = this.requestsCache[url];\r\n            delete cacheItem.requests[cacheKey];\r\n            if (Object.keys(cacheItem.requests).length === 0) {\r\n                delete this.requestsCache[url];\r\n            }\r\n        }\r\n    },\r\n    _add: function(atBegin, url, options) {\r\n        var id = 'id' + (++this.uniqueID),\r\n            request = new ImageRequest(id, url, options);\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            atBegin ? this.requests.unshift(request) : this.requests.push(request);\r\n            this._nextLoad();\r\n        }\r\n\r\n        this.fire('request', {request: request});\r\n\r\n        return request;\r\n    },\r\n\r\n    push: function(url, options) {  // добавить запрос в конец очереди\r\n        return this._add(false, url, options);\r\n    },\r\n\r\n    unshift: function(url, options) {   // добавить запрос в начало очереди\r\n        return this._add(true, url, options);\r\n    }\r\n});\r\n\r\nL.gmx.imageLoader = new GmxImageLoader();\r\n\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ImageLoader.js","/**\r\n* @name L.gmxUtil\r\n* @namespace\r\n*/\r\nvar gmxAPIutils = {\r\n    lastMapId: 0,\r\n\r\n    newId: function()\r\n    {\r\n        gmxAPIutils.lastMapId += 1;\r\n        return '_' + gmxAPIutils.lastMapId;\r\n    },\r\n\r\n    uniqueGlobalName: function(thing)\r\n    {\r\n        var id = gmxAPIutils.newId();\r\n        window[id] = thing;\r\n        return id;\r\n    },\r\n\r\n    isPageHidden: function()\t{\t\t// Видимость окна браузера\r\n        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\r\n    },\r\n\r\n    normalizeHostname: function(hostName) {\r\n        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\r\n\r\n        hostName = parsedHost.host + parsedHost.directory;\r\n\r\n        if (hostName[hostName.length - 1] === '/') {\r\n            hostName = hostName.substring(0, hostName.length - 1);\r\n        }\r\n\r\n        return hostName;\r\n    },\r\n\r\n\tgetLayerItemFromServer: function(options) {\r\n        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\r\n            req = {\r\n                WrapStyle: 'func',\r\n                geometry: true,\r\n                layer: options.layerID,\r\n                query: query\r\n            };\r\n        if (options.border) { req.border = options.border; }\r\n        return gmxAPIutils.requestJSONP(\r\n            options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx',\r\n            req,\r\n            options\r\n        );\r\n    },\r\n\r\n\tgetCadastreFeatures: function(options) {\r\n\t\t// example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\r\n        if (options.latlng) {\r\n\t\t\tvar latlng = options.latlng,\r\n\t\t\t\treq = {\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\ttext: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\r\n\t\t\t\t\ttolerance: options.tolerance || 0\r\n\t\t\t\t};\r\n\t\t\treturn gmxAPIutils.requestJSONP(\r\n\t\t\t\toptions.url || 'http://pkk5.rosreestr.ru/api/features/',\r\n\t\t\t\treq,\r\n\t\t\t\toptions\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n    },\r\n\r\n\tgetFormData: function(json) {\r\n\t\tvar arr = [];\r\n\t\tfor (var key in json) {\r\n\t\t\tvar val = json[key];\r\n\t\t\tarr.push(key + '=' + (typeof val === 'object' ? JSON.stringify(val) : val));\r\n\t\t}\r\n\t\treturn arr.join('&');\r\n    },\r\n\r\n    /** Sends JSONP requests\r\n     * @memberof L.gmxUtil\r\n     * @param {String} url - request URL\r\n     * @param {Object} params - request params\r\n     * @param {Object} [options] - additional request options\r\n     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n     * @return {Deferred} Promise with server JSON response or with error status\r\n    */\r\n\trequestJSONP: function(url, params, options) {\r\n        options = options || {};\r\n        var def = new L.gmx.Deferred();\r\n\r\n        var script = document.createElement('script');\r\n        script.setAttribute('charset', 'UTF-8');\r\n        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\r\n        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\r\n\r\n        if (callbackParamName) {\r\n            var callbackName = gmxAPIutils.uniqueGlobalName(function(obj) {\r\n                delete window[callbackName];\r\n                def.resolve(obj, options);\r\n            });\r\n\r\n            urlParams[callbackParamName] = callbackName;\r\n        }\r\n\r\n        var paramsStringItems = [];\r\n\r\n        for (var p in urlParams) {\r\n            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\r\n        }\r\n\r\n        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\r\n\r\n        script.onerror = function(e) {\r\n            def.reject(e);\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        script.onload = function() {\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        L.gmxUtil.loaderStatus(src, null, 'vector');\r\n        script.setAttribute('src', src);\r\n\r\n        document.getElementsByTagName('head').item(0).appendChild(script);\r\n        return def;\r\n    },\r\n    getXmlHttp: function() {\r\n        var xmlhttp;\r\n        if (typeof XMLHttpRequest !== 'undefined') {\r\n            xmlhttp = new XMLHttpRequest();\r\n        } else {\r\n          try {\r\n            xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\r\n          } catch (e) {\r\n            try {\r\n              xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\r\n            } catch (E) {\r\n              xmlhttp = false;\r\n            }\r\n          }\r\n        }\r\n        return xmlhttp;\r\n    },\r\n    request: function(ph) { // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\r\n        var xhr = gmxAPIutils.getXmlHttp();\r\n        if (xhr) {\r\n            xhr.open((ph.type ? ph.type : 'GET'), ph.url, ph.async || false);\r\n            if (ph.headers) {\r\n                for (var key in ph.headers) {\r\n                    xhr.setRequestHeader(key, ph.headers[key]);\r\n                }\r\n            }\r\n            var reqId = L.gmxUtil.loaderStatus();\r\n            if (ph.async) {\r\n                if (ph.withCredentials) {\r\n                    xhr.withCredentials = true;\r\n                }\r\n                xhr.onreadystatechange = function() {\r\n                    if (xhr.readyState === 4) {\r\n                        L.gmxUtil.loaderStatus(reqId, true);\r\n                        if (xhr.status === 200) {\r\n                            ph.callback(xhr.responseText);\r\n                            xhr = null;\r\n                        } else if (ph.onError) {\r\n                            ph.onError(xhr);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\t\t\tvar params = null;\r\n\t\t\tif (ph.params) {\r\n\t\t\t\tparams = ph.params;\r\n\t\t\t\tvar syncParams = L.gmx.gmxMapManager.getSyncParams(true);\r\n\t\t\t\tif (syncParams) {\r\n\t\t\t\t\tparams += '&' + syncParams;\r\n\t\t\t\t}\r\n\t\t\t}\r\n            xhr.send(params);\r\n            if (!ph.async && xhr.status === 200) {\r\n                ph.callback(xhr.responseText);\r\n                L.gmxUtil.loaderStatus(reqId, true);\r\n                return xhr.status;\r\n            }\r\n            return true;\r\n        }\r\n        if (ph.onError) {\r\n            ph.onError({Error: 'bad XMLHttpRequest!'});\r\n        }\r\n        return false;\r\n    },\r\n\r\n    tileSizes: [], // Размеры тайла по zoom\r\n    getTileNumFromLeaflet: function (tilePoint, zoom) {\r\n        if ('z' in tilePoint) {\r\n            zoom = tilePoint.z;\r\n        }\r\n        var pz = Math.pow(2, zoom),\r\n            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\r\n            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\r\n        return {\r\n            z: zoom,\r\n            x: tx % pz - pz / 2,\r\n            y: pz / 2 - 1 - ty % pz\r\n        };\r\n    },\r\n\r\n\tgetTilePosZoomDelta: function(tilePoint, zoomFrom, zoomTo) {\t\t// получить смещение тайла на меньшем zoom\r\n        var dz = Math.pow(2, zoomFrom - zoomTo),\r\n            size = 256 / dz,\r\n            dx = tilePoint.x % dz,\r\n            dy = tilePoint.y % dz;\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tzDelta: dz,\r\n\t\t\tx: size * (dx < 0 ? dz + dx : dx),\r\n\t\t\ty: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\r\n\t\t};\r\n    },\r\n\r\n    geoItemBounds: function(geo) {  // get item bounds array by geometry\r\n        if (!geo) {\r\n            return {\r\n                bounds: null,\r\n                boundsArr: []\r\n            };\r\n        }\r\n        var type = geo.type,\r\n            coords = geo.coordinates,\r\n            b = null,\r\n            i = 0,\r\n            len = 0,\r\n            bounds = null,\r\n            boundsArr = [];\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr1 = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr1.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                }\r\n                boundsArr.push(arr1);\r\n            }\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                boundsArr.push(b);\r\n                if (i === 0) { bounds.extendBounds(b); }\r\n            }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds([coords[i]]);\r\n                bounds.extendBounds(b);\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n            //boundsArr.push(bounds);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                bounds.extendBounds(b);\r\n                //boundsArr.push(b);\r\n            }\r\n        }\r\n        return {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n    },\r\n\r\n    getUnFlattenGeo: function(geo) {  // get unFlatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            coords = geo.coordinates,\r\n            coordsOut = coords;\r\n\r\n        if (isLikePolygon) {\r\n            coordsOut = [];\r\n            var isPolygon = type === 'POLYGON' || type === 'Polygon';\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                var ring = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\r\n                }\r\n                coordsOut.push(ring);\r\n            }\r\n            if (isPolygon) { coordsOut = coordsOut[0]; }\r\n        }\r\n        return {type: type, coordinates: coordsOut};\r\n    },\r\n\r\n    unFlattenRing: function(arr) {\r\n        if (typeof arr[0] !== 'number') {\r\n            return arr;\r\n        }\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            res = new Array(len / 2);\r\n\r\n        for (var i = 0; i < len; i += 2) {\r\n            res[cnt++] = [arr[i], arr[i + 1]];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    geoFlatten: function(geo) {  // get flatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates;\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    flattenRing: function(arr) {\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\r\n            res = new CurArray(2 * len);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            res[cnt++] = arr[i][0];\r\n            res[cnt++] = arr[i][1];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /** Check rectangle type by coordinates\r\n     * @memberof L.gmxUtil\r\n     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n     * @return {Boolean}\r\n    */\r\n    isRectangle: function(coords) {\r\n        return (coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4)\r\n            && ((coords[0][0][0] === coords[0][1][0]) || (coords[0][0][1] === coords[0][1][1]))\r\n            && ((coords[0][1][0] === coords[0][2][0]) || (coords[0][1][1] === coords[0][2][1]))\r\n            && ((coords[0][2][0] === coords[0][3][0]) || (coords[0][2][1] === coords[0][3][1]))\r\n            && ((coords[0][3][0] === coords[0][0][0]) || (coords[0][3][1] === coords[0][0][1]))\r\n        );\r\n    },\r\n\r\n    /** Get bounds from geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n     * @return {Object} bounds\r\n    */\r\n    getGeometryBounds: function(geo) {\r\n        var pt = gmxAPIutils.geoItemBounds(geo);\r\n        return pt.bounds;\r\n    },\r\n\r\n    getMarkerPolygon: function(bounds, dx, dy) {\r\n        var x = (bounds.min.x + bounds.max.x) / 2,\r\n            y = (bounds.min.y + bounds.max.y) / 2;\r\n        return [\r\n            [x - dx, y - dy],\r\n            [x - dx, y + dy],\r\n            [x + dx, y + dy],\r\n            [x + dx, y - dy],\r\n            [x - dx, y - dy]\r\n        ];\r\n    },\r\n\r\n    getQuicklookPointsFromProperties: function(pArr, gmx) {\r\n        var indexes = gmx.tileAttributeIndexes;\r\n        var points = {\r\n                x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\r\n                y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\r\n                x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\r\n                y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\r\n                x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\r\n                y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\r\n                x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\r\n                y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\r\n            },\r\n            bounds = gmxAPIutils.bounds([\r\n                [points.x1, points.y1],\r\n                [points.x2, points.y2],\r\n                [points.x3, points.y3],\r\n                [points.x4, points.y4]\r\n            ]);\r\n\r\n        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\r\n            return null;\r\n        }\r\n\r\n        if (!gmx.quicklookPlatform) {\r\n            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\r\n            points.x1 = merc.x; points.y1 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\r\n            points.x2 = merc.x; points.y2 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\r\n            points.x3 = merc.x; points.y3 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\r\n            points.x4 = merc.x; points.y4 = merc.y;\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /** Get hash properties from array properties\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} properties in Array format\r\n     * @param {Object} keys indexes\r\n     * @return {Object} properties in Hash format\r\n    */\r\n    getPropertiesHash: function(arr, indexes) {\r\n        var properties = {};\r\n        for (var key in indexes) {\r\n            properties[key] = arr[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    getPropItem: function(key, arr, indexes) {\r\n        return key in indexes ? arr[indexes[key]] : '';\r\n    },\r\n\r\n    dec2rgba: function(i, a)\t{\t\t\t\t// convert decimal to rgb\r\n        var r = (i >> 16) & 255,\r\n            g = (i >> 8) & 255,\r\n            b = i & 255;\r\n\t\treturn 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\r\n\t},\r\n\r\n    dec2hex: function(i) {\t\t\t\t\t// convert decimal to hex\r\n        return (i + 0x1000000).toString(16).substr(-6);\r\n    },\r\n\r\n    dec2color: function(i, a)   {   // convert decimal to canvas color\r\n        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\r\n    },\r\n\r\n    oneDay: 60 * 60 * 24,\t\t\t// один день\r\n\r\n    isTileKeysIntersects: function(tk1, tk2) { // пересечение по номерам двух тайлов\r\n        if (tk1.z < tk2.z) {\r\n            var t = tk1; tk1 = tk2; tk2 = t;\r\n        }\r\n\r\n        var dz = tk1.z - tk2.z;\r\n        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\r\n\t},\r\n\r\n    rotatePoints: function(arr, angle, iconScale, center) {\t\t\t// rotate - массива точек\r\n        var out = [];\r\n        angle *= Math.PI / 180.0;\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n        if (!iconScale) { iconScale = 1; }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            var x = iconScale * arr[i].x - center.x;\r\n            var y = iconScale * arr[i].y - center.y;\r\n            out.push({\r\n                'x': cos * x - sin * y + center.x,\r\n                'y': sin * x + cos * y + center.y\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n    getPatternIcon: function(item, style, indexes) { // получить bitmap стиля pattern\r\n        if (!style.fillPattern) { return null; }\r\n\r\n        var notFunc = true,\r\n            pattern = style.fillPattern,\r\n            prop = item ? item.properties : null,\r\n            step = pattern.step > 0 ? pattern.step : 0,\r\n            patternDefaults = {\r\n                minWidth: 1,\r\n                maxWidth: 1000,\r\n                minStep: 0,\r\n                maxStep: 1000\r\n            };\r\n        if (pattern.patternStepFunction && prop !== null) {\r\n            step = pattern.patternStepFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (step > patternDefaults.maxStep) {\r\n            step = patternDefaults.maxStep;\r\n        }\r\n        else if (step < patternDefaults.minStep) {\r\n            step = patternDefaults.minStep;\r\n        }\r\n\r\n        var size = pattern.width > 0 ? pattern.width : 8;\r\n        if (pattern.patternWidthFunction && prop !== null) {\r\n            size = pattern.patternWidthFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (size > patternDefaults.maxWidth) {\r\n            size = patternDefaults.maxWidth;\r\n        } else if (size < patternDefaults.minWidth) {\r\n            size = patternDefaults.minWidth;\r\n        }\r\n\r\n        var op = style.fillOpacity;\r\n        if (style.opacityFunction && prop !== null) {\r\n            op = style.opacityFunction(prop, indexes) / 100;\r\n            notFunc = false;\r\n        }\r\n\r\n        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\r\n            arr = (pattern.colors != null ? pattern.colors : rgb),\r\n            count = arr.length,\r\n            resColors = [],\r\n            i = 0;\r\n\r\n        for (i = 0; i < count; i++) {\r\n            var col = arr[i];\r\n            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\r\n                col = (prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3]);\r\n                notFunc = false;\r\n            }\r\n            resColors.push(col);\r\n        }\r\n        if (count === 0) { resColors = [0]; op = 0; count = 1; }   // pattern without colors\r\n\r\n        var delta = size + step,\r\n            allSize = delta * count,\r\n            center = 0,\r\n            //radius,\r\n            rad = 0,\r\n            hh = allSize,\t\t\t\t// высота битмапа\r\n            ww = allSize,\t\t\t\t// ширина битмапа\r\n            type = pattern.style || 'horizontal',\r\n            flagRotate = false;\r\n\r\n        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\r\n            flagRotate = true;\r\n        } else if (type === 'circle') {\r\n            ww = hh = 2 * delta;\r\n            center = Math.floor(ww / 2);\t// центр круга\r\n            //radius = Math.floor(size / 2);\t// радиус\r\n            rad = 2 * Math.PI / count;\t\t// угол в рад.\r\n        } else if (type === 'vertical') {\r\n            hh = 1;\r\n        } else if (type === 'horizontal') {\r\n            ww = 1;\r\n        }\r\n        if (ww * hh > patternDefaults.maxWidth) {\r\n            console.log({'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big'});\r\n            return null;\r\n        }\r\n\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.clearRect(0, 0, canvas.width, canvas.height);\r\n        if (type === 'diagonal2' || type === 'vertical') {\r\n            ptx.translate(ww, 0);\r\n            ptx.rotate(Math.PI / 2);\r\n        }\r\n\r\n        for (i = 0; i < count; i++) {\r\n            ptx.beginPath();\r\n            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\r\n            ptx.fillStyle = fillStyle;\r\n\r\n            if (flagRotate) {\r\n                var x1 = i * delta; var xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n\r\n                x1 += allSize; xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n                if (type === 'cross' || type === 'cross1') {\r\n                    x1 = i * delta; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n\r\n                    x1 += allSize; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n                }\r\n            } else if (type === 'circle') {\r\n                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\r\n                ptx.lineTo(center, center);\r\n            } else {\r\n                ptx.fillRect(0, i * delta, ww, size);\r\n            }\r\n            ptx.closePath();\r\n            ptx.fill();\r\n        }\r\n        var canvas1 = document.createElement('canvas');\r\n        canvas1.width = ww;\r\n        canvas1.height = hh;\r\n        var ptx1 = canvas1.getContext('2d');\r\n        ptx1.drawImage(canvas, 0, 0, ww, hh);\r\n        return {'notFunc': notFunc, 'canvas': canvas1};\r\n    },\r\n\r\n    getSVGIcon: function (options) {\r\n        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\r\n            type = options.type,\r\n            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\r\n            stroke = options.strokeStyle || '#0000ff',\r\n            strokeWidth = options.lineWidth || 2,\r\n            iconOptions = {\r\n                className: 'gmx-svg-icon'\r\n            };\r\n\r\n        if (options.className) {\r\n            iconOptions.className = options.className;\r\n        }\r\n        var size = options.iconSize;\r\n        iconOptions.iconSize = [size, size];\r\n        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\r\n\r\n        if (type === 'circle') {\r\n            if (options.fillRadialGradient) {\r\n                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\r\n                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop\r\n                    || [     // [%, color, opacity]\r\n                        [0, '#ffff00', 0.8],\r\n                        [1, '#ff0000', 0.8]\r\n                    ];\r\n\r\n                for (var i = 0, len = stopColor.length; i < len; i++) {\r\n                    var it = stopColor[i];\r\n                    svg += '<stop offset=\"' + (100 * it[0]) + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\r\n                }\r\n                svg += '</radialGradient></defs>';\r\n                fill = 'url(#myRadialGradient4)';\r\n                stroke = strokeWidth = null;\r\n            }\r\n            size /= 2;\r\n            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:\"' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:\"' + strokeWidth + ';'; }\r\n            svg += ';\" />';\r\n        } else if (type === 'square') {\r\n            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:' + 2 * strokeWidth + ';'; }\r\n            svg += '\" />';\r\n        }\r\n        if (options.text) {\r\n            var text = options.text;\r\n            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\r\n            for (var key in text) {\r\n                if (key !== 'count') { svg += ' ' + key + '=\"' + text[key] + '\"'; }\r\n            }\r\n            svg += '>' + text.count + '</text>';\r\n        }\r\n        svg += '</g></svg>';\r\n        iconOptions.html = svg;\r\n\r\n        return new L.DivIcon(iconOptions);\r\n    },\r\n\r\n    toPixels: function(p, tpx, tpy, mInPixel) { // get pixel point\r\n        var px1 = p[0] * mInPixel; \tpx1 = (0.5 + px1) << 0;\r\n        var py1 = p[1] * mInPixel;\tpy1 = (0.5 + py1) << 0;\r\n        return [px1 - tpx, tpy - py1].concat(p.slice(2));\r\n    },\r\n\r\n    getPixelPoint: function(attr, coords) {\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n            style = attr.style || {},\r\n            iconScale = currentStyle.iconScale || 1,\r\n            iconCenter = currentStyle.iconCenter || false,\r\n            sx = currentStyle.sx || style.sx || 4,\r\n            sy = currentStyle.sy || style.sy || 4,\r\n            weight = currentStyle.weight || style.weight || 0,\r\n            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy;\r\n\r\n        if (!iconCenter && iconAnchor) {\r\n            px1 -= iconAnchor[0];\r\n            py1 -= iconAnchor[1];\r\n        }\r\n        sx *= iconScale;\r\n        sy *= iconScale;\r\n        sx += weight;\r\n        sy += weight;\r\n\r\n        var py1 = py - coords[1] * mInPixel,\r\n\t\t\tpx1 = coords[0] * mInPixel - px;\r\n\r\n\t\tif (px1 - sx > 256) {\r\n\t\t\tpx1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t} else if (px1 < -sx) {\r\n\t\t\tpx1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t}\r\n\r\n        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0\r\n\t\t\t? null :\r\n            {\r\n                sx: sx,\r\n                sy: sy,\r\n                px1: (0.5 + px1) << 0,\r\n                py1: (0.5 + py1) << 0\r\n            }\r\n        ;\r\n    },\r\n    getImageData: function(img) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return null; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.drawImage(img, 0, 0);\r\n        return ptx.getImageData(0, 0, ww, hh).data;\r\n    },\r\n    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\r\n    isIE: function(v) {\r\n        return v === gmxAPIutils.getIEversion();\r\n    },\r\n    gtIE: function(v) {\r\n        return v < gmxAPIutils.getIEversion();\r\n    },\r\n\r\n    getIEversion: function() {\r\n        var ua = navigator.userAgent || '',\r\n            msie = ua.indexOf('MSIE ');\r\n        if (msie > 0) {\r\n            // IE 10 or older => return version number\r\n            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n        }\r\n\r\n        var trident = ua.indexOf('Trident/');\r\n        if (trident > 0) {\r\n            // IE 11 => return version number\r\n            var rv = ua.indexOf('rv:');\r\n            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n        }\r\n\r\n        var edge = ua.indexOf('Edge/');\r\n        if (edge > 0) {\r\n            // Edge (IE 12+) => return version number\r\n            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n        }\r\n\r\n        // other browser\r\n        return -1;\r\n    },\r\n\r\n    replaceColor: function(img, color, fromData) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return img; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var flag = false,\r\n            imageData,\r\n            ptx = canvas.getContext('2d');\r\n\r\n        if (typeof color === 'string') {\r\n            color = parseInt('0x' + color.replace(/#/, ''));\r\n        }\r\n        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\r\n            var r = (color >> 16) & 255,\r\n                g = (color >> 8) & 255,\r\n                b = color & 255;\r\n\r\n            if (fromData) {\r\n                imageData = ptx.createImageData(ww, hh);\r\n            } else {\r\n                ptx.drawImage(img, 0, 0);\r\n                imageData = ptx.getImageData(0, 0, ww, hh);\r\n                fromData = imageData.data;\r\n            }\r\n            var toData = imageData.data;\r\n            for (var i = 0, len = fromData.length; i < len; i += 4) {\r\n                if ((fromData[i] === 0xff || fromData[i] === 238)\r\n                    && fromData[i + 1] === 0\r\n                    && fromData[i + 2] === 0xff\r\n                    ) {\r\n                    toData[i] = r;\r\n                    toData[i + 1] = g;\r\n                    toData[i + 2] = b;\r\n                    toData[i + 3] = fromData[i + 3];\r\n                    flag = true;\r\n                }\r\n            }\r\n        }\r\n        if (flag) {\r\n            ptx.putImageData(imageData, 0, 0);\r\n        } else {\r\n            ptx.drawImage(img, 0, 0);\r\n        }\r\n        return canvas;\r\n    },\r\n\r\n    drawIconPath: function(path, attr) { // draw iconPath in canvas\r\n        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) { return; }\r\n        var trFlag = false,\r\n            ctx = attr.ctx,\r\n            rad = attr.radian;\r\n\r\n        if (attr.px || attr.py) { ctx.translate(attr.px || 0, attr.py || 0); trFlag = true; }\r\n        if (!rad && attr.rotateRes) { rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes); }\r\n        if (rad) { ctx.rotate(rad); trFlag = true; }\r\n        ctx.moveTo(path[0], path[1]);\r\n        for (var i = 2, len = path.length; i < len; i += 2) {\r\n            ctx.lineTo(path[i], path[i + 1]);\r\n        }\r\n        if (trFlag) { ctx.setTransform(1, 0, 0, 1, 0, 0); }\r\n    },\r\n\r\n    pointToCanvas: function(attr) { // Точку в canvas\r\n        var gmx = attr.gmx,\r\n            pointAttr = attr.pointAttr,\r\n            style = attr.style || {},\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconScale = currentStyle.iconScale || 1,\r\n            image = currentStyle.image,\r\n            sx = pointAttr.sx,\r\n            sy = pointAttr.sy,\r\n            px1 = pointAttr.px1,\r\n            py1 = pointAttr.py1,\r\n            px1sx = px1,\r\n            py1sy = py1,\r\n            ctx = attr.ctx;\r\n\r\n        if (currentStyle.type === 'image') {\r\n            sx = style.sx;\r\n            sy = style.sy;\r\n            image = style.image;\r\n        }\r\n        if (currentStyle.iconCenter) {\r\n            px1sx -= sx / 2;\r\n            py1sy -= sy / 2;\r\n        } else if (style.type === 'circle') {\r\n            px1 += sx / 2;\r\n            py1 += sy / 2;\r\n        }\r\n        if (currentStyle.iconPath) {\r\n            attr.px = px1;\r\n            attr.py = py1;\r\n            attr.rotateRes = currentStyle.rotate || 0;\r\n        }\r\n        if (image) {\r\n            if ('iconColor' in currentStyle) {\r\n                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\r\n            }\r\n            style.rotateRes = currentStyle.rotate || 0;\r\n            if ('opacity' in style) { ctx.globalAlpha = currentStyle.opacity || style.opacity; }\r\n            if (gmx.transformFlag) {\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\r\n                ctx.drawImage(image, px1, -py1, sx, sy);\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\r\n            } else {\r\n\t\t\t\tif (iconScale !== 1) {\r\n\t\t\t\t\tsx *= iconScale;\r\n\t\t\t\t\tsy *= iconScale;\r\n\t\t\t\t\tpx1 = pointAttr.px1;\r\n\t\t\t\t\tpy1 = pointAttr.py1;\r\n\t\t\t\t\tpx1sx = px1;\r\n\t\t\t\t\tpy1sy = py1;\r\n\t\t\t\t\tif (currentStyle.iconCenter) {\r\n\t\t\t\t\t\tpx1sx -= sx / 2;\r\n\t\t\t\t\t\tpy1sy -= sy / 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (style.rotateRes) {\r\n\t\t\t\t\tctx.translate(px1, py1);\r\n\t\t\t\t\tctx.rotate(gmxAPIutils.degRad(style.rotateRes));\r\n\t\t\t\t\tctx.translate(-px1, -py1);\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t}\r\n            }\r\n            if ('opacity' in style) { ctx.globalAlpha = 1; }\r\n        } else if (style.fillColor || currentStyle.fillRadialGradient) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\r\n                var circle = style.iconSize / 2;\r\n                if (currentStyle.fillRadialGradient) {\r\n                    var rgr = currentStyle.fillRadialGradient;\r\n                    circle = rgr.r2 * iconScale;\r\n                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\r\n                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\r\n                        var arr = rgr.addColorStop[i];\r\n                        radgrad.addColorStop(arr[0], arr[1]);\r\n                    }\r\n                    ctx.fillStyle = radgrad;\r\n                }\r\n                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.fillRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.fill();\r\n        }\r\n        if (currentStyle.strokeStyle) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle') {\r\n                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.strokeRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n    },\r\n    lineToCanvasAsIcon: function(pixels, attr) {  // add line(as icon) to canvas\r\n        var len = pixels.length,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconPath = currentStyle.iconPath;\r\n\r\n        if (len > 0) {\r\n            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n                ctx.setLineDash([]);\r\n            }\r\n            ctx.beginPath();\r\n            for (var i = 0, p; i < len; i++) {\r\n                p = pixels[i];\r\n                gmxAPIutils.drawIconPath(iconPath, {ctx: ctx, px: p.x, py: p.y, radian: p.radian});\r\n            }\r\n            if (currentStyle.strokeStyle) {\r\n                ctx.stroke();\r\n            }\r\n            if (currentStyle.fillStyle) {\r\n                ctx.fill();\r\n            }\r\n        }\r\n    },\r\n    lineToCanvas: function(attr) {  // Lines in canvas\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            pixels = currentStyle.iconPath ? [] : null;\r\n\r\n        var lastX = null, lastY = null;\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\r\n                x = p[0],\r\n                y = p[1];\r\n            if (lastX !== x || lastY !== y) {\r\n                if (pixels) { pixels.push({x: x, y: y, radian: p[2]}); }\r\n                if (i === 0) {\r\n                    ctx.moveTo(x, y);\r\n                } else {\r\n                    ctx.lineTo(x, y);\r\n                }\r\n                lastX = x; lastY = y;\r\n            }\r\n        }\r\n        ctx.stroke();\r\n        return pixels;\r\n    },\r\n\r\n    getCoordsPixels: function(attr) {\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || [],\r\n            pixels = [],\r\n            hidden = [],\r\n            hiddenFlag = false,\r\n            hash = {\r\n                gmx: gmx,\r\n                tpx: attr.tpx,\r\n                tpy: attr.tpy,\r\n                coords: null,\r\n                hiddenLines: null\r\n            };\r\n        for (var j = 0, len = coords.length; j < len; j++) {\r\n            var coords1 = coords[j],\r\n                hiddenLines1 = hiddenLines[j] || [],\r\n                pixels1 = [], hidden1 = [];\r\n            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\r\n                hash.coords = coords1[j1];\r\n                hash.hiddenLines = hiddenLines1[j1] || [];\r\n                var res = gmxAPIutils.getRingPixels(hash);\r\n                pixels1.push(res.coords);\r\n                hidden1.push(res.hidden);\r\n                if (res.hidden) {\r\n                    hiddenFlag = true;\r\n                }\r\n            }\r\n            pixels.push(pixels1);\r\n            hidden.push(hidden1);\r\n        }\r\n        return {coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom};\r\n    },\r\n\r\n    getRingPixels: function(attr) {\r\n        if (attr.coords.length === 0) { return null; }\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            lastX = null, lastY = null,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            pixels = [], hidden = [];\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var lineIsOnEdge = false;\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x1 = c[0] * mInPixel, y1 = c[1] * mInPixel,\r\n                x2 = Math.round(x1 - px), y2 = Math.round(py - y1);\r\n\r\n            if (lastX !== x2 || lastY !== y2) {\r\n                lastX = x2; lastY = y2;\r\n                if (lineIsOnEdge) {\r\n                    hidden.push(cnt);\r\n                }\r\n                pixels[cnt++] = x1;\r\n                pixels[cnt++] = y1;\r\n            }\r\n        }\r\n        return {coords: pixels, hidden: hidden.length ? hidden : null};\r\n    },\r\n\r\n    polygonToCanvas: function(attr) {       // Polygons in canvas\r\n        if (attr.coords.length === 0) { return null; }\r\n        var hiddenLines = attr.hiddenLines || null,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            lastX = null, lastY = null;\r\n\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x = Math.round(c[0] - px),\r\n                y = Math.round(py - c[1]),\r\n                lineIsOnEdge = false;\r\n\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n\r\n            if (lastX !== x || lastY !== y) {\r\n                ctx[(lineIsOnEdge ? 'moveTo' : 'lineTo')](x, y);\r\n                lastX = x; lastY = y;\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt === 1) { ctx.lineTo(lastX + 1, lastY); }\r\n        ctx.stroke();\r\n    },\r\n\r\n    polygonToCanvasFill: function(attr) {     // Polygon fill\r\n        if (attr.coords.length < 3) { return; }\r\n        var coords = attr.coords,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            vectorSize = 1,\r\n            ctx = attr.ctx;\r\n\r\n        ctx.lineWidth = 0;\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\r\n        } else {\r\n            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\r\n        }\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\r\n        }\r\n    },\r\n\r\n    isPatternNode: function(it) {\r\n        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\r\n    },\r\n    labelCanvasContext: null,    // 2dContext canvas for Label size\r\n    getLabelWidth: function(txt, style) {   // Get label size Label\r\n        if (style) {\r\n            if (!gmxAPIutils.labelCanvasContext) {\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = canvas.height = 512;\r\n                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\r\n            }\r\n            var ptx = gmxAPIutils.labelCanvasContext;\r\n            ptx.clearRect(0, 0, 512, 512);\r\n\r\n            if (ptx.font !== style.font) { ptx.font = style.font; }\r\n            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\r\n            if (ptx.fillStyle !== style.fillStyle) { ptx.fillStyle = style.fillStyle; }\r\n\t\t\tvar arr = txt.split('\\n');\r\n            return arr.map(function(it) {\r\n\t\t\t\tptx.fillText(it, 0, 0);\r\n\t\t\t\treturn [it, ptx.measureText(it).width];\r\n\t\t\t});\r\n        }\r\n        return 0;\r\n    },\r\n    setLabel: function(ctx, txt, coord, style) {\r\n        var x = coord[0],\r\n            y = coord[1];\r\n\r\n        if (ctx.shadowColor !== style.strokeStyle) { ctx.shadowColor = style.strokeStyle; }\r\n        if (ctx.shadowBlur !== style.shadowBlur) { ctx.shadowBlur = style.shadowBlur; }\r\n        if (ctx.font !== style.font) { ctx.font = style.font; }\r\n        if (ctx.strokeStyle !== style.strokeStyle) { ctx.strokeStyle = style.strokeStyle; }\r\n        if (ctx.fillStyle !== style.fillStyle) { ctx.fillStyle = style.fillStyle; }\r\n        ctx.strokeText(txt, x, y);\r\n        ctx.fillText(txt, x, y);\r\n    },\r\n    worldWidthMerc: 20037508,\r\n    rMajor: 6378137.000,\r\n    degRad: function(ang) {\r\n        return ang * (Math.PI / 180.0);\r\n    },\r\n\r\n    distVincenty: function(lon1, lat1, lon2, lat2) {\r\n        var p1 = {\r\n            lon: gmxAPIutils.degRad(lon1),\r\n            lat: gmxAPIutils.degRad(lat1)\r\n        },\r\n            p2 = {\r\n            lon: gmxAPIutils.degRad(lon2),\r\n            lat: gmxAPIutils.degRad(lat2)\r\n        },\r\n            a = gmxAPIutils.rMajor,\r\n            b = 6356752.3142,\r\n            f = 1 / 298.257223563;  // WGS-84 ellipsiod\r\n\r\n        var L1 = p2.lon - p1.lon,\r\n            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\r\n            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\r\n            sinU1 = Math.sin(U1), cosU1 = Math.cos(U1),\r\n            sinU2 = Math.sin(U2), cosU2 = Math.cos(U2),\r\n            lambda = L1,\r\n            lambdaP = 2 * Math.PI,\r\n            iterLimit = 20;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda),\r\n                    sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +\r\n                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n                if (sinSigma === 0) { return 0; }\r\n                var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\r\n                    sigma = Math.atan2(sinSigma, cosSigma),\r\n                    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\r\n                    cosSqAlpha = 1 - sinAlpha * sinAlpha,\r\n                    cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n                if (isNaN(cos2SigmaM)) { cos2SigmaM = 0; }\r\n                var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n                lambdaP = lambda;\r\n                lambda = L1 + (1 - C) * f * sinAlpha *\r\n                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0) { return NaN; }\r\n\r\n        var uSq = cosSqAlpha * ((a * a) / (b * b) - 1),\r\n        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\r\n            A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\r\n            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\r\n            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -\r\n                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\r\n            s = b * A * (sigma - deltaSigma);\r\n\r\n        //s = s.toFixed(3);\r\n        return s;\r\n    },\r\n\r\n    _vfi: function(fi, a, b) {\r\n        return [\r\n            -Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a),\r\n            Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a),\r\n            -Math.sin(fi) * Math.cos(b)\r\n        ];\r\n    },\r\n\r\n    getCircleLatLngs: function(latlng, r) {   // Get latlngs for circle\r\n        var x = 0, y = 0;\r\n        if (latlng instanceof L.LatLng) {\r\n            x = latlng.lng;\r\n            y = latlng.lat;\r\n        } else if (L.Util.isArray(latlng)) {\r\n            x = latlng[1];\r\n            y = latlng[0];\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        var rad = Math.PI / 180,\r\n            a = x * rad,  //долгота центра окружности в радианах\r\n            b = y * rad,  //широта центра окружности в радианах\r\n            R = gmxAPIutils.rMajor,\r\n            d = R * Math.sin(r / R),\r\n            Rd = R * Math.cos(r / R),\r\n            VR = [\r\n                Rd * Math.cos(b) * Math.cos(a),\r\n                Rd * Math.cos(b) * Math.sin(a),\r\n                Rd * Math.sin(b)\r\n            ],\r\n            latlngs = [];\r\n\r\n        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\r\n            var v = gmxAPIutils._vfi(fi, a, b),\r\n                circle = [];\r\n            for (var i = 0; i < 3; i++) { circle[i] = VR[i] + d * v[i]; }\r\n\r\n            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\r\n            if (circle[1] < 0) { t2 = -t2; }\r\n\r\n            if (t2 < x - 180) {\r\n                t2 += 360;\r\n            } else if (t2 > x + 180) {\r\n                t2 -= 360;\r\n            }\r\n            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\r\n        }\r\n        return latlngs;\r\n    },\r\n\r\n    /** Get point coordinates from string\r\n     * @memberof L.gmxUtil\r\n     * @param {String} text - point coordinates in following formats:\r\n         <br/><i>55.74312, 37.61558</i>\r\n         <br/><i>55°44'35\" N, 37°36'56\" E</i>\r\n         <br/><i>4187347, 7472103</i>\r\n         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n     * @return {Array} [lat, lng] or null\r\n    */\r\n    parseCoordinates: function(text) {\r\n        var crs = null,\r\n            regex = /\\(EPSG:(\\d+)\\)/g,\r\n            t = regex.exec(text);\r\n\r\n        if (t) {\r\n            crs = t[1];\r\n            text = text.replace(regex, '');\r\n        }\r\n\r\n        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\r\n            return null;\r\n        }\r\n\r\n        //there should be a separator in the string (exclude strings like \"11E11\")\r\n        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\r\n            return null;\r\n        }\r\n\r\n        if (text.indexOf(' ') !== -1) {\r\n            text = text.replace(/,/g, '.');\r\n        }\r\n        var results = [];\r\n        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\r\n        t = regex.exec(text);\r\n        while (t) {\r\n            results.push(t[1]);\r\n            t = regex.exec(text);\r\n        }\r\n        if (results.length < 2) {\r\n            return null;\r\n        }\r\n        var ii = Math.floor(results.length / 2),\r\n            y = 0,\r\n            mul = 1,\r\n            i;\r\n        for (i = 0; i < ii; i++) {\r\n            y += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n        var x = 0;\r\n        mul = 1;\r\n        for (i = ii; i < results.length; i++) {\r\n            x += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n\r\n        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\r\n            t = x;\r\n            x = y;\r\n            y = t;\r\n        }\r\n\r\n        var pos;\r\n        if (crs === '3857') {\r\n            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\r\n            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n\r\n        if (text.indexOf('W') !== -1) {\r\n            x = -x;\r\n        }\r\n\r\n        if (text.indexOf('S') !== -1) {\r\n            y = -y;\r\n        }\r\n        return [y, x];\r\n    },\r\n\r\n\tpad2: function(t) {\r\n\t\treturn (t >= 0 && t < 10) ? ('0' + t) : ('' + t);\r\n\t},\r\n\r\n\ttrunc: function(x) {\r\n\t\treturn ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\r\n\t},\r\n\r\n\tformatDegrees: function(angle, format) {\r\n\t\tangle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\r\n\t\tvar a1 = Math.floor(angle),\r\n\t\t\ta2 = Math.floor(60 * (angle - a1)),\r\n\t\t\ta3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\r\n\t\t\tst = gmxAPIutils.pad2(a1) + '°';\r\n\r\n\t\tif (format ===  undefined ) { format = 2; }\r\n\t\tif (format > 0) {\r\n\t\t\tst += gmxAPIutils.pad2(a2) + '\\'';\r\n\t\t}\r\n\t\tif (format > 1) {\r\n\t\t\tst += gmxAPIutils.pad2(a3) + '\"';\r\n\t\t}\r\n\t\treturn st;\r\n\t},\r\n\r\n    /** Get point coordinates in string format with degrees\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format with degrees\r\n    */\r\n\tlatLonFormatCoordinates: function(x, y) {\r\n        x %= 360;\r\n        if (x > 180) { x -= 360; }\r\n        else if (x < -180) { x += 360; }\r\n\t\treturn  gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\r\n\tformatCoordinates: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates(x, y);\r\n\t},\r\n\r\n    /** Get point coordinates in string format\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format\r\n    */\r\n\tlatLonFormatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\tformatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates2(x, y);\r\n\t},\r\n\r\n    getPixelScale: function(zoom) {\r\n        return 256 / gmxAPIutils.tileSizes[zoom];\r\n    },\r\n\r\n    forEachPoint: function(coords, callback) {\r\n        if (!coords || coords.length === 0) { return []; }\r\n        var i, len, ret = [];\r\n        if (!coords[0].length) {\r\n            if (coords.length === 2) {\r\n                return callback(coords);\r\n            } else {\r\n                for (i = 0, len = coords.length / 2; i < len; i++) {\r\n                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                if (typeof coords[i] !== 'string') {\r\n                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    },\r\n/*\r\n\tgetQuicklookPoints: function(coord) { // получить 4 точки привязки снимка\r\n\t\tvar d1 = Number.MAX_VALUE;\r\n\t\tvar d2 = Number.MAX_VALUE;\r\n\t\tvar d3 = Number.MAX_VALUE;\r\n\t\tvar d4 = Number.MAX_VALUE;\r\n\t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t\tthis.forEachPoint(coord, function(p) {\r\n\t\t\tvar x = p[0];\r\n\t\t\tvar y = p[1];\r\n\t\t\tif ((x - y) < d1) {\r\n\t\t\t\td1 = x - y;\r\n\t\t\t\tx1 = p[0];\r\n\t\t\t\ty1 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x - y) < d2) {\r\n\t\t\t\td2 = -x - y;\r\n\t\t\t\tx2 = p[0];\r\n\t\t\t\ty2 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x + y) < d3) {\r\n\t\t\t\td3 = -x + y;\r\n\t\t\t\tx3 = p[0];\r\n\t\t\t\ty3 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((x + y) < d4) {\r\n\t\t\t\td4 = x + y;\r\n\t\t\t\tx4 = p[0];\r\n\t\t\t\ty4 = p[1];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t},\r\n*/\r\n    getItemCenter: function(item, geoItems) {\r\n        var bounds = item.bounds,\r\n            min = bounds.min, max = bounds.max,\r\n            type = item.type,\r\n            isPoint = type === 'POINT' || type === 'MULTIPOINT',\r\n            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n\r\n        if (type === 'MULTIPOLYGON') {\r\n\t\t\treturn center;\r\n\t\t} else if (type === 'POLYGON') {\r\n            for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                var it = geoItems[i],\r\n                    geom = it.geo,\r\n                    coords = geom.coordinates,\r\n                    dataOption = it.dataOption,\r\n                    bbox = dataOption.bounds;\r\n\r\n                if (bbox.contains(center)) {\r\n                    if (geom.type === 'POLYGON') { coords = [coords]; }\r\n                    for (var j = 0, len1 = coords.length; j < len1; j++) {\r\n                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\r\n                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\r\n                            if (pt) {\r\n                                return pt.max.center;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (type === 'POINT' || type === 'MULTIPOINT') {\r\n            return center;\r\n        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\r\n            return center;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    getHSegmentsInPolygon: function(y, poly) {\r\n        var s = [], i, len, out,\r\n            vectorSize = 1,\r\n            p1 = poly[0];\r\n\r\n        if (typeof poly[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [poly[0], poly[1]];\r\n        }\r\n        var isGt1 = y > p1[1];\r\n        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\r\n                isGt2 = y > p2[1];\r\n            if (isGt1 !== isGt2) {\r\n                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\r\n            }\r\n            p1 = p2;\r\n            isGt1 = isGt2;\r\n        }\r\n        len = s.length;\r\n        if (len) {\r\n            s = s.sort();\r\n            var max = 0,\r\n                index = -1;\r\n            for (i = 1; i < len; i += 2) {\r\n                var j = i - 1,\r\n                    d = Math.abs(s[i] - s[j]);\r\n                if (d > max) {\r\n                    max = d;\r\n                    index = j;\r\n                }\r\n            }\r\n            out = {\r\n                y: y,\r\n                segArr: s,\r\n                max: {\r\n                    width: max,\r\n                    center: [(s[index] + s[index + 1]) / 2, y]\r\n                }\r\n            };\r\n        }\r\n        return out;\r\n    },\r\n\r\n    isPointInPolygonArr: function(chkPoint, coords) { // Проверка точки на принадлежность полигону в виде массива\r\n        var isIn = false,\r\n            x = chkPoint[0],\r\n            y = chkPoint[1],\r\n            vectorSize = 1,\r\n            p1 = coords[0];\r\n\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [coords[0], coords[1]];\r\n        }\r\n\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                xmin = Math.min(p1[0], p2[0]),\r\n                xmax = Math.max(p1[0], p2[0]),\r\n                ymax = Math.max(p1[1], p2[1]);\r\n            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\r\n                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\r\n                if (p1[1] === p2[1] || y <= xinters) { isIn = !isIn; }\r\n            }\r\n            p1 = p2;\r\n        }\r\n        return isIn;\r\n    },\r\n\r\n    /** Is point in polygon with holes\r\n     * @memberof L.gmxUtil\r\n     * @param {chkPoint} chkPoint - point in [x, y] format\r\n     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n     * @return {Boolean} true if polygon contain chkPoint\r\n    */\r\n    isPointInPolygonWithHoles: function(chkPoint, coords) {\r\n        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) { return false; }\r\n        for (var j = 1, len = coords.length; j < len; j++) {\r\n            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) { return false; }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /** Is polygon clockwise\r\n     * @memberof L.gmxUtil\r\n     * @param {ring} ring - ring from geoJSON coordinates data format\r\n     * @return {Boolean} true if ring is clockwise\r\n    */\r\n    isClockwise: function(ring) {\r\n        var area = 0;\r\n        for (var i = 0, j, len = ring.length; i < len; i++) {\r\n            j = (i + 1) % len;\r\n            area += ring[i][0] * ring[j][1];\r\n            area -= ring[j][0] * ring[i][1];\r\n        }\r\n        return (area < 0);\r\n    },\r\n\r\n    isPointInPolyLine: function(chkPoint, lineHeight, coords, hiddenLines) {\r\n        // Проверка точки(с учетом размеров) на принадлежность линии\r\n        var dx = chkPoint[0], dy = chkPoint[1],\r\n            nullPoint = {x: dx, y: dy},\r\n            minx = dx - lineHeight, maxx = dx + lineHeight,\r\n            miny = dy - lineHeight, maxy = dy + lineHeight,\r\n            cntHide = 0;\r\n\r\n        lineHeight *= lineHeight;\r\n        for (var i = 1, len = coords.length; i < len; i++) {\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                cntHide++;\r\n            } else {\r\n                var p1 = coords[i - 1], p2 = coords[i],\r\n                    x1 = p1[0], y1 = p1[1],\r\n                    x2 = p2[0], y2 = p2[1];\r\n\r\n                if (!(Math.max(x1, x2) < minx\r\n                    || Math.min(x1, x2) > maxx\r\n                    || Math.max(y1, y2) < miny\r\n                    || Math.min(y1, y2) > maxy)) {\r\n                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, {x: x1, y: y1}, {x: x2, y: y2}, true);\r\n                    if (sqDist < lineHeight) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    isPointInLines: function (attr) {\r\n        var arr = attr.coords,\r\n            point = attr.point,\r\n            delta = attr.delta,\r\n            boundsArr = attr.boundsArr,\r\n            hidden = attr.hidden;\r\n        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\r\n            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\r\n            if (flag\r\n                && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)\r\n            ) {\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /** Get length\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} latlngs array\r\n     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n     * @return {Number} length\r\n    */\r\n    getLength: function(latlngs, isMerc) {\r\n        var length = 0;\r\n        if (latlngs && latlngs.length) {\r\n            var lng = false,\r\n                lat = false;\r\n\r\n            isMerc = isMerc === undefined || isMerc;\r\n            latlngs.forEach(function(latlng) {\r\n                if (L.Util.isArray(latlng)) {\r\n                    if (L.Util.isArray(latlng[0])) {\r\n                        length += gmxAPIutils.getLength(latlng, isMerc);\r\n                        return length;\r\n                    } else if (isMerc) {   // From Mercator array\r\n                        latlng = L.Projection.Mercator.unproject({x: latlng[0], y: latlng[1]});\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\r\n                }\r\n                lng = latlng.lng;\r\n                lat = latlng.lat;\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get prettify length\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area\r\n     * @param {String} type: ('km', 'm', 'nm')\r\n     * @return {String} prettify length\r\n    */\r\n    prettifyDistance: function(length, type) {\r\n        var km = ' ' + L.gmxLocale.getText('units.km');\r\n        if (type === 'nm') {\r\n            return (Math.round(0.539956803 * length) / 1000) + ' ' + L.gmxLocale.getText('units.nm');\r\n        } else if (type === 'km') {\r\n            return (Math.round(length) / 1000) + km;\r\n        } else if (length < 2000 || type === 'm') {\r\n            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\r\n        } else if (length < 200000) {\r\n            return (Math.round(length / 10) / 100) + km;\r\n        }\r\n        return Math.round(length / 1000) + km;\r\n    },\r\n\r\n    /** Get geoJSON length\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} length\r\n    */\r\n    geoJSONGetLength: function(geoJSON) {\r\n        var out = 0,\r\n            i, j, len, len1, coords;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'LineString') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingLength(coords[i]);\r\n            }\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                for (j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    out += gmxAPIutils.getRingLength(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getRingLength: function(coords) {\r\n        var length = 0;\r\n        if (coords && coords.length) {\r\n            var lng = false, lat = false;\r\n            coords.forEach(function(lnglat) {\r\n                if (L.Util.isArray(lnglat)) {\r\n                    if (lnglat.length > 2) {\r\n                        length += gmxAPIutils.getRingLength(lnglat);\r\n                        return length;\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\r\n                }\r\n                lng = lnglat[0];\r\n                lat = lnglat[1];\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get geoJSON area\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoJSONGetArea: function(geoJSON) {\r\n        var out = 0;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            var coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingArea(coords[i][0]);\r\n                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\r\n                    out -= gmxAPIutils.getRingArea(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    geoJSONGetLatLng: function(geoJSON) {\r\n        if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'Point') {\r\n            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\r\n        } else {\r\n            throw new Error('cannot get ' + geoJSON.type + ' latLng');\r\n        }\r\n    },\r\n\r\n    getRingArea: function(coords) {\r\n        var area = 0;\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = coords[i], p2 = coords[ipp];\r\n            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\r\n        }\r\n        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n        return out;\r\n    },\r\n\r\n    /** Get area\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} L.latLng array\r\n     * @return {Number} area in square meters\r\n    */\r\n    getArea: function(arr) {\r\n        var area = 0;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = arr[i], p2 = arr[ipp];\r\n            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\r\n        }\r\n        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n    },\r\n\r\n    /** Get prettified size of area\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area in square meters\r\n     * @param {String} type: ('km2', 'ha', 'm2')\r\n     * @return {String} prettified area\r\n    */\r\n    prettifyArea: function(area, type) {\r\n        var km2 = ' ' + L.gmxLocale.getText('units.km2');\r\n\r\n        if (type === 'km2') {\r\n            return ('' + (Math.round(area / 100) / 10000)) + km2;\r\n        } else if (type === 'ha') {\r\n            return ('' + (Math.round(area / 100) / 100)) + ' ' + L.gmxLocale.getText('units.ha');\r\n        } else if (area < 100000 || type === 'm2') {\r\n            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\r\n        } else if (area < 3000000) {\r\n            return ('' + (Math.round(area / 1000) / 1000)).replace('.', ',') + km2;\r\n        } else if (area < 30000000) {\r\n            return ('' + (Math.round(area / 10000) / 100)).replace('.', ',') + km2;\r\n        } else if (area < 300000000) {\r\n            return ('' + (Math.round(area / 100000) / 10)).replace('.', ',') + km2;\r\n        }\r\n        return (Math.round(area / 1000000)) + km2;\r\n    },\r\n\r\n    geoLength: function(geom) {\r\n        var ret = 0,\r\n            type = geom.type;\r\n        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoLength({type: 'LINESTRING', coordinates: geom.coordinates[i]});\r\n            }\r\n            return ret;\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            ret = gmxAPIutils.getLength(geom.coordinates);\r\n        }\r\n        return ret;\r\n    },\r\n\r\n    /** Converts Geomixer geometry to geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - Geomixer geometry\r\n     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n     * @return {Object} geoJSON geometry\r\n    */\r\n    geometryToGeoJSON: function (geom, mercFlag) {\r\n        if (!geom) {\r\n            return null;\r\n        }\r\n\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    convertGeometry: function (geom, fromMerc) {\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (fromMerc) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        } else {\r\n            coords = gmxAPIutils.coordsToMercator(type, coords);\r\n        }\r\n        return {\r\n            type: geom.type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    /** Converts GeoJSON object into GeoMixer format\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - GeoJSON object\r\n     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n     * @return {Object} Geometry in GeoMixer format\r\n    */\r\n    geoJSONtoGeometry: function (geoJSON, mercFlag) {\r\n        if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        }\r\n\r\n        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON'\r\n                : geoJSON.type === 'Polygon' ? 'POLYGON'\r\n                : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING'\r\n                : geoJSON.type === 'LineString' ? 'LINESTRING'\r\n                : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT'\r\n                : geoJSON.type === 'Point' ? 'POINT'\r\n                : geoJSON.type,\r\n            coords = geoJSON.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    _coordsConvert: function(type, coords, toMerc) {\r\n        var i, len, p,\r\n            resCoords = [];\r\n        if (type === 'Point') {\r\n            if (toMerc) {\r\n                p = L.Projection.Mercator.project({lat: coords[1], lng: coords[0]});\r\n                resCoords = [p.x, p.y];\r\n            } else {\r\n                p = L.Projection.Mercator.unproject({y: coords[1], x: coords[0]});\r\n                resCoords = [p.lng, p.lat];\r\n            }\r\n        } else if (type === 'LineString' || type === 'MultiPoint') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'Polygon' || type === 'MultiLineString') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'MultiPolygon') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\r\n            }\r\n        }\r\n        return resCoords;\r\n    },\r\n\r\n    coordsFromMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, false);\r\n    },\r\n\r\n    coordsToMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, true);\r\n    },\r\n\r\n    transformGeometry: function(geom, callback) {\r\n        return !geom ? geom : {\r\n            type: geom.type,\r\n            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function(p) {\r\n                return callback(p);\r\n            })\r\n        };\r\n    },\r\n\r\n    /** Get area for geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry\r\n     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoArea: function(geom, isMerc) {\r\n        var i, len, ret = 0,\r\n            type = geom.type || '';\r\n        isMerc = isMerc === undefined || isMerc;\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            for (i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoArea({type: 'POLYGON', coordinates: geom.coordinates[i]}, isMerc);\r\n            }\r\n            return ret;\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\r\n            for (i = 1, len = geom.coordinates.length; i < len; i++) {\r\n                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\r\n            }\r\n            return ret;\r\n        } else if (geom.length) {\r\n            var latlngs = [],\r\n                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\r\n\r\n            for (i = 0, len = geom.length; i < len; i += vectorSize) {\r\n                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\r\n                latlngs.push(\r\n                    isMerc ?\r\n                    L.Projection.Mercator.unproject({y: p[1], x: p[0]}) :\r\n                    {lat: p[1], lng: p[0]}\r\n                );\r\n            }\r\n            return gmxAPIutils.getArea(latlngs);\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    /** Get summary for geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON geometry\r\n     * @param {Object} unitOptions {\r\n     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n     *               }\r\n     * @return {String} Summary string for geometry\r\n    */\r\n    getGeoJSONSummary: function(geom, unitOptions) {\r\n        var type = geom.type,\r\n            units = unitOptions || {},\r\n            out = 0,\r\n            i, len, coords;\r\n        if (type === 'Point') {\r\n            coords = geom.coordinates;\r\n            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\r\n        } else if (type === 'Polygon') {\r\n            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\r\n        } else if (type === 'MultiPolygon') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoArea({type: 'Polygon', coordinates: coords[i]}, false);\r\n            }\r\n            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\r\n        } else if (type === 'LineString') {\r\n            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\r\n        } else if (type === 'MultiLineString') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoJSONGetLength({type: 'LineString', coordinates: coords[i]});\r\n            }\r\n            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for point\r\n     * @memberof L.gmxUtil\r\n     * @param {latlng} point\r\n     * @param {num} format number:\r\n     *         0: 62°52'30.68\" N, 22°48'27.42\" E\r\n     *         1: 62.875188 N, 22.807617 E\r\n     *         2: 2538932, 9031643 (EPSG:3395)\r\n     *         3: 2538932, 9069712 (EPSG:3857)\r\n     * @return {String} Summary string for LatLng point\r\n    */\r\n    getCoordinatesString: function(latlng, num) {\r\n        var x = latlng.lng,\r\n            y = latlng.lat,\r\n            formats = [\r\n                '',\r\n                '',\r\n                ' (EPSG:3395)',\r\n                ' (EPSG:3857)'\r\n            ],\r\n            len = formats.length,\r\n            merc,\r\n            out = '';\r\n        num = num || 0;\r\n        if (x > 180) { x -= 360; }\r\n        if (x < -180) { x += 360; }\r\n        if (num % len === 0) {\r\n            out = gmxAPIutils.formatCoordinates2(x, y);\r\n        } else if (num % len === 1) {\r\n            out = gmxAPIutils.formatCoordinates(x, y);\r\n        } else if (num % len === 2) {\r\n            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\r\n        } else {\r\n            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for geometries array\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} geometries array in Geomixer format\r\n     * @param {Object} units Options for length and area\r\n     * @return {String} Summary string for geometries array\r\n    */\r\n    getGeometriesSummary: function(arr, unitOptions) {\r\n        var out = '',\r\n            type = '',\r\n            res = 0;\r\n        if (!unitOptions) { unitOptions = {}; }\r\n        if (arr) {\r\n            arr.forEach(function(geom) {\r\n                if (geom) {\r\n                    type = geom.type.toUpperCase();\r\n                    if (type.indexOf('POINT') !== -1) {\r\n                        var latlng = L.Projection.Mercator.unproject({y: geom.coordinates[1], x: geom.coordinates[0]});\r\n                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: '\r\n                            + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\r\n                    } else if (type.indexOf('LINESTRING') !== -1) {\r\n                        res += gmxAPIutils.geoLength(geom);\r\n                    } else if (type.indexOf('POLYGON') !== -1) {\r\n                        res += gmxAPIutils.geoArea(geom);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (!out) {\r\n            if (type.indexOf('LINESTRING') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: '\r\n                    + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\r\n            } else if (type.indexOf('POLYGON') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: '\r\n                    + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getGeometrySummary: function(geom, unitOptions) {\r\n        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\r\n    },\r\n\r\n    chkOnEdge: function(p1, p2, ext) { // отрезок на границе\r\n        if ((p1[0] < ext.min.x && p2[0] < ext.min.x) || (p1[0] > ext.max.x && p2[0] > ext.max.x)) { return true; }\r\n        if ((p1[1] < ext.min.y && p2[1] < ext.min.y) || (p1[1] > ext.max.y && p2[1] > ext.max.y)) { return true; }\r\n        return false;\r\n    },\r\n\r\n    getHidden: function(coords, tb) {  // массив точек на границах тайлов\r\n        var hiddenLines = [],\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            prev = null;\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\r\n                hiddenLines.push(i);\r\n            }\r\n            prev = p;\r\n        }\r\n        return hiddenLines;\r\n    },\r\n\r\n    getNormalizeBounds: function (screenBounds, mercDeltaY) { // get bounds array from -180 180 lng\r\n        var northWest = screenBounds.getNorthWest(),\r\n            southEast = screenBounds.getSouthEast(),\r\n            minX = northWest.lng,\r\n            maxX = southEast.lng,\r\n            w = (maxX - minX) / 2,\r\n            minX1 = null,\r\n            maxX1 = null,\r\n            out = [];\r\n\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = {x: minX, y: southEast.lat},\r\n            m2 = {x: maxX, y: northWest.lat};\r\n\r\n        if (mercDeltaY !== undefined) {\r\n            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\r\n            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\r\n            m1.y -= mercDeltaY;\r\n            m2.y -= mercDeltaY;\r\n        }\r\n        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\r\n\r\n        if (minX1) {\r\n            var m11 = {x: minX1, y: southEast.lat},\r\n                m12 = {x: maxX1, y: northWest.lat};\r\n            if (mercDeltaY !== undefined) {\r\n                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\r\n                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\r\n                m11.y -= mercDeltaY;\r\n                m12.y -= mercDeltaY;\r\n            }\r\n            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\r\n        }\r\n        return out;\r\n    },\r\n\r\n    toPrecision: function(x, prec) {\r\n        var zn = Math.pow(10, prec ? prec : 4);\r\n        return Math.round(zn * x) / zn;\r\n    },\r\n\r\n    getTileBounds: function(x, y, z) {  //x, y, z - GeoMixer tile coordinates\r\n        var tileSize = gmxAPIutils.tileSizes[z],\r\n            minx = x * tileSize,\r\n            miny = y * tileSize;\r\n        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\r\n    },\r\n\r\n    parseTemplate: function(str, properties) {\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = key in properties ? properties[key] : '';\r\n\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getDefaultBalloonTemplate: function(properties, tileAttributeTypes) {\r\n        var str = '';\r\n        for (var key in properties) {\r\n            if (!tileAttributeTypes || (key in tileAttributeTypes)) {\r\n\t\t\t\tstr += '<b>' + key + ':</b> [' +  key + ']<br />';\r\n\t\t\t}\r\n        }\r\n        str += '<br />[SUMMARY]<br />';\r\n        return str;\r\n    },\r\n\r\n    parseBalloonTemplate: function(str, options) {\r\n        var properties = options.properties;\r\n\r\n        if (!str) {\r\n            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\r\n        }\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            var tileAttributeTypes = options.tileAttributeTypes,\r\n                unitOptions = options.unitOptions,\r\n                geometries = options.geometries;\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = '';\r\n\r\n                if (key in properties) {\r\n                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\r\n                } else if (key === 'SUMMARY') {\r\n                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    styleKeys: {\r\n        marker: {\r\n            server: ['image',   'angle',     'scale',     'minScale',     'maxScale',     'size',         'circle',     'center',     'color'],\r\n            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\r\n        },\r\n        outline: {\r\n            server: ['color',  'opacity',   'thickness', 'dashes'],\r\n            client: ['color',  'opacity',   'weight',    'dashArray']\r\n        },\r\n        fill: {\r\n            server: ['color',     'opacity',   'image',       'pattern',     'radialGradient',     'linearGradient'],\r\n            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\r\n        },\r\n        label: {\r\n            server: ['text',      'field',      'template',      'color',      'haloColor',      'size',          'spacing',      'align'],\r\n            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\r\n        }\r\n    },\r\n    styleFuncKeys: {\r\n        iconSize: 'iconSizeFunction',\r\n        iconAngle: 'rotateFunction',\r\n        iconScale: 'scaleFunction',\r\n        iconColor: 'iconColorFunction',\r\n        opacity: 'opacityFunction',\r\n        fillOpacity: 'fillOpacityFunction',\r\n        color: 'colorFunction',\r\n        fillColor: 'fillColorFunction'\r\n    },\r\n    styleFuncError: {\r\n        iconSize: function() { return 8; },\r\n        iconAngle: function() { return 0; },\r\n        iconScale: function() { return 1; },\r\n        iconColor: function() { return 0xFF; },\r\n        opacity: function() { return 1; },\r\n        fillOpacity: function() { return 0.5; },\r\n        color: function() { return 0xFF; },\r\n        fillColor: function() { return 0xFF; }\r\n    },\r\n    defaultStyles: {\r\n       MinZoom: 1,\r\n       MaxZoom: 21,\r\n       Filter: '',\r\n       Balloon: '',\r\n       DisableBalloonOnMouseMove: true,\r\n       DisableBalloonOnClick: false,\r\n       RenderStyle: {\r\n            point: {    // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\r\n                color: 0xFF,\r\n                weight: 1,\r\n                iconSize: 8\r\n            },\r\n            linestring: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            },\r\n            polygon: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    getDefaultStyle: function(type) {\r\n        var from = gmxAPIutils.defaultStyles,\r\n            out = L.extend({}, from);\r\n        out.RenderStyle = from.RenderStyle[type];\r\n        return out;\r\n    },\r\n\r\n    toServerStyle: function(style) {   // Style leaflet->Scanex\r\n        var out = {};\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (var i = 0, len = keys.client.length; i < len; i++) {\r\n                var key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    if (!out[key]) { out[key] = {}; }\r\n                    var zn = style[key1];\r\n                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\r\n                        zn *= 100;\r\n                    }\r\n                    out[key][keys.server[i]] = zn;\r\n                }\r\n            }\r\n        }\r\n        if ('iconAnchor' in style) {\r\n            if (!out.marker) { out.marker = {}; }\r\n            out.marker.dx = -style.iconAnchor[0];\r\n            out.marker.dy = -style.iconAnchor[1];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    fromServerStyle: function(style) {   // Style Scanex->leaflet\r\n        var st, i, len, key1,\r\n            out = {\r\n                type: ''    // 'polygon', 'line', 'circle', 'square', 'image'\r\n            };\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (i = 0, len = keys.client.length; i < len; i++) {\r\n                key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    out[key1] = style[key1];\r\n                }\r\n            }\r\n            st = style[key];\r\n            if (st && typeof (st) === 'object') {\r\n                for (i = 0, len = keys.server.length; i < len; i++) {\r\n                    key1 = keys.server[i];\r\n                    if (key1 in st) {\r\n                        var newKey = keys.client[i],\r\n                            zn = st[key1];\r\n                        if (typeof (zn) === 'string') {\r\n                            if (gmxAPIutils.styleFuncKeys[newKey]) {\r\n                                if (zn.match(/[^\\d\\.]/) === null) {\r\n                                    zn = Number(zn);\r\n                                } else {\r\n                                    var func = L.gmx.Parsers.parseExpression(zn);\r\n                                    if (func === null) {\r\n                                        zn = gmxAPIutils.styleFuncError[newKey]();\r\n                                    } else {\r\n                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else if (key1 === 'opacity') {\r\n                            zn /= 100;\r\n                        }\r\n                        out[newKey] = zn;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (style.marker) {\r\n            st = style.marker;\r\n            if ('dx' in st || 'dy' in st) {\r\n                var dx = st.dx || 0,\r\n                    dy = st.dy || 0;\r\n                out.iconAnchor = [-dx, -dy];    // For leaflet type iconAnchor\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getUnixTimeFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\treturn Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\r\n    },\r\n\r\n    getDateFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\tvar dt = new Date(arr[0], arr[1] - 1, arr[2]);\r\n        return dt;\r\n    },\r\n\r\n    getUTCdate: function(utime) {\r\n        var dt = new Date(utime * 1000);\r\n\r\n        return [\r\n            dt.getUTCFullYear(),\r\n            gmxAPIutils.pad2(dt.getUTCMonth() + 1),\r\n            gmxAPIutils.pad2(dt.getUTCDate())\r\n        ].join('.');\r\n    },\r\n\r\n    getUTCtime: function(utime) {\r\n        var h = Math.floor(utime / 3600),\r\n            m = Math.floor((utime - h * 3600) / 60),\r\n            s = Math.floor(utime - h * 3600 - m * 60);\r\n\r\n        return [\r\n            //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\r\n            gmxAPIutils.pad2(h),\r\n            gmxAPIutils.pad2(m),\r\n            gmxAPIutils.pad2(s)\r\n        ].join(':');\r\n    },\r\n\r\n    getUTCdateTime: function(utime) {\r\n        var time = utime % (3600 * 24);\r\n\r\n        if (time) {\r\n            return [\r\n                gmxAPIutils.getUTCdate(utime),\r\n                gmxAPIutils.getUTCtime(utime % (3600 * 24))\r\n            ].join(' ');\r\n        } else {\r\n            return gmxAPIutils.getUTCdate(utime);\r\n        }\r\n    },\r\n\r\n    attrToString: function(type, value) {\r\n        if (type === 'date') {\r\n            return value ? L.gmxUtil.getUTCdate(value) : value;\r\n        } else if (type === 'time') {\r\n            return value ? L.gmxUtil.getUTCtime(value) : value;\r\n        } else if (type === 'datetime') {\r\n            return value ? L.gmxUtil.getUTCdateTime(value) : value;\r\n        } else {\r\n            return value;\r\n        }\r\n    },\r\n\r\n    getTileAttributes: function(prop) {\r\n        var tileAttributeIndexes = {},\r\n            tileAttributeTypes = {};\r\n        if (prop.attributes) {\r\n            var attrs = prop.attributes,\r\n                attrTypes = prop.attrTypes || null;\r\n            if (prop.identityField) { tileAttributeIndexes[prop.identityField] = 0; }\r\n            for (var a = 0; a < attrs.length; a++) {\r\n                var key = attrs[a];\r\n                tileAttributeIndexes[key] = a + 1;\r\n                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\r\n            }\r\n        }\r\n        return {\r\n            tileAttributeTypes: tileAttributeTypes,\r\n            tileAttributeIndexes: tileAttributeIndexes\r\n        };\r\n    }\r\n};\r\n\r\ngmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0);\t\t\t\t// 111319.5;\r\ngmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI;\t// 6335440.712613423;\r\n\r\n(function() {\r\n    //pre-calculate tile sizes\r\n    for (var z = 0; z < 30; z++) {\r\n        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\r\n    }\r\n})();\r\n\r\ngmxAPIutils.Bounds = function(arr) {\r\n    this.min = {\r\n        x: Number.MAX_VALUE,\r\n        y: Number.MAX_VALUE\r\n    };\r\n    this.max = {\r\n        x: -Number.MAX_VALUE,\r\n        y: -Number.MAX_VALUE\r\n    };\r\n    this.extendArray(arr);\r\n};\r\ngmxAPIutils.Bounds.prototype = {\r\n    extend: function(x, y) {\r\n        if (x < this.min.x) { this.min.x = x; }\r\n        if (x > this.max.x) { this.max.x = x; }\r\n        if (y < this.min.y) { this.min.y = y; }\r\n        if (y > this.max.y) { this.max.y = y; }\r\n        return this;\r\n    },\r\n    extendBounds: function(bounds) {\r\n        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\r\n    },\r\n    extendArray: function(arr) {\r\n        if (!arr || !arr.length) { return this; }\r\n        var i, len;\r\n        if (typeof arr[0] === 'number') {\r\n            for (i = 0, len = arr.length; i < len; i += 2) {\r\n                this.extend(arr[i], arr[i + 1]);\r\n            }\r\n        } else {\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                this.extend(arr[i][0], arr[i][1]);\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    addBuffer: function(dxmin, dymin, dxmax, dymax) {\r\n        this.min.x -= dxmin;\r\n        this.min.y -= dymin || dxmin;\r\n        this.max.x += dxmax || dxmin;\r\n        this.max.y += dymax || dymin || dxmin;\r\n        return this;\r\n    },\r\n    contains: function (point) { // ([x, y]) -> Boolean\r\n        var min = this.min, max = this.max,\r\n            x = point[0], y = point[1];\r\n        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\r\n    },\r\n    getCenter: function () {\r\n        var min = this.min, max = this.max;\r\n        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n    },\r\n    addOffset: function (offset) {\r\n        this.min.x += offset[0]; this.max.x += offset[0];\r\n        this.min.y += offset[1]; this.max.y += offset[1];\r\n        return this;\r\n    },\r\n    intersects: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\r\n    },\r\n    intersectsWithDelta: function (bounds, dx, dy) { // (Bounds, dx, dy) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            x = dx || 0,\r\n            y = dy || 0,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\r\n    },\r\n    isEqual: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\r\n    },\r\n    isNodeIntersect: function (coords) {\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            if (this.contains(coords[i])) {\r\n                return {\r\n                    num: i,\r\n                    point: coords[i]\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n    clipPolygon: function (coords) { // (coords) -> clip coords\r\n        var min = this.min,\r\n            max = this.max,\r\n            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\r\n            cp1, cp2, s, e,\r\n            inside = function (p) {\r\n                return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\r\n            },\r\n            intersection = function () {\r\n                var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\r\n                    dp = [s[0] - e[0], s[1] - e[1]],\r\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n                    n2 = s[0] * e[1] - s[1] * e[0],\r\n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n                return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\r\n            };\r\n\r\n        var outputList = coords;\r\n        cp1 = clip[3];\r\n        for (var j = 0; j < 4; j++) {\r\n            cp2 = clip[j];\r\n            var inputList = outputList,\r\n                len = inputList.length;\r\n            outputList = [];\r\n            s = inputList[len - 1]; //last on the input list\r\n            for (var i = 0; i < len; i++) {\r\n                e = inputList[i];\r\n                if (inside(e)) {\r\n                    if (!inside(s)) { outputList.push(intersection()); }\r\n                    outputList.push(e);\r\n                } else if (inside(s)) {\r\n                    outputList.push(intersection());\r\n                }\r\n                s = e;\r\n            }\r\n            cp1 = cp2;\r\n        }\r\n        return outputList;\r\n    },\r\n    clipPolyLine: function (coords, angleFlag, delta) { // (coords) -> clip coords\r\n        delta = delta || 0;\r\n        var min = this.min,\r\n            max = this.max,\r\n            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\r\n            bitCode = function (p) {\r\n                var code = 0;\r\n\r\n                if (p[0] < bbox[0]) code |= 1; // left\r\n                else if (p[0] > bbox[2]) code |= 2; // right\r\n\r\n                if (p[1] < bbox[1]) code |= 4; // bottom\r\n                else if (p[1] > bbox[3]) code |= 8; // top\r\n\r\n                return code;\r\n            },\r\n            getAngle = function (a, b) {\r\n                return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\r\n            },\r\n            intersect = function (a, b, edge) {\r\n                return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\r\n                       edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\r\n                       edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\r\n                       edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\r\n                       null;\r\n            },\r\n            result = [],\r\n            len = coords.length,\r\n            codeA = bitCode(coords[0], bbox),\r\n            part = [],\r\n            i, a, b, c, codeB, lastCode;\r\n\r\n        for (i = 1; i < len; i++) {\r\n            a = coords[i - 1];\r\n            b = coords[i];\r\n            if (a[0] === b[0] && a[1] === b[1]) { continue; }\r\n            codeB = lastCode = bitCode(b, bbox);\r\n\r\n            while (true) {\r\n\r\n                if (!(codeA | codeB)) { // accept\r\n                    if (angleFlag) {\r\n                        a[2] = getAngle(a, b);\r\n                        c = coords[i + 1];\r\n                        b[2] = c ? getAngle(b, c) : a[2];\r\n                    }\r\n                    part.push(a);\r\n\r\n                    if (codeB !== lastCode) { // segment went outside\r\n                        part.push(b);\r\n\r\n                        if (i < len - 1) { // start a new line\r\n                            result.push(part);\r\n                            part = [];\r\n                        }\r\n                    } else if (i === len - 1) {\r\n                        part.push(b);\r\n                    }\r\n                    break;\r\n\r\n                } else if (codeA & codeB) { // trivial reject\r\n                    break;\r\n\r\n                } else if (codeA) { // a outside, intersect with clip edge\r\n                    a = intersect(a, b, codeA, bbox);\r\n                    codeA = bitCode(a, bbox);\r\n\r\n                } else { // b outside\r\n                    b = intersect(a, b, codeB, bbox);\r\n                    codeB = bitCode(b, bbox);\r\n                }\r\n            }\r\n\r\n            codeA = lastCode;\r\n        }\r\n\r\n        if (part.length) result.push(part);\r\n\r\n        return result;\r\n    }\r\n};\r\n\r\ngmxAPIutils.bounds = function(arr) {\r\n    return new gmxAPIutils.Bounds(arr);\r\n};\r\n\r\n//скопирована из API для обеспечения независимости от него\r\ngmxAPIutils.parseUri = function (str) {\r\n    var\to   = gmxAPIutils.parseUri.options,\r\n        m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\r\n        uri = {},\r\n        i   = 14;\r\n\r\n    while (i--) {\r\n        uri[o.key[i]] = m[i] || '';\r\n    }\r\n\r\n    uri[o.q.name] = {};\r\n    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n        if ($1) { uri[o.q.name][$1] = $2; }\r\n    });\r\n\r\n    uri.hostOnly = uri.host;\r\n    uri.host = uri.authority; // HACK\r\n\r\n    return uri;\r\n};\r\n\r\ngmxAPIutils.parseUri.options = {\r\n    strictMode: false,\r\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\r\n    q:   {\r\n        name:   'queryKey',\r\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n    },\r\n    parser: {\r\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n        loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n    }\r\n};\r\n\r\nif (!L.gmxUtil) { L.gmxUtil = {}; }\r\n\r\n//public interface\r\nL.extend(L.gmxUtil, {\r\n    newId: gmxAPIutils.newId,\r\n    loaderStatus: function () {},\r\n    isIE9: gmxAPIutils.isIE(9),\r\n    isIE10: gmxAPIutils.isIE(10),\r\n    isIE11: gmxAPIutils.isIE(11),\r\n    gtIE11: gmxAPIutils.gtIE(11),\r\n    getFormData: gmxAPIutils.getFormData,\r\n    requestJSONP: gmxAPIutils.requestJSONP,\r\n    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\r\n    request: gmxAPIutils.request,\r\n    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\r\n    fromServerStyle: gmxAPIutils.fromServerStyle,\r\n    toServerStyle: gmxAPIutils.toServerStyle,\r\n    getDefaultStyle: gmxAPIutils.getDefaultStyle,\r\n    bounds: gmxAPIutils.bounds,\r\n    getGeometryBounds: gmxAPIutils.getGeometryBounds,\r\n    tileSizes: gmxAPIutils.tileSizes,\r\n    getDateFromStr: gmxAPIutils.getDateFromStr,\r\n    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\r\n    getUTCdate: gmxAPIutils.getUTCdate,\r\n    getUTCtime: gmxAPIutils.getUTCtime,\r\n    getUTCdateTime: gmxAPIutils.getUTCdateTime,\r\n    attrToString: gmxAPIutils.attrToString,\r\n    getTileAttributes: gmxAPIutils.getTileAttributes,\r\n    formatCoordinates: function (latlng, type) {\r\n        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\r\n    },\r\n    formatDegrees: gmxAPIutils.formatDegrees,\r\n    pad2: gmxAPIutils.pad2,\r\n    dec2hex: gmxAPIutils.dec2hex,\r\n\tdec2rgba: gmxAPIutils.dec2rgba,\r\n    trunc: gmxAPIutils.trunc,\r\n    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\r\n    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\r\n    getLength: gmxAPIutils.getLength,\r\n    geoLength: gmxAPIutils.geoLength,\r\n    prettifyDistance: gmxAPIutils.prettifyDistance,\r\n    getArea: gmxAPIutils.getArea,\r\n    prettifyArea: gmxAPIutils.prettifyArea,\r\n    geoArea: gmxAPIutils.geoArea,\r\n    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\r\n    getSVGIcon: gmxAPIutils.getSVGIcon,\r\n    getCoordinatesString: gmxAPIutils.getCoordinatesString,\r\n    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\r\n    getGeometrySummary: gmxAPIutils.getGeometrySummary,\r\n    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\r\n    getPropertiesHash: gmxAPIutils.getPropertiesHash,\r\n    distVincenty: gmxAPIutils.distVincenty,\r\n    parseCoordinates: gmxAPIutils.parseCoordinates,\r\n    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\r\n    convertGeometry: gmxAPIutils.convertGeometry,\r\n    transformGeometry: gmxAPIutils.transformGeometry,\r\n    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\r\n    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\r\n    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\r\n    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\r\n    parseUri: gmxAPIutils.parseUri,\r\n    isRectangle: gmxAPIutils.isRectangle,\r\n    isClockwise: gmxAPIutils.isClockwise,\r\n    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\r\n    getPatternIcon: gmxAPIutils.getPatternIcon,\r\n    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\r\n    normalizeHostname: gmxAPIutils.normalizeHostname,\r\n    getTileBounds: gmxAPIutils.getTileBounds,\r\n    parseTemplate: gmxAPIutils.parseTemplate\r\n});\r\n\r\n(function() {\r\n    var requests = {};\r\n    var lastRequestId = 0;\r\n\r\n    var processMessage = function(e) {\r\n\r\n        if (!(e.origin in requests)) {\r\n            return;\r\n        }\r\n\r\n        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\r\n        try {\r\n            var dataObj = JSON.parse(dataStr);\r\n        } catch (ev) {\r\n            console.log({Status:'error', ErrorInfo: {ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr}});\r\n        }\r\n        var request = requests[e.origin][dataObj.CallbackName];\r\n        if (!request) {\r\n            return;    // message от других запросов\r\n        }\r\n\r\n        delete requests[e.origin][dataObj.CallbackName];\r\n        delete dataObj.CallbackName;\r\n\r\n        if (request.iframe.parentNode) {\r\n            request.iframe.parentNode.removeChild(request.iframe);\r\n        }\r\n        if ('callback' in request) { request.callback(dataObj); }\r\n    };\r\n\r\n    L.DomEvent.on(window, 'message', processMessage);\r\n\r\n    function createPostIframe2(id, callback, url) {\r\n        var uniqueId = 'gmxAPIutils_id' + (lastRequestId++),\r\n            iframe = L.DomUtil.create('iframe');\r\n\r\n        iframe.style.display = 'none';\r\n        iframe.setAttribute('id', id);\r\n        iframe.setAttribute('name', id);    /*eslint-disable no-script-url */\r\n        iframe.src = 'javascript:true';     /*eslint-enable */\r\n        iframe.callbackName = uniqueId;\r\n\r\n        var parsedURL = gmxAPIutils.parseUri(url);\r\n        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\r\n\r\n        requests[origin] = requests[origin] || {};\r\n        requests[origin][uniqueId] = {callback: callback, iframe: iframe};\r\n\r\n        return iframe;\r\n    }\r\n\r\n\t//расширяем namespace\r\n    gmxAPIutils.createPostIframe2 = createPostIframe2;\r\n\r\n})();\r\n\r\n// кроссдоменный POST запрос\r\n(function()\r\n{\r\n\t/** Посылает кроссдоменный POST запрос\r\n\t* @namespace L.gmxUtil\r\n    * @ignore\r\n\t* @function\r\n\t*\r\n\t* @param url {string} - URL запроса\r\n\t* @param params {object} - хэш параметров-запросов\r\n\t* @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные\r\n\t* @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл.\r\n\t*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.\r\n\t*/\r\n\tfunction sendCrossDomainPostRequest(url, params, callback, baseForm) {\r\n        var form,\r\n            id = '$$iframe_' + gmxAPIutils.newId();\r\n\r\n        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\r\n            originalFormAction;\r\n\r\n        if (baseForm) {\r\n            form = baseForm;\r\n            originalFormAction = form.getAttribute('action');\r\n            form.setAttribute('action', url);\r\n            form.target = id;\r\n        } else if (L.Browser.ielt9) {\r\n            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\r\n            form = document.createElement(str);\r\n        } else {\r\n            form = document.createElement('form');\r\n            form.style.display = 'none';\r\n            form.setAttribute('enctype', 'multipart/form-data');\r\n            form.target = id;\r\n            form.setAttribute('method', 'POST');\r\n            form.setAttribute('action', url);\r\n            form.id = id;\r\n        }\r\n\r\n        var hiddenParamsDiv = document.createElement('div');\r\n        hiddenParamsDiv.style.display = 'none';\r\n\r\n        if (params.WrapStyle === 'window') {\r\n            params.WrapStyle = 'message';\r\n        }\r\n\r\n        if (params.WrapStyle === 'message') {\r\n            params.CallbackName = iframe.callbackName;\r\n        }\r\n\r\n        for (var paramName in params) {\r\n            var input = document.createElement('input');\r\n            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\r\n            input.setAttribute('type', 'hidden');\r\n            input.setAttribute('name', paramName);\r\n            input.setAttribute('value', value);\r\n            hiddenParamsDiv.appendChild(input);\r\n        }\r\n\r\n        form.appendChild(hiddenParamsDiv);\r\n\r\n        if (!baseForm) {\r\n            document.body.appendChild(form);\r\n        }\r\n        document.body.appendChild(iframe);\r\n\r\n        form.submit();\r\n\r\n        if (baseForm) {\r\n            form.removeChild(hiddenParamsDiv);\r\n            if (originalFormAction !== null) {\r\n                form.setAttribute('action', originalFormAction);\r\n            } else {\r\n                form.removeAttribute('action');\r\n            }\r\n        } else {\r\n            form.parentNode.removeChild(form);\r\n        }\r\n    }\r\n    //расширяем namespace\r\n    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\r\n})();\r\nexport {gmxAPIutils};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Utils.js","import {gmxAPIutils as utils} from './Utils.js';\r\n\r\nvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\r\n    styleCanvasKeysLen = styleCanvasKeys.length;\r\n\r\nvar setCanvasStyle = function(prop, indexes, ctx, style) {\r\n    for (var i = 0; i < styleCanvasKeysLen; i++) {\r\n        var key = styleCanvasKeys[i],\r\n            valKey = style[key];\r\n        if (valKey !== ctx[key]) {\r\n            ctx[key] = valKey;\r\n        }\r\n    }\r\n    if (style.dashArray) {\r\n        var dashes = style.dashArray,\r\n            dashOffset = style.dashOffset || 0;\r\n        if ('setLineDash' in ctx) {\r\n            ctx.setLineDash(dashes);\r\n            if (ctx.lineDashOffset !== dashOffset) {\r\n                ctx.lineDashOffset = dashOffset;\r\n            }\r\n        }\r\n    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n        ctx.setLineDash([]);\r\n    }\r\n    if (ctx.lineCap !== 'round') { ctx.lineCap = 'round'; }\r\n    if (ctx.lineJoin !== 'round') { ctx.lineJoin = 'round'; }\r\n\r\n    if (style.canvasPattern) {\r\n        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\r\n    } else if (style.fillLinearGradient) {\r\n        var rgr = style.fillLinearGradient,\r\n            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\r\n            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\r\n            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\r\n            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\r\n            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\r\n        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\r\n            var arr1 = rgr.addColorStop[j],\r\n                arrFunc = rgr.addColorStopFunctions[j],\r\n                p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0]),\r\n                p2 = (arr1.length < 3 ? 100 : (arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2])),\r\n                p1 = utils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\r\n            lineargrad.addColorStop(p0, p1);\r\n        }\r\n        ctx.fillStyle = style.fillStyle = lineargrad;\r\n    }\r\n};\r\n\r\n/*\r\ngeoItem\r\n     properties: объект (в формате векторного тайла)\r\n     dataOption: дополнительные свойства объекта\r\nitem\r\n     skipRasters: скрыть растр\r\n     currentStyle: текущий canvas стиль объекта\r\n     parsedStyleKeys: стиль прошедший парсинг\r\noptions\r\n     ctx: canvas context\r\n     tbounds: tile bounds\r\n     tpx: X смещение тайла\r\n     tpy: Y смещение тайла\r\n     gmx: ссылка на layer._gmx\r\n        gmx.currentZoom\r\n        gmx.lastHover\r\n        gmx.tileAttributeIndexes\r\n     bgImage: растр для background\r\n     rasters: растры по объектам для background\r\ncurrentStyle\r\n    текущий стиль\r\nstyle\r\n    стиль в новом формате\r\n    style.image - для type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n*/\r\nL.gmxUtil.drawGeoItem = function(geoItem, item, options, currentStyle, style) {\r\n    var propsArr = geoItem.properties,\r\n        idr = propsArr[0],\r\n        i, len, j, len1,\r\n        gmx = options.gmx,\r\n        ctx = options.ctx,\r\n        geom = propsArr[propsArr.length - 1],\r\n        coords = null,\r\n        dataOption = geoItem.dataOption,\r\n        rasters = options.rasters || {},\r\n        tbounds = options.tbounds;\r\n\r\n    item.currentStyle = L.extend({}, currentStyle);\r\n    if (style) {\r\n        if (gmx.styleHook) {\r\n            if (!geoItem.styleExtend) {\r\n                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\r\n            }\r\n            if (geoItem.styleExtend) {\r\n                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\r\n    } else {\r\n        style = {};\r\n    }\r\n\r\n    var geoType = geom.type,\r\n        dattr = {\r\n            gmx: gmx,\r\n            item: item,\r\n            style: style,\r\n            styleExtend: geoItem.styleExtend || {},\r\n            ctx: ctx,\r\n            tpx: options.tpx,\r\n            tpy: options.tpy\r\n        };\r\n    if (geoType === 'POINT') {\r\n        dattr.pointAttr = utils.getPixelPoint(dattr, geom.coordinates);\r\n        if (!dattr.pointAttr) { return false; }   // point not in canvas tile\r\n    }\r\n    if (geoType === 'POINT' || geoType === 'MULTIPOINT') { // Отрисовка геометрии точек\r\n        coords = geom.coordinates;\r\n        if ('iconColor' in style && style.image) {\r\n            if (style.lastImage !== style.image) {\r\n                style.lastImage = style.image;\r\n                style.lastImageData = utils.getImageData(style.image);\r\n            }\r\n            dattr.imageData = style.lastImageData;\r\n        }\r\n\r\n        if (geoType === 'MULTIPOINT') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                dattr.coords = coords[i];\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            dattr.coords = coords;\r\n            utils.pointToCanvas(dattr);\r\n        }\r\n    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\r\n        if (style.image) { // set MULTIPOLYGON as marker\r\n            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\r\n            dattr.pointAttr = utils.getPixelPoint(dattr, dattr.coords);\r\n            if (dattr.pointAttr) {\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            coords = geom.coordinates;\r\n            if (geoType === 'POLYGON') { coords = [coords]; }\r\n\r\n            var hiddenLines = dataOption.hiddenLines || [],\r\n                pixelsMap = dataOption.pixels,\r\n                flagPixels = true;\r\n\r\n            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\r\n                pixelsMap = dataOption.pixels = utils.getCoordsPixels({\r\n                    gmx: gmx,\r\n                    coords: coords,\r\n                    tpx: options.tpx,\r\n                    tpy: options.tpy,\r\n                    hiddenLines: hiddenLines\r\n                });\r\n            }\r\n\r\n            var coordsToCanvas = function(func, flagFill) {\r\n                coords = pixelsMap.coords;\r\n                hiddenLines = pixelsMap.hidden || [];\r\n                dattr.flagPixels = flagPixels;\r\n                for (i = 0, len = coords.length; i < len; i++) {\r\n                    var coords1 = coords[i];\r\n                    var hiddenLines1 = hiddenLines[i] || [];\r\n                    ctx.beginPath();\r\n                    for (j = 0, len1 = coords1.length; j < len1; j++) {\r\n                        dattr.coords = coords1[j];\r\n                        dattr.hiddenLines = hiddenLines1[j] || [];\r\n                        func(dattr);\r\n                    }\r\n                    ctx.closePath();\r\n                    if (flagFill) { ctx.fill(); }\r\n                }\r\n            };\r\n            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\r\n                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\r\n            if (strokeStyle && lineWidth) {\r\n                coordsToCanvas(utils.polygonToCanvas);\r\n            }\r\n            if (options.bgImage) {\r\n                dattr.bgImage = options.bgImage;\r\n            } else if (rasters[idr]) {\r\n                dattr.bgImage = rasters[idr];\r\n            }\r\n            if (dattr.styleExtend.skipRasters || item.skipRasters) {\r\n                delete dattr.bgImage;\r\n            }\r\n            if (style.imagePattern) {\r\n                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\r\n            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                if (utils.isPatternNode(dattr.bgImage)) {\r\n                    if ('rasterOpacity' in gmx) { ctx.globalAlpha = gmx.rasterOpacity; }\r\n                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\r\n                    style.bgImage = true;\r\n                }\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n                ctx.globalAlpha = 1;\r\n            }\r\n            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\r\n                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n            }\r\n        }\r\n    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\r\n        coords = geom.coordinates;\r\n        if (geoType === 'LINESTRING') { coords = [coords]; }\r\n        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\r\n        for (i = 0, len = coords.length; i < len; i++) {\r\n            var arr = tbounds.clipPolyLine(coords[i], true, size);\r\n            for (j = 0, len1 = arr.length; j < len1; j++) {\r\n                dattr.coords = arr[j];\r\n                var pixels = utils.lineToCanvas(dattr);\r\n                if (pixels) {\r\n                    ctx.save();\r\n                    utils.lineToCanvasAsIcon(pixels, dattr);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DrawCanvas.js","/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n*/\r\nvar gmxSessionManager = {\r\n    APIKEY_PARAM: 'key',\r\n    SCRIPT_REGEXP: [\r\n\t\t/\\bleaflet-geomixer(-\\w*)?\\.js\\b/,\r\n\t\t/\\bgeomixer(-\\w*)?\\.js\\b/\r\n\t],\r\n    _scriptSearched: false,\r\n    _scriptAPIKey: null,\r\n    _searchScriptAPIKey: function() {\r\n        var _this = this;\r\n        if (this._scriptSearched) {\r\n            return this._scriptAPIKey;\r\n        }\r\n\r\n        var scripts = document.getElementsByTagName('script');\r\n        for (var i = 0; i < scripts.length; i++) {\r\n            var src = scripts[i].getAttribute('src'),\r\n\t\t\t\tarr = this.SCRIPT_REGEXP;\r\n\t\t\tfor (var j = 0, len = arr.length; j < len; j++) {\r\n\t\t\t\tif (arr[j].exec(src)) {\r\n\t\t\t\t\tvar query = src.split('?')[1];\r\n\r\n\t\t\t\t\tif (query) {\r\n\t\t\t\t\t\tvar params = query.split('&');\r\n\t\t\t\t\t\tfor (var p = 0; p < params.length; p++) {\r\n\t\t\t\t\t\t\tvar parsedParam = params[p].split('=');\r\n\t\t\t\t\t\t\tif (parsedParam[0] === _this.APIKEY_PARAM) {\r\n\t\t\t\t\t\t\t\t_this._scriptAPIKey = parsedParam[1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n            }\r\n\t\t\tif (_this._scriptAPIKey) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n        }\r\n        this._scriptSearched = true;\r\n        return this._scriptAPIKey;\r\n    },\r\n\r\n    //we will search apiKey in script tags iff apiKey parameter is undefined.\r\n    //if it is defined as falsy (null, '', etc), we won't send any requests to server\r\n    requestSessionKey: function(serverHost, apiKey) {\r\n        var keys = this._sessionKeys;\r\n\r\n        if (!(serverHost in keys)) {\r\n            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\r\n            keys[serverHost] = new L.gmx.Deferred();\r\n            if (apiKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/ApiKey.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        Key: apiKey\r\n                    }\r\n                ).then(function(response) {\r\n                    if (response && response.Status === 'ok') {\r\n                        keys[serverHost].resolve(response.Result.Key);\r\n                    } else {\r\n                        keys[serverHost].reject();\r\n                    }\r\n                }, keys[serverHost].reject);\r\n            } else {\r\n                keys[serverHost].resolve('');\r\n            }\r\n        }\r\n        return keys[serverHost];\r\n    },\r\n\r\n    //get already received session key\r\n    getSessionKey: function(serverHost) {\r\n        var keyPromise = this._sessionKeys[serverHost];\r\n\r\n        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\r\n    },\r\n    _sessionKeys: {} //deferred for each host\r\n};\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxSessionManager = gmxSessionManager;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/SessionManager.js","/** Asynchronously request information about map given server host and map name\r\n*/\r\nimport {gmxAPIutils} from './Utils.js';\r\nvar gmxMapManager = {\r\n    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\r\n    getMap: function(serverHost, apiKey, mapName, skipTiles) {\r\n        var maps = this._maps;\r\n        if (!maps[serverHost] || !maps[serverHost][mapName]) {\r\n            var def = new L.gmx.Deferred();\r\n            maps[serverHost] = maps[serverHost] || {};\r\n            maps[serverHost][mapName] = {promise: def};\r\n\r\n            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function(sessionKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/TileSender.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        skipTiles: skipTiles || 'None', // All, NotVisible, None\r\n                        key: sessionKey,\r\n                        MapName: mapName,\r\n                        ModeKey: 'map'\r\n                    }\r\n                ).then(function(json) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        json.Result.properties.hostName = serverHost;\r\n                        def.resolve(json.Result);\r\n                    } else {\r\n                        def.reject(json);\r\n                    }\r\n                }, def.reject);\r\n            }, def.reject);\r\n        }\r\n        return maps[serverHost][mapName].promise;\r\n    },\r\n\r\n\tsyncParams: {},\r\n    // установка дополнительных параметров для серверных запросов\r\n    setSyncParams: function(hash) {\r\n\t\tthis.syncParams = hash;\r\n    },\r\n    getSyncParams: function(stringFlag) {\r\n\t\tvar res = this.syncParams;\r\n\t\tif (stringFlag) {\r\n\t\t\tvar arr = [];\r\n\t\t\tfor (var key in res) {\r\n\t\t\t\tarr.push(key + '=' + res[key]);\r\n\t\t\t}\r\n\t\t\tres = arr.join('&');\r\n\t\t}\r\n\t\treturn res;\r\n    },\r\n\r\n    //we will (lazy) create index by layer name to speed up multiple function calls\r\n    findLayerInfo: function(serverHost, mapID, layerID) {\r\n        var hostMaps = this._maps[serverHost],\r\n            mapInfo = hostMaps && hostMaps[mapID];\r\n\r\n        if (!mapInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (mapInfo.layers) {\r\n            return mapInfo.layers[layerID];\r\n        }\r\n\r\n        var serverData = mapInfo.promise.getFulfilledData();\r\n\r\n        if (!serverData) {\r\n            return null;\r\n        }\r\n\r\n        mapInfo.layers = {};\r\n\r\n        //create index by layer name\r\n        gmxMapManager.iterateLayers(serverData[0], function(layerInfo) {\r\n            mapInfo.layers[layerInfo.properties.name] = layerInfo;\r\n        });\r\n\r\n        return mapInfo.layers[layerID];\r\n    },\r\n    iterateLayers: function(treeInfo, callback) {\r\n        var iterate = function(arr) {\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var layer = arr[i];\r\n\r\n                if (layer.type === 'group') {\r\n                    iterate(layer.content.children);\r\n                } else if (layer.type === 'layer') {\r\n                    callback(layer.content);\r\n                }\r\n            }\r\n        };\r\n\r\n        treeInfo && iterate(treeInfo.children);\r\n    },\r\n    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\r\n};\r\nexport {gmxMapManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/MapManager.js","//Helper class, that represents layers of single Geomixer's map\r\n//Creates layers from given map description\r\nvar gmxMap = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    initialize: function(mapInfo, commonLayerOptions) {\r\n\t\tthis.layers = [];\r\n\t\tthis.layersByTitle = {};\r\n\t\tthis.layersByID = {};\r\n\t\tthis.dataManagers = {};\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.properties = L.extend({}, mapInfo.properties);\r\n\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\r\n\t\tthis.rawTree = mapInfo;\r\n\r\n\t\tthis.layersCreated = new L.gmx.Deferred();\r\n\r\n\t\tvar missingLayerTypes = {},\r\n\t\t\tdataSources = {};\r\n\r\n\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function(layerInfo) {\r\n\t\t\tvar props = layerInfo.properties,\r\n\t\t\t\tmeta = props.MetaProperties || {},\r\n\t\t\t\toptions = {\r\n\t\t\t\t\tmapID: mapInfo.properties.name,\r\n\t\t\t\t\tlayerID: props.name\r\n\t\t\t\t};\r\n\r\n\t\t\tprops.hostName = mapInfo.properties.hostName;\r\n\r\n\t\t\tvar type = props.ContentID || props.type,\r\n\t\t\t\tlayerOptions = L.extend(options, commonLayerOptions);\r\n\r\n\t\t\tif (props.dataSource || 'parentLayer' in meta) {      \t// Set dataSource layer\r\n\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\r\n\t\t\t\tif ('parentLayer' in meta) {      \t// todo удалить после изменений вов вьювере\r\n\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\r\n\t\t\t\t}\r\n\t\t\t\tdataSources[options.layerID] = {\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t};\r\n\t\t\t} else if (type in L.gmx._layerClasses) {\r\n\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\r\n\t\t\t} else {\r\n\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\r\n\t\t\t\tmissingLayerTypes[type].push({\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t//load missing layer types\r\n\t\tvar loaders = [];\r\n\t\tfor (var type in missingLayerTypes) {\r\n\t\t\tloaders.push(L.gmx._loadLayerClass(type).then(/*eslint-disable no-loop-func */function (type) {/*eslint-enable */\r\n\t\t\t\tvar it = missingLayerTypes[type];\r\n\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\r\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\r\n\t\t\t\t}\r\n\t\t\t}.bind(null, type)));\r\n\t\t}\r\n\t\tvar hosts = {}, host, id, it;\r\n\t\tfor (id in dataSources) {\r\n\t\t\tit = dataSources[id];\r\n\t\t\tvar opt = it.options,\r\n\t\t\t\tpId = opt.parentLayer,\r\n\t\t\t\tpLayer = this.layersByID[pId];\r\n\t\t\tif (pLayer) {\r\n\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\r\n\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);\r\n\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\r\n\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\r\n\t\t\t} else {\r\n\t\t\t\thost = opt.hostName;\r\n\t\t\t\tif (!hosts[host]) { hosts[host] = {}; }\r\n\t\t\t\tif (!hosts[host][pId]) { hosts[host][pId] = []; }\r\n\t\t\t\thosts[host][pId].push(id);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (host in hosts) {\r\n\t\t\tvar arr = [],\r\n\t\t\t\tprefix = 'http://' + host;\r\n\t\t\tfor (id in hosts[host]) {\r\n\t\t\t\tarr.push({Layer: id});\r\n\t\t\t}\r\n\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx',\r\n\t\t\t\t{\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\tLayers: JSON.stringify(arr)\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tids: hosts[host]\r\n\t\t\t\t}\r\n\t\t\t).then(function(json, opt) {\r\n\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\r\n\t\t\t\t\tjson.Result.forEach(function(it) {\r\n\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\r\n\t\t\t\t\t\t\tprops = it.properties,\r\n\t\t\t\t\t\t\tpId = props.name;\r\n\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\tvar pt = dataSources[id];\r\n\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\r\n\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\r\n\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\r\n\t\t\t\t\tif (opt && opt.ids) {\r\n\t\t\t\t\t\tfor (var pId in opt.ids) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\r\n\t},\r\n\r\n\taddDataManager: function(it) {\r\n\t\tvar pid = it.properties.name;\r\n\t\tif (!this.dataManagers[pid]) {\r\n\t\t\tthis.dataManagers[pid] = new DataManager(it.properties);\r\n\t\t}\r\n\t\treturn this.dataManagers[pid];\r\n\t},\r\n\tgetDataManager: function(id) {\r\n\t\treturn this.dataManagers[id];\r\n\t},\r\n\r\n\taddLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tthis.layers.push(layer);\r\n\t\tthis.layersByTitle[props.title] = layer;\r\n\t\tthis.layersByID[props.name] = layer;\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tfor (var i = 0; i < this.layers.length; i++) {\r\n\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\r\n\t\t\t\tthis.layers.splice(i, 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdelete this.layersByTitle[props.title];\r\n\t\tdelete this.layersByID[props.name];\r\n\t\tthis.fire('layerremove', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddLayersToMap: function(leafletMap) {\r\n\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\r\n\t\t\tvar layer = this.layers[l];\r\n\t\t\tif (layer.getGmxProperties().visible) {\r\n\t\t\t\tleafletMap.addLayer(layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxMap = gmxMap;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/GeomixerMap.js","/*\r\n * gmxEventsManager - handlers manager\r\n */\r\nvar GmxEventsManager = L.Handler.extend({\r\n    options: {\r\n    },\r\n\r\n    initialize: function (map) {\r\n        this._map = map;\r\n        this._layers = {};\r\n        this._lastLayer = null;\r\n        this._lastId = null;\r\n        var _this = this;\r\n        this._drawstart = null;\r\n        this._lastCursor = '';\r\n\r\n        var isDrawing = function () {\r\n            if (_this._drawstart) {\r\n                return true;\r\n            } else if (_this._drawstart === null) {\r\n                if (map.gmxControlsManager) {\r\n                    var drawingControl = map.gmxControlsManager.get('drawing');\r\n                    if (drawingControl) {\r\n                        drawingControl.on('activechange', function (ev) {\r\n                            _this._drawstart = ev.activeIcon;\r\n                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\r\n                        });\r\n                    }\r\n                }\r\n                _this._drawstart = false;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        var getDomIndex = function (layer) {\r\n            var container = layer._container;\r\n            if (container) {\r\n                var arr = container.parentNode.childNodes;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    if (container === arr[i]) {\r\n                        return i;\r\n                    }\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n\r\n        var skipNodeName = {\r\n            IMG: true,\r\n            DIV: true,\r\n            path: true\r\n        };\r\n\r\n        var clearLastHover = function () {\r\n            if (_this._lastLayer) {\r\n                _this._lastLayer.gmxEventCheck({type: 'mousemove'}, true);\r\n                _this._lastLayer = null;\r\n            }\r\n        };\r\n\r\n        var eventCheck = function (ev) {\r\n            var type = ev.type,\r\n                map = _this._map,\r\n                skipNode = false;\r\n            if (ev.originalEvent) {\r\n                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\r\n                var target = ev.originalEvent.target;\r\n                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\r\n            }\r\n            if (map._animatingZoom ||\r\n                isDrawing() ||\r\n                skipNode ||\r\n                (type === 'click' &&  map._skipClick) ||        // from drawing\r\n                (type === 'mousemove' &&  map.gmxMouseDown)\r\n                ) {\r\n                clearLastHover();\r\n                map._skipClick = false;\r\n                return;\r\n            }\r\n            if (ev.layerPoint) {\r\n                map._gmxMouseLatLng = ev.latlng;\r\n                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\r\n            }\r\n\r\n            var arr = Object.keys(_this._layers).sort(function(a, b) {\r\n                var la = map._layers[a],\r\n                    lb = map._layers[b];\r\n                if (la && lb) {\r\n                    var oa = la.options, ob = lb.options,\r\n                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\r\n                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\r\n                        delta = zb - za;\r\n                    return delta ? delta : _this._layers[b] - _this._layers[a];\r\n                }\r\n                return 0;\r\n            });\r\n\r\n            var layer,\r\n                foundLayer = null,\r\n                cursor = '';\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                layer = map._layers[id];\r\n                if (layer && layer._map && !layer._animating && layer.options.clickable) {\r\n                    if (layer.gmxEventCheck(ev)) {\r\n                        if (layer.hasEventListeners('mouseover')) {\r\n                            cursor = 'pointer';\r\n                        }\r\n                        foundLayer = layer;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (_this._lastCursor !== cursor && !isDrawing()) {\r\n                map._container.style.cursor = cursor;\r\n            }\r\n            _this._lastCursor = cursor;\r\n\r\n            if (type !== 'zoomend') {\r\n                if (foundLayer) {\r\n                    if (_this._lastLayer !== foundLayer) {\r\n                        clearLastHover();\r\n                    }\r\n                    _this._lastLayer = foundLayer;\r\n                } else {\r\n                    clearLastHover();\r\n                }\r\n            }\r\n        };\r\n\r\n        map.on({\r\n            zoomend: function () {\r\n                if (map._gmxMouseLatLng) {\r\n                    setTimeout(function () {\r\n                        eventCheck({type: 'mousemove', latlng: map._gmxMouseLatLng});\r\n                    }, 0);\r\n                }\r\n            },\r\n            click: eventCheck,\r\n            dblclick: eventCheck,\r\n            mousedown: eventCheck,\r\n            mouseup: eventCheck,\r\n            mousemove: eventCheck,\r\n            contextmenu: eventCheck,\r\n            layeradd: function (ev) {\r\n                var layer = ev.layer;\r\n                if ('gmxEventCheck' in layer && layer.options.clickable) {\r\n                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\r\n                }\r\n            },\r\n            layerremove: function (ev) {\r\n                var id = ev.layer._leaflet_id;\r\n                delete _this._layers[id];\r\n                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\r\n                    _this._lastLayer = null;\r\n                    _this._lastId = 0;\r\n                }\r\n            }\r\n        }, this);\r\n    }\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n    // Check to see if handler has already been initialized.\r\n    if (!this._gmxEventsManager) {\r\n        this._gmxEventsManager = new GmxEventsManager(this);\r\n\t\tthis.isGmxDrawing = function () {\r\n\t\t\treturn this._gmxEventsManager._drawstart;\r\n\t\t};\r\n\r\n        this.on('remove', function () {\r\n            if (this._gmxEventsManager) {\r\n                this._gmxEventsManager.removeHooks();\r\n            }\r\n        });\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/EventsManager.js","(function() {\r\n    var DEFAULT_LANGUAGE = 'rus',\r\n        _setKeyText = function(lang, key, item, hash) {\r\n            if (!hash[lang]) { hash[lang] = {}; }\r\n            hash[lang][key] = item;\r\n        };\r\n    L.gmxLocale = {\r\n\r\n        setLanguage: function(lang) {\r\n            this._language = lang;\r\n        },\r\n\r\n        getLanguage: function() {\r\n            return window.language || this._language || DEFAULT_LANGUAGE;\r\n        }\r\n    };\r\n\r\n    L.gmxLocaleMixin = {\r\n        addText: function() {\r\n            var lang = arguments[0],\r\n                newHash = arguments[1];\r\n            if (arguments.length === 1) {\r\n                newHash = lang;\r\n                lang = null;\r\n            }\r\n            for (var k in newHash) {\r\n                if (lang === null) {\r\n                    for (var k1 in newHash[k]) {\r\n                        _setKeyText(k, k1, newHash[k][k1], this);\r\n                    }\r\n                } else {\r\n                    _setKeyText(lang, k, newHash[k], this);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n\r\n        getText: function(key) {\r\n            var lang = L.gmxLocale.getLanguage(),\r\n                locale = this[lang] || {};\r\n\r\n            var keyArr = key ? key.split(/\\./) : [];\r\n            for (var i = 0, len = keyArr.length; i < len; i++) {\r\n                if (!locale) { break; }\r\n                locale = locale[keyArr[i]];\r\n            }\r\n            return locale;\r\n        }\r\n    };\r\n    L.extend(L.gmxLocale, L.gmxLocaleMixin);\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Locale.js","L.extend(L.gmxLocale, {\r\n    rus: {\r\n        Coordinates : 'Координаты',\r\n        Length : 'Длина',\r\n        nodeLength : 'Длина от начала',\r\n        edgeLength : 'Длина сегмента',\r\n        Area : 'Площадь',\r\n        Perimeter : 'Периметр',\r\n        units: {\r\n            m: 'м',\r\n            nm: 'м.мили',\r\n            km: 'км',\r\n            m2: 'кв. м',\r\n            km2: 'кв. км',\r\n            ha: 'га',\r\n            m2html: 'м<sup>2',\r\n            km2html: 'км<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_ru.js","L.extend(L.gmxLocale, {\r\n    eng: {\r\n        Coordinates : 'Coordinates',\r\n        Length : 'Length',\r\n        nodeLength : 'From start point',\r\n        edgeLength : 'Segment length',\r\n        Area : 'Area',\r\n        Perimeter : 'Perimeter',\r\n        units: {\r\n            m: 'm',\r\n            nm: 'nmi',\r\n            km: 'km',\r\n            m2: 'sq. m',\r\n            km2: 'sq. km',\r\n            ha: 'ha',\r\n            m2html: 'm<sup>2',\r\n            km2html: 'km<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_en.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar gmxVectorTileLoader = {\r\n    _loadedTiles: {},\r\n    _getKey: function(ti) {\r\n        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\r\n    },\r\n    load: function(tileSenderPrefix, tileInfo) {\r\n        var key = gmxVectorTileLoader._getKey(tileInfo);\r\n\r\n        if (!this._loadedTiles[key]) {\r\n            var def = new L.gmx.Deferred();\r\n            this._loadedTiles[key] = def;\r\n\r\n            var requestParams = {\r\n                ModeKey: 'tile',\r\n                r: 'j',\r\n                LayerName: tileInfo.layerID,\r\n                z: tileInfo.z,\r\n                x: tileInfo.x,\r\n                y: tileInfo.y,\r\n                v: tileInfo.v\r\n            };\r\n\r\n            if (tileInfo.d !== -1) {\r\n                requestParams.Level = tileInfo.d;\r\n                requestParams.Span = tileInfo.s;\r\n            }\r\n\r\n            gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, {callbackParamName: null}).then(null, function() {\r\n                def.reject();\r\n            });\r\n        }\r\n\r\n        return this._loadedTiles[key];\r\n    }\r\n};\r\n\r\nwindow.gmxAPI = window.gmxAPI || {};\r\nwindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function(data) {\r\n    var key = gmxVectorTileLoader._getKey({\r\n        layerID: data.LayerName,\r\n        x: data.x,\r\n        y: data.y,\r\n        z: data.z,\r\n        d: data.level,\r\n        s: data.span,\r\n        v: data.v\r\n    });\r\n\r\n    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\r\n};\r\nexport {gmxVectorTileLoader};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTileLoader.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n//Single vector tile, received from GeoMixer server\r\n//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\r\n//      - {Object[]} data - information about vector objects in tile\r\n//      - {Number[4]} [bbox] - optional bbox of objects in tile\r\n//  options:\r\n//      x, y, z, v, s, d: GeoMixer vector tile point\r\n//      dateZero: zero Date for temporal layers\r\n//      isGeneralized: flag for generalized tile\r\nvar VectorTile = function(dataProvider, options) {\r\n    this.dataProvider = dataProvider;\r\n    this.loadDef = new L.gmx.Deferred();\r\n    this.data = null;\r\n    this.dataOptions = null;\r\n\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.z = options.z;\r\n    this.v = options.v;\r\n    this.s = options.s || -1;\r\n    this.d = options.d || -1;\r\n    this.isGeneralized = options.isGeneralized;\r\n    this.isFlatten = options.isFlatten;\r\n    this.bounds = gmxAPIutils.getTileBounds(this.x, this.y, this.z);\r\n    this.gmxTilePoint = {x: this.x, y: this.y, z: this.z, s: this.s, d: this.d};\r\n    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\r\n\r\n    if (this.s >= 0 && options.dateZero) {\r\n        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * gmxAPIutils.oneDay * 1000);\r\n        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * gmxAPIutils.oneDay * 1000);\r\n    }\r\n\r\n    this.state = 'notLoaded'; //notLoaded, loading, loaded\r\n};\r\n\r\nVectorTile.prototype = {\r\n    addData: function(data, keys) {\r\n\r\n        if (keys) {\r\n            this.removeData(keys, true);\r\n        }\r\n\r\n        var len = data.length,\r\n            dataOptions = new Array(len),\r\n            dataBounds = gmxAPIutils.bounds();\r\n        for (var i = 0; i < len; i++) {\r\n            var dataOption = this._parseItem(data[i]);\r\n            dataOptions[i] = dataOption;\r\n            dataBounds.extendBounds(dataOption.bounds);\r\n        }\r\n\r\n        if (!this.data) {\r\n            this.data = data;\r\n            this.dataOptions = dataOptions;\r\n        } else {\r\n            this.data = this.data.concat(data);\r\n            this.dataOptions = this.dataOptions.concat(dataOptions);\r\n        }\r\n\r\n        this.state = 'loaded';\r\n\r\n        this.loadDef.resolve(this.data);\r\n        return dataBounds;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\r\n            if (keys[arr[i][0]]) {\r\n                arr.splice(i, 1);\r\n                if (this.dataOptions) { this.dataOptions.splice(i, 1); }\r\n            }\r\n        }\r\n    },\r\n\r\n    load: function() {\r\n        if (this.state === 'notLoaded') {\r\n            this.state = 'loading';\r\n            var _this = this;\r\n            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function(data, bbox) {\r\n                _this.bbox = bbox;\r\n                _this.addData(data);\r\n            });\r\n        }\r\n\r\n        return this.loadDef;\r\n    },\r\n\r\n    clear: function() {\r\n        this.state = 'notLoaded';\r\n        this.data = null;\r\n        this.dataOptions = null;\r\n\r\n        this.loadDef = new L.gmx.Deferred();\r\n    },\r\n\r\n    _parseItem: function(it) {\r\n        var len = it.length,\r\n            i;\r\n\r\n        // TODO: old properties null = ''\r\n        for (i = 0; i < len; i++) {\r\n            if (it[i] === null) { it[i] = ''; }\r\n        }\r\n\r\n        var geo = it[len - 1],\r\n            needFlatten = this.isFlatten,\r\n            type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates,\r\n            hiddenLines = [],\r\n            bounds = null,\r\n            boundsArr = [];\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            bounds = gmxAPIutils.bounds();\r\n            var edgeBounds = gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\r\n                hiddenFlag = false;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr = [],\r\n                    hiddenLines1 = [];\r\n\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\r\n                        coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                    }\r\n                    var b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                    // EdgeLines calc\r\n                    var edgeArr = gmxAPIutils.getHidden(coords[i][j], edgeBounds);\r\n                    hiddenLines1.push(edgeArr);\r\n                    if (edgeArr.length) {\r\n                        hiddenFlag = true;\r\n                    }\r\n                }\r\n                boundsArr.push(arr);\r\n                hiddenLines.push(hiddenLines1);\r\n            }\r\n            if (!hiddenFlag) { hiddenLines = null; }\r\n            if (isPolygon) { boundsArr = boundsArr[0]; }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds([coords[i]]));\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds(coords[i]));\r\n            }\r\n        }\r\n        var dataOption = {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n        if (hiddenLines) {\r\n            dataOption.hiddenLines = hiddenLines;\r\n        }\r\n        return dataOption;\r\n    }\r\n};\r\n//class methods\r\n\r\nVectorTile.makeTileKey = function(x, y, z, v, s, d) {\r\n    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\r\n};\r\n\r\nVectorTile.createTileKey = function(opt) {\r\n    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\r\n};\r\n\r\nVectorTile.parseTileKey = function(gmxTileKey) {\r\n    var p = gmxTileKey.split('_').map(function(it) { return Number(it); });\r\n    return {z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5]};\r\n};\r\n\r\nVectorTile.boundsFromTileKey = function(gmxTileKey) {\r\n    var p = VectorTile.parseTileKey(gmxTileKey);\r\n    return gmxAPIutils.getTileBounds(p.x, p.y, p.z);\r\n};\r\nexport {VectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTile.js","//Single observer with vector data\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nvar Observer = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    /* options : {\r\n            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n                                        // `update` - send only changed data\r\n            callback: Func,             // will be called when layer's data for this observer is changed\r\n            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n            bbox: bbox,                 // bbox to observe on Mercator\r\n            filters: [String]           // filter keys array\r\n            active: [Boolean=true]      // is this observer active\r\n            targetZoom: [Number]        // for zoom generalized type default(null)\r\n        }\r\n    */\r\n    initialize: function(options) {\r\n        this.type = options.type || 'update';\r\n        this._callback = options.callback;\r\n        this._items = null;\r\n        this.bbox = options.bbox;      // set bbox by Mercator bounds\r\n        this.filters = options.filters || [];\r\n        this.targetZoom = options.targetZoom || null;\r\n        this.active = 'active' in options ? options.active : true;\r\n\r\n        if (options.bounds) {   // set bbox by LatLngBounds\r\n            this.setBounds(options.bounds);\r\n        }\r\n\r\n\t\tvar w = gmxAPIutils.worldWidthMerc,\r\n\t\t\tdx;\r\n        if (!this.bbox) {\r\n            this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n            this.world = true;\r\n        } else if (this.bbox.max.x > w) {\r\n\t\t\tdx = this.bbox.max.x - w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\r\n        } else if (this.bbox.min.x < -w) {\r\n\t\t\tdx = this.bbox.min.x + w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\r\n        }\r\n\r\n        if (options.dateInterval) {\r\n            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\r\n        }\r\n    },\r\n\r\n    hasFilter: function(filterName) {\r\n        for (var i = 0, len = this.filters.length; i < len; i++) {\r\n            if (this.filters[i] === filterName) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    activate: function() {\r\n        if (!this.active) {\r\n            this.active = true;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    deactivate: function() {\r\n        if (this.active) {\r\n            this.active = false;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    toggleActive: function(isActive) {\r\n        return isActive ? this.activate() : this.deactivate();\r\n    },\r\n\r\n    isActive: function() {\r\n        return this.active;\r\n    },\r\n\r\n    updateData: function(data) {\r\n        var len = data.length,\r\n            out = {count: len};\r\n\r\n        if (this.type === 'update') {\r\n            //calculate difference with previous data\r\n            if (!this._items) { this._items = {}; }\r\n            var prevItems = this._items,\r\n                newItems = {},\r\n                added = [],\r\n                removed = [],\r\n                key;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                var it = data[i];\r\n\r\n                key = it.id + '_' + it.tileKey;\r\n\r\n                newItems[key] = it;\r\n\r\n                if (!prevItems[key]) {\r\n                    added.push(it);\r\n                }\r\n            }\r\n\r\n            for (key in prevItems) {\r\n                if (!newItems[key]) {\r\n                    removed.push(prevItems[key]);\r\n                }\r\n            }\r\n\r\n            if (added.length) {\r\n                out.added = added;\r\n            }\r\n            if (removed.length) {\r\n                out.removed = removed;\r\n            }\r\n\r\n            this._items = newItems;\r\n\r\n        } else {\r\n            out.added = data;\r\n        }\r\n        this._callback(out);\r\n        out = null;\r\n        data = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        if (this.type !== 'update' || !this._items) {\r\n            return this;\r\n        }\r\n\r\n        var items = this._items,\r\n            removed = [];\r\n\r\n        for (var id in keys) {\r\n            if (items[id]) {\r\n                removed.push(items[id]);\r\n                delete items[id];\r\n            }\r\n        }\r\n\r\n        if (removed.length) {\r\n            this._callback({removed: removed});\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /*setFilter: function (func) {\r\n        this._filters.userFilter = func;\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        delete this._filters.userFilter;\r\n        this.fire('update');\r\n        return this;\r\n    },*/\r\n\r\n    setBounds: function(bounds) {\r\n        var w;\r\n        if (!bounds) {\r\n            if (!this.world) {\r\n                w = gmxAPIutils.worldWidthMerc;\r\n                this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n                this.bbox1 = null;\r\n                this.world = true;\r\n                this.fire('update');\r\n            }\r\n            return this;\r\n        }\r\n\r\n        var min = bounds.min,\r\n            max = bounds.max;\r\n        if (!min || !max) {\r\n            var latLngBounds = L.latLngBounds(bounds),\r\n                sw = latLngBounds.getSouthWest(),\r\n                ne = latLngBounds.getNorthEast();\r\n            min = {x: sw.lng, y: sw.lat};\r\n            max = {x: ne.lng, y: ne.lat};\r\n        }\r\n        var minX = min.x, maxX = max.x,\r\n            minY = min.y, maxY = max.y,\r\n            minX1 = null,\r\n            maxX1 = null;\r\n\r\n        this.world = false;\r\n        w = (maxX - minX) / 2;\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n            this.world = true;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\r\n\r\n        this.bbox = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        this.bbox1 = null;\r\n        if (minX1) {\r\n            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\r\n            this.bbox1 = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        }\r\n\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    intersects: function(bounds) {\r\n        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\r\n    },\r\n\r\n    intersectsWithTile: function(tile) {\r\n        if (this.targetZoom) {\r\n            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\r\n            if ((tile.isGeneralized && tile.z !== z) || tile.z > z) { return false; }\r\n        }\r\n        var di = this.dateInterval;\r\n        return this.intersects(tile.bounds) && (!tile.beginDate || (di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate));\r\n    },\r\n\r\n    _setDateInterval: function(beginDate, endDate) {\r\n        if (beginDate && endDate) {\r\n            // var beginValue = beginDate.valueOf(),\r\n                // endValue = endDate.valueOf();\r\n            this.dateInterval = {\r\n                beginDate: beginDate,\r\n                endDate: endDate\r\n            };\r\n        } else {\r\n            this.dateInterval = null;\r\n        }\r\n    },\r\n\r\n    setDateInterval: function(beginDate, endDate) {\r\n        var isValid = beginDate && endDate;\r\n\r\n        if (!this.dateInterval !== !isValid ||\r\n            isValid && (\r\n                this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() ||\r\n                this.dateInterval.endDate.valueOf() !== endDate.valueOf()\r\n            )\r\n        ) {\r\n            this._setDateInterval(beginDate, endDate);\r\n            this.fire('update', {temporalFilter: true});\r\n        }\r\n        return this;\r\n    }\r\n});\r\nexport {Observer};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/Observer.js","(function() {\r\n//tree for fast tiles selection inside temporal interval\r\n//  options:\r\n//      TemporalTiles: tilePoints array\r\n//      TemporalVers: tiles version array\r\n//      TemporalPeriods: periods\r\n//      ZeroDate: start Date\r\nvar TilesTree = function(options) {\r\n    var _rootNodes = [],\r\n        tiles = options.TemporalTiles || [],\r\n        vers = options.TemporalVers || [],\r\n        periods = options.TemporalPeriods || [],\r\n        maxPeriod = periods[periods.length - 1],\r\n        smin = Number.MAX_VALUE,\r\n        arr = options.ZeroDate.split('.'),\r\n        zn = new Date(\r\n            (arr.length > 2 ? arr[2] : 2008),\r\n            (arr.length > 1 ? arr[1] - 1 : 0),\r\n            (arr.length > 0 ? arr[0] : 1)\r\n        ),\r\n        dateZero = new Date(zn.getTime()  - zn.getTimezoneOffset() * 60000),\r\n        zeroUT = dateZero.getTime() / 1000;\r\n\r\n    this.dateZero = dateZero;\r\n\r\n    var addTile = function (node, tile, key) {\r\n        var d = node.d;\r\n        if (tile.d === periods[d]) {\r\n            node.count++;\r\n            node.tiles.push(key);\r\n            return;\r\n        }\r\n\r\n        var pd = periods[d - 1],\r\n            childrenCount = periods[d] / pd;\r\n\r\n        if (!('children' in node)) {\r\n            node.children = new Array(childrenCount);\r\n        }\r\n\r\n        var sChild = Math.floor(tile.s * tile.d / pd),\r\n            ds = sChild - node.s * childrenCount;\r\n\r\n        if (!node.children[ds]) {\r\n            var pdOneDay = pd * gmxAPIutils.oneDay,\r\n                t1 = sChild * pdOneDay + zeroUT;\r\n            node.children[ds] = {\r\n                d: d - 1,\r\n                s: sChild,\r\n                t1: t1,\r\n                t2: t1 + pdOneDay,\r\n                count: 0,\r\n                children: [],\r\n                tiles: []\r\n            };\r\n        }\r\n\r\n        addTile(node.children[ds], tile, key);\r\n    };\r\n\r\n    var dmax = periods.length - 1,\r\n        dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\r\n        i, len;\r\n\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var s = Number(arr[1]),\r\n            d = Number(arr[0]);\r\n\r\n        if (d === maxPeriod) {\r\n            smin = Math.min(smin, s);\r\n        }\r\n    }\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var t = {\r\n            x: Number(arr[2]),\r\n            y: Number(arr[3]),\r\n            z: Number(arr[4]),\r\n            v: Number(vers[i]),\r\n            s: Number(arr[1]),\r\n            d: Number(arr[0])\r\n        };\r\n        if (t.d < 0) {\r\n            continue;\r\n        }\r\n\r\n        var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\r\n            cs = ds + smin;\r\n\r\n        _rootNodes[ds] = _rootNodes[ds] || {\r\n            d: dmax,\r\n            s: cs,\r\n            t1: cs * dmaxOneDay + zeroUT,\r\n            t2: (cs + 1) * dmaxOneDay + zeroUT,\r\n            count: 0,\r\n            tiles: []\r\n        };\r\n        var key = VectorTile.createTileKey(t);\r\n\r\n        addTile(_rootNodes[ds], t, key);\r\n    }\r\n    tiles = vers = null;\r\n\r\n    //options: bounds (in mercator projection)\r\n    this.selectTiles = function(t1, t2, options) {\r\n\r\n        options = options || {};\r\n\r\n        var t1Val = t1.valueOf() / 1000,\r\n            t2Val = t2.valueOf() / 1000;\r\n\r\n        // We will restrict tile levels by the nearest two levels to target date interval length\r\n        // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\r\n        var minLevel = 0,\r\n            dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\r\n\r\n        for (var i = 0; i < periods.length; i++) {\r\n            if (periods[i] > dateIntervalLength) {\r\n                minLevel = Math.max(0, i - 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (periods[periods.length - 1] <= dateIntervalLength) {\r\n            minLevel = periods.length - 1;\r\n        }\r\n\r\n        var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\r\n\r\n        var getCountOfIntersected = function(tileBounds, bounds) {\r\n            var count = 0;\r\n            for (var t = 0; t < tileBounds.length; t++) {\r\n                if (tileBounds[t].intersects(bounds)) {\r\n                    count++;\r\n                }\r\n            }\r\n\r\n            return count;\r\n        };\r\n\r\n        // --------------------\r\n        var selectTilesForNode = function(node, t1, t2) {\r\n            if (t1 >= node.t2 || t2 <= node.t1) {\r\n                return {count: 0, tiles: [], nodes: []};\r\n            }\r\n\r\n            if (options.bounds && !node.tileBounds) {\r\n                node.tileBounds = node.tiles.map(function(it) {\r\n                    return VectorTile.boundsFromTileKey(it);\r\n                });\r\n            }\r\n\r\n            if (node.d === minLevel) {\r\n                var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: count,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n\r\n            var childrenCount = 0, //number of tiles if we use shorter intervals\r\n                childrenRes = [],\r\n\t\t\t\tlen = node.children ? node.children.length : 0,\r\n                ds;\r\n\r\n            for (ds = 0; ds < len; ds++) {\r\n                if (node.children[ds]) {\r\n                    childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\r\n                } else {\r\n                    childrenRes[ds] = {count: 0, tiles: [], nodes: []};\r\n                }\r\n                childrenCount += childrenRes[ds].count;\r\n            }\r\n\r\n            var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n\r\n            if (node.d > maxLevel || childrenCount < intersectCount) {\r\n                var resTilesArr = [],\r\n                    resNodesArr = [];\r\n                for (ds = 0; ds < childrenRes.length; ds++) {\r\n                    resNodesArr.push(childrenRes[ds].nodes);\r\n                    resTilesArr.push(childrenRes[ds].tiles);\r\n                }\r\n\r\n                return {\r\n                    tiles: [].concat.apply([], resTilesArr),\r\n                    count: childrenCount,\r\n                    nodes: [].concat.apply([], resNodesArr)\r\n                };\r\n            } else {\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: intersectCount,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n        };\r\n\r\n        var resTiles = [];\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            if (_rootNodes[ds]) {\r\n                var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\r\n                if (nodeSelection.tiles.length) {\r\n                    resTiles = resTiles.concat(nodeSelection.tiles);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resTilesHash = {};\r\n        for (var t = 0; t < resTiles.length; t++) {\r\n            resTilesHash[resTiles[t]] = true;\r\n        }\r\n\r\n        return {tiles: resTilesHash};\r\n    };\r\n\r\n    this.getNode = function(d, s) {\r\n        if (d < 0 || s < 0) {\r\n            return null;\r\n        }\r\n\r\n        var findNode = function(node, d, s) {\r\n            if (!node) { return null; }\r\n\r\n            if (periods[node.d] === d) {\r\n                return node.s === s ? node : null;\r\n            }\r\n\r\n            var childrenCount = periods[node.d] / periods[node.d - 1];\r\n            var sChild = Math.floor(s * d / periods[node.d - 1]);\r\n            var ds = sChild - node.s * childrenCount;\r\n\r\n            return node.children[ds] ? findNode(node.children[ds], d, s) : null;\r\n        };\r\n\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            var node = findNode(_rootNodes[ds], d, s);\r\n            if (node) {\r\n                return node;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n};\r\nL.gmx.tilesTree = function(options) {\r\n    return new TilesTree(options);\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/TilesTree.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {VectorTile} from './VectorTile.js';\r\nimport {gmxVectorTileLoader} from './VectorTileLoader.js';\r\n\r\nvar ObserverTileLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    initialize: function(dataManager) {\r\n        this._dataManager = dataManager;\r\n        this._observerData = {};\r\n        this._tileData = {};\r\n    },\r\n\r\n    addObserver: function(observer) {\r\n        this._observerData[observer.id] = {\r\n            observer: observer,\r\n            tiles: {},\r\n            leftToLoad: 0,\r\n            loadingState: false //are we loading any tiles for this observer?\r\n        };\r\n\r\n        observer.on('update', this._updateObserver.bind(this, observer));\r\n\r\n        this._updateObserver(observer);\r\n\r\n        return this;\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        var obsTiles = this._observerData[id].tiles;\r\n\r\n        for (var tileId in obsTiles) {\r\n            delete this._tileData[tileId].observers[id];\r\n        }\r\n\r\n        delete this._observerData[id];\r\n\r\n        return this;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\r\n        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\r\n\r\n        var tileObservers = {};\r\n\r\n        for (var key in this._observerData) {\r\n            var obsInfo = this._observerData[key];\r\n\r\n            if (obsInfo.observer.intersectsWithTile(tile)) {\r\n                obsInfo.tiles[tile.vectorTileKey] = true;\r\n                obsInfo.leftToLoad += leftToLoadDelta;\r\n                tileObservers[key] = true;\r\n            }\r\n        }\r\n\r\n        this._tileData[tile.vectorTileKey] = {\r\n            observers: tileObservers,\r\n            tile: tile\r\n        };\r\n\r\n        return this;\r\n    },\r\n\r\n    removeTile: function(tileId) {\r\n        var tileData = this._tileData[tileId],\r\n            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\r\n\r\n        for (var id in tileData.observers) {\r\n            var observerData = this._observerData[id];\r\n            observerData.leftToLoad -= leftToLoadDelta;\r\n            delete observerData.tiles[tileId];\r\n        }\r\n\r\n        delete this._tileData[tileId];\r\n\r\n        return this;\r\n    },\r\n\r\n    startLoadTiles: function(observer) {\r\n\r\n        //force active tile list update\r\n        this._dataManager._getActiveTileKeys();\r\n\r\n        var obsData = this._observerData[observer.id];\r\n        if (obsData.leftToLoad === 0) {\r\n            this.fire('observertileload', {observer: observer});\r\n            return this;\r\n        }\r\n\r\n        if (!obsData.loadingState) {\r\n            obsData.loadingState = true;\r\n            observer.fire('startLoadingTiles');\r\n        }\r\n\r\n        for (var tileId in obsData.tiles) {\r\n            this._tileData[tileId].tile.load();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getTileObservers: function(tileId) {\r\n        return this._tileData[tileId].observers;\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerData[observer.id].loadingState;\r\n    },\r\n\r\n    _updateObserver: function(observer) {\r\n        var obsData = this._observerData[observer.id],\r\n            newObserverTiles = {},\r\n            leftToLoad = 0,\r\n            key;\r\n\r\n        for (key in this._tileData) {\r\n            var tile = this._tileData[key].tile;\r\n            if (observer.intersectsWithTile(tile)) {\r\n                newObserverTiles[key] = true;\r\n                if (tile.state !== 'loaded') {\r\n                    leftToLoad++;\r\n                }\r\n                this._tileData[key].observers[observer.id] = true;\r\n            }\r\n        }\r\n\r\n        for (key in obsData.tiles) {\r\n            if (!(key in newObserverTiles)) {\r\n                delete this._tileData[key].observers[observer.id];\r\n            }\r\n        }\r\n\r\n        obsData.tiles = newObserverTiles;\r\n        obsData.leftToLoad = leftToLoad;\r\n    },\r\n\r\n    _tileLoadedCallback: function(tile) {\r\n        this.fire('tileload', {tile: tile});\r\n\r\n        if (!(tile.vectorTileKey in this._tileData)) {\r\n            return;\r\n        }\r\n\r\n        var tileObservers = this._tileData[tile.vectorTileKey].observers;\r\n        for (var id in tileObservers) {\r\n            var obsData = this._observerData[id];\r\n            obsData.leftToLoad--;\r\n\r\n            if (obsData.leftToLoad === 0) {\r\n                if (obsData.loadingState) {\r\n                    obsData.loadingState = false;\r\n                    obsData.observer.fire('stopLoadingTiles');\r\n                }\r\n                this.fire('observertileload', {observer: obsData.observer});\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar DataManager = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    options: {\r\n        name: null,                         // layer ID\r\n        identityField: '',                  // attribute name for identity items\r\n        attributes: [],                     // attributes names\r\n        attrTypes: [],                      // attributes types\r\n        tiles: null,                        // tiles array for nontemporal data\r\n        tilesVers: null,                    // tiles version array for nontemporal data\r\n        LayerVersion: -1,                   // layer version\r\n        GeoProcessing: null,                // processing data\r\n        Temporal: false,                    // only for temporal data\r\n        TemporalColumnName: '',             // temporal attribute name\r\n        ZeroDate: '01.01.2008',             // 0 date string\r\n        TemporalPeriods: [],                // temporal periods\r\n        TemporalTiles: [],                  // temporal tiles array\r\n        TemporalVers: [],                   // temporal version array\r\n        hostName: 'maps.kosmosnimki.ru',    // default hostName\r\n        sessionKey: '',                     // session key\r\n        isGeneralized: false,               // flag for use generalized tiles\r\n        isFlatten: false                    // flag for flatten geometry\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        this._clearProcessing();\r\n        if (options.GeoProcessing) {\r\n            this.processingTile = this.addData([]);\r\n            this._chkProcessing(options.GeoProcessing);\r\n        }\r\n        L.setOptions(this, options);\r\n        this.optionsLink = options;\r\n\r\n        this._isTemporalLayer = this.options.Temporal;\r\n\r\n        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\r\n        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\r\n        var hostName = this.options.hostName,\r\n            sessionKey = this.options.sessionKey;\r\n        if (!sessionKey) {\r\n            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\r\n        }\r\n        this.tileSenderPrefix = 'http://' + hostName + '/' +\r\n            'TileSender.ashx?WrapStyle=None' +\r\n            '&key=' + encodeURIComponent(sessionKey);\r\n\r\n        this._needCheckActiveTiles = true;\r\n    },\r\n\r\n    _vectorTileDataProviderLoad: function(x, y, z, v, s, d, callback) {\r\n        var _this = this;\r\n        gmxVectorTileLoader.load(\r\n            _this.tileSenderPrefix,\r\n            {x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name}\r\n        ).then(callback, function() {\r\n            console.log('Error loading vector tile');\r\n            callback([]);\r\n            _this.fire('chkLayerUpdate', {dataProvider: _this}); //TODO: do we really need event here?\r\n        });\r\n    },\r\n\r\n    initialize: function(options, clearVersion) {\r\n        this._tilesTree = null;\r\n        this._activeTileKeys = {};\r\n        this._endDate = null;\r\n        this._beginDate = null;\r\n\r\n        this._tiles = {};\r\n        this._filters = {};\r\n        this._freeSubscrID = 0;\r\n        this._items = {};\r\n        this._observers = {};\r\n\r\n        this._needCheckDateInterval = false;\r\n        this._needCheckActiveTiles = true;\r\n\r\n        var _this = this;\r\n        this._vectorTileDataProvider = {\r\n            load: this._vectorTileDataProviderLoad.bind(this)\r\n        };\r\n\r\n        this._observerTileLoader = new ObserverTileLoader(this);\r\n        this._observerTileLoader.on('tileload', function(event) {\r\n            var tile = event.tile;\r\n            _this._updateItemsFromTile(tile);\r\n\r\n            if (_this._tilesTree) {\r\n                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\r\n                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\r\n            }\r\n        });\r\n\r\n        this._observerTileLoader.on('observertileload', function(event) {\r\n            var observer = event.observer;\r\n            if (observer.isActive()) {\r\n                observer.needRefresh = false;\r\n                observer.updateData(_this.getItems(observer.id));\r\n            }\r\n        });\r\n        this.setOptions(options);\r\n        if (clearVersion) {\r\n\t\t\tthis.options.LayerVersion = -1;\r\n\t\t}\r\n        if (this._isTemporalLayer) {\r\n            this.addFilter('TemporalFilter', function(item, tile, observer) {\r\n                var unixTimeStamp = item.options.unixTimeStamp,\r\n                    dates = observer.dateInterval;\r\n                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\r\n            });\r\n        }\r\n    },\r\n\r\n    _getActiveTileKeys: function() {\r\n\r\n        this._chkMaxDateInterval();\r\n        if (!this._needCheckActiveTiles) {\r\n            return this._activeTileKeys;\r\n        }\r\n\r\n        this._needCheckActiveTiles = false;\r\n\r\n        if (this._isTemporalLayer) {\r\n            var newTileKeys = {};\r\n            if (this._beginDate && this._endDate) {\r\n                if (!this._tilesTree) {\r\n                    this.initTilesTree();\r\n                }\r\n\r\n                /*var commonBounds = L.gmxUtil.bounds();\r\n                for (var obs in this._observers) {\r\n                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n                }*/\r\n\r\n                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\r\n            }\r\n            this._updateActiveTilesList(newTileKeys);\r\n        } else {\r\n            this.initTilesList();\r\n        }\r\n\r\n        return this._activeTileKeys;\r\n    },\r\n\r\n    _getObserversByFilterName: function(filterName) {\r\n        var oKeys = {};\r\n        for (var id in this._observers) {\r\n            if (this._observers[id].hasFilter(filterName)) {\r\n                oKeys[id] = true;\r\n            }\r\n        }\r\n        return oKeys;\r\n    },\r\n\r\n    addFilter: function(filterName, filterFunc) {\r\n        this._filters[filterName] = filterFunc;\r\n        this._triggerObservers(this._getObserversByFilterName(filterName));\r\n    },\r\n\r\n    removeFilter: function(filterName) {\r\n        if (this._filters[filterName]) {\r\n            var oKeys = this._getObserversByFilterName(filterName);\r\n            delete this._filters[filterName];\r\n            this._triggerObservers(oKeys);\r\n        }\r\n    },\r\n\r\n    getItems: function(oId) {\r\n        var resItems = [],\r\n            observer = this._observers[oId];\r\n\r\n        if (!observer) {\r\n            return [];\r\n        }\r\n\r\n        //add internal filters\r\n        var filters = observer.filters.concat('processingFilter');\r\n        this._isTemporalLayer && filters.push('TemporalFilter');\r\n\r\n        filters = filters.filter(function(filter) {\r\n            return filter in this._filters;\r\n        }.bind(this));\r\n\r\n        var _this = this,\r\n            putData = function(tile) {\r\n                var data = tile.data;\r\n                for (var i = 0, len = data.length; i < len; i++) {\r\n                    var dataOption = tile.dataOptions[i];\r\n                    if (!observer.intersects(dataOption.bounds)) { continue; }\r\n\r\n                    var it = data[i],\r\n                        id = it[0],\r\n                        item = _this.getItem(id);\r\n\r\n                    var geom = it[it.length - 1],\r\n                        isFiltered = false;\r\n\r\n                    for (var f = 0; f < filters.length; f++) {\r\n                        var filterFunc = _this._filters[filters[f]];\r\n                        if (!filterFunc(item, tile, observer, geom, dataOption)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!isFiltered) {\r\n                        resItems.push({\r\n                            id: id,\r\n                            properties: it,\r\n                            item: item,\r\n                            dataOption: dataOption,\r\n                            tileKey: tile.vectorTileKey\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n        var activeTileKeys =  this._getActiveTileKeys();\r\n        for (var tkey in activeTileKeys) {\r\n            var tile = _this._tiles[tkey].tile;\r\n            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\r\n                putData(tile);\r\n            }\r\n        }\r\n\r\n        return resItems;\r\n    },\r\n\r\n    _updateItemsFromTile: function(tile) {\r\n        var vectorTileKey = tile.vectorTileKey,\r\n            data = tile.data || [],\r\n            len = data.length,\r\n            geomIndex = data[0] && (data[0].length - 1);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            var it = data[i],\r\n                geom = it[geomIndex],\r\n                id = it[0],\r\n                item = this._items[id];\r\n            if (item) {\r\n                if (!item.processing) {\r\n                    item.properties = it;\r\n                    if (item.type.indexOf('MULTI') === -1) {\r\n                        item.type = 'MULTI' + item.type;\r\n                    }\r\n                } else {\r\n                    tile.data[i] = item.properties;\r\n                }\r\n                delete item.bounds;\r\n                item.currentFilter = null;\r\n            } else {\r\n                item = {\r\n                    id: id,\r\n                    type: geom.type,\r\n                    properties: it,\r\n                    options: {\r\n                        fromTiles: {}\r\n                    }\r\n                };\r\n                this._items[id] = item;\r\n            }\r\n            item.options.fromTiles[vectorTileKey] = i;\r\n            if (tile.isGeneralized) {\r\n                item.options.isGeneralized = true;\r\n            }\r\n\r\n            if (this.options.TemporalColumnName) {\r\n                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\r\n                item.options.unixTimeStamp = zn * 1000;\r\n            }\r\n        }\r\n        return len;\r\n    },\r\n\r\n    getMaxDateInterval: function() {\r\n        this._chkMaxDateInterval();\r\n\t\treturn {\r\n\t\t\tbeginDate: this._beginDate,\r\n\t\t\tendDate: this._endDate\r\n\t\t};\r\n    },\r\n\r\n    _chkMaxDateInterval: function() {\r\n        if (this._isTemporalLayer && this._needCheckDateInterval) {\r\n            this._needCheckDateInterval = false;\r\n            var observers = this._observers,\r\n                newBeginDate = null,\r\n                newEndDate = null;\r\n            for (var oId in observers) {\r\n                var observer = observers[oId],\r\n                    dateInterval = observer.dateInterval;\r\n\r\n                if (!dateInterval) {\r\n                    continue;\r\n                }\r\n\r\n                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\r\n                    newBeginDate = dateInterval.beginDate;\r\n                }\r\n\r\n                if (!newEndDate || dateInterval.endDate > newEndDate) {\r\n                    newEndDate = dateInterval.endDate;\r\n                }\r\n            }\r\n            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\r\n                this._beginDate = newBeginDate;\r\n                this._endDate = newEndDate;\r\n                this._needCheckActiveTiles = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    addObserver: function(options, id) {\r\n        id = id || 's' + (++this._freeSubscrID);\r\n        var _this = this,\r\n            observer = L.gmx.observer(options);\r\n\r\n        observer.id = id;\r\n        observer.needRefresh = true;\r\n        this._observerTileLoader.addObserver(observer);\r\n\r\n        observer\r\n            .on('update', function(ev) {\r\n                observer.needRefresh = true;\r\n                if (ev.temporalFilter) {\r\n                    _this._needCheckDateInterval = true;\r\n                }\r\n\r\n                _this._waitCheckObservers();\r\n            })\r\n            .on('activate', function() {\r\n                _this.fire('observeractivate');\r\n                _this.checkObserver(observer);\r\n            });\r\n\r\n        _this._needCheckDateInterval = true;\r\n        this._observers[id] = observer;\r\n        this._waitCheckObservers();\r\n\r\n        if (observer.isActive()) {\r\n            this.fire('observeractivate');\r\n        }\r\n\r\n        return observer;\r\n    },\r\n\r\n    getActiveObserversCount: function() {\r\n        var count = 0;\r\n        for (var k in this._observers) {\r\n            if (this._observers[k].isActive()) { count++; }\r\n        }\r\n        return count;\r\n    },\r\n\r\n    getObserver: function(id) {\r\n        return this._observers[id];\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        if (this._observers[id]) {\r\n            this._observerTileLoader.removeObserver(id);\r\n            var isActive = this._observers[id].isActive();\r\n\r\n            delete this._observers[id];\r\n\r\n            if (isActive) {\r\n                this.fire('observeractivate');\r\n            }\r\n        }\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerTileLoader.getObserverLoadingState(observer);\r\n    },\r\n\r\n    getItemsBounds: function() {\r\n        if (!this._itemsBounds) {\r\n            this._itemsBounds = gmxAPIutils.bounds();\r\n            for (var id in this._items) {\r\n                var item = this.getItem(id);\r\n                this._itemsBounds.extendBounds(item.bounds);\r\n            }\r\n        }\r\n        return this._itemsBounds;\r\n    },\r\n\r\n    //combine and return all parts of geometry\r\n    getItem: function(id) {\r\n        var item = this._items[id];\r\n        if (item && !item.bounds) {\r\n            var fromTiles = item.options.fromTiles,\r\n                arr = [];\r\n            for (var key in fromTiles) {    // get full object bounds\r\n                if (this._tiles[key]) {\r\n                    var num = fromTiles[key],\r\n                        tile = this._tiles[key].tile;\r\n                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\r\n                        arr.push(tile.dataOptions[num].bounds);\r\n                    } else {\r\n                        delete fromTiles[key];\r\n                    }\r\n                }\r\n            }\r\n            if (arr.length === 1) {\r\n                item.bounds = arr[0];\r\n            } else {\r\n                item.bounds = gmxAPIutils.bounds();\r\n                var w = gmxAPIutils.worldWidthMerc;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    var it = arr[i];\r\n                    if (item.bounds.max.x - it.min.x > w) {\r\n                        it = gmxAPIutils.bounds([\r\n                            [it.min.x + 2 * w, it.min.y],\r\n                            [it.max.x + 2 * w, it.max.y]\r\n                        ]);\r\n                    }\r\n                    item.bounds.extendBounds(it);\r\n                }\r\n            }\r\n        }\r\n        return item;\r\n    },\r\n\r\n    getItemMembers: function(id) {\r\n        var fromTiles = this._items[id].options.fromTiles,\r\n            members = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key]) {\r\n                var tile = this._tiles[key].tile;\r\n                if (tile.data) {\r\n                    var objIndex = fromTiles[key],\r\n                        props = tile.data[objIndex],\r\n                        dataOption = tile.dataOptions[objIndex],\r\n                        bbox = dataOption.bounds;\r\n\r\n                    members.push({\r\n                        geo: props[props.length - 1],\r\n                        width: bbox.max.x - bbox.min.x,\r\n                        dataOption: dataOption\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n        return members.sort(function(a, b) {\r\n            return b.width - a.width;\r\n        });\r\n    },\r\n\r\n    getItemGeometries: function(id) {\r\n        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\r\n            geomItems = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key] && this._tiles[key].tile.data) {\r\n                var tileData = this._tiles[key].tile.data,\r\n                    props = tileData[fromTiles[key]];\r\n\r\n                geomItems.push(gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\r\n            }\r\n        }\r\n        return geomItems;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        this._tiles[tile.vectorTileKey] = {tile: tile};\r\n        this._getActiveTileKeys()[tile.vectorTileKey] = true;\r\n        this._observerTileLoader.addTile(tile);\r\n        this.checkObservers();\r\n    },\r\n\r\n    checkObserver: function(observer) {\r\n        if (observer.needRefresh && observer.isActive()) {\r\n            this._observerTileLoader.startLoadTiles(observer);\r\n        }\r\n    },\r\n\r\n    checkObservers: function() {\r\n        var observers = this._observers;\r\n        for (var id in this._observers) {\r\n            this.checkObserver(observers[id]);\r\n        }\r\n    },\r\n\r\n    _waitCheckObservers: function() {\r\n        //TODO: refactor\r\n        if (this._checkObserversTimer) {\r\n            clearTimeout(this._checkObserversTimer);\r\n        }\r\n\r\n        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\r\n    },\r\n\r\n    _triggerObservers: function(oKeys) {\r\n        var keys = oKeys || this._observers;\r\n\r\n        for (var id in keys) {\r\n            if (this._observers[id]) {\r\n                this._observers[id].needRefresh = true;\r\n            }\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    _removeDataFromObservers: function(data) {\r\n        var keys = this._observers;\r\n        for (var id in keys) {\r\n            this._observers[id].removeData(data);\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    preloadTiles: function(dateBegin, dateEnd, bounds) {\r\n        var tileKeys = {};\r\n        if (this._isTemporalLayer) {\r\n            if (!this._tilesTree) {\r\n                this.initTilesTree();\r\n            }\r\n            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\r\n        } else {\r\n            this._needCheckActiveTiles = true;\r\n            tileKeys = this._getActiveTileKeys();\r\n        }\r\n\r\n        var loadingDefs = [];\r\n        for (var key in tileKeys) {\r\n            var tile = this._getVectorTile(key, true).tile;\r\n\r\n            if (tile.state !== 'notLoaded') {\r\n                continue;\r\n            }\r\n\r\n            if (bounds && !bounds.intersects(tile.bounds)) {\r\n                continue;\r\n            }\r\n\r\n            var loadDef = tile.load();\r\n            loadingDefs.push(loadDef);\r\n        }\r\n\r\n        return Deferred.all.apply(null, loadingDefs);\r\n    },\r\n\r\n    _updateActiveTilesList: function(newTilesList) {\r\n\r\n        if (this._tileFilteringHook) {\r\n            var filteredTilesList = {};\r\n            for (var tk in newTilesList) {\r\n                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\r\n                    filteredTilesList[tk] = true;\r\n                }\r\n            }\r\n            newTilesList = filteredTilesList;\r\n        }\r\n\r\n        var oldTilesList = this._activeTileKeys || {};\r\n\r\n        var observersToUpdate = {},\r\n            _this = this,\r\n            key;\r\n\r\n        if (this.processingTile) {\r\n            newTilesList[this.processingTile.vectorTileKey] = true;\r\n        }\r\n        if (this._rasterVectorTile) {\r\n\t\t\tkey = this._rasterVectorTile.vectorTileKey;\r\n            newTilesList[key] = true;\r\n\t\t\tthis._tiles[key] = {tile: this._rasterVectorTile};\r\n\t\t}\r\n\r\n        var checkSubscription = function(vKey) {\r\n            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\r\n            for (var sid in observerIds) {\r\n                observersToUpdate[sid] = true;\r\n            }\r\n        };\r\n\r\n        for (key in newTilesList) {\r\n            if (!oldTilesList[key]) {\r\n                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\r\n                checkSubscription(key);\r\n            }\r\n        }\r\n\r\n        for (key in oldTilesList) {\r\n            if (!newTilesList[key]) {\r\n                checkSubscription(key);\r\n                this._observerTileLoader.removeTile(key);\r\n            }\r\n        }\r\n\r\n        this._activeTileKeys = newTilesList;\r\n\r\n        this._triggerObservers(observersToUpdate);\r\n    },\r\n\r\n    _propertiesToArray: function(it) {\r\n        var prop = it.properties,\r\n            indexes = this.tileAttributeIndexes,\r\n            arr = [];\r\n\r\n        for (var key in indexes)\r\n            arr[indexes[key]] = prop[key];\r\n\r\n        arr[arr.length] = it.geometry;\r\n        arr[0] = it.id;\r\n        return arr;\r\n    },\r\n\r\n    _clearProcessing: function() {\r\n        if (this.processingTile) {\r\n            var _items = this._items,\r\n                tile = this.processingTile,\r\n                vKey = tile.vectorTileKey,\r\n                data = tile.data || [];\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i][0];\r\n                if (_items[id]) {\r\n                    var item = _items[id];\r\n                    item.processing = null;\r\n                    item.currentFilter = null;\r\n                    delete item.options.fromTiles[vKey];\r\n                    delete item.fromServerProps;\r\n                    delete item.geometry;\r\n               }\r\n            }\r\n            tile.clear();\r\n        }\r\n    },\r\n\r\n    _chkProcessing: function(processing) {\r\n        var _items = this._items,\r\n            needProcessingFilter = false,\r\n            skip = {},\r\n            id, i, len, it, data;\r\n\r\n        if (processing) {\r\n            if (processing.Deleted) {\r\n                for (i = 0, len = processing.Deleted.length; i < len; i++) {\r\n                    id = processing.Deleted[i];\r\n                    skip[id] = true;\r\n                    if (_items[id]) {\r\n                        _items[id].processing = true;\r\n                        _items[id].currentFilter = null;\r\n                    }\r\n                    if (len > 0) { needProcessingFilter = true; }\r\n                }\r\n            }\r\n\r\n            var out = {};\r\n            if (processing.Inserted) {\r\n                for (i = 0, len = processing.Inserted.length; i < len; i++) {\r\n                    it = processing.Inserted[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n            }\r\n\r\n            if (processing.Updated) {\r\n                for (i = 0, len = processing.Updated.length; i < len; i++) {\r\n                    it = processing.Updated[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n                if (!needProcessingFilter && len > 0) { needProcessingFilter = true; }\r\n            }\r\n\r\n            data = [];\r\n            for (id in out) {\r\n                if (this._items[id]) {\r\n                    this._items[id].properties = out[id];\r\n                    this._items[id].processing = true;\r\n                    this._items[id].currentFilter = null;\r\n                }\r\n                data.push(out[id]);\r\n            }\r\n\r\n            if (data.length > 0) {\r\n                this.processingTile = this.addData(data);\r\n            }\r\n        }\r\n        if (needProcessingFilter) {\r\n            this.addFilter('processingFilter', function(item, tile) {\r\n                return tile.z === 0 || !item.processing;\r\n            });\r\n        } else {\r\n            this.removeFilter('processingFilter');\r\n        }\r\n    },\r\n\r\n    enableGeneralization: function() {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function() {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    _resetTilesTree: function() {\r\n        this._tilesTree = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    updateVersion: function(options) {\r\n        if (options) {\r\n            this.setOptions(options);\r\n        }\r\n        this._resetTilesTree();\r\n\t\t// this.fire('versionchange');\r\n    },\r\n\r\n    _getDataKeys: function(data) {\r\n        var chkKeys = {};\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            chkKeys[data[i][0]] = true;\r\n        }\r\n        return chkKeys;\r\n    },\r\n\r\n    _getProcessingTile: function() {\r\n        if (!this.processingTile) {\r\n        var x = -0.5, y = -0.5, z = 0, v = 0, s = -1, d = -1, isFlatten = this.options.isFlatten;\r\n\r\n            this.processingTile = new VectorTile({load: function(x, y, z, v, s, d, callback) {\r\n                            callback([]);\r\n            }}, {x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten});\r\n\r\n            this.addTile(this.processingTile);\r\n        }\r\n        return this.processingTile;\r\n    },\r\n\r\n    addData: function(data) {\r\n        if (!data) {\r\n            data = [];\r\n        }\r\n        var vTile = this._getProcessingTile(),\r\n            chkKeys = this._getDataKeys(data),\r\n            dataBounds = vTile.addData(data, chkKeys);\r\n\r\n        if (this._itemsBounds) {\r\n            this._itemsBounds.extendBounds(dataBounds);\r\n        }\r\n        this._updateItemsFromTile(vTile);\r\n        this._triggerObservers();\r\n        return vTile;\r\n    },\r\n\r\n    removeData: function(data) {\r\n        this._itemsBounds = null;\r\n        var vTile = this.processingTile;\r\n        if (vTile) {\r\n            var chkKeys = {};\r\n\r\n            if (!data || !data.length) {\r\n                return vTile;\r\n            }\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i];\r\n                chkKeys[id] = true;\r\n                delete this._items[id];\r\n            }\r\n            this._removeDataFromObservers(chkKeys);\r\n            vTile.removeData(chkKeys, true);\r\n            this._updateItemsFromTile(vTile);\r\n\r\n            this._triggerObservers();\r\n        }\r\n\r\n        return vTile;\r\n    },\r\n\r\n    initTilesTree: function() {\r\n        this._tilesTree = L.gmx.tilesTree(this.options);\r\n        this.options.TemporalTiles = this.options.TemporalVers = null;\r\n\r\n        if ('TemporalTiles' in this.optionsLink) {\r\n            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\r\n        }\r\n        this.dateZero = this._tilesTree.dateZero;\r\n        if (this.processingTile) {\r\n            this._tiles[this.processingTile.vectorTileKey] = {\r\n                tile: this.processingTile\r\n            };\r\n        }\r\n    },\r\n\r\n    _getVectorTile: function(vKey, createFlag) {\r\n        if (!this._tiles[vKey] && createFlag) {\r\n            var info = VectorTile.parseTileKey(vKey);\r\n            info.dateZero = this.dateZero;\r\n            this._addVectorTile(info);\r\n        }\r\n        return this._tiles[vKey];\r\n    },\r\n\r\n    _addVectorTile: function(info) {\r\n        info.isFlatten = this.options.isFlatten;\r\n        var tile = new VectorTile(this._vectorTileDataProvider, info),\r\n            vKey = tile.vectorTileKey;\r\n\r\n        this._tiles[vKey] = {tile: tile};\r\n        return vKey;\r\n    },\r\n\r\n    _getGeneralizedTileKeys: function(vTilePoint) {\r\n        var dz = vTilePoint.z % 2 ? 1 : 2,\r\n            pz = Math.pow(2, dz),\r\n            z = vTilePoint.z - dz,\r\n            x = Math.floor(vTilePoint.x / pz),\r\n            y = Math.floor(vTilePoint.y / pz),\r\n            temp = {v: vTilePoint.v, s: -1, d: -1, isGeneralized: true},\r\n            keys = {};\r\n\r\n        while (z > 1) {\r\n            var gKey = [z, x, y].join('_');\r\n            keys[gKey] = L.extend({}, temp, {x: x, y: y, z: z});\r\n            z -= 2;\r\n            x = Math.floor(x / 4);\r\n            y = Math.floor(y / 4);\r\n        }\r\n        return keys;\r\n    },\r\n\r\n    initTilesList: function() {         // For non temporal layers we create all Vector tiles\r\n        var newActiveTileKeys = {};\r\n        if (this.options.tiles) {\r\n            var arr = this.options.tiles || [],\r\n                vers = this.options.tilesVers,\r\n                generalizedKeys = this.options.isGeneralized ? {} : null,\r\n                newTiles = {},\r\n                gKey, tKey, info, tHash;\r\n\r\n            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\r\n                info = {\r\n                    x: Number(arr[i]),\r\n                    y: Number(arr[i + 1]),\r\n                    z: Number(arr[i + 2]),\r\n                    v: Number(vers[cnt]),\r\n                    s: -1,\r\n                    d: -1\r\n                };\r\n\r\n                tHash = this._getVectorTile(VectorTile.createTileKey(info), true);\r\n                tKey = tHash.tile.vectorTileKey;\r\n                newTiles[tKey] = tHash;\r\n                newActiveTileKeys[tKey] = true;\r\n                if (generalizedKeys) {\r\n                    var gKeys = this._getGeneralizedTileKeys(info);\r\n                    for (gKey in gKeys) {\r\n                        var gPoint = gKeys[gKey];\r\n                        if (generalizedKeys[gKey]) {\r\n                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\r\n                        } else {\r\n                            generalizedKeys[gKey] = gPoint;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (generalizedKeys) {\r\n                for (gKey in generalizedKeys) {\r\n                    info = generalizedKeys[gKey];\r\n                    tKey = VectorTile.createTileKey(info);\r\n                    if (!newTiles[tKey]) {\r\n                        if (!this._tiles[tKey]) { this._addVectorTile(info); }\r\n                        newTiles[tKey] = this._tiles[tKey];\r\n                        newActiveTileKeys[tKey] = true;\r\n                    }\r\n                }\r\n            }\r\n            this._tiles = newTiles;\r\n            if (this.processingTile) {\r\n                this._tiles[this.processingTile.vectorTileKey] = {\r\n                    tile: this.processingTile\r\n                };\r\n            }\r\n        }\r\n        this._updateActiveTilesList(newActiveTileKeys);\r\n    },\r\n\r\n    //Tile filtering hook filters out active vector tiles.\r\n    //Can be used to prevent loading data from some spatial-temporal region\r\n    setTileFilteringHook: function(filteringHook) {\r\n        this._tileFilteringHook = filteringHook;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    removeTileFilteringHook: function() {\r\n        this._tileFilteringHook = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    }\r\n\r\n});\r\nexport {DataManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/DataManager.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {StyleManager} from './StyleManager.js';\r\nimport {ScreenVectorTile} from './ScreenVectorTile.js';\r\n\r\nL.gmx.VectorLayer = L.TileLayer.Canvas.extend(\r\n{\r\n    options: {\r\n        openPopups: [],\r\n        minZoom: 1,\r\n        zIndexOffset: 0,\r\n        isGeneralized: true,\r\n        isFlatten: false,\r\n        useWebGL: false,\r\n        clickable: true\r\n    },\r\n\r\n    initialize: function(options) {\r\n        options = L.setOptions(this, options);\r\n\r\n        this.initPromise = new L.gmx.Deferred();\r\n\r\n        this._drawQueue = [];\r\n        this._drawQueueHash = {};\r\n\r\n        this._drawInProgress = {};\r\n\r\n        this._anyDrawings = false; //are we drawing something?\r\n        this.repaintObservers = {};    // external observers like screen\r\n\r\n        var _this = this;\r\n\r\n        this._gmx = {\r\n            hostName: gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\r\n            mapName: options.mapID,\r\n            useWebGL: options.useWebGL,\r\n            layerID: options.layerID,\r\n            beginDate: options.beginDate,\r\n            endDate: options.endDate,\r\n            sortItems: options.sortItems || null,\r\n            styles: options.styles || [],\r\n            tileSubscriptions: {},\r\n            _tilesToLoad: 0,\r\n            shiftXlayer: 0,\r\n            shiftYlayer: 0,\r\n            renderHooks: [],\r\n            preRenderHooks: [],\r\n            _needPopups: {}\r\n        };\r\n        if (options.crossOrigin) {\r\n            this._gmx.crossOrigin = options.crossOrigin;\r\n        }\r\n\r\n        this.on('tileunload', function(e) {\r\n            _this._clearTileSubscription(e.tile.zKey);\r\n        });\r\n    },\r\n\r\n    // extended from L.TileLayer.Canvas\r\n    _removeTile: function (zKey) {\r\n        var tileLink = this._tiles[zKey];\r\n        if (tileLink) {\r\n            var tile = tileLink.el;\r\n            if (tile && tile.parentNode) {\r\n                tile.parentNode.removeChild(tile);\r\n            }\r\n\r\n            delete this._tiles[zKey];\r\n        }\r\n    },\r\n\r\n    onAdd: function(map) {\r\n        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\r\n            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\r\n        }\r\n        var gmx = this._gmx;\r\n\r\n        gmx.shiftY = 0;\r\n        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\r\n        gmx.currentZoom = map.getZoom();\r\n        gmx.styleManager.initStyles();\r\n\r\n        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\r\n\r\n        map.on('zoomstart', this._zoomStart, this);\r\n        map.on('zoomend', this._zoomEnd, this);\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.on('moveend', this._moveEnd, this);\r\n        }\r\n        if (this.options.clickable === false) {\r\n            this._container.style.pointerEvents = 'none';\r\n        }\r\n        if (gmx.balloonEnable && !this._popup) { this.bindPopup(''); }\r\n        this.on('stylechange', this._onStyleChange, this);\r\n        this.on('versionchange', this._onVersionChange, this);\r\n\r\n        // this._zIndexOffsetCheck();\r\n        L.gmx.layersVersion.add(this);\r\n        this.fire('add');\r\n    },\r\n\r\n    onRemove: function(map) {\r\n        if (this._container) {\r\n            this._container.parentNode.removeChild(this._container);\r\n        }\r\n\r\n        map.off({\r\n            'viewreset': this._reset,\r\n            'moveend': this._update\r\n        }, this);\r\n\r\n        if (this._animated) {\r\n            map.off({\r\n                'zoomanim': this._animateZoom,\r\n                'zoomend': this._endZoomAnim\r\n            }, this);\r\n        }\r\n\r\n        if (!this.options.updateWhenIdle) {\r\n            map.off('move', this._limitedUpdate, this);\r\n        }\r\n        this._container = null;\r\n        this._map = null;\r\n\r\n        this._clearAllSubscriptions();\r\n        map.off('zoomstart', this._zoomStart, this);\r\n        map.off('zoomend', this._zoomEnd, this);\r\n        this.off('stylechange', this._onStyleChange, this);\r\n\r\n        var gmx = this._gmx;\r\n\r\n        delete gmx.map;\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.off('moveend', this._moveEnd, this);\r\n        }\r\n        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\r\n            L.gmx.layersVersion.remove(this);\r\n        }\r\n        this.fire('remove');\r\n    },\r\n\r\n    _initContainer: function () {\r\n        L.TileLayer.Canvas.prototype._initContainer.call(this);\r\n        this._prpZoomData();\r\n        this.setZIndexOffset();\r\n    },\r\n\r\n    _updateZIndex: function () {\r\n        if (this._container) {\r\n            var options = this.options,\r\n                zIndex = options.zIndex || 0,\r\n                zIndexOffset = options.zIndexOffset || 0;\r\n\r\n            this._container.style.zIndex = zIndexOffset + zIndex;\r\n        }\r\n    },\r\n\r\n    _update: function () {\r\n        if (!this._map ||\r\n            this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\r\n            ) {\r\n            this._clearAllSubscriptions();\r\n            return;\r\n        }\r\n        this._gmx.styleManager.deferred.then(this.__update.bind(this));\r\n    },\r\n\r\n    _addTile: function (tilePoint) {\r\n        var myLayer = this,\r\n            zoom = this._map._zoom,\r\n            gmx = this._gmx;\r\n\r\n        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\r\n            this._tileLoaded();\r\n            return;\r\n        }\r\n\r\n        var zKey = this._tileCoordsToKey(tilePoint, zoom);\r\n        if (!gmx.tileSubscriptions[zKey]) {\r\n            gmx._tilesToLoad++;\r\n            var isDrawnFirstTime = false,\r\n                gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\r\n                done = function() {\r\n                    if (!isDrawnFirstTime) {\r\n                        gmx._tilesToLoad--;\r\n                        myLayer._tileLoaded();\r\n                        isDrawnFirstTime = true;\r\n                    }\r\n                },\r\n                attr = {\r\n                    type: 'resend',\r\n                    active: false,\r\n                    bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\r\n                    filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                    callback: function(data) {\r\n                        myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\r\n                    }\r\n                };\r\n            if (this.options.isGeneralized) {\r\n                attr.targetZoom = zoom;\r\n            }\r\n            if (gmx.layerType === 'VectorTemporal') {\r\n                attr.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n\r\n            var observer = gmx.dataManager.addObserver(attr, zKey);\r\n            observer.on('activate', function() {\r\n                //if observer is deactivated before drawing,\r\n                //we can consider corresponding tile as already drawn\r\n                if (!observer.isActive()) {\r\n                    done();\r\n                }\r\n            });\r\n\r\n            observer.on('startLoadingTiles', this._chkDrawingState, this);\r\n\r\n            gmx.tileSubscriptions[zKey] = {\r\n                z: zoom,\r\n                x: tilePoint.x,\r\n                y: tilePoint.y,\r\n                px: 256 * gmxTilePoint.x,\r\n                py: 256 * (1 + gmxTilePoint.y)\r\n            };\r\n            observer.activate();\r\n        }\r\n    },\r\n\r\n    _chkDrawingState: function() {\r\n        var gmx = this._gmx,\r\n            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\r\n\r\n        if (!isDrawing) {\r\n            for (var key in gmx.tileSubscriptions) {\r\n                var observer = gmx.dataManager.getObserver(key);\r\n                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\r\n                    isDrawing = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isDrawing && this._anyDrawings) {\r\n            this.fire('doneDraw');\r\n        } else  if (isDrawing && !this._anyDrawings) {\r\n            this.fire('startDraw');\r\n        }\r\n\r\n        this._anyDrawings = isDrawing;\r\n    },\r\n\r\n    _getLoadedTilesPercentage: function (container) {\r\n        if (!container) { return 0; }\r\n        var len = 0, count = 0;\r\n        var arr = ['img', 'canvas'];\r\n        for (var key in arr) {\r\n            var tiles = container.getElementsByTagName(arr[key]);\r\n            if (tiles && tiles.length > 0) {\r\n                len += tiles.length;\r\n                for (var i = 0, len1 = tiles.length; i < len1; i++) {\r\n                    if (tiles[i]._tileComplete) {\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (len < 1) { return 0; }\r\n        return count / len;\r\n    },\r\n\r\n    _tileLoaded: function () {\r\n        if (this._animated) {\r\n            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n        }\r\n        if (this._gmx._tilesToLoad === 0) {\r\n            this.fire('load');\r\n\r\n            if (this._animated) {\r\n                // clear scaled tiles after all new tiles are loaded (for performance)\r\n                this._setClearBgBuffer(0);\r\n            }\r\n        }\r\n    },\r\n\r\n    _tileOnLoad: function (tile) {\r\n        if (tile) { L.DomUtil.addClass(tile, 'leaflet-tile-loaded'); }\r\n        this._tileLoaded();\r\n    },\r\n\r\n    _tileOnError: function () {\r\n    },\r\n\r\n    tileDrawn: function (tile) {\r\n        this._tileOnLoad(tile);\r\n    },\r\n\r\n    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\r\n    // converts tile coordinates to key for the tile cache\r\n    _tileCoordsToKey: function (coords, zoom) {\r\n        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\r\n    },\r\n\r\n    _getTiledPixelBounds: function (center) {\r\n        var map = this._map,\r\n            gmx = this._gmx,\r\n            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\r\n            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\r\n            halfSize = map.getSize().divideBy(2);\r\n\r\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\r\n    },\r\n\r\n    _pxBoundsToTileRange: function (bounds) {\r\n        var tileSize = this.options.tileSize;\r\n        return new L.Bounds(\r\n            bounds.min.divideBy(tileSize)._floor(),\r\n            bounds.max.divideBy(tileSize)._round());\r\n    },\r\n\r\n    // original for L.gmx.VectorLayer\r\n\r\n    //public interface\r\n    initFromDescription: function(ph) {\r\n        var gmx = this._gmx;\r\n\r\n        gmx.properties = ph.properties;\r\n        gmx.geometry = ph.geometry;\r\n\r\n        if (gmx.properties._initDone) {    // need delete tiles key\r\n            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\r\n        }\r\n        gmx.properties._initDone = true;\r\n\r\n        if (!gmx.geometry) {\r\n            var worldSize = gmxAPIutils.tileSizes[1];\r\n            gmx.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n        // Original properties from the server.\r\n        // Descendant classes can override this property\r\n        // Not so good solution, but it works\r\n        gmx.rawProperties = ph.rawProperties || ph.properties;\r\n\r\n        this._updateProperties(ph.properties);\r\n\r\n        ph.properties.isGeneralized = this.options.isGeneralized;\r\n        ph.properties.isFlatten = this.options.isFlatten;\r\n\r\n        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tif (!ph.properties.styles) { ph.properties.styles = this.options.parentOptions.styles; }\r\n\t\t\tgmx.dataManager.on('versionchange', this._onVersionChange, this);\r\n\t\t}\r\n\r\n\t\tgmx.styleManager = new StyleManager(gmx);\r\n        this.options.minZoom = gmx.styleManager.minZoom;\r\n        this.options.maxZoom = gmx.styleManager.maxZoom;\r\n\r\n        gmx.dataManager.on('observeractivate', function() {\r\n            if (gmx.dataManager.getActiveObserversCount()) {\r\n                L.gmx.layersVersion.add(this);\r\n            } else {\r\n                L.gmx.layersVersion.remove(this);\r\n            }\r\n        }, this);\r\n\r\n        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\r\n            this.options.chkUpdate = true; //Check updates for vector layers by default\r\n        }\r\n        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\r\n            this._objectsReorderInit(this);\r\n        }\r\n\r\n        if (gmx.clusters) {\r\n            this.bindClusters(JSON.parse(gmx.clusters));\r\n        }\r\n        if (gmx.filter) {\r\n            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (func) {\r\n\t\t\t\tgmx.dataManager.addFilter('userFilter_' + gmx.layerID, function(item) {\r\n\t\t\t\t\treturn gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\r\n\t\t\t\t}.bind(this));\r\n            }\r\n        }\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\r\n        }\r\n\r\n        this.initPromise.resolve();\r\n        return this;\r\n    },\r\n\r\n    getDataManager: function () {\r\n\t\treturn this._gmx.dataManager;\r\n    },\r\n\r\n    enableGeneralization: function () {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.enableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function () {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.disableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    setRasterOpacity: function (opacity) {\r\n        var _this = this;\r\n        if (this._gmx.rasterOpacity !== opacity) {\r\n            this._gmx.rasterOpacity = opacity;\r\n            this.initPromise.then(function() {\r\n                _this.repaint();\r\n            });\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStyles: function () {\r\n        return this._gmx.styleManager.getStyles();\r\n    },\r\n\r\n    getIcons: function (callback) {\r\n        this._gmx.styleManager.getIcons(callback);\r\n        return this;\r\n    },\r\n\r\n    setStyles: function (styles) {\r\n        var _this = this;\r\n\r\n        this.initPromise.then(function() {\r\n            _this._gmx.styleManager.clearStyles();\r\n            if (styles) {\r\n                styles.forEach(function(it, i) {\r\n                    _this.setStyle(it, i, true);\r\n                });\r\n            } else {\r\n                _this.fire('stylechange');\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    getStyle: function (num) {\r\n        return this.getStyles()[num];\r\n    },\r\n\r\n    setStyle: function (style, num, createFlag) {\r\n        var _this = this,\r\n            gmx = this._gmx;\r\n        this.initPromise.then(function() {\r\n            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\r\n                _this.fire('stylechange', {num: num || 0});\r\n            });\r\n        });\r\n        return this;\r\n    },\r\n\r\n    setStyleHook: function (func) {\r\n        this._gmx.styleHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeStyleHook: function () {\r\n        this._gmx.styleHook = null;\r\n        return this;\r\n    },\r\n\r\n    setRasterHook: function (func) {\r\n        this._gmx.rasterProcessingHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeRasterHook: function () {\r\n        this._gmx.rasterProcessingHook = null;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    setFilter: function (func) {\r\n        var gmx = this._gmx;\r\n        gmx.dataManager.addFilter('userFilter', function(item) {\r\n            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\r\n        }.bind(this));\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        this._gmx.dataManager.removeFilter('userFilter');\r\n        return this;\r\n    },\r\n\r\n    setDateInterval: function (beginDate, endDate) {\r\n        var gmx = this._gmx;\r\n\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n\t\t\tbeginDate = gmx.dateBegin;\r\n\t\t\tendDate = gmx.dateEnd;\r\n\t\t}\r\n\r\n        //check that something changed\r\n        if (!gmx.beginDate !== !beginDate ||\r\n            !gmx.endDate !== !endDate ||\r\n            beginDate && (gmx.beginDate.valueOf() !== beginDate.valueOf()) ||\r\n            endDate && (gmx.endDate.valueOf() !== endDate.valueOf())\r\n        ) {\r\n            if (gmx.rawProperties.maxShownPeriod && beginDate) {\r\n                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\r\n                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\r\n            }\r\n\r\n            gmx.beginDate = beginDate;\r\n            gmx.endDate = endDate;\r\n\r\n            var observer = null,\r\n\t\t\t\tdataManager = gmx.dataManager;\r\n            for (var key in gmx.tileSubscriptions) {\r\n                observer = dataManager.getObserver(key);\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n            observer = dataManager.getObserver('_Labels');\r\n            if (observer) {\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n\t\t\tif (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\r\n\t\t\t\tgmx.properties.LayerVersion = -1;\r\n\t\t\t\tdataManager.setOptions({LayerVersion: -1});\r\n\t\t\t\tif (this._map) {\r\n\t\t\t\t\tL.gmx.layersVersion.now();\r\n\t\t\t\t}\r\n\t\t\t}\r\n            this.fire('dateIntervalChanged');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getDateInterval: function() {\r\n        return {\r\n            beginDate: this._gmx.beginDate,\r\n            endDate: this._gmx.endDate\r\n        };\r\n    },\r\n\r\n    addObserver: function (options) {\r\n        return this._gmx.dataManager.addObserver(options);\r\n    },\r\n\r\n    removeObserver: function(observer) {\r\n        return this._gmx.dataManager.removeObserver(observer.id);\r\n    },\r\n\r\n    setPositionOffset: function(dx, dy) {\r\n        var gmx = this._gmx;\r\n        gmx.shiftXlayer = dx;\r\n        gmx.shiftYlayer = dy;\r\n        this._update();\r\n        return this;\r\n    },\r\n\r\n    getPositionOffset: function() {\r\n        var gmx = this._gmx;\r\n        return {shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer};\r\n    },\r\n\r\n    setZIndexOffset: function (offset) {\r\n        if (arguments.length) {\r\n            this.options.zIndexOffset = offset;\r\n        }\r\n        this._updateZIndex();\r\n        return this;\r\n    },\r\n\r\n    repaint: function (zKeys) {\r\n        if (this._map) {\r\n            if (!zKeys) {\r\n                zKeys = {};\r\n                for (var key in this._gmx.tileSubscriptions) { zKeys[key] = true; }\r\n                L.extend(zKeys, this.repaintObservers);\r\n            }\r\n            this._gmx.dataManager._triggerObservers(zKeys);\r\n        }\r\n    },\r\n\r\n    redrawItem: function (id) {\r\n        if (this._map) {\r\n            var item = this._gmx.dataManager.getItem(id),\r\n                gmxTiles = this._getTilesByBounds(item.bounds);\r\n\r\n            this.repaint(gmxTiles);\r\n        }\r\n    },\r\n\r\n    gmxGetCanvasTile: function (tilePoint) {\r\n        var zKey = this._tileCoordsToKey(tilePoint);\r\n\r\n        if (zKey in this._tiles) {\r\n            return this._tiles[zKey];\r\n        }\r\n        // save tile in cache\r\n        var tile = this._getTile();\r\n        this._tiles[zKey] = {\r\n            el: tile,\r\n            coords: tilePoint,\r\n            current: true\r\n        };\r\n\r\n        // tile._zKey = zKey;\r\n        tile._zoom = this._map._zoom;\r\n        tile._tileComplete = true;\r\n        tile._tilePoint = tilePoint;\r\n        this.tileDrawn(tile);\r\n        return this._tiles[zKey];\r\n    },\r\n\r\n    appendTileToContainer: function (tile) {\r\n        this._tileContainer.appendChild(tile);\r\n        var tilePos = this._getTilePos(tile._tilePoint);\r\n        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\r\n    },\r\n\r\n    addData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.addData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.removeData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStylesByProperties: function(propArray, zoom) {\r\n        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\r\n    },\r\n\r\n    getItemStyle: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        return gmx.styleManager.getObjStyle(item);\r\n    },\r\n\r\n    getTileAttributeTypes: function() {\r\n        return this._gmx.tileAttributeTypes;\r\n    },\r\n\r\n    getTileAttributeIndexes: function() {\r\n        return this._gmx.tileAttributeIndexes;\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id),\r\n            styles = this.getStyles(),\r\n            out = '';\r\n\r\n        if (item && styles[item.currentFilter]) {\r\n            var propsArr = item.properties;\r\n            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\r\n                properties: this.getItemProperties(propsArr),\r\n                geometries: [propsArr[propsArr.length - 1]],\r\n                tileAttributeTypes: gmx.tileAttributeTypes,\r\n                unitOptions: this._map ? this._map.options : {}\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getItemProperties: function(propArray) {\r\n        var properties = {},\r\n            indexes = this._gmx.tileAttributeIndexes;\r\n        for (var key in indexes) {\r\n            properties[key] = propArray[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    addPreRenderHook: function(renderHook) {\r\n        this._gmx.preRenderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removePreRenderHook: function(hook) {\r\n        var arr = this._gmx.preRenderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    addRenderHook: function(renderHook) {\r\n        this._gmx.renderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removeRenderHook: function(hook) {\r\n        var arr = this._gmx.renderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    //get original properties from the server\r\n    getGmxProperties: function() {\r\n        return this._gmx.rawProperties;\r\n    },\r\n\r\n    //returns L.LatLngBounds\r\n    getBounds: function() {\r\n        var proj = L.Projection.Mercator,\r\n            gmxBounds = this._gmx.layerID ? gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\r\n\r\n        if (gmxBounds) {\r\n            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\r\n        } else {\r\n            return new L.LatLngBounds();\r\n        }\r\n    },\r\n\r\n    getGeometry: function() {\r\n        if (!this._gmx.latLngGeometry) {\r\n            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\r\n        }\r\n\r\n        return this._gmx.latLngGeometry;\r\n    },\r\n\r\n    // internal methods\r\n    _clearTileSubscription: function(zKey) {\r\n        var gmx = this._gmx;\r\n\r\n        if (zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            delete gmx.tileSubscriptions[zKey];\r\n            this._removeTile(zKey);\r\n\r\n            if (this._anyDrawings) {\r\n                this._chkDrawingState();\r\n            }\r\n        }\r\n\r\n        if (zKey in this._drawQueueHash) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n    },\r\n\r\n    _clearAllSubscriptions: function() {\r\n        while (this._drawQueue.length) {\r\n            this._drawQueue[0].def.cancel();\r\n        }\r\n\r\n        var gmx = this._gmx;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            gmx.dataManager.removeObserver(zKey);\r\n            delete gmx.tileSubscriptions[zKey];\r\n            delete this._tiles[zKey];\r\n        }\r\n\r\n        if (this._anyDrawings) {\r\n            this._chkDrawingState();\r\n        }\r\n\r\n        gmx._tilesToLoad = 0;\r\n    },\r\n\r\n    _zoomStart: function() {\r\n        this._gmx.zoomstart = true;\r\n    },\r\n\r\n    _zoomEnd: function() {\r\n        this._gmx.zoomstart = false;\r\n        this.setCurrentZoom(this._map);\r\n        // this._zIndexOffsetCheck();\r\n    },\r\n\r\n    _moveEnd: function() {\r\n        if ('dataManager' in this._gmx) {\r\n            this._gmx.dataManager.fire('moveend');\r\n        }\r\n    },\r\n\r\n    _onStyleChange: function() {\r\n        var gmx = this._gmx;\r\n        if (!gmx.balloonEnable && this._popup) {\r\n            this.unbindPopup();\r\n        } else if (gmx.balloonEnable && !this._popup) {\r\n            this.bindPopup('');\r\n        }\r\n        if (this._map) {\r\n            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\r\n                this.options.minZoom = gmx.styleManager.minZoom;\r\n                this.options.maxZoom = gmx.styleManager.maxZoom;\r\n                this._map._updateZoomLevels();\r\n            }\r\n            if (gmx.labelsLayer) {\r\n                this._map._labelsLayer.add(this);\r\n            } else if (!gmx.labelsLayer) {\r\n                this._map._labelsLayer.remove(this);\r\n            }\r\n            if (Object.keys(gmx.tileSubscriptions).length > 0) {\r\n                for (var key in gmx.tileSubscriptions) {    // recheck bbox on screen observers\r\n                    var observer = gmx.dataManager.getObserver(key),\r\n                        parsedKey = gmx.tileSubscriptions[key],\r\n                        gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\r\n                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\r\n                    if (!observer.bbox.isEqual(bbox)) {\r\n                        var proj = L.Projection.Mercator;\r\n                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\r\n                    }\r\n                }\r\n            } else {\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    _removeInProgressDrawing: function(zKey) {\r\n        delete this._drawInProgress[zKey];\r\n        this._chkDrawingState();\r\n    },\r\n\r\n    _drawTileAsync: function (tilePoint, zoom, data) {\r\n        var queue = this._drawQueue,\r\n            isEmpty = queue.length === 0,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            _this = this;\r\n\r\n        if (this._drawQueueHash[zKey]) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n\r\n        var drawNextTile = function() {\r\n            _this._chkDrawingState();\r\n\r\n            if (!queue.length) {\r\n                return;\r\n            }\r\n\r\n            var queueItem = queue.shift();\r\n            delete _this._drawQueueHash[queueItem.zKey];\r\n            if (_this._map && queueItem.z === _this._map._zoom) {\r\n                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\r\n\r\n                _this._drawInProgress[queueItem.zKey] = true;\r\n\r\n                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\r\n\r\n                queueItem.drawDef.then(\r\n                    queueItem.def.resolve.bind(queueItem.def, queueItem.data),\r\n                    queueItem.def.reject\r\n                );\r\n            } else {\r\n                queueItem.def.reject();\r\n            }\r\n            setTimeout(drawNextTile, 0);\r\n        };\r\n\r\n        var gtp = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\r\n        var queueItem = {gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data};\r\n        var def = queueItem.def = new L.gmx.Deferred(function() {\r\n            queueItem.drawDef && queueItem.drawDef.cancel();\r\n\r\n            _this._removeInProgressDrawing(zKey);\r\n\r\n            delete _this._drawQueueHash[zKey];\r\n            for (var i = queue.length - 1; i >= 0; i--) {\r\n                var elem = queue[i];\r\n                if (elem.zKey === zKey) {\r\n                    queue.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        queue.push(queueItem);\r\n\r\n        this._drawQueueHash[zKey] = def;\r\n\r\n        if (isEmpty) {\r\n            setTimeout(drawNextTile, 0);\r\n        }\r\n\r\n        return def;\r\n    },\r\n\r\n    _updateShiftY: function() {\r\n        var gmx = this._gmx,\r\n            map = this._map,\r\n            deltaY = 0;\r\n\r\n        if (map) {\r\n            var pos = map.getCenter();\r\n            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\r\n        }\r\n\r\n        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\r\n        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\r\n        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY);     // Сдвиг слоя\r\n\r\n        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\r\n    },\r\n\r\n    _prpZoomData: function() {\r\n        this.setCurrentZoom(this._map);\r\n        // this.repaint();\r\n    },\r\n\r\n    setCurrentZoom: function(map) {\r\n        var gmx = this._gmx;\r\n        gmx.currentZoom = map._zoom;\r\n        gmx.tileSize = gmxAPIutils.tileSizes[gmx.currentZoom];\r\n        gmx.mInPixel = 256 / gmx.tileSize;\r\n    },\r\n\r\n    // _zIndexOffsetCheck: function() {\r\n        // var gmx = this._gmx;\r\n        // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\r\n            // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\r\n            // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\r\n            // if (zIndexOffset !== this.options.zIndexOffset) {\r\n                // this.setZIndexOffset(zIndexOffset);\r\n            // }\r\n        // }\r\n    // },\r\n\r\n    _setClearBgBuffer: function (zd) {\r\n        if (this._clearBgBufferTimer) { clearTimeout(this._clearBgBufferTimer); }\r\n        var _this = this;\r\n        this._clearBgBufferTimer = setTimeout(function () {\r\n            if (_this._bgBuffer) {\r\n                _this._clearBgBuffer();\r\n            }\r\n        }, zd || 0);\r\n    },\r\n\r\n    _getNeedPopups: function () {\r\n        var out = {},\r\n            openPopups = this.options.openPopups;\r\n        for (var i = 0, len = openPopups.length; i < len; i++) {\r\n            out[openPopups[i]] = false;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    __update: function () {\r\n        var map = this._map;\r\n        if (!map) { return; }\r\n        var zoom = map.getZoom(),\r\n            center = map.getCenter();\r\n\r\n        if (this._gmx.applyShift) {\r\n            this._updateShiftY();\r\n        }\r\n        this._tileZoom = zoom;\r\n        if (this.options.openPopups.length) {\r\n            this._gmx._needPopups = this._getNeedPopups();\r\n            this.options.openPopups = [];\r\n        }\r\n\r\n        var pixelBounds = this._getTiledPixelBounds(center),\r\n            tileRange = this._pxBoundsToTileRange(pixelBounds),\r\n            limit = this._getWrapTileNum();\r\n\r\n        if (tileRange.min.y < 0) { tileRange.min.y = 0; }\r\n        if (tileRange.max.y >= limit.y) { tileRange.max.y = limit.y - 1; }\r\n\r\n        this._chkTileSubscriptions(zoom, tileRange);\r\n\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            this._setClearBgBuffer(500);\r\n            return;\r\n        }\r\n\r\n        // create a queue of coordinates to load tiles from\r\n        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\r\n            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\r\n                var coords = new L.Point(i, j);\r\n                coords.z = this._tileZoom;\r\n\r\n                if (!this._tiles[this._tileCoordsToKey(coords)]) {\r\n                    this._addTile(coords);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkTileSubscriptions: function (zoom, tileRange) {\r\n        //L.TileVector will remove all tiles from other zooms.\r\n        //But it will not remove subscriptions without tiles - we should do it ourself\r\n        var gmx = this._gmx,\r\n            min = tileRange.min,\r\n            max = tileRange.max;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.z !== zoom\r\n                || subscription.x < min.x\r\n                || subscription.x > max.x\r\n                || subscription.y < min.y\r\n                || subscription.y > max.y\r\n            ) {\r\n                this._clearTileSubscription(zKey);\r\n            }\r\n        }\r\n    },\r\n\r\n    _getScreenTile: function (tilePoint, zoom) {\r\n        var gmx = this._gmx,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            subscription = gmx.tileSubscriptions[zKey],\r\n            screenTile = null;\r\n        if (subscription) {\r\n            if (subscription.screenTile) {\r\n                screenTile = subscription.screenTile;\r\n            } else {\r\n                subscription.screenTile = screenTile = new ScreenVectorTile(this, tilePoint, zoom);\r\n            }\r\n        }\r\n        return screenTile;\r\n    },\r\n\r\n    _gmxDrawTile: function (tilePoint, zoom, data) {\r\n        var gmx = this._gmx,\r\n            cancelled = false,\r\n            screenTileDrawPromise = null,\r\n            def = new L.gmx.Deferred(function() {\r\n                cancelled = true;\r\n                screenTileDrawPromise && screenTileDrawPromise.cancel();\r\n            });\r\n\r\n        if (!this._map) {\r\n            def.reject();\r\n            return def;\r\n        }\r\n        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\r\n        if (screenTile) {\r\n            gmx.styleManager.deferred.then(function () {\r\n                if (!cancelled) {\r\n                    screenTileDrawPromise = screenTile.drawTile(data);\r\n                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\r\n                }\r\n            });\r\n        }\r\n       return def;\r\n    },\r\n\r\n    _getTilesByBounds: function (bounds) {    // Получить список gmxTiles по bounds\r\n        var gmx = this._gmx,\r\n            zoom = this._map._zoom,\r\n            shiftX = gmx.shiftX || 0,   // Сдвиг слоя\r\n            shiftY = gmx.shiftY || 0,   // Сдвиг слоя + OSM\r\n            minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\r\n            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\r\n            screenBounds = this._map.getBounds(),\r\n            sw = screenBounds.getSouthWest(),\r\n            ne = screenBounds.getNorthEast(),\r\n            dx = 0;\r\n\r\n        if (ne.lng - sw.lng < 360) {\r\n            if (maxLatLng.lng < sw.lng) {\r\n                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\r\n            } else if (minLatLng.lng > ne.lng) {\r\n                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\r\n            }\r\n        }\r\n        minLatLng.lng += dx;\r\n        maxLatLng.lng += dx;\r\n\r\n        var pixelBounds = this._map.getPixelBounds(),\r\n            minPoint = this._map.project(minLatLng),\r\n            maxPoint = this._map.project(maxLatLng);\r\n\r\n        var minY, maxY, minX, maxX;\r\n        if (pixelBounds) {\r\n            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\r\n            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\r\n            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\r\n            minX = Math.floor((minX + shiftX) / 256);\r\n            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\r\n            maxX = Math.floor((maxX + shiftX) / 256);\r\n        } else {\r\n            minY = Math.floor((maxPoint.y + shiftY) / 256);\r\n            maxY = Math.floor((minPoint.y + shiftY) / 256);\r\n            minX = Math.floor((minPoint.x + shiftX) / 256);\r\n            maxX = Math.floor((maxPoint.x + shiftX) / 256);\r\n        }\r\n        var gmxTiles = {};\r\n        for (var x = minX; x <= maxX; x++) {\r\n            for (var y = minY; y <= maxY; y++) {\r\n                var zKey = this._tileCoordsToKey({x: x, y: y}, zoom);\r\n                gmxTiles[zKey] = true;\r\n            }\r\n        }\r\n        return gmxTiles;\r\n    },\r\n\r\n    _updateProperties: function (prop) {\r\n        var gmx = this._gmx,\r\n            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\r\n\r\n        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tprop = this.options.parentOptions;\r\n\t\t}\r\n\r\n        gmx.identityField = prop.identityField; // ogc_fid\r\n        gmx.GeometryType = (prop.GeometryType || '').toLowerCase();   // тип геометрий обьектов в слое\r\n        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1;// мин. zoom для растров\r\n        gmx.minZoomQuicklooks = gmx.minZoomRasters; // по умолчанию minZoom для квиклуков и КР равны\r\n\r\n        var type = prop.type || 'Vector';\r\n        if (prop.Temporal) { type += 'Temporal'; }\r\n        gmx.layerType = type;   // VectorTemporal Vector\r\n        gmx.items = {};\r\n\r\n        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\r\n        if (gmx.dataManager) {\r\n            gmx.dataManager.setOptions(prop);\r\n        }\r\n        if ('ZIndexField' in prop) {\r\n            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\r\n                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField];   // sort field index\r\n            }\r\n        }\r\n        if (this._objectsReorder) {\r\n            this._objectsReorder.initialize();\r\n        }\r\n\r\n        // if ('clusters' in prop) {\r\n            // gmx.clusters = prop.clusters;\r\n        // }\r\n\r\n        gmx.filter = prop.filter; \t// for dataSource attr\r\n        gmx.dateBegin = prop.dateBegin;\r\n        gmx.dateEnd = prop.dateEnd;\r\n        gmx.dataSource = prop.dataSource;\r\n        if ('MetaProperties' in gmx.rawProperties) {\r\n            var meta = gmx.rawProperties.MetaProperties;\r\n            if ('parentLayer' in meta) {  // фильтр слоя\t\t// todo удалить после изменений вов вьювере\r\n                gmx.dataSource = meta.parentLayer.Value || '';\r\n            }\r\n            if ('filter' in meta) {  // фильтр слоя\r\n                gmx.filter = meta.filter.Value || '';\r\n            }\r\n            if ('dateBegin' in meta) {  // фильтр для мультивременного слоя\r\n                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\r\n            }\r\n            if ('dateEnd' in meta) {  // фильтр для мультивременного слоя\r\n                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\r\n            }\r\n            if ('shiftX' in meta || 'shiftY' in meta) {  // сдвиг всего слоя\r\n                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\r\n                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\r\n            }\r\n            if ('shiftXfield' in meta || 'shiftYfield' in meta) {    // поля сдвига растров объектов слоя\r\n                if (meta.shiftXfield) { gmx.shiftXfield = meta.shiftXfield.Value; }\r\n                if (meta.shiftYfield) { gmx.shiftYfield = meta.shiftYfield.Value; }\r\n            }\r\n            if ('quicklookPlatform' in meta) {    // тип спутника\r\n                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\r\n                if (gmx.quicklookPlatform === 'image') { delete gmx.quicklookPlatform; }\r\n            }\r\n            if ('quicklookX1' in meta) { gmx.quicklookX1 = meta.quicklookX1.Value; }\r\n            if ('quicklookY1' in meta) { gmx.quicklookY1 = meta.quicklookY1.Value; }\r\n            if ('quicklookX2' in meta) { gmx.quicklookX2 = meta.quicklookX2.Value; }\r\n            if ('quicklookY2' in meta) { gmx.quicklookY2 = meta.quicklookY2.Value; }\r\n            if ('quicklookX3' in meta) { gmx.quicklookX3 = meta.quicklookX3.Value; }\r\n            if ('quicklookY3' in meta) { gmx.quicklookY3 = meta.quicklookY3.Value; }\r\n            if ('quicklookX4' in meta) { gmx.quicklookX4 = meta.quicklookX4.Value; }\r\n            if ('quicklookY4' in meta) { gmx.quicklookY4 = meta.quicklookY4.Value; }\r\n\r\n            if ('multiFilters' in meta) {    // проверка всех фильтров для обьектов слоя\r\n                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\r\n            }\r\n            if ('isGeneralized' in meta) {    // Set generalization\r\n                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\r\n            }\r\n            if ('isFlatten' in meta) {        // Set flatten geometry\r\n                this.options.isFlatten = meta.isFlatten.Value !== 'false';\r\n            }\r\n        }\r\n        if (prop.Temporal) {    // Clear generalization flag for Temporal layers\r\n            this.options.isGeneralized = false;\r\n        }\r\n\r\n        if (prop.IsRasterCatalog) {\r\n            gmx.IsRasterCatalog = prop.IsRasterCatalog;\r\n            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\r\n            if (layerLink) {\r\n                gmx.rasterBGfunc = function(x, y, z, item) {\r\n                    var properties = item.properties;\r\n                    return 'http://' + gmx.hostName\r\n                        + '/TileSender.ashx?ModeKey=tile'\r\n                        + '&x=' + x\r\n                        + '&y=' + y\r\n                        + '&z=' + z\r\n                        + '&LayerName=' + properties[layerLink]\r\n                        + '&key=' + encodeURIComponent(gmx.sessionKey);\r\n                };\r\n            }\r\n        }\r\n        if (prop.Quicklook) {\r\n            var quicklookParams;\r\n\r\n            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом\r\n            if (prop.Quicklook[0] === '{') {\r\n                quicklookParams = JSON.parse(prop.Quicklook);\r\n            } else {\r\n                quicklookParams = {\r\n                    minZoom: gmx.minZoomRasters,\r\n                    template: prop.Quicklook\r\n                };\r\n            }\r\n\r\n            if ('X1' in quicklookParams) { gmx.quicklookX1 = quicklookParams.X1; }\r\n            if ('Y1' in quicklookParams) { gmx.quicklookY1 = quicklookParams.Y1; }\r\n            if ('X2' in quicklookParams) { gmx.quicklookX2 = quicklookParams.X2; }\r\n            if ('Y2' in quicklookParams) { gmx.quicklookY2 = quicklookParams.Y2; }\r\n            if ('X3' in quicklookParams) { gmx.quicklookX3 = quicklookParams.X3; }\r\n            if ('Y3' in quicklookParams) { gmx.quicklookY3 = quicklookParams.Y3; }\r\n            if ('X4' in quicklookParams) { gmx.quicklookX4 = quicklookParams.X4; }\r\n            if ('Y4' in quicklookParams) { gmx.quicklookY4 = quicklookParams.Y4; }\r\n\r\n            var template = gmx.Quicklook = quicklookParams.template;\r\n            if ('minZoom' in quicklookParams) { gmx.minZoomQuicklooks = quicklookParams.minZoom; }\r\n            gmx.quicklookBGfunc = function(item) {\r\n                var url = template,\r\n                    reg = /\\[([^\\]]+)\\]/,\r\n                    matches = reg.exec(url);\r\n                while (matches && matches.length > 1) {\r\n                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\r\n                    matches = reg.exec(url);\r\n                }\r\n                return url;\r\n            };\r\n            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\r\n        }\r\n        this.options.attribution = prop.Copyright || '';\r\n    },\r\n\r\n    _onVersionChange: function () {\r\n        this._updateProperties(this._gmx.rawProperties);\r\n    },\r\n\r\n    getViewRasters: function() {\r\n        var gmx = this._gmx,\r\n\t\t\thash = {},\r\n\t\t\tout = [];\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey],\r\n\t\t\t\tscreenTile = subscription.screenTile;\r\n            if (screenTile) {\r\n                screenTile.itemsView.forEach(function(it) {\r\n\t\t\t\t\thash[it.id] = true;\r\n\t\t\t\t});\r\n            }\r\n        }\r\n        for (var id in hash) {\r\n\t\t\tout.push(id);\r\n\t\t}\r\n\r\n        return out;\r\n    },\r\n\r\n    getPropItem: function (key, propArr) {\r\n        return gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar StyleManager = function(gmx) {\r\n    this.gmx = gmx;\r\n    this.deferred = new L.gmx.Deferred();\r\n\r\n    this._maxVersion = 0;\r\n    this._maxStyleSize = 0;\r\n    this._styles = [];\r\n    this._deferredIcons = [];\r\n    this._parserFunctions = {};\r\n    this._serverStylesParsed = false;\r\n\r\n    var minZoom = Infinity,\r\n        maxZoom = -Infinity,\r\n        arr = gmx.properties.styles || [];\r\n\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n        var st = arr[i];\r\n        minZoom = Math.min(minZoom, st.MinZoom);\r\n        maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n    }\r\n    this.minZoom = minZoom === Infinity ? 0 : minZoom;\r\n    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\r\n};\r\nStyleManager.prototype = {\r\n    _getMaxStyleSize: function(zoom) {  // estimete style size for arbitrary object\r\n        var maxSize = 0;\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom > style.MaxZoom || zoom < style.MinZoom) { continue; }\r\n            var RenderStyle = style.RenderStyle;\r\n            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\r\n            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\r\n                maxSize = StyleManager.MAX_STYLE_SIZE;\r\n                break;\r\n            }\r\n            var maxShift = 0;\r\n            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\r\n                maxShift = Math.max(\r\n                    Math.abs(RenderStyle.iconAnchor[0]),\r\n                    Math.abs(RenderStyle.iconAnchor[1])\r\n                );\r\n            }\r\n            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\r\n        }\r\n        return maxSize;\r\n    },\r\n\r\n    getStyleBounds: function(gmxTilePoint) {\r\n        if (!gmxTilePoint) {\r\n            return gmxAPIutils.bounds();\r\n        }\r\n\r\n        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\r\n\r\n        var mercSize = 2 * this._maxStyleSize * gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\r\n        return gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\r\n    },\r\n\r\n    //is any style is visible at given zoom?\r\n    isVisibleAtZoom: function(zoom) {\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    getIcons: function(callback) {\r\n        var _this = this;\r\n        this.deferred.then(function() {\r\n            var out = [];\r\n            for (var i = 0, len = _this._styles.length; i < len; i++) {\r\n                var style = _this._styles[i],\r\n                    pt = {};\r\n                if (style.RenderStyle) {\r\n                    pt.RenderStyle = {image: style.RenderStyle.image};\r\n                }\r\n                if (style.HoverStyle) {\r\n                    pt.HoverStyle = {image: style.HoverStyle.image};\r\n                }\r\n                out.push(pt);\r\n            }\r\n            if (callback) {\r\n                callback(out);\r\n            }\r\n        });\r\n        this.initStyles();\r\n    },\r\n\r\n    _chkReady: function() {\r\n        if (this._needLoadIcons < 1) {\r\n            var _this = this;\r\n\t\t\tif (this.gmx.dataManager) {\r\n\t\t\t\tthis.gmx.dataManager.addFilter('styleFilter', function(it) { return _this._chkStyleFilter(it); });\r\n\t\t\t}\r\n            this.deferred.resolve();\r\n        }\r\n    },\r\n\r\n    initStyles: function() {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\r\n            this._getImageSize(this._deferredIcons[i]);\r\n        }\r\n        this._deferredIcons = [];\r\n        this._chkReady();\r\n        return this.deferred;\r\n    },\r\n\r\n    getStyles: function () {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        var out = [];\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = L.extend({}, this._styles[i]);\r\n            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\r\n            if (style.HoverStyle) {\r\n                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\r\n            }\r\n            delete style.filterFunction;\r\n            delete style.version;\r\n            delete style.common;\r\n            delete style.type;\r\n            out.push(style);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    clearStyles: function () {\r\n        this._styles = [];\r\n        this.gmx.balloonEnable = false;\r\n        this.gmx.labelsLayer = false;\r\n    },\r\n\r\n    _changeStylesVersion: function () {\r\n        var _this = this;\r\n        this._styles.map(function(it) {\r\n            it.version = ++_this._maxVersion;\r\n        });\r\n    },\r\n\r\n    setStyle: function(st, num, createFlag) {\r\n        num = num || 0;\r\n        if (num < this._styles.length || createFlag) {\r\n            var style = this._styles[num];\r\n            if (!style) {\r\n                style = this._prepareItem({});\r\n                this._styles[num] = style;\r\n            }\r\n            this.deferred = new L.gmx.Deferred();\r\n            style.version = ++this._maxVersion;\r\n            if ('Filter' in st) {\r\n                style.Filter = st.Filter;\r\n                var type = typeof (st.Filter);\r\n                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'))\r\n                    : type === 'function' ? style.Filter : null;\r\n\r\n                this._changeStylesVersion();\r\n            }\r\n            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\r\n                var key = StyleManager.DEFAULT_KEYS[i];\r\n                if (key in st) { style[key] = st[key]; }\r\n            }\r\n            if (st.RenderStyle) {\r\n                style.RenderStyle = this._parseStyle(st.RenderStyle);\r\n            }\r\n            if (st.HoverStyle) { style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle); }\r\n            this._checkStyles();\r\n        }\r\n        return this.initStyles();\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var item = this.gmx.dataManager.getItem(id),\r\n            currentFilter = item ? item.currentFilter : 0,\r\n            style = this._styles[currentFilter];\r\n        return style ? {\r\n                DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\r\n                DisableBalloonOnClick: style.DisableBalloonOnClick || false,\r\n                templateBalloon: style.Balloon || null,\r\n                isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\r\n            }\r\n            : null\r\n        ;\r\n    },\r\n\r\n    // apply styleHook func\r\n    // applyStyleHook: function(item, hoverFlag) {\r\n        // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\r\n    // },\r\n\r\n    getObjStyle: function(item) {\r\n        this._chkStyleFilter(item);\r\n        var style = this._styles[item.currentFilter],\r\n            version;\r\n\r\n        if (!style) { return null; }\r\n        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\r\n            if (style.HoverStyle) {\r\n                version = style.HoverStyle.version || -1;\r\n                if (version !== item.styleVersion) {\r\n                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\r\n                }\r\n                return style.HoverStyle;\r\n            } else {\r\n                delete item.parsedStyleHover;\r\n            }\r\n            return null;\r\n        }\r\n        version = style.version || -1;\r\n        if (version !== item.styleVersion) {\r\n            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\r\n        }\r\n        return style.RenderStyle;\r\n    },\r\n\r\n    _needLoadIcons: 0,\r\n    _getImageSize: function(pt) {     // check image size\r\n        var url = pt.iconUrl || pt.fillIconUrl,\r\n            opt = pt.iconAngle || pt.iconScale ? {crossOrigin: 'anonymous'} : {},\r\n            _this = this;\r\n\r\n        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\r\n            opt = {};   // skip bug in IE11\r\n        }\r\n        opt.layerID = this.gmx.layerID;\r\n        ++this._needLoadIcons;\r\n        L.gmx.imageLoader.unshift(url, opt).def.then(\r\n            function(it) {\r\n                pt.version = ++_this._maxVersion;\r\n                if (pt.fillIconUrl) {\r\n                    pt.imagePattern = it;\r\n                } else {\r\n                    var w = it.width,\r\n                        h = it.height;\r\n                    if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {   // skip bug in IE11\r\n                        document.body.appendChild(it);\r\n                        w = it.offsetWidth;\r\n                        h = it.offsetHeight;\r\n                        document.body.removeChild(it);\r\n                    }\r\n                    pt.sx = w;\r\n                    pt.sy = h;\r\n                    pt.image = it;\r\n                    var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\r\n                    if (!pt.scaleFunction && !pt.rotateFunction) {\r\n                        if (pt.iconScale || pt.iconScale === 1) { maxSize *= pt.iconScale; }\r\n                        pt.common = true;\r\n                    }\r\n                    pt.maxSize = Number(maxSize.toFixed());\r\n                }\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n            },\r\n            function() {\r\n                pt.version = ++_this._maxVersion;\r\n                pt.sx = 1;\r\n                pt.sy = 0;\r\n                pt.image = null;\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n                console.log({url: url, func: '_getImageSize', Error: 'image not found'});\r\n            }\r\n        );\r\n    },\r\n\r\n    getCurrentFilters: function(propArray, zoom) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            types = gmx.tileAttributeTypes,\r\n            z = zoom || 1,\r\n            out = [];\r\n\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n            if (z > st.MaxZoom || z < st.MinZoom\r\n                || (st.filterFunction && !st.filterFunction(propArray, indexes, types))) {\r\n                continue;\r\n            }\r\n            out.push(i);\r\n            if (!gmx.multiFilters) { break; }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    _chkStyleFilter: function(item) {\r\n        var gmx = this.gmx,\r\n            zoom = gmx.currentZoom,\r\n            fnum = gmx.multiFilters ? -1 : item.currentFilter,\r\n            curr = this._styles[fnum],\r\n            needParse = !curr || curr.version !== item.styleVersion;\r\n\r\n        if (needParse || item._lastZoom !== zoom) {\r\n            item.currentFilter = -1;\r\n            item.multiFilters = [];\r\n            var filters = this.getCurrentFilters(item.properties, zoom);\r\n            for (var i = 0, len = filters.length; i < len; i++) {\r\n                var num = filters[i],\r\n                    st = this._styles[num];\r\n                item.hoverDiff = st.hoverDiff;\r\n                item.currentFilter = num;\r\n                if (needParse || fnum !== num) {\r\n                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\r\n                        parsedHover = null;\r\n\r\n                    item.parsedStyleKeys = parsed;\r\n                    if (st.HoverStyle) {\r\n                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\r\n                        item.parsedStyleHover = parsedHover;\r\n                    }\r\n                    if (gmx.multiFilters) {\r\n                        item.multiFilters.push({\r\n                            style: st.RenderStyle,\r\n                            styleHover: st.HoverStyle,\r\n                            parsedStyle: parsed,\r\n                            parsedStyleHover: parsedHover\r\n                        });\r\n                    }\r\n                }\r\n                item.styleVersion = st.version;\r\n                if (!gmx.multiFilters) { break; }\r\n            }\r\n            item._lastZoom = zoom;\r\n        }\r\n        if (this._styles[item.currentFilter]) {\r\n            return true;\r\n        } else {\r\n            item.currentFilter = -1;\r\n            return false;\r\n        }\r\n    },\r\n\r\n    _parseServerStyles: function() {\r\n        var gmx = this.gmx,\r\n            props = gmx.properties,\r\n            arr = props.styles || [{MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE}],\r\n            len = Math.max(arr.length, gmx.styles.length);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            if (!this._styles[i]) {\r\n                var gmxStyle = gmx.styles[i] || arr[i];\r\n                if (!gmxStyle.RenderStyle) { gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE; }\r\n                if (gmxStyle.HoverStyle === undefined) {\r\n                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\r\n                    if (hoveredStyle.outline) { hoveredStyle.outline.thickness += 1; }\r\n                    gmxStyle.HoverStyle = hoveredStyle;\r\n                } else if (gmxStyle.HoverStyle === null) {\r\n                    delete gmxStyle.HoverStyle;\r\n                }\r\n                var pt = this._prepareItem(gmxStyle);\r\n                this._styles.push(pt);\r\n                if (this._isLabel(pt.RenderStyle)) { gmx.labelsLayer = true; }\r\n            }\r\n        }\r\n        this._checkStyles();\r\n        this._serverStylesParsed = true;\r\n    },\r\n\r\n    _checkStyles: function() {\r\n        var minZoom = Infinity,\r\n            maxZoom = -Infinity,\r\n            balloonEnable = false,\r\n            labelsLayer = false;\r\n\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n\r\n            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\r\n            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\r\n            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\r\n                balloonEnable = true;\r\n                st.BalloonEnable = true;\r\n            }\r\n            st.hoverDiff = null;\r\n            st.common = {};\r\n            if (st.RenderStyle) {\r\n                if (!labelsLayer) {\r\n                    if (this._isLabel(st.RenderStyle)) {\r\n                        labelsLayer = true;\r\n                    }\r\n                }\r\n                if (st.RenderStyle.common) {\r\n                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\r\n                }\r\n                if (st.HoverStyle) {\r\n                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\r\n                }\r\n            }\r\n            if (st.HoverStyle && st.HoverStyle.common) {\r\n                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\r\n            }\r\n            minZoom = Math.min(minZoom, st.MinZoom);\r\n            maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n        }\r\n        if (this.minZoom !== Infinity) { this.minZoom = minZoom; }\r\n        if (this.maxZoom !== -Infinity) { this.maxZoom = maxZoom; }\r\n        this.gmx.balloonEnable = balloonEnable;\r\n        this.gmx.labelsLayer = labelsLayer;\r\n    },\r\n\r\n    _parseStyle: function(st, renderStyle) {\r\n        if (st) {\r\n            st.common = true;\r\n            for (var key in st) {\r\n                if (gmxAPIutils.styleFuncKeys[key]) {\r\n                    var fkey = gmxAPIutils.styleFuncKeys[key],\r\n                        val = st[key];\r\n                    if (typeof (val) === 'string') {\r\n                        st.common = false;\r\n                        if (renderStyle && renderStyle[key] === val) {\r\n                            st[fkey] = renderStyle[fkey];\r\n                        } else {\r\n                            if (!this._parserFunctions[val]) {\r\n                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\r\n                            }\r\n                            st[fkey] = this._parserFunctions[val];\r\n                        }\r\n                    } else if (typeof (val) === 'function') {\r\n                        st.common = false;\r\n                        st[fkey] = val;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var type = '';\r\n            if ('iconUrl' in st) {\r\n                type = 'image';\r\n                if (st.iconUrl) {\r\n                    st.maxSize = 256;\r\n                    this._deferredIcons.push(st);\r\n                }\r\n            } else if (st.fillIconUrl) {\r\n                type = 'square';\r\n                this._deferredIcons.push(st);\r\n            } else if (st.fillPattern) {\r\n                type = 'square';\r\n                st.common = StyleManager.parsePattern(st.fillPattern);\r\n                st.canvasPattern = gmxAPIutils.getPatternIcon(null, st);\r\n            } else if (st.iconCircle) {\r\n                type = 'circle';\r\n                if (!('iconSize' in st)) { st.iconSize = 4; }\r\n            } else if (st.iconPath) {\r\n                type = 'iconPath';\r\n                var iconSize = 0,\r\n                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\r\n                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function(it, i) {\r\n                    var z = arr[i] || it;\r\n                    iconSize = Math.max(iconSize, z);\r\n                    return z;\r\n                });\r\n                st.iconSize = 2 * iconSize;\r\n            } else if (st.fillRadialGradient) {\r\n                type = 'circle';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\r\n                if (size === null) {\r\n                    st.common = false;\r\n                } else {\r\n                    st.iconSize = size;\r\n                }\r\n            } else if (st.fillLinearGradient) {\r\n                type = 'square';\r\n                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\r\n            } else if (st.iconSize) {\r\n                type = 'square';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n            }\r\n            st.type = type;\r\n            if (st.common && !st.maxSize) {\r\n                st.maxSize = st.iconSize || 0;\r\n                st.maxSize += st.weight ? st.weight : 0;\r\n                if ('iconScale' in st) { st.maxSize *= st.iconScale; }\r\n            }\r\n        }\r\n        return st;\r\n    },\r\n\r\n    _prepareItem: function(style) { // Style Scanex->leaflet\r\n        var pt = {\r\n            MinZoom: style.MinZoom || 0,\r\n            MaxZoom: style.MaxZoom || 18,\r\n            Filter: style.Filter || null,\r\n            Balloon: style.Balloon || '',\r\n            RenderStyle: (style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {}),\r\n            version: ++this._maxVersion\r\n        };\r\n        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\r\n        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\r\n        if (style.HoverStyle) {\r\n            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\r\n        }\r\n\r\n        if ('Filter' in style) {\r\n            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (ph) { pt.filterFunction = ph; }\r\n        }\r\n        return pt;\r\n    },\r\n\r\n    _isLabel: function(st) {\r\n        var indexes = this.gmx.tileAttributeIndexes;\r\n        return (st && (st.labelTemplate || (st.labelField && st.labelField in indexes)));\r\n    },\r\n\r\n    _itemStyleParser: function(item, pt) {\r\n        pt = pt || {};\r\n        var out = {}, arr, i, len,\r\n            indexes = this.gmx.tileAttributeIndexes,\r\n            prop = item.properties || {},\r\n            itemType = item.type,\r\n            type = pt.type,\r\n            color = 'color' in pt ? pt.color : 255,\r\n            opacity = 'opacity' in pt ? pt.opacity : 1;\r\n\r\n        out.sx = pt.sx;\r\n        out.sy = pt.sy;\r\n        if (pt.maxSize) {\r\n            out.maxSize = pt.maxSize;\r\n        }\r\n        if (pt.iconAngle) {\r\n            var rotateRes = pt.iconAngle || 0;\r\n            if (rotateRes && typeof (rotateRes) === 'string') {\r\n                rotateRes = (pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0);\r\n            }\r\n            out.rotate = rotateRes || 0;\r\n        }\r\n        if ('iconColor' in pt) {\r\n            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\r\n        }\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if (type === 'image') {\r\n            out.type = type;\r\n            if (pt.iconUrl) { out.iconUrl = pt.iconUrl; }\r\n            if (pt.image) { out.image = pt.image; }\r\n        } else if (pt.fillRadialGradient) {\r\n            var rgr = pt.fillRadialGradient,\r\n                r1 = (rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1),\r\n                r2 = (rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2),\r\n                x1 = (rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1),\r\n                y1 = (rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1),\r\n                x2 = (rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2),\r\n                y2 = (rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2);\r\n            if (rgr.r2max) {\r\n                r2 = Math.min(r2, rgr.r2max);\r\n            }\r\n            var colorStop = [];\r\n            len = rgr.addColorStop.length;\r\n            if (!rgr.addColorStopFunctions) {\r\n                rgr.addColorStopFunctions = new Array(len);\r\n            }\r\n            for (i = 0; i < len; i++) {\r\n                arr = rgr.addColorStop[i];\r\n                var arrFunc = rgr.addColorStopFunctions[i] || [],\r\n                    p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0]),\r\n                    p3 = arr[3];\r\n                if (arr.length < 4) {\r\n                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\r\n                    p3 = gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\r\n                 }\r\n                colorStop.push([p0, p3]);\r\n            }\r\n            out.maxSize = out.sx = out.sy = out.iconSize = r2;\r\n            out.fillRadialGradient = {\r\n                x1:x1, y1:y1, r1:r1, x2:x2, y2:y2, r2:r2,\r\n                addColorStop: colorStop\r\n            };\r\n            out._radialGradientParsed = {\r\n                create: [x1, y1, r1, x2, y2, r2],\r\n                colorStop: colorStop\r\n            };\r\n        } else if (pt.fillLinearGradient) {\r\n            out.fillLinearGradient = pt.fillLinearGradient;\r\n        } else {\r\n            if (pt.fillPattern) {\r\n                out.canvasPattern = (pt.canvasPattern ? pt.canvasPattern : gmxAPIutils.getPatternIcon(item, pt, indexes));\r\n            }\r\n\r\n            if (type === 'iconPath') {\r\n                out.type = type;\r\n                out.iconPath = pt.iconPath;\r\n            }\r\n\r\n            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\r\n                type = 'polygon';\r\n            }\r\n            if (pt.iconSize) {\r\n                var iconSize = ('sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize);\r\n                out.sx = out.sy = iconSize;\r\n                // iconSize += pt.weight ? pt.weight : 0;\r\n                out.iconSize = iconSize;\r\n                if ('iconScale' in pt) {\r\n                    out.iconSize *= pt.iconScale;\r\n                }\r\n                out.maxSize = iconSize;\r\n            }\r\n            out.stroke = true;\r\n            if ('colorFunction' in pt || 'opacityFunction' in pt) {\r\n                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\r\n                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\r\n            }\r\n            out.strokeStyle = gmxAPIutils.dec2color(color, opacity);\r\n            out.lineWidth = 'weight' in pt ? pt.weight : 1;\r\n        }\r\n\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if ('iconAnchor' in pt) {\r\n            out.iconAnchor = pt.iconAnchor;\r\n        }\r\n        if ('iconCenter' in pt) {\r\n            out.iconCenter = pt.iconCenter;\r\n        }\r\n\r\n        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\r\n            out.type = type;\r\n            var fop = pt.fillOpacity,\r\n                fc = pt.fillColor,\r\n                fcDec = typeof (fc) === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\r\n\r\n            if ('fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, 1);\r\n            }\r\n            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\r\n                color = ('fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255);\r\n                opacity = ('fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1);\r\n                out.fillStyle = gmxAPIutils.dec2color(color, opacity);\r\n            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, fop);\r\n            }\r\n        }\r\n\r\n        if ('dashArray' in pt) { out.dashArray = pt.dashArray; }\r\n        if ('dashOffset' in pt) { out.dashOffset = pt.dashOffset; }\r\n\r\n        if (this.gmx.labelsLayer) {\r\n            arr = gmxAPIutils.styleKeys.label.client;\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                var it = arr[i];\r\n                if (it in pt) {\r\n                    if (it === 'labelField') {\r\n                        if (!indexes[pt[it]]) {\r\n                            continue;\r\n                        }\r\n                    } else if (it === 'labelTemplate') {\r\n                        var properties = gmxAPIutils.getPropertiesHash(prop, indexes);\r\n                        out.labelText = gmxAPIutils.parseTemplate(pt[it], properties);\r\n                    }\r\n                    out[it] = pt[it];\r\n                }\r\n            }\r\n            if ('labelAnchor' in pt) {\r\n                out.labelAnchor = pt.labelAnchor;\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n};\r\nStyleManager.MAX_STYLE_SIZE = 256;\r\n//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\r\nStyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8}};\r\nStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\r\nStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10];  // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\r\n\r\nStyleManager.parsePattern = function(pattern) {\r\n    var common = true,\r\n        parsers = L.gmx.Parsers;\r\n    if ('step' in pattern && typeof (pattern.step) === 'string') {\r\n        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\r\n        common = false;\r\n    }\r\n    if ('width' in pattern && typeof (pattern.width) === 'string') {\r\n        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\r\n        common = false;\r\n    }\r\n    if ('colors' in pattern) {\r\n        var arr = [];\r\n        for (var i = 0, len = pattern.colors.length; i < len; i++) {\r\n            var rt = pattern.colors[i];\r\n            if (typeof (rt) === 'string') {\r\n                arr.push(parsers.parseExpression(rt));\r\n                common = false;\r\n            } else {\r\n                arr.push(null);\r\n            }\r\n        }\r\n        pattern.patternColorsFunction = arr;\r\n    }\r\n    return common;\r\n};\r\n\r\nStyleManager.getStyleKeys = function(style) {\r\n    var out = {};\r\n    for (var key in gmxAPIutils.styleKeys) {\r\n        var keys = gmxAPIutils.styleKeys[key];\r\n        for (var i = 0, len = keys.client.length; i < len; i++) {\r\n            var key1 = keys.client[i];\r\n            if (key1 in style) {\r\n                if (style[key1] !== undefined) {\r\n                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\r\n                }\r\n                if (key1 === 'fillPattern') { delete out[key1].patternColorsFunction; }\r\n                else if (key1 === 'fillLinearGradient') { delete out[key1].addColorStopFunctions; }\r\n            }\r\n        }\r\n    }\r\n    if ('iconAnchor' in style) {\r\n        out.iconAnchor = style.iconAnchor;\r\n    }\r\n    if ('labelAnchor' in style) {\r\n        out.labelAnchor = style.labelAnchor;\r\n    }\r\n    return out;\r\n};\r\n\r\nStyleManager.checkDiff = function(st, st1) {\r\n    for (var key in st) {\r\n        if (st[key] !== st1[key]) {\r\n            return key;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nStyleManager.parseRadialGradient = function(rg) {\r\n    //\tx1,y1,r1 — координаты центра и радиус первой окружности;\r\n    //\tx2,y2,r2 — координаты центра и радиус второй окружности.\r\n    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\r\n    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\r\n    //\t\tcolor — код цвета или формула.\r\n    //\t\topacity — прозрачность\r\n    //\t\tcanvasStyleColor — результрующий цвет в формате canvas\r\n    var common = true,\r\n        parsers = L.gmx.Parsers,\r\n        i = 0,\r\n        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (!rg[it]) { rg[it] = 0; }\r\n        if (typeof (rg[it]) === 'string') {\r\n            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\r\n            common = false;\r\n        }\r\n    }\r\n\r\n    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\r\n    rg.addColorStopFunctions = [];\r\n    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\r\n        arr = rg.addColorStop[i];\r\n        var resFunc = [\r\n                (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n                (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n                (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n            ];\r\n        rg.addColorStopFunctions.push(resFunc);\r\n        if (resFunc[1] === null && resFunc[2] === null) {\r\n            arr[3] = gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\r\n        } else {\r\n            common = false;\r\n        }\r\n    }\r\n    if ('r2Function' in rg) { common = false; }\r\n    return common ? Math.max(rg.r1, rg.r2) : null;\r\n};\r\n\r\nStyleManager.parseLinearGradient = function(lg) {\r\n    var common = true;\r\n    //\tx1,y1 — координаты начальной точки\r\n    //\tx2,y2 — координаты конечной точки\r\n    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\r\n    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\r\n    //\t\tcolor — код цвета или формула.\r\n    //\t\topacity — прозрачность\r\n    var i = 0,\r\n        parsers = L.gmx.Parsers,\r\n        arr = ['x1', 'y1', 'x2', 'y2'],\r\n        def = [0, 0, 0, 256],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (it in lg) {\r\n            if (typeof (lg[it]) === 'string') {\r\n                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\r\n                common = false;\r\n            }\r\n        } else {\r\n            lg[it] = def[i];\r\n        }\r\n    }\r\n\r\n    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\r\n    lg.addColorStopFunctions = [];\r\n    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\r\n        arr = lg.addColorStop[i];\r\n        lg.addColorStopFunctions.push([\r\n            (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n            (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n            (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n        ]);\r\n    }\r\n    return common;\r\n};\r\nexport {StyleManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/StyleManager.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n// Single tile on screen with vector data\r\nfunction ScreenVectorTile(layer, tilePoint, zoom) {\r\n    this.layer = layer;\r\n    this.tilePoint = tilePoint;\r\n    this.zoom = zoom;\r\n    this.gmx = layer._gmx;\r\n    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\r\n    var utils = gmxAPIutils;\r\n    this.worldWidthMerc = utils.worldWidthMerc;\r\n    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\r\n    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\r\n    this.tpx = 256 * gmxTilePoint.x;\r\n    this.tpy = 256 * (1 + gmxTilePoint.y);\r\n    this.gmxTilePoint = gmxTilePoint;\r\n\r\n    this.showRaster =\r\n        (zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx) ||\r\n        (zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx);\r\n    this.rasters = {}; //combined and processed canvases for each vector item in tile\r\n    this.rasterRequests = {};   // all cached raster requests\r\n    this.itemsView = [];   \t\t// items on screen tile + todo: without not visible\r\n    this._uniqueID = 0;         // draw attempt id\r\n    this.gmx.badTiles = this.gmx.badTiles || {};\r\n}\r\n\r\nScreenVectorTile.prototype = {\r\n\r\n    //return promise, which resolves with object {gtp, image}\r\n    _loadTileRecursive: function (gtp, urlFunction) {\r\n        var gmx = this.gmx,\r\n            _this = this,\r\n            requestPromise = null,\r\n            currentUrl,\r\n            def = new L.gmx.Deferred(function() {\r\n                if (requestPromise) {\r\n                    //don't store cancelled requests in request cache\r\n                    delete _this.rasterRequests[currentUrl];\r\n                    requestPromise.cancel();\r\n                }\r\n            });\r\n\r\n        var tryLoad = function(gtp, crossOrigin) {\r\n            var rUrl = urlFunction(gtp);\r\n\r\n            var tryHigherLevelTile = function() {\r\n                if (gtp.z > 1) {\r\n                    tryLoad({\r\n                        x: Math.floor(gtp.x / 2),\r\n                        y: Math.floor(gtp.y / 2),\r\n                        z: gtp.z - 1\r\n                    }, ''); // 'anonymous' 'use-credentials'\r\n                } else {\r\n                    def.reject();\r\n                }\r\n            };\r\n\r\n            if (gmx.badTiles[rUrl] || (gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z)) {\r\n                tryHigherLevelTile();\r\n                return;\r\n            }\r\n            var request = _this.rasterRequests[rUrl];\r\n            if (!request) {\r\n                if (gmx.rasterProcessingHook) {\r\n                    crossOrigin = 'anonymous';\r\n                }\r\n                request = L.gmx.imageLoader.push(rUrl, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    zoom: _this.zoom,\r\n                    cache: true,\r\n                    crossOrigin: crossOrigin || ''\r\n                });\r\n                _this.rasterRequests[rUrl] = request;\r\n            } else {\r\n                request.options.tileRastersId = _this._uniqueID;\r\n            }\r\n            currentUrl = rUrl;\r\n            requestPromise = request.def;\r\n\r\n            requestPromise.then(\r\n                function(imageObj) {\r\n                    def.resolve({gtp: gtp, image: imageObj});\r\n                },\r\n                function() {\r\n                    gmx.badTiles[rUrl] = true;\r\n                    tryHigherLevelTile();\r\n                }\r\n            );\r\n        };\r\n\r\n        tryLoad(gtp);\r\n        return def;\r\n    },\r\n\r\n    _rasterHook: function (attr) {\r\n        var source = attr.sourceTilePoint || attr.destinationTilePoint,\r\n            info = {\r\n                geoItem: attr.geoItem,\r\n                destination: {\r\n                    z: attr.destinationTilePoint.z,\r\n                    x: attr.destinationTilePoint.x,\r\n                    y: attr.destinationTilePoint.y\r\n                },\r\n                source: {\r\n                    z: source.z,\r\n                    x: source.x,\r\n                    y: source.y\r\n                }\r\n            };\r\n        if (attr.url) { info.quicklook = attr.url; }\r\n        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(\r\n            attr.res, attr.image,\r\n            attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256,\r\n            attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256,\r\n            info\r\n        );\r\n    },\r\n\r\n    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\r\n    _defaultRasterHook: function (res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n        var ptx = res.getContext('2d');\r\n        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    },\r\n\r\n    // get pixels parameters for shifted object\r\n    _getShiftPixels: function (it) {\r\n        var w = it.dx + (it.dx < 0 ? 256 : 0),\r\n            h = it.dy + (it.dy < 0 ? 256 : 0),\r\n            sx = 0, sw = 256 - w, dx = w, dw = sw;\r\n        if (it.tx > it.x) {\r\n            sx = sw; sw = w; dx = 0; dw = sw;\r\n        }\r\n        if (sx === 256 || sw < 1) { return null; }\r\n\r\n        var sy = h, sh = 256 - h, dy = 0, dh = sh;\r\n        if (it.ty > it.y) {\r\n            sy = 0; dy = sh; sh = h; dh = sh;\r\n        }\r\n        if (sy === 256 || sh < 1) { return null; }\r\n\r\n        return {\r\n            sx: sx, sy: sy, sw: sw, sh: sh,\r\n            dx: dx, dy: dy, dw: dw, dh: dh\r\n        };\r\n    },\r\n\r\n    // get tiles parameters for shifted object\r\n    _getShiftTilesArray: function (bounds, shiftX, shiftY) {\r\n        var mInPixel = this.gmx.mInPixel,\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            px = shiftX * mInPixel,\r\n            py = shiftY * mInPixel,\r\n            deltaX = Math.floor(0.5 + px % 256),            // shift on tile in pixel\r\n            deltaY = Math.floor(0.5 + py % 256),\r\n            tileSize = 256 / mInPixel,\r\n            tminX = gmxTilePoint.x - shiftX / tileSize,     // by screen tile\r\n            tminY = gmxTilePoint.y - shiftY / tileSize,\r\n            rminX = Math.floor(tminX),\r\n            rmaxX = rminX + (tminX === rminX ? 0 : 1),\r\n            rminY = Math.floor(tminY),\r\n            rmaxY = rminY + (tminY === rminY ? 0 : 1),\r\n            minX = Math.floor((bounds.min.x - shiftX) / tileSize),  // by geometry bounds\r\n            maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\r\n            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\r\n            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\r\n\r\n        if (rminX < minX) { rminX = minX; }\r\n        if (rmaxX > maxX) { rmaxX = maxX; }\r\n        if (rminY < minY) { rminY = minY; }\r\n        if (rmaxY > maxY) { rmaxY = maxY; }\r\n\r\n        var arr = [];\r\n        for (var j = rminY; j <= rmaxY; j++) {\r\n            for (var i = rminX; i <= rmaxX; i++) {\r\n                arr.push({\r\n                    z: gmxTilePoint.z,\r\n                    x: i,\r\n                    y: j,\r\n                    dx: deltaX,\r\n                    dy: deltaY,\r\n                    tx: tminX,\r\n                    ty: tminY\r\n                });\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    // Loads missing rasters for single item and combines them in canvas.\r\n    // Stores resulting canvas in this.rasters\r\n    _getItemRasters: function (geo) {\r\n        var properties = geo.properties,\r\n            idr = properties[0],\r\n            _this = this,\r\n            gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            rasters = this.rasters,\r\n            mainRasterLoader = null,\r\n            recursiveLoaders,\r\n            shiftX = Number(gmx.shiftXfield ? gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\r\n            shiftY = Number(gmx.shiftYfield ? gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\r\n            isShift = shiftX || shiftY,\r\n            urlBG = gmxAPIutils.getPropItem('urlBG', properties, indexes),\r\n            url = '',\r\n            itemImageProcessingHook = null,\r\n            isTiles = false,\r\n            item = gmx.dataManager.getItem(idr),\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            resCanvas = null,\r\n            imageItem = null;\r\n\r\n        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\r\n            isTiles = true;                     // Raster Layer\r\n        } else if (gmx.quicklookBGfunc) {\r\n            url = gmx.quicklookBGfunc(item);    // Quicklook\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        } else if (urlBG) {\r\n            url = urlBG;                        // Image urlBG from properties\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        }\r\n        if (isTiles) {\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                recursiveLoaders.forEach(function(it) {\r\n                    it.cancel();\r\n                });\r\n                recursiveLoaders = null;\r\n            });\r\n        } else {\r\n            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey;  //  for browser cache from another tabs\r\n            var request = this.rasterRequests[url];\r\n            if (!request) {\r\n                request = L.gmx.imageLoader.push(url, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    crossOrigin: gmx.crossOrigin || 'anonymous'\r\n                });\r\n                this.rasterRequests[url] = request;\r\n            } else {\r\n                request.options.tileRastersId = this._uniqueID;\r\n            }\r\n\r\n            // in fact, we want to return request.def, but need to do additional action during cancellation.\r\n            // so, we consctruct new promise and add pipe it with request.def\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                //don't cache cancelled requests\r\n                delete _this.rasterRequests[url];\r\n                request.def.cancel();\r\n            });\r\n            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\r\n        }\r\n        var itemRasterPromise = new L.gmx.Deferred(function() {\r\n            if (mainRasterLoader) {\r\n                mainRasterLoader.cancel();\r\n                mainRasterLoader = null;\r\n            }\r\n        });\r\n\r\n        if (isTiles) {\r\n            var dataOption = geo.dataOption || {},\r\n                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\r\n                cnt = tileToLoadPoints.length,\r\n                chkReadyRasters = function() {\r\n                    if (cnt < 1) { mainRasterLoader.resolve(); }\r\n                },\r\n                skipRasterFunc = function() {\r\n                    cnt--;\r\n                    chkReadyRasters();\r\n                },\r\n                urlFunction = function(gtp) {\r\n                    return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\r\n                },\r\n                onLoadFunction = function(gtp, p, img) {\r\n                    item.skipRasters = false;\r\n                    var isImage = true;\r\n\r\n                    if (itemImageProcessingHook) {\r\n                        img = itemImageProcessingHook(img, {\r\n                            gmx: gmx,\r\n                            geoItem: geo,\r\n                            item: item,\r\n                            gmxTilePoint: gtp\r\n                        });\r\n                        isImage = false;\r\n                    }\r\n\r\n                    var info = {\r\n                            geoItem: geo,\r\n                            image: img,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            sourceTilePoint: gtp,\r\n                            sx: 0, sy: 0, sw: 256, sh: 256,\r\n                            dx: 0, dy: 0, dw: 256, dh: 256\r\n                        };\r\n\r\n                    if (isShift) {\r\n                        var pos = _this._getShiftPixels(p);\r\n                        if (pos === null) {\r\n                            skipRasterFunc();\r\n                            return;\r\n                        }\r\n                        L.extend(info, pos);\r\n                        isImage = false;\r\n                    }\r\n\r\n                    if (gtp.z !== gmxTilePoint.z) {\r\n                        var posInfo = gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\r\n                        if (posInfo.size < 1 / 256) {// меньше 1px\r\n                            chkReadyRasters();\r\n                            return;\r\n                        }\r\n                        isImage = false;\r\n                        info.sx = Math.floor(posInfo.x);\r\n                        info.sy = Math.floor(posInfo.y);\r\n                        info.sw = info.sh = posInfo.size;\r\n                        if (isShift) {\r\n                            var sw = Math.floor(info.dw / posInfo.zDelta);\r\n                            info.sx = (info.dx === 0 ? info.sw : 256) - sw;\r\n                            info.sw = sw;\r\n\r\n                            var sh = Math.floor(info.dh / posInfo.zDelta);\r\n                            info.sy = (info.dy === 0 ? info.sh : 256) - sh;\r\n                            info.sh = sh;\r\n                        }\r\n                    }\r\n                    if (isImage && !gmx.rasterProcessingHook) {\r\n                        cnt--;\r\n                        resCanvas = img;\r\n                        chkReadyRasters();\r\n                    } else {\r\n                        if (!resCanvas) {\r\n                            resCanvas = document.createElement('canvas');\r\n                            resCanvas.width = resCanvas.height = 256;\r\n                        }\r\n                        info.res = resCanvas;\r\n                        var hookResult = _this._rasterHook(info),\r\n                            then = function() {\r\n                                cnt--;\r\n                                p.resImage = resCanvas;\r\n                                chkReadyRasters();\r\n                            };\r\n\r\n                        if (hookResult) {\r\n                            if (hookResult instanceof L.gmx.Deferred) {\r\n                                hookResult.then(then);\r\n                            }\r\n                        } else if (hookResult === null) {\r\n                            item.skipRasters = true;\r\n                            skipRasterFunc();\r\n                        } else {\r\n                            then();\r\n                        }\r\n                    }\r\n                };\r\n            recursiveLoaders = tileToLoadPoints.map(function(it) {\r\n                var loader = _this._loadTileRecursive(it, urlFunction);\r\n                loader.then(function(loadResult) {\r\n                    onLoadFunction(loadResult.gtp, it, loadResult.image);\r\n                }, skipRasterFunc);\r\n                return loader;\r\n            });\r\n\r\n            mainRasterLoader.then(function() {\r\n                rasters[idr] = resCanvas;\r\n                itemRasterPromise.resolve();\r\n            });\r\n        } else {\r\n            // for quicklook\r\n            item.skipRasters = false;\r\n            var imageLoaded = function(img) {\r\n                var imgAttr = {\r\n                    gmx: gmx,\r\n                    geoItem: geo,\r\n                    item: item,\r\n                    gmxTilePoint: gmxTilePoint\r\n                };\r\n                if (!resCanvas) {\r\n                    resCanvas = document.createElement('canvas');\r\n                    resCanvas.width = resCanvas.height = 256;\r\n                }\r\n                var prepareItem = function(imageElement) {\r\n                    var promise = _this._rasterHook({\r\n                            geoItem: geo,\r\n                            res: resCanvas,\r\n                            image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            url: url\r\n                        }),\r\n                        then = function() {\r\n                            rasters[idr] = resCanvas;\r\n                            itemRasterPromise.resolve();\r\n                        };\r\n                    if (promise) {\r\n                        if (promise instanceof L.gmx.Deferred) {\r\n                            promise.then(then);\r\n                        }\r\n                    } else if (promise === null) {\r\n                        item.skipRasters = true;\r\n                        itemRasterPromise.resolve();\r\n                    } else {\r\n                        then();\r\n                    }\r\n                };\r\n                prepareItem(img);\r\n                delete _this.rasterRequests[url];\r\n            };\r\n            if (imageItem) {\r\n                imageLoaded(imageItem);\r\n            } else {\r\n                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\r\n            }\r\n        }\r\n        itemRasterPromise.always(function() {\r\n            mainRasterLoader = null;\r\n            if (recursiveLoaders) {\r\n                recursiveLoaders = null;\r\n            }\r\n        });\r\n        return itemRasterPromise;\r\n    },\r\n\r\n    _getVisibleItems: function (geoItems) {\r\n        if (geoItems.length < 2) {\r\n\t\t\tthis.itemsView = geoItems;\r\n            return geoItems;\r\n        }\r\n        if (!gmxAPIutils._tileCanvas) {\r\n            gmxAPIutils._tileCanvas = document.createElement('canvas');\r\n            gmxAPIutils._tileCanvas.width = gmxAPIutils._tileCanvas.height = 256;\r\n        }\r\n        var i, len,\r\n            gmx = this.gmx,\r\n            dm = gmx.dataManager,\r\n            canvas = gmxAPIutils._tileCanvas,\r\n            ctx = canvas.getContext('2d'),\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        ctx.clearRect(0, 0, 256, 256);\r\n        ctx.imageSmoothingEnabled = false;\r\n        for (i = 0, len = geoItems.length; i < len; i++) {\r\n            ctx.fillStyle = gmxAPIutils.dec2rgba(i + 1, 1);\r\n            var geoItem = geoItems[i];\r\n            L.gmxUtil.drawGeoItem(\r\n                geoItem,\r\n                dm.getItem(geoItem.properties[0]),\r\n                dattr,\r\n                {fillStyle: ctx.fillStyle}\r\n            );\r\n        }\r\n        var items = {},\r\n            data = ctx.getImageData(0, 0, 256, 256).data;\r\n\r\n        for (i = 0, len = data.length; i < len; i += 4) {\r\n            if (data[i + 3] === 255) {\r\n                var color = data[i + 2];\r\n                if (data[i + 1]) { color += (data[i + 1] << 8); }\r\n                if (data[i]) { color += (data[i] << 16); }\r\n                if (color) { items[color] = true; }\r\n            }\r\n        }\r\n        var out = [];\r\n        for (var num in items) {\r\n            var it = geoItems[Number(num) - 1];\r\n            if (it) { out.push(it); }\r\n        }\r\n\t\tthis.itemsView = out;\r\n        return out;\r\n    },\r\n\r\n    _getNeedRasterItems: function (geoItems) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            tbounds = this.tbounds,\r\n            out = [];\r\n        for (var i = 0, len = geoItems.length; i < len; i++) {\r\n            var geo = geoItems[i],\r\n                properties = geo.properties,\r\n                idr = properties[0],\r\n                dataOption = geo.dataOption || {},\r\n                skipRasters = false;\r\n\r\n            if (gmx.quicklookBGfunc && !gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\r\n                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) { continue; }\r\n                var platform = gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\r\n                if ((!platform || platform === 'imageMercator') &&\r\n                    !gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)\r\n                ) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (gmx.styleHook) {\r\n                geo.styleExtend = gmx.styleHook(\r\n                    gmx.dataManager.getItem(idr),\r\n                    gmx.lastHover && idr === gmx.lastHover.id\r\n                );\r\n                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\r\n            }\r\n            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                out.push(geo);\r\n            }\r\n        }\r\n        return this._getVisibleItems(out);\r\n    },\r\n\r\n    _getTileRasters: function (geoItems) {   //load all missing rasters for items we are going to render\r\n        var itemPromises = [],\r\n            def = new L.gmx.Deferred(function() {\r\n                itemPromises.forEach(function(promise) {\r\n                    promise.cancel();\r\n                });\r\n                itemPromises = null;\r\n            }),\r\n            itemRasters = this._getNeedRasterItems(geoItems),\r\n            needLoadRasters = itemRasters.length;\r\n\r\n        if (needLoadRasters) {\r\n            var _this = this,\r\n                chkReadyRasters = function() {\r\n                    if (needLoadRasters < 1) {\r\n                        def.resolve();\r\n                    }\r\n                };\r\n            itemRasters.forEach(function (geo) {\r\n                var itemRasterPromise = _this._getItemRasters(geo);\r\n                itemRasterPromise.then(function() {\r\n                    needLoadRasters--;\r\n                    chkReadyRasters();\r\n                });\r\n                itemPromises.push(itemRasterPromise);\r\n            });\r\n        } else {\r\n            def.resolve();\r\n        }\r\n        return def;\r\n    },\r\n\r\n    _chkItems: function (data) {\r\n        var layer = this.layer;\r\n        if (!layer._map) {\r\n            return null;\r\n        }\r\n        var items = data && data.added && data.added.length ? data.added : null;\r\n\r\n        if (!items) {\r\n            var tLink = layer._tiles[this.zKey];\r\n            if (tLink && tLink.el) {\r\n                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\r\n            }\r\n            return null;\r\n        }\r\n        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\r\n    },\r\n\r\n    _cancelRastersPromise: function () {\r\n        if (this.rastersPromise) {\r\n            this.rastersPromise.cancel();\r\n            this.rastersPromise = null;\r\n        }\r\n    },\r\n\r\n    drawTile: function (data) {\r\n        var drawPromise = this.currentDrawPromise,\r\n            _this = this;\r\n\r\n        this._uniqueID++;       // count draw attempt\r\n\r\n        if (drawPromise) {\r\n            this._cancelRastersPromise();\r\n            if (this._preRenderPromise) {\r\n                this._preRenderPromise.cancel();        // cancel preRenderHooks chain if exists\r\n            }\r\n            if (this._renderPromise) {\r\n                this._renderPromise.cancel();           // cancel renderHooks chain if exists\r\n            }\r\n            drawPromise.reject();\r\n        }\r\n        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\r\n        drawPromise.always(function() {\r\n            _this._drawDone();\r\n            _this.currentDrawPromise = null;\r\n            _this.rastersPromise = null;\r\n            _this._preRenderPromise = null;\r\n            _this._renderPromise = null;\r\n        });\r\n\r\n        this.currentDrawPromise = drawPromise;\r\n\r\n        var geoItems = this._chkItems(data);\r\n        if (!geoItems) {\r\n            drawPromise.resolve();\r\n            return drawPromise;\r\n        }\r\n        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\r\n            tile = tileLink.el,\r\n            ctx = tile.getContext('2d'),\r\n            gmx = this.gmx,\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                rasters: this.rasters,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        tile.zKey = tileLink.el._zKey = this.zKey;\r\n\r\n        var doDraw = function() {\r\n            ctx.clearRect(0, 0, 256, 256);\r\n            var hookInfo = {\r\n                    tpx: _this.tpx,\r\n                    tpy: _this.tpy,\r\n                    x: _this.tilePoint.x,\r\n                    y: _this.tilePoint.y,\r\n                    z: _this.zoom\r\n                },\r\n                bgImage = null;\r\n\r\n            _this._preRenderPromise = new L.gmx.Deferred();\r\n            _this._preRenderPromise.resolve(bgImage);\r\n\r\n            gmx.preRenderHooks.forEach(function (f) {\r\n                _this._preRenderPromise = _this._preRenderPromise.then(function(hookBgImage) {\r\n\r\n                    //in-place modifications are possible\r\n                    bgImage = hookBgImage || bgImage;\r\n\r\n                    if (!bgImage) {\r\n                        bgImage = document.createElement('canvas');\r\n                        bgImage.width = bgImage.height = 256;\r\n                    }\r\n                    return f(bgImage, hookInfo);\r\n                });\r\n            });\r\n            _this._preRenderPromise.then(function(hookBgImage) {\r\n                bgImage = hookBgImage || bgImage;\r\n                if (bgImage) { dattr.bgImage = bgImage; }\r\n                //ctx.save();\r\n                for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                    var geoItem = geoItems[i],\r\n                        id = geoItem.id,\r\n                        item = gmx.dataManager.getItem(id);\r\n                    if (item) {     // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\r\n                        var style = gmx.styleManager.getObjStyle(item),\r\n                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\r\n\r\n                        if (gmx.multiFilters) {\r\n                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                                var it = item.multiFilters[j];\r\n                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\r\n                            }\r\n                        } else {\r\n                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\r\n                        }\r\n                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\r\n                            gmx._needPopups[id] = true;\r\n                        }\r\n                    }\r\n                }\r\n                //ctx.restore();\r\n                _this.rasters = {}; // clear rasters\r\n                if (_this.layer._map && !tile.parentNode) {\r\n                    _this.layer.appendTileToContainer(tile);\r\n                }\r\n                //async chain\r\n                _this._renderPromise = new L.gmx.Deferred();\r\n                _this._renderPromise.resolve(tile);\r\n                gmx.renderHooks.forEach(function (f) {\r\n                    _this._renderPromise = _this._renderPromise.then(function(hookTile) {\r\n                        tile = hookTile || tile;\r\n                        return f(tile, hookInfo);\r\n                    });\r\n                });\r\n                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\r\n            }, drawPromise.reject);\r\n        };\r\n\r\n        if (this.showRaster) {\r\n            this.rastersPromise = this._getTileRasters(geoItems);\r\n            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\r\n        } else {\r\n            doDraw();\r\n        }\r\n\r\n        return drawPromise;\r\n    },\r\n\r\n    destructor: function () {\r\n        this._cancelRastersPromise();\r\n        this._clearCache();\r\n\r\n        this.currentDrawPromise && this.currentDrawPromise.reject();\r\n    },\r\n\r\n    _drawDone: function () {\r\n        for (var url in this.rasterRequests) {\r\n            var req = this.rasterRequests[url];\r\n            if (this._uniqueID !== req.options.tileRastersId) {\r\n                req.remove();\r\n                delete this.rasterRequests[url];\r\n            }\r\n        }\r\n        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\r\n    },\r\n\r\n    _clearCache: function () {\r\n        for (var url in this.rasterRequests) {\r\n            this.rasterRequests[url].remove();\r\n        }\r\n        this.rasterRequests = {};\r\n    }\r\n};\r\nexport {ScreenVectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ScreenVectorTile.js","/*\r\n * ObjectsReorder  - Reorder objects in Gemixer layer\r\n */\r\n(function() {\r\n\r\nvar MAX = 1000000,\r\n    ObjectsReorder = function (layer) {\r\n        this.all = {};\r\n        this.userSetSortFunc = false;     // user sort func flag\r\n        this.sortFunc = null;\r\n        this.count = 0;\r\n        this.disabled = false;\r\n        this.layer = layer;\r\n        layer.on('add', this.onAdd, this);\r\n        layer.on('remove', this.onRemove, this);\r\n    };\r\n    ObjectsReorder.prototype = {\r\n        addToReorder: function (id, bottomFlag) {\r\n            ++this.count;\r\n            this.all[id] = bottomFlag ? -this.count : this.count;\r\n        },\r\n        clickFunc: function (ev) {\r\n            if (!this.disabled) {\r\n                var id = ev.gmx.id;\r\n                this.addToReorder(id, ev.originalEvent.ctrlKey);\r\n                this.layer.redrawItem(id);\r\n            }\r\n        },\r\n        sortItems: function(a, b) {     // layer context\r\n            var reorder = this._objectsReorder;\r\n            if (reorder.count > 0) {\r\n                var ap = reorder.all[a.id],\r\n                    bp = reorder.all[b.id];\r\n\r\n                if (ap || bp) {\r\n                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\r\n                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\r\n                    return ap - bp;\r\n                }\r\n            }\r\n            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\r\n        },\r\n        resetSortFunc: function () {\r\n            var layer = this.layer,\r\n                gmx = layer._gmx,\r\n                zIndexField = gmx.zIndexField;\r\n            gmx.sortItems = this.sortItems;\r\n            this.sortFunc = (zIndexField && !this.userSetSortFunc ?\r\n                function(a, b) {    // layer context\r\n                    var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\r\n                    return res ? res : a.id - b.id;\r\n                }\r\n                :\r\n                function(a, b) {\r\n                    return a.id - b.id;\r\n                }\r\n            );\r\n        },\r\n        initialize: function () {\r\n            var gmx = this.layer._gmx;\r\n            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\r\n                this.resetSortFunc();\r\n            }\r\n        },\r\n        onAdd: function () {\r\n            this.initialize();\r\n            this.layer.on('click', this.clickFunc, this);\r\n        },\r\n        onRemove: function () {\r\n            this.layer.off('click', this.clickFunc, this);\r\n        }\r\n    };\r\n\r\nL.gmx.VectorLayer.include({\r\n    _objectsReorder: null,\r\n\r\n    _objectsReorderInit: function () {\r\n        if (!this._objectsReorder) {\r\n            this._objectsReorder = new ObjectsReorder(this);\r\n        }\r\n    },\r\n\r\n    getReorderArrays: function () {\r\n        var out = {top: [], bottom: []};\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder,\r\n                arr = Object.keys(reorder.all).sort(function(a, b) {\r\n                    return reorder.all[a] - reorder.all[b];\r\n                });\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                if (reorder.all[id] > 0) {\r\n                    out.top.push(id);\r\n                } else {\r\n                    out.bottom.push(id);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    bringToTopItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    bringToBottomItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id, true);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    clearReorderArrays: function () {\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder;\r\n            reorder.all = {};\r\n            reorder.count = 0;\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    setReorderArrays: function (top, bottom) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.all = {};\r\n        reorder.count = 0;\r\n        bottom.forEach(function (id) { reorder.addToReorder(id, true); });\r\n        top.forEach(function (id) { reorder.addToReorder(id); });\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    getSortedItems: function (arr) {\r\n        this._objectsReorderInit();\r\n        return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\r\n    },\r\n\r\n    setSortFunc: function (func) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.sortFunc = func;\r\n        reorder.userSetSortFunc = func ? true : false;\r\n        this._gmx.sortItems = reorder.sortItems;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n    disableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = true;\r\n        return this;\r\n    },\r\n    enableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = false;\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ObjectsReorder.js","L.gmx.VectorLayer.include({\r\n    bindPopup: function (content, options) {\r\n        var popupOptions = L.extend({maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID}, options);\r\n\r\n        if (this._popup) { this.unbindPopup(); }\r\n        if (content instanceof L.Popup) {\r\n            this._popup = content;\r\n        } else {\r\n            if (!this._popup || options) {\r\n                this._popup = new L.Popup(popupOptions);\r\n            }\r\n            this._popup.setContent(content);\r\n        }\r\n        this._popup._initContent = content;\r\n        this._popup._state = '';\r\n\r\n        if (!this._popupHandlersAdded) {\r\n            this\r\n                .on('click', this._openClickPopup, this)\r\n                .on('mousemove', this._movePopup, this)\r\n                .on('mouseover', this._overPopup, this)\r\n                .on('mouseout', this._outPopup, this)\r\n                .on('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupHandlersAdded = true;\r\n        }\r\n        if (popupOptions && popupOptions.popupopen) {\r\n            this._popupopen = popupOptions.popupopen;\r\n        }\r\n\r\n        this._popup.updateLayout = this._popup._updateLayout;\r\n\r\n        return this;\r\n    },\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openClickPopup, this)\r\n                .off('mousemove', this._movePopup, this)\r\n\t\t\t    .off('mouseover', this._overPopup, this)\r\n                .off('mouseout', this._outPopup, this)\r\n                .off('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupopen = null;\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n        this._gmx.balloonEnable = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n    _chkNeedOpenPopup: function () {\r\n        for (var id in this._gmx._needPopups) {\r\n            if (this._gmx._needPopups[id]) {\r\n                this.addPopup(id);\r\n                delete this._gmx._needPopups[id];\r\n            }\r\n        }\r\n    },\r\n\r\n    disablePopup: function () {\r\n        this._popupDisabled = true;\r\n\t\treturn this;\r\n    },\r\n\r\n    enablePopup: function () {\r\n        this._popupDisabled = false;\r\n\t\treturn this;\r\n    },\r\n\r\n\topenPopup: function (latlng, options) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\toptions = options || {};\r\n            options.latlng = latlng;\r\n            this._openPopup(options);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n            this.fire('popupclose', {popup: this._popup});\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n    _movePopup: function (options) {\r\n        if (this._popup._state === 'mouseover') {\r\n            var id = this._popup.options._gmxID || -1;\r\n            if (id !== options.gmx.id) {\r\n                this._setPopupContent(options);\r\n            }\r\n            this._popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _overPopup: function (options) {\r\n        var _popup = this._popup;\r\n        if (!_popup._map) {\r\n            this._openPopup(options);\r\n        } else {\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: this._setPopupContent(options, _popup)\r\n            });\r\n        }\r\n        if (_popup._state === 'mouseover') {\r\n            _popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _outPopup: function (ev) {\r\n        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\r\n            this.closePopup();\r\n        }\r\n    },\r\n\r\n    _callBalloonHook: function (props, div) {\r\n\r\n        var spans = div.getElementsByTagName('span'),\r\n            hooksCount = {},\r\n            key, i, len;\r\n        for (key in this._balloonHook) {    // collect hook counts\r\n            var hookID = this._balloonHook[key].hookID;\r\n            hooksCount[key] = 0;\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                if (spans[i].id === hookID) {\r\n                    hooksCount[key]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (key in this._balloonHook) {\r\n            var hook = this._balloonHook[key],\r\n                fid = hook.hookID,\r\n                notFound = true;\r\n\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                var node = spans[i];\r\n                if (node.id === fid) {\r\n                    notFound = false;\r\n                    node.id += '_' + i;\r\n                    hook.callback(props, div, node, hooksCount);\r\n                }\r\n            }\r\n            if (notFound) {\r\n                hook.callback(props, div, null, hooksCount);\r\n            }\r\n        }\r\n    },\r\n\r\n    _setPopupContent: function (options, _popup) {\r\n        if (!_popup) { _popup = this._popup; }\r\n        var gmx = options.gmx || {},\r\n            balloonData = gmx.balloonData || {},\r\n            properties = L.extend({}, gmx.properties),\r\n            target = gmx.target || {},\r\n            geometry = target.geometry || {},\r\n            offset = target.offset,\r\n            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\r\n            type = options.type,\r\n            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\r\n            outItem = {\r\n                id: gmx.id,\r\n                type: type,\r\n                nodePoint: gmx.nodePoint,\r\n                latlng: options.latlng,\r\n                properties: properties,\r\n                templateBalloon: templateBalloon\r\n            };\r\n\r\n        if (geometry.type === 'POINT') {\r\n            var coord = geometry.coordinates;\r\n            outItem.latlng = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n        }\r\n        if (offset) {\r\n            var protoOffset = L.Popup.prototype.options.offset;\r\n            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\r\n        }\r\n\r\n        if (this._popupopen) {\r\n            this._popupopen({\r\n                popup: _popup,\r\n                latlng: outItem.latlng,\r\n                layerPoint: options.layerPoint,\r\n                contentNode: _popup._contentNode,\r\n                containerPoint: options.containerPoint,\r\n                originalEvent: options.originalEvent,\r\n                gmx: outItem\r\n            });\r\n        } else if (!(templateBalloon instanceof L.Popup)) {\r\n            if (!(templateBalloon instanceof HTMLElement)) {\r\n                var geometries,\r\n                    summary = '',\r\n                    unitOptions = this._map ? this._map.options : {};\r\n\r\n                if (!skipSummary) {\r\n                    geometries = target.geometry ? [target.geometry] : (gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || []);\r\n                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                if (this._balloonHook) {\r\n                    if (!templateBalloon) {\r\n                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\r\n                    }\r\n                    for (var key in this._balloonHook) {\r\n                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\r\n                    }\r\n                }\r\n                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\r\n                    properties: properties,\r\n                    tileAttributeTypes: this._gmx.tileAttributeTypes,\r\n                    unitOptions: unitOptions,\r\n                    summary: summary,\r\n                    geometries: geometries\r\n                });\r\n            }\r\n\r\n            var contentDiv = L.DomUtil.create('div', '');\r\n            contentDiv.innerHTML = templateBalloon;\r\n            _popup.setContent(contentDiv);\r\n            if (this._balloonHook) {\r\n                this._callBalloonHook(gmx.properties, _popup.getContent());\r\n            }\r\n            //outItem.templateBalloon = templateBalloon;\r\n        }\r\n        _popup.options._gmxID = gmx.id;\r\n        return outItem;\r\n    },\r\n\r\n    _openClickPopup: function (options) {\r\n        var originalEvent = options.originalEvent || {},\r\n            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                gmx = options.gmx,\r\n                balloonData = gmx.balloonData,\r\n                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\r\n                item = gmx.target;\r\n\r\n            if (flag && item.options.isGeneralized && !item.geometry) {\r\n                var layerProp = gmx.layer.getGmxProperties();\r\n                gmxAPIutils.getLayerItemFromServer({\r\n                    options: options,\r\n                    layerID: layerProp.name,\r\n                    value: item.id,\r\n                    field: layerProp.identityField\r\n                }).then(function(json, params) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        var pArr = json.Result.values[0];\r\n                        params.options.gmx.target.fromServerProps = pArr;\r\n                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\r\n                        this._openPopup(params.options);\r\n                    }\r\n                }.bind(this));\r\n            } else {\r\n                this._openPopup(options);\r\n            }\r\n        }\r\n    },\r\n\r\n    _openPopup: function (options, notSkip) {\r\n        var map = this._map,\r\n            originalEvent = options.originalEvent || {},\r\n            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                _popup = this._popup,\r\n                gmx = options.gmx || {},\r\n                balloonData = gmx.balloonData || {};\r\n\r\n            if (type === 'click') {\r\n                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) { return; }\r\n\r\n                if (!('_gmxPopups' in map)) {\r\n                    map._gmxPopups = [];\r\n                }\r\n                if (!('maxPopupCount' in map.options)) { map.options.maxPopupCount = 1; }\r\n                if (!this._gmx._gmxPopupsInit) {\r\n                    this._gmx._gmxPopupsInit = true;\r\n                    map.on({\r\n                        layerremove: function (ev) {\r\n                            if (ev.layer instanceof L.Popup) {\r\n                                this._clearPopup(ev.layer);\r\n                            } else if (ev.layer === this) {\r\n                                if (map._gmxPopups) {\r\n                                    var layerId = this._gmx.layerID;\r\n                                    map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                                        if (c._map) {\r\n                                            if (c.options.layerId === layerId) { c._map.removeLayer(c); }\r\n                                            else { p.push(c); }\r\n                                        }\r\n                                        return p;\r\n                                    }, []);\r\n                                }\r\n                                this.closePopup();\r\n                            }\r\n                        }\r\n                    }, this);\r\n                }\r\n\r\n                this._clearPopup(gmx.id);\r\n                var opt = this._popup ? this._popup.options : {maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID};\r\n                _popup = new L.Popup(L.extend({}, opt, {closeOnClick: map.options.maxPopupCount === 1, autoPan: true}));\r\n            } else if (type === 'mouseover') {\r\n                if (balloonData.DisableBalloonOnMouseMove) {\r\n                    _popup._state = '';\r\n                    return;\r\n                }\r\n                _popup.options.autoPan = false;\r\n            } else {\r\n                return;\r\n            }\r\n            _popup.options.objectId = gmx.id;\r\n            _popup._state = type;\r\n            var outItem = this._setPopupContent(options, _popup);\r\n            _popup.setLatLng(outItem.latlng);\r\n\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: outItem\r\n            });\r\n            if (type === 'click') {\r\n                if (map._gmxPopups.length >= map.options.maxPopupCount) {\r\n                    map.removeLayer(map._gmxPopups.shift());\r\n                }\r\n                map._gmxPopups.push(_popup);\r\n            }\r\n            _popup.addTo(map);    // this._map.openPopup(_popup);\r\n\r\n            if (_popup._closeButton) {\r\n                var closeStyle = _popup._closeButton.style;\r\n                if (type === 'mouseover' && closeStyle !== 'hidden') {\r\n                    closeStyle.visibility = 'hidden';\r\n                    _popup._container.style.marginBottom = '7px';\r\n                    _popup._container.style.pointerEvents = 'none';\r\n                } else if (type === 'click' && closeStyle !== 'inherit') {\r\n                    closeStyle.visibility = 'inherit';\r\n                    _popup._container.style.marginBottom = '';\r\n                    _popup._container.style.pointerEvents = '';\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\t_clearPopup: function (item /* <L.Popup> or objectId */) {\r\n        var map = this._map;\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID,\r\n                flagPopup = item instanceof L.Popup;\r\n            map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                if (c._map) {\r\n                    if (flagPopup && c === item) { c._map.removeLayer(c); }\r\n                    else if (c.options.layerId === layerId && c.options.objectId === item) { c._map.removeLayer(c); }\r\n                    else { p.push(c); }\r\n                }\r\n                return p;\r\n            }, []);\r\n        }\r\n    },\r\n\r\n    getPopups: function (flag) {\r\n        var map = this._map,\r\n            out = [];\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID;\r\n            map._gmxPopups.reduce(function(p, c) {\r\n                if (c.options.layerId === layerId) { p.push(flag ? c : c.options.objectId); }\r\n                return p;\r\n            }, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    addPopup: function (id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        if (!item || !this._map) {\r\n            gmx._needPopups[id] = false;\r\n        } else {\r\n            var center = item.bounds.getCenter(),\r\n                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\r\n            this._openPopup({\r\n                type: 'click',\r\n                latlng: latlng,\r\n                gmx: this.getHoverOption(item)\r\n            }, true);\r\n            delete gmx._needPopups[id];\r\n        }\r\n        return this;\r\n    },\r\n\r\n    addPopupHook: function (key, callback) {\r\n        if (!this._balloonHook) { this._balloonHook = {}; }\r\n        if (!this._balloonHook[key]) {\r\n            var hookID = '_' + L.stamp({});\r\n            this._balloonHook[key] = {\r\n                key: key,\r\n                hookID: hookID,\r\n                resStr: '<span id=\"' + hookID + '\"></span>',\r\n                callback: callback\r\n            };\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removePopupHook: function(key) {\r\n        if (this._balloonHook) { delete this._balloonHook[key]; }\r\n        return this;\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Popup.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nL.gmx.VectorLayer.include({\r\n    _gmxFirstObjectsByPoint: function (geoItems, mercPoint, bounds) {    // Получить верхний объект по координатам mouseClick\r\n        var gmx = this._gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            j,\r\n            len;\r\n\r\n        for (var i = geoItems.length - 1; i >= 0; i--) {\r\n            var geoItem = geoItems[i].properties,\r\n                idr = geoItem[0],\r\n                dataOption = geoItems[i].dataOption || {},\r\n                item = gmx.dataManager.getItem(idr),\r\n                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n                iconScale = currentStyle.iconScale || 1,\r\n                iconCenter = currentStyle.iconCenter,\r\n                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\r\n                parsedStyle = gmx.styleManager.getObjStyle(item),\r\n                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\r\n                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\r\n                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\r\n                offset = [\r\n                    iconScale * sx / 2,\r\n                    iconScale * sy / 2\r\n                ],\r\n                point = mercPoint,\r\n                geom = geoItem[geoItem.length - 1],\r\n                type = geom.type;\r\n\r\n            if (type === 'POINT' && parsedStyle.type === 'circle') {\r\n                offset[0] *= 2;\r\n                offset[1] *= 2;\r\n            }\r\n            var radius = offset[0],\r\n                objBounds = gmxAPIutils.bounds()\r\n                    .extendBounds(dataOption.bounds)\r\n                    .addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n            if (iconAnchor) {\r\n                offset = [\r\n                    iconAnchor[0] - offset[0],\r\n                    iconAnchor[1] - offset[1]\r\n                ];\r\n                point = [\r\n                    mercPoint[0] + offset[0] / mInPixel,\r\n                    mercPoint[1] - offset[1] / mInPixel\r\n                ];\r\n            }\r\n            if (!objBounds.contains(point)) { continue; }\r\n\r\n            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\r\n                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\r\n                chktype = type,\r\n                hiddenLines = dataOption.hiddenLines || [],\r\n                boundsArr = dataOption.boundsArr,\r\n                coords = geom.coordinates,\r\n                nodePoint = null,\r\n                ph = {\r\n                    point: mercPoint,\r\n                    bounds: bounds,\r\n                    coords: coords,\r\n                    boundsArr: boundsArr\r\n                };\r\n\r\n            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\r\n                if (marker) {\r\n                    chktype = 'POINT';\r\n                } else if (!fill) {\r\n                    if (type === 'POLYGON') {\r\n                        chktype = 'MULTILINESTRING';\r\n                        hiddenLines = hiddenLines[0];\r\n                    } else {\r\n                        chktype = 'LIKEMULTILINESTRING';\r\n                    }\r\n                    ph.hidden = hiddenLines;\r\n                }\r\n            }\r\n\r\n            if (chktype === 'LINESTRING') {\r\n                if (!gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\r\n                    nodePoint = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'LIKEMULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                var flag = false;\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    ph.coords = coords[j];\r\n                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\r\n                    ph.boundsArr = boundsArr[j];\r\n                    if (gmxAPIutils.isPointInLines(ph)) {\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'MULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                ph.hidden = hiddenLines;\r\n                if (!gmxAPIutils.isPointInLines(ph)) {\r\n                    var pBounds = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n                    for (j = 0, len = coords.length; j < len; j++) {\r\n                        nodePoint = pBounds.isNodeIntersect(coords[j]);\r\n                        if (nodePoint !== null) {\r\n                            nodePoint.ring = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\r\n                var chkPoint = mercPoint;\r\n                flag = false;\r\n                if (chktype === 'POLYGON') {\r\n                    coords = [geom.coordinates];\r\n                    boundsArr = [dataOption.boundsArr];\r\n                }\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    var arr = coords[j],\r\n                        bbox = boundsArr[j];\r\n                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\r\n                        var b = bbox[j1];\r\n                        if (b.intersects(bounds)) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\r\n                                flag = j1 === 0 ? true : false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'POINT') {\r\n                if (parsedStyle.type === 'circle') {\r\n                    var x = (coords[0] - point[0]) * mInPixel,\r\n                        y = (coords[1] - point[1]) * mInPixel;\r\n                    if (x * x + y * y > radius * radius) { continue; }\r\n                }\r\n            }\r\n            if (!this.isPointInClipPolygons(mercPoint)) {\r\n                continue;\r\n            }\r\n\r\n            return {\r\n                id: idr,\r\n                properties: item.properties,\r\n                geometry: geom,\r\n                bounds: item.bounds,\r\n                nodePoint: nodePoint,\r\n                offset: iconAnchor ? offset : null,\r\n                parsedStyle: parsedStyle\r\n            };\r\n        }\r\n        return null;\r\n    },\r\n\r\n    gmxEventCheck: function (ev, skipOver) {\r\n        if (!this._map) {\r\n            return 0;\r\n        }\r\n        var layer = this,\r\n            gmx = layer._gmx,\r\n            type = ev.type,\r\n            lastHover = gmx.lastHover,\r\n            chkHover = function (evType) {\r\n                if (lastHover && type === 'mousemove') {\r\n                    if (evType && layer.hasEventListeners(evType)) {\r\n                        ev.gmx = lastHover;\r\n                        layer.fire(evType, ev);\r\n                    }\r\n                    if (lastHover.hoverDiff) { layer.redrawItem(lastHover.id); }\r\n                }\r\n            };\r\n\r\n        var zoom = this._map.getZoom();\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            skipOver = true;\r\n        }\r\n        if (skipOver) {\r\n            if (lastHover) { lastHover.prevId = null; }\r\n            chkHover('mouseout');\r\n            gmx.lastHover = null;\r\n        } else if (\r\n            this.hasEventListeners('mouseover') ||\r\n            this.hasEventListeners('mouseout') ||\r\n            this.hasEventListeners(type) ||\r\n            (type === 'mousemove' && gmx.properties.fromType !== 'Raster')\r\n            ) {\r\n\r\n            var lng = ev.latlng.lng % 360,\r\n                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : (lng > 180 ? -360 : 0))),\r\n                point = L.Projection.Mercator.project(latlng)._subtract(\r\n                    {x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0}\r\n                ),\r\n                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\r\n                mercatorPoint = [point.x, point.y];\r\n\r\n            //создаём observer только для того, чтобы сделать выборку данных вокруг курсора\r\n            var observerOptions = {\r\n                type: 'resend',\r\n                bbox: gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\r\n                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\r\n                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                active: false //делаем его неактивным, так как потом будем явно выбирать данные\r\n            };\r\n            if (this.options.isGeneralized) {\r\n                observerOptions.targetZoom = zoom;\r\n            }\r\n\r\n            gmx.dataManager.addObserver(observerOptions, 'hover');\r\n\r\n            var geoItems = gmx.dataManager.getItems('hover');\r\n\r\n            gmx.dataManager.removeObserver('hover');\r\n\r\n            if (geoItems && geoItems.length) {\r\n                if (geoItems.length > 1 && gmx.sortItems) { geoItems = this.getSortedItems(geoItems); }\r\n\r\n                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\r\n                if (target) {\r\n                    var idr = target.id,\r\n                        item = gmx.dataManager.getItem(idr),\r\n                        prevId = lastHover ? lastHover.id : null,\r\n                        changed = !lastHover || lastHover.id !== idr;\r\n                    if (type === 'mousemove' && lastHover) {\r\n                        if (!changed) {\r\n                            ev.gmx = lastHover;\r\n                            this.fire(type, ev);\r\n                            return idr;\r\n                        }\r\n                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\r\n                        gmx.lastHover = null;\r\n                    }\r\n\r\n                    ev.gmx = L.extend(this.getHoverOption(item), {\r\n                        targets: geoItems,\r\n                        nodePoint: target.nodePoint,\r\n                        prevId: prevId,\r\n                        hoverDiff: item.hoverDiff\r\n                    });\r\n                    if (this.hasEventListeners(type)) { this.fire(type, ev); }\r\n                    if (type === 'mousemove' && changed) {\r\n                        lastHover = gmx.lastHover = ev.gmx;\r\n                        chkHover('mouseover');\r\n                        gmx.lastMouseover = gmx.lastHover;\r\n                    }\r\n                    this._map.doubleClickZoom.disable();\r\n                    return idr;\r\n                }\r\n            }\r\n        }\r\n        if (this._map) {\r\n            this._map.doubleClickZoom.enable();\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    getHoverOption: function (item) {\r\n        return {\r\n            layer: this,\r\n            target: item,\r\n            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\r\n            properties: this.getItemProperties(item.properties),\r\n            currentFilter: item.currentFilter || 0,\r\n            id: item.id\r\n        };\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Hover.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n(function() {\r\nvar delay = 20000,\r\n    layers = {},\r\n    dataManagersLinks = {},\r\n    script = '/Layer/CheckVersion.ashx',\r\n    intervalID = null,\r\n    timeoutID = null,\r\n    lastLayersStr = '';\r\n\r\nvar isExistsTiles = function(prop) {\r\n    var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\r\n    return tilesKey in prop;\r\n};\r\nvar getParams = function(prop, dm, layerDateInterval) {\r\n    var pt = {\r\n        Name: prop.name,\r\n        Version: isExistsTiles(prop) ? prop.LayerVersion : -1\r\n    };\r\n\tif (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\r\n\t\tvar maxDateInterval = dm.getMaxDateInterval(),\r\n\t\t\tbeginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\r\n\t\t\tendDate = maxDateInterval.endDate || layerDateInterval.endDate;\r\n        if (beginDate) { pt.dateBegin = Math.floor(beginDate.getTime() / 1000); }\r\n        if (endDate) { pt.dateEnd = Math.floor(endDate.getTime() / 1000); }\r\n    }\r\n    return pt;\r\n};\r\nvar getRequestParams = function(layer) {\r\n    var hosts = {},\r\n        prop, hostName, dm, layerDateInterval;\r\n    if (layer) {\r\n        if (layer instanceof L.gmx.DataManager) {\r\n\t\t\tdm = layer;\r\n\t\t\tprop = dm.options;\r\n\t\t} else {\r\n\t\t\tprop = layer._gmx.properties;\r\n\t\t\tdm = layer._gmx.dataManager;\r\n\t\t\tlayerDateInterval = layer._gmx;\r\n\t\t}\r\n        hostName = prop.hostName || layer._gmx.hostName;\r\n\t\thosts[hostName] = [getParams(prop, dm, layerDateInterval)];\r\n    } else {\r\n        var skipItems = {};\r\n        for (var id in layers) {\r\n            var obj = layers[id],\r\n\t\t\t\tisDataManager = obj instanceof L.gmx.DataManager;\r\n            if (obj.options.chkUpdate || isDataManager) {\r\n\t\t\t\tdm = isDataManager ? obj : obj._gmx.dataManager;\r\n                prop = isDataManager ? obj.options : obj._gmx.properties;\r\n\t\t\t\tlayerDateInterval = isDataManager ? obj : obj._gmx;\r\n                hostName = prop.hostName || obj._gmx.hostName;\r\n                var pt = getParams(prop, dm, layerDateInterval),\r\n                    key = pt.Name + pt.Version;\r\n                if (!skipItems[key]) {\r\n                    if (hosts[hostName]) { hosts[hostName].push(pt); }\r\n                    else { hosts[hostName] = [pt]; }\r\n                }\r\n                skipItems[key] = true;\r\n            }\r\n        }\r\n    }\r\n    return hosts;\r\n};\r\n\r\nvar chkVersion = function (layer, callback) {\r\n    var processResponse = function(res) {\r\n        if (res && res.Status === 'ok' && res.Result) {\r\n            for (var i = 0, len = res.Result.length; i < len; i++) {\r\n                var item = res.Result[i],\r\n                    id = item.properties.name;\r\n\r\n\t\t\t\tif (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) { layer.updateVersion(item); }\r\n                for (var key in layers) {\r\n                    var curLayer = layers[key];\r\n\t\t\t\t\tif (layer && layer === curLayer) { continue; }\r\n                    if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\t// слои\r\n\t\t\t\t\t\tcurLayer.updateVersion(item);\r\n\t\t\t\t\t} else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\t// источники данных\r\n\t\t\t\t\t\tcurLayer.updateVersion(item.properties);\r\n\t\t\t\t\t}\r\n                }\r\n            }\r\n        }\r\n        lastLayersStr = '';\r\n        if (callback) { callback(res); }\r\n    };\r\n\r\n    if (document.body && !gmxAPIutils.isPageHidden()) {\r\n        var hosts = getRequestParams(layer),\r\n            chkHost = function(hostName) {\r\n                var url = 'http://' + hostName + script,\r\n                    layersStr = JSON.stringify(hosts[hostName]);\r\n\r\n                if (lastLayersStr !== layersStr) {\r\n                    lastLayersStr = layersStr;\r\n                    if ('FormData' in window) {\r\n                        gmxAPIutils.request({\r\n                            url: url,\r\n                            async: true,\r\n                            headers: {\r\n                                'Content-type': 'application/x-www-form-urlencoded'\r\n                            },\r\n                            type: 'POST',\r\n                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\r\n                            withCredentials: true,\r\n                            callback: function(response) {\r\n                                processResponse(JSON.parse(response));\r\n                            },\r\n                            onError: function(response) {\r\n                                console.log('Error: LayerVersion ', response);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        gmxAPIutils.sendCrossDomainPostRequest(url, {\r\n                            WrapStyle: 'message',\r\n                            layers: layersStr\r\n                        }, processResponse);\r\n                    }\r\n                    var timeStamp = Date.now();\r\n                    for (var key in layers) {\r\n                        var it = layers[key];\r\n                        var options = it._gmx || it.options;\r\n                        if (options.hostName === hostName) { options._stampVersionRequest = timeStamp; }\r\n                    }\r\n                }\r\n            };\r\n        for (var hostName in hosts) {\r\n            chkHost(hostName);\r\n        }\r\n    }\r\n};\r\n\r\nvar layersVersion = {\r\n\r\n    addDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\t\tdataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\tlayers[id] = dataManager;\r\n    },\r\n\r\n    removeDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n\t\t\tdataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\t\tdelete layers[id];\r\n\t\t}\r\n    },\r\n\r\n    remove: function(layer) {\r\n        delete layers[layer._leaflet_id];\r\n        var _gmx = layer._gmx,\r\n\t\t\tpOptions = layer.options.parentOptions;\r\n\t\tif (pOptions) {\r\n\t\t\tvar pId = pOptions.name;\r\n\t\t\tif (dataManagersLinks[pId]) {\r\n\t\t\t\tdelete dataManagersLinks[pId][_gmx.properties.name];\r\n\t\t\t\tif (!Object.keys(dataManagersLinks[pId]).length) {\r\n\t\t\t\t\tlayersVersion.removeDataManager(_gmx.dataManager);\r\n\t\t\t\t\tdelete dataManagersLinks[pId];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t}\r\n    },\r\n\r\n    add: function(layer) {\r\n        var id = layer._leaflet_id;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\r\n        var _gmx = layer._gmx,\r\n            prop = _gmx.properties;\r\n        if ('LayerVersion' in prop) {\r\n            layers[id] = layer;\r\n            _gmx._chkVersion = function () {\r\n                chkVersion(layer);\r\n            };\r\n            _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t\tvar pOptions = layer.options.parentOptions;\r\n\t\t\tif (pOptions) {\r\n\t\t\t\tvar pId = pOptions.name;\r\n\t\t\t\tlayersVersion.addDataManager(_gmx.dataManager);\r\n\t\t\t\tif (!dataManagersLinks[pId]) { dataManagersLinks[pId] = {}; }\r\n\t\t\t\tdataManagersLinks[pId][prop.name] = layer;\r\n\t\t\t}\r\n\r\n            layersVersion.start();\r\n            if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\r\n\t\t\t\tlayersVersion.now();\r\n            }\r\n        }\r\n    },\r\n\r\n    chkVersion: chkVersion,\r\n\r\n    now: function() {\r\n\t\tif (timeoutID) { clearTimeout(timeoutID); }\r\n\t\ttimeoutID = setTimeout(chkVersion, 0);\r\n    },\r\n\r\n    stop: function() {\r\n        if (intervalID) { clearInterval(intervalID); }\r\n        intervalID = null;\r\n    },\r\n\r\n    start: function(msec) {\r\n        if (msec) { delay = msec; }\r\n        layersVersion.stop();\r\n        intervalID = setInterval(chkVersion, delay);\r\n    }\r\n};\r\n\r\nif (!L.gmx) { L.gmx = {}; }\r\nL.gmx.layersVersion = layersVersion;\r\n\r\nL.gmx.VectorLayer.include({\r\n    updateVersion: function (layerDescription) {\r\n        if (layerDescription) {\r\n            var gmx = this._gmx;\r\n            if (layerDescription.geometry) {\r\n                gmx.geometry = layerDescription.geometry;\r\n            }\r\n            if (layerDescription.properties) {\r\n                L.extend(gmx.properties, layerDescription.properties);\r\n                gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\r\n                gmx.rawProperties = gmx.properties;\r\n                this.fire('versionchange');\r\n\t\t\t\tif (!gmx.dataSource) {\r\n\t\t\t\t\tgmx.dataManager.updateVersion(gmx.rawProperties);\r\n\t\t\t\t}\r\n            }\r\n        }\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LayersVersion.js","//Raster layer is just vector layer with the single object and special background tiles\r\nL.gmx.RasterLayer = L.gmx.VectorLayer.extend(\r\n{\r\n    options: {\r\n        isGeneralized: false,\r\n        zIndexOffset: 0\r\n        //clickable: false\r\n    },\r\n    initFromDescription: function(ph) {\r\n        var props = ph.properties,\r\n            styles = props.styles[0] || {MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21},\r\n            vectorProperties = {\r\n                type: 'Vector',\r\n                fromType: props.type,\r\n                identityField: 'ogc_fid',\r\n                GeometryType: 'POLYGON',\r\n                IsRasterCatalog: true,\r\n                Copyright: props.Copyright || '',\r\n                RCMinZoomForRasters: styles.MinZoom,\r\n                visible: props.visible,\r\n                styles: [{\r\n                    DisableBalloonOnClick: true,\r\n                    MinZoom: styles.MinZoom,\r\n                    MaxZoom: styles.MaxZoom,\r\n                    RenderStyle: {outline: {thickness: 0}, fill: {opacity: 100}},\r\n                    HoverStyle: null\r\n                }]\r\n            },\r\n            gmx = this._gmx,\r\n            worldSize = gmxAPIutils.tileSizes[1];\r\n\r\n        if (props.MaxZoom) {\r\n            gmx.maxNativeZoom = props.MaxZoom;\r\n        }\r\n        if (!ph.geometry) {\r\n            ph.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n\t\tL.gmx.VectorLayer.prototype.initFromDescription.call(this, {geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties});\r\n\r\n        gmx.rasterBGfunc = function(x, y, z) {\r\n\t\t\treturn 'http://' + gmx.hostName + '/' +\r\n\t\t\t\t'TileSender.ashx?ModeKey=tile' +\r\n\t\t\t\t'&key=' + encodeURIComponent(gmx.sessionKey) +\r\n\t\t\t\t'&LayerName=' + gmx.layerID +\r\n\t\t\t\t'&z=' + z +\r\n\t\t\t\t'&x=' + x +\r\n\t\t\t\t'&y=' + y;\r\n\t\t};\r\n\r\n\t\tvar vectorDataProvider = {load: function(x, y, z, v, s, d, callback) {\r\n            var objects = [[777, ph.geometry]],\r\n                itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\r\n                bounds = itemBounds.bounds;\r\n\r\n            if (bounds.max.x > worldSize) {\r\n                // for old layers geometry\r\n                var ww2 = 2 * worldSize,\r\n                    id = 777,\r\n                    coords = ph.geometry.coordinates,\r\n                    bboxArr = itemBounds.boundsArr;\r\n\r\n                objects = [];\r\n                if (ph.geometry.type === 'POLYGON') {\r\n                    coords = [coords];\r\n                    bboxArr = [bboxArr];\r\n                }\r\n\r\n                for (var i = 0, len = coords.length; i < len; i++) {\r\n                    var it = coords[i],\r\n                        bbox = bboxArr[i][0],\r\n                        arr = it;\r\n                    objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    if (bbox.max.x > worldSize) {\r\n                        arr = [];\r\n                        for (var j = 0, len1 = it.length; j < len1; j++) {\r\n                            var it1 = it[j];\r\n                            for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\r\n                                var it2 = it1[j1];\r\n                                arr1.push([it2[0] - ww2, it2[1]]);\r\n                            }\r\n                            arr.push(arr1);\r\n                        }\r\n                        objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    }\r\n                }\r\n            }\r\n\t\t\tcallback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\r\n\t\t}};\r\n\t\tgmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, {x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2});\r\n\t\tgmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\r\n\r\n        return this;\r\n    },\r\n\r\n    setZoomBounds: function(minZoom, maxZoom) {\r\n        var styles = this.getStyles().slice(0);\r\n        styles[0] = L.extend({}, styles[0]);\r\n        styles[0].MinZoom = minZoom;\r\n        styles[0].MaxZoom = maxZoom;\r\n        this.setStyles(styles);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/RasterLayer.js","/*\r\n (c) 2014, Sergey Alekseev\r\n Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n*/\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nL.LabelsLayer = L.Class.extend({\r\n\r\n    options: {\r\n        pane: 'overlayPane'\r\n    },\r\n\r\n    initialize: function (map, options) {\r\n        L.setOptions(this, options);\r\n        this._observers = {};\r\n        this._styleManagers = {};\r\n        this._labels = {};\r\n        var _this = this;\r\n\r\n        this.bbox = gmxAPIutils.bounds();\r\n\r\n        var chkData = function (data, layer) {\r\n            if (!data.added && !data.removed) { return; }\r\n\r\n            var opt = layer.options,\r\n                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\r\n                layerId = '_' + layer._leaflet_id,\r\n                gmx = layer._gmx,\r\n                labels = {};\r\n\r\n            for (var i = 0, len = added.length; i < len; i++) {\r\n                var item = added[i].item,\r\n                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\r\n                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\r\n\r\n                if (gmx.styleHook) {\r\n                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\r\n                    if (styleExtend) {\r\n                        currentStyle = L.extend({}, currentStyle, styleExtend);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (item.multiFilters) {\r\n                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                        var st = item.multiFilters[j].parsedStyle;\r\n                        if ('labelField' in st || 'labelText' in st) {\r\n                            currentStyle = st;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                var style = gmx.styleManager.getObjStyle(item) || {},\r\n                    labelText = currentStyle.labelText || style.labelText,\r\n                    labelField = currentStyle.labelField || style.labelField,\r\n                    fieldType = gmx.tileAttributeTypes[labelField],\r\n                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\r\n\r\n                if (style.labelTemplate) {\r\n\t\t\t\t\tvar reg = /\\[([^\\]]*)\\]/g,\r\n\t\t\t\t\t\tmatch;\r\n\t\t\t\t\ttxt = style.labelTemplate;\r\n\r\n\t\t\t\t\twhile ((match = reg.exec(style.labelTemplate))) {\r\n\t\t\t\t\t\tif (match.length === 2) {\r\n\t\t\t\t\t\t\tlabelField = match[1];\r\n\t\t\t\t\t\t\tfieldType = gmx.tileAttributeTypes[labelField];\r\n\t\t\t\t\t\t\tvar val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\r\n\t\t\t\t\t\t\ttxt = txt.replace(match[0], val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                }\r\n\t\t\t\tif (txt || txt === 0) {\r\n                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\r\n                        id = '_' + item.id,\r\n                        changed = true,\r\n                        width = 0,\r\n\t\t\t\t\t\tarrTxtWidth,\r\n                        options = item.options,\r\n                        labelStyle = {\r\n                            font: fontSize + 'px \"Arial\"',\r\n                            labelHaloColor: ('labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : ('labelHaloColor' in style ? style.labelHaloColor : 0xffffff)),\r\n                            labelColor: currentStyle.labelColor || style.labelColor,\r\n                            labelAlign: currentStyle.labelAlign || style.labelAlign,\r\n                            labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\r\n                            labelFontSize: fontSize\r\n                        };\r\n                    if (options) {\r\n                        if (!('center' in options)) {\r\n                            var center = gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\r\n                            if (!center) { continue; }\r\n                            options.center = center;\r\n                        }\r\n                        if (options.label) {\r\n                            width = options.label.width;\r\n                            arrTxtWidth = options.label.arrTxtWidth;\r\n                            var pstyle = options.label.style;\r\n                            changed = options.label.txt !== txt ||\r\n                                pstyle.labelHaloColor !== labelStyle.labelHaloColor ||\r\n                                pstyle.labelColor !== labelStyle.labelColor ||\r\n                                pstyle.labelAlign !== labelStyle.labelAlign ||\r\n                                pstyle.labelAnchor !== labelStyle.labelAnchor ||\r\n                                pstyle.labelFontSize !== labelStyle.labelFontSize;\r\n                        }\r\n                    }\r\n                    if (changed) {\r\n\t\t\t\t\t\twidth = 0;\r\n                        arrTxtWidth = gmxAPIutils.getLabelWidth(txt, labelStyle);\r\n\t\t\t\t\t\tif (arrTxtWidth) {\r\n\t\t\t\t\t\t    arrTxtWidth.forEach(function(it) {\r\n\t\t\t\t\t\t\t\twidth = Math.max(width, it[1]);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n                        if (!width) {\r\n                            delete labels[id];\r\n                            continue;\r\n                        }\r\n                        width += 4;\r\n                        item.options.labelStyle = null;\r\n                    }\r\n                    options.label = {\r\n                        isPoint: isPoint,\r\n                        width: width,\r\n                        sx: style.sx || 0,\r\n                        txt: txt,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        style: labelStyle\r\n                    };\r\n                    labels[id] = item;\r\n                }\r\n            }\r\n            _this._labels[layerId] = labels;\r\n        };\r\n\r\n        var addObserver = function (layer) {\r\n            var gmx = layer._gmx,\r\n                filters = ['styleFilter', 'userFilter'],\r\n                options = {\r\n                    type: 'resend',\r\n                    bbox: _this.bbox,\r\n                    filters: filters,\r\n                    callback: function(data) {\r\n                        chkData(data, layer);\r\n                        _this.redraw();\r\n                    }\r\n                };\r\n            if (gmx.beginDate && gmx.endDate) {\r\n                options.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n            return gmx.dataManager.addObserver(options, '_Labels');\r\n        };\r\n        this.add = function (layer) {\r\n            var id = layer._leaflet_id,\r\n                gmx = layer._gmx;\r\n\r\n            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\r\n                gmx.styleManager.deferred.then(function () {\r\n                    var observer = addObserver(layer),\r\n\t\t\t\t\t\t_zoom = _this._map._zoom;\r\n                    if (layer.options.isGeneralized) {\r\n                        observer.targetZoom = _zoom;\t//need update to current zoom\r\n                    }\r\n                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\r\n                        observer.deactivate();\r\n                    }\r\n                    _this._observers[id] = observer;\r\n                    _this._styleManagers[id] = gmx.styleManager;\r\n\r\n                    _this._labels['_' + id] = {};\r\n                    _this._updateBbox();\r\n                });\r\n            }\r\n        };\r\n        this.remove = function (layer) {\r\n            var id = layer._leaflet_id;\r\n            if (_this._observers[id]) {\r\n                var gmx = layer._gmx,\r\n                    dataManager = gmx.dataManager;\r\n                dataManager.removeObserver(_this._observers[id].id);\r\n                delete _this._observers[id];\r\n                delete _this._styleManagers[id];\r\n                delete _this._labels['_' + id];\r\n                _this.redraw();\r\n            }\r\n        };\r\n        this._layeradd = function (ev) {\r\n            _this.add(ev.layer);\r\n        };\r\n        this._layerremove = function (ev) {\r\n            _this.remove(ev.layer);\r\n        };\r\n    },\r\n\r\n    redraw: function () {\r\n        if (!this._frame && !this._map._animating) {\r\n            this._frame = L.Util.requestAnimFrame(this._redraw, this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    _addToPane: function () {\r\n        var pane = this._map.getPanes()[this.options.pane];\r\n        if (pane) {\r\n            pane.insertBefore(this._canvas, pane.firstChild);\r\n        }\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n\r\n        if (!this._canvas) {\r\n            this._initCanvas();\r\n        }\r\n        // this._addToPane();\r\n\r\n        map.on('moveend', this._reset, this);\r\n        map.on({\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        });\r\n        if (map.options.zoomAnimation && L.Browser.any3d) {\r\n            map.on('zoomanim', this._animateZoom, this);\r\n        }\r\n\r\n        this._reset();\r\n    },\r\n\r\n    onRemove: function (map) {\r\n        if (this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n\r\n        map.off('moveend', this._reset, this);\r\n        map.off('layeradd', this._layeradd);\r\n        map.off('layerremove', this._layerremove);\r\n\r\n        if (map.options.zoomAnimation) {\r\n            map.off('zoomanim', this._animateZoom, this);\r\n        }\r\n    },\r\n\r\n    addTo: function (map) {\r\n        map.addLayer(this);\r\n        return this;\r\n    },\r\n\r\n    _initCanvas: function () {\r\n        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\r\n            size = this._map.getSize();\r\n        canvas.width  = size.x; canvas.height = size.y;\r\n        canvas.style.pointerEvents = 'none';\r\n        this._canvas = canvas;\r\n\r\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\r\n        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\r\n    },\r\n\r\n    _updateBbox: function () {\r\n        var _map = this._map,\r\n            screenBounds = _map.getBounds(),\r\n            southWest = screenBounds.getSouthWest(),\r\n            northEast = screenBounds.getNorthEast(),\r\n            m1 = L.Projection.Mercator.project(southWest),\r\n            m2 = L.Projection.Mercator.project(northEast),\r\n\t\t\t_zoom = _map.getZoom();\r\n\r\n        this.mInPixel = gmxAPIutils.getPixelScale(_zoom);\r\n        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\r\n        for (var id in this._observers) {\r\n\t\t\tvar observer = this._observers[id];\r\n\t\t\tif (observer.targetZoom) {\r\n\t\t\t\tobserver.targetZoom = _zoom;\r\n\t\t\t}\r\n            observer.setBounds({\r\n                min: {x: southWest.lng, y: southWest.lat},\r\n                max: {x: northEast.lng, y: northEast.lat}\r\n            });\r\n        }\r\n    },\r\n\r\n    _reset: function () {\r\n        this._updateBbox();\r\n        for (var id in this._observers) {\r\n            var observer = this._observers[id];\r\n            if (!observer.isActive() &&\r\n                this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())\r\n            ) {\r\n                observer.activate();\r\n            }\r\n            observer.fire('update');\r\n        }\r\n    },\r\n\r\n    _redraw: function () {\r\n        var out = [],\r\n            _map = this._map,\r\n            mapSize = _map.getSize(),\r\n            _canvas = this._canvas,\r\n            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\r\n            topLeft = _map.containerPointToLayerPoint(offset);\r\n\r\n\t\t_canvas.width = mapSize.x; _canvas.height = mapSize.y;\r\n        L.DomUtil.setPosition(_canvas, topLeft);\r\n\r\n        var w2 = 2 * this.mInPixel * gmxAPIutils.worldWidthMerc,\r\n            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\r\n            ctx = _canvas.getContext('2d'),\r\n            i, len, it;\r\n\r\n        for (var layerId in this._labels) {\r\n            var labels = this._labels[layerId];\r\n            for (var id in labels) {\r\n                it = labels[id];\r\n                var options = it.options,\r\n                    label = options.label,\r\n                    style = label.style,\r\n\t\t\t\t\tlabelAlign = style.labelAlign || 'center',\r\n                    arrTxtWidth = label.arrTxtWidth,\r\n\t\t\t\t\tcount = arrTxtWidth.length || 1,\r\n                    width = label.width,\r\n                    width2 = width / 2,\r\n                    size = style.labelFontSize || 12,\r\n                    size2 = size / 2,\r\n                    center = options.center,\r\n                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\r\n                    isFiltered = false;\r\n\r\n                if (label.isPoint) {\r\n                    var delta = label.sx;\r\n                    if (labelAlign === 'left') {\r\n                        pos[0] += width2 + delta;\r\n                    } else if (labelAlign === 'right') {\r\n                        pos[0] -= width + delta;\r\n                    }\r\n                }\r\n                pos[0] -= width2 + this._ctxShift[0];\r\n                pos[1] = -size2 - pos[1] + this._ctxShift[1];\r\n\t\t\t\tsize2 *= count;\r\n                if (style.labelAnchor) {\r\n                    pos[0] += style.labelAnchor[0];\r\n                    pos[1] += style.labelAnchor[1];\r\n                }\r\n\r\n                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\r\n                    var coord = [Math.floor(tx), Math.floor(pos[1])],\r\n                        bbox = gmxAPIutils.bounds([\r\n                            [coord[0] - width2, coord[1] - size2],\r\n                            [coord[0] + width2, coord[1] + size2]\r\n                        ]);\r\n                    for (i = 0, len = out.length; i < len; i++) {\r\n                        if (bbox.intersects(out[i].bbox)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (isFiltered) { continue; }\r\n\r\n                    if (!options.labelStyle) {\r\n                        options.labelStyle = {\r\n                            font: size + 'px \"Arial\"',\r\n                            fillStyle: gmxAPIutils.dec2color(style.labelColor || 0, 1),\r\n                            shadowBlur: 4\r\n                        };\r\n                        if (style.labelHaloColor !== -1) {\r\n                            options.labelStyle.strokeStyle =\r\n                            options.labelStyle.shadowColor =\r\n                                gmxAPIutils.dec2color(style.labelHaloColor, 1);\r\n                        }\r\n                    }\r\n                    out.push({\r\n                        arr: it.properties,\r\n                        bbox: bbox,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        width2: labelAlign === 'center' ? width2 : 0,\r\n                        txt: label.txt,\r\n                        style: options.labelStyle,\r\n                        size: size,\r\n                        coord: coord\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (out.length) {\r\n            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\r\n            for (i = 0, len = out.length; i < len; i++) {\r\n                it = out[i];\r\n\t\t\t\tit.arrTxtWidth.forEach(function(pt, nm) {\r\n\t\t\t\t\tvar coord = [it.coord[0] + it.width2 - pt[1]/2, it.coord[1] + nm * it.size];\r\n\t\t\t\t\tgmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\r\n\t\t\t\t});\r\n            }\r\n            if (!_canvas.parentNode) { this._addToPane(); }\r\n        } else if (_canvas.parentNode) {\r\n            _canvas.parentNode.removeChild(_canvas);\r\n        }\r\n\r\n        this._frame = null;\r\n    },\r\n\r\n    _animateZoom: function (e) {\r\n        var scale = this._map.getZoomScale(e.zoom),\r\n            pixelBoundsMin = this._map.getPixelBounds().min;\r\n\r\n        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\r\n        if (pixelBoundsMin.y < 0) {\r\n            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\r\n        }\r\n\r\n        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\r\n    }\r\n});\r\n\r\nL.labelsLayer = function (map, options) {\r\n    return new L.LabelsLayer(map, options);\r\n};\r\n\r\nL.Map.addInitHook(function () {\r\n\t// Check to see if Labels has already been initialized.\r\n    if (!this._labelsLayer) {\r\n        this._labelsLayer = new L.LabelsLayer(this);\r\n        this._labelsLayer.addTo(this);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LabelsLayer.js","(function() {\r\nvar isBoundsIntersects = function (bounds, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].intersects(bounds)) { return true; }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\nvar isObserverIntersects = function (observer, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (observer.intersects(bbox[j1])) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar isPointInClipPolygons = function (chkPoint, clipPolygons) {\r\n    if (!clipPolygons || Object.keys(clipPolygons).length === 0) { return true; }\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].contains(chkPoint)) {\r\n                        var coords = it.geometry.coordinates,\r\n                            isIn = false;\r\n                        if (type === 'Polygon') { coords = [coords]; }\r\n                        for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\r\n                                isIn = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (isIn) { return true; }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar getClipPolygonItem = function (geo) {\r\n    var geometry = gmxAPIutils.convertGeometry(geo),\r\n        bboxArr = gmxAPIutils.geoItemBounds(geometry);\r\n    bboxArr.geometry = geometry;\r\n    return bboxArr;\r\n};\r\n\r\nvar clipTileByPolygon = function (dattr) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = canvas.height = 256;\r\n    var ctx = canvas.getContext('2d'),\r\n        clipPolygons = dattr.clipPolygons;\r\n\r\n    dattr.ctx = ctx;\r\n    ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\r\n\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var geo = arr[i].geometry,\r\n                coords = geo.coordinates;\r\n            if (geo.type === 'Polygon') { coords = [coords]; }\r\n            for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\r\n                var coords1 = coords[i1];\r\n                ctx.beginPath();\r\n                for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\r\n                    dattr.coords = coords1[j1];\r\n                    var pixels = gmxAPIutils.getRingPixels(dattr);\r\n                    dattr.coords = pixels.coords;\r\n                    gmxAPIutils.polygonToCanvasFill(dattr);\r\n                }\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    ctx = dattr.tile.getContext('2d');\r\n    ctx.clearRect(0, 0, 256, 256);\r\n    ctx.drawImage(canvas, 0, 0);\r\n};\r\n\r\nL.gmx.VectorLayer.include({\r\n\r\n    isPointInClipPolygons: function (point) { // point [x, y] in Mercator\r\n        return isPointInClipPolygons(point, this._gmx._clipPolygons);\r\n    },\r\n\r\n    addClipPolygon: function (polygon) { // (L.Polygon) or (L.GeoJSON with Polygons)\r\n        var item = [],\r\n            i, len;\r\n\r\n        if ('coordinates' in polygon && 'type' in polygon) {\r\n            item.push(getClipPolygonItem(polygon));\r\n        } else if (polygon instanceof L.Polygon) {\r\n            item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\r\n        } else if (polygon instanceof L.GeoJSON) {\r\n            var layers = polygon.getLayers();\r\n            for (i = 0, len = layers.length; i < len; i++) {\r\n                var layer = layers[i];\r\n                if (layer instanceof L.Polygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                } else if (layer instanceof L.MultiPolygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                }\r\n            }\r\n        }\r\n        if (item.length) {\r\n            var gmx = this._gmx,\r\n                dataManager = gmx.dataManager,\r\n                _this = this,\r\n                id = L.stamp(polygon);\r\n\r\n            if (!this._gmx._clipPolygons) { this._gmx._clipPolygons = {}; }\r\n            this._gmx._clipPolygons[id] = item;\r\n            dataManager.setTileFilteringHook(function (tile) {\r\n                return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipFilter', function (item, tile, observer) {\r\n                return isObserverIntersects(observer, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipPointsFilter', function (item) {\r\n                if (item.type === 'POINT') {\r\n                    var propArr = item.properties,\r\n                        geom = propArr[propArr.length - 1];\r\n                    return isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\r\n                }\r\n                return true;\r\n            });\r\n            if (Object.keys(this._gmx._clipPolygons).length === 1) {\r\n                gmx.renderHooks.unshift(function (tile, hookInfo) {\r\n                    if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\r\n                        clipTileByPolygon({\r\n                            tile: tile,\r\n                            tpx: hookInfo.tpx,\r\n                            tpy: hookInfo.tpy,\r\n                            gmx: {mInPixel: gmx.mInPixel},\r\n                            clipPolygons: _this._gmx._clipPolygons\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeClipPolygon: function (polygon) {\r\n        var id = L.stamp(polygon);\r\n        if (this._gmx._clipPolygons) {\r\n            delete this._gmx._clipPolygons[id];\r\n            if (Object.keys(this._gmx._clipPolygons).length === 0) {\r\n                this._gmx.dataManager.removeTileFilteringHook();\r\n                this._gmx.dataManager.removeFilter('clipFilter');\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ClipPolygon.js","L.gmx.gmxImageTransform = function(img, hash) {\r\n    var gmx = hash.gmx,\r\n        gmxTilePoint = hash.gmxTilePoint,\r\n        mInPixel = gmx.mInPixel,\r\n        geoItem = hash.geoItem,\r\n        properties = geoItem.properties,\r\n        dataOption = geoItem.dataOption || {},\r\n        // geom = properties[properties.length - 1],\r\n        // coord = geom.coordinates[0],\r\n        indexes = gmx.tileAttributeIndexes,\r\n        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\r\n        points = {};\r\n\r\n    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\r\n    if (quicklookPlatform === 'LANDSAT8') {\r\n        points.x1 = dataOption.bounds.min.x; points.y1 = dataOption.bounds.max.y;\r\n        points.x2 = dataOption.bounds.max.x; points.y2 = dataOption.bounds.max.y;\r\n        points.x3 = dataOption.bounds.max.x; points.y3 = dataOption.bounds.min.y;\r\n        points.x4 = dataOption.bounds.min.x; points.y4 = dataOption.bounds.min.y;\r\n    } else {\r\n        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\r\n    }\r\n\r\n    var x1 = mInPixel * points.x1, y1 = mInPixel * points.y1,\r\n        x2 = mInPixel * points.x2, y2 = mInPixel * points.y2,\r\n        x3 = mInPixel * points.x3, y3 = mInPixel * points.y3,\r\n        x4 = mInPixel * points.x4, y4 = mInPixel * points.y4,\r\n        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\r\n        ww = Math.round(boundsP.max.x - boundsP.min.x),\r\n        hh = Math.round(boundsP.max.y - boundsP.min.y),\r\n        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\r\n        itbounds = geoItem.item.bounds,\r\n        wMerc = gmxAPIutils.worldWidthMerc,\r\n        tpx = gmxTilePoint.x;\r\n\r\n    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\t// For points intersects 180 deg\r\n\t\ttpx += Math.round(wMerc * mInPixel / 128);\r\n\t}\r\n\tvar dx = boundsP.min.x - 256 * tpx;\r\n\r\n    x1 -= boundsP.min.x; y1 = boundsP.max.y - y1;\r\n    x2 -= boundsP.min.x; y2 = boundsP.max.y - y2;\r\n    x3 -= boundsP.min.x; y3 = boundsP.max.y - y3;\r\n    x4 -= boundsP.min.x; y4 = boundsP.max.y - y4;\r\n\r\n    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\r\n\r\n    if (!gmx.ProjectiveImage) {\r\n        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\r\n    }\r\n    var pt = gmx.ProjectiveImage.getCanvas({\r\n        imageObj: img,\r\n        points: shiftPoints,\r\n        wView: ww,\r\n        hView: hh,\r\n        deltaX: dx,\r\n        deltaY: dy\r\n    });\r\n    return pt.canvas;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ImageTransform.js","(function() {\r\nvar ProjectiveImageWebGL = L.Class.extend({\r\n    options: {\r\n        antialias: true,\r\n        depth: false,\r\n        preserveDrawingBuffer: true,\r\n        shaderVS: 'attribute vec2 aVertCoord;\\\r\n            uniform mat4 uTransformMatrix;\\\r\n            varying vec2 vTextureCoord;\\\r\n            void main(void) {\\\r\n                vTextureCoord = aVertCoord;\\\r\n                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n            }\\\r\n        ',\r\n        shaderFS: 'precision mediump float;\\\r\n            varying vec2 vTextureCoord;\\\r\n            uniform sampler2D uSampler;\\\r\n            void main(void) {\\\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n            }\\\r\n        '\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        L.setOptions(this, options);\r\n    },\r\n\r\n    initialize: function(options) {\r\n        this.setOptions(options);\r\n\r\n        var canvas = document.createElement('canvas'),\r\n            glOpts = {\r\n                antialias: this.options.antialias,\r\n                depth: this.options.depth,\r\n                preserveDrawingBuffer: this.options.preserveDrawingBuffer\r\n            },\r\n            gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\r\n        if (!gl) { return; }\r\n        var glResources = this._setupGlContext(gl);\r\n        if (!glResources) { return; }\r\n\r\n        canvas.width = canvas.height = 256;\r\n        glResources.canvas = canvas;\r\n\r\n        this.glResources = glResources;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n    },\r\n\r\n    _getShader: function (type, source, gl) {\r\n        var shader = gl.createShader(type);\r\n\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return shader;\r\n    },\r\n\r\n    _setupGlContext: function (gl) {\r\n        // Store return values here\r\n        var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\r\n            fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\r\n\r\n        if (vertexShader && fragmentShader) {\r\n            // Compile the program\r\n            var shaderProgram = gl.createProgram();\r\n            gl.attachShader(shaderProgram, vertexShader);\r\n            gl.attachShader(shaderProgram, fragmentShader);\r\n            gl.linkProgram(shaderProgram);\r\n\r\n            if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n                // Find and set up the uniforms and attributes\r\n                gl.useProgram(shaderProgram);\r\n                this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n                var vertexBuffer = gl.createBuffer(),    // Create a buffer to hold the vertices\r\n                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\r\n\r\n                // draw the triangles\r\n                gl.enableVertexAttribArray(vertAttrib);\r\n                gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\r\n                return {\r\n                    transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\r\n                    samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\r\n                    screenTexture: gl.createTexture() // Create a texture to use for the screen image\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    _bindTexture: function (gl, image, texture) {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n        // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        // Prevents s-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        // Prevents t-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    getCanvas: function (attr) {\r\n        var p = attr.points,\r\n            deltaX = attr.deltaX,\r\n            deltaY = attr.deltaY,\r\n            dstPoints = new Float32Array([\r\n                (p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128,\r\n                (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128,\r\n                (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128,\r\n                (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128\r\n            ]);\r\n\r\n        var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\r\n            gl = this.gl,\r\n            glResources = this.glResources;\r\n\r\n        this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\r\n\r\n        gl.viewport(0, 0, 256, 256);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    // set background to full transparency\r\n\r\n        gl.uniformMatrix4fv(\r\n            glResources.transMatUniform,\r\n            false, [\r\n                v[0], v[3],    0, v[6],\r\n                v[1], v[4],    0, v[7],\r\n                   0,    0,    1,    0,\r\n                v[2], v[5],    0,    1\r\n            ]);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\r\n        gl.uniform1i(glResources.samplerUniform, 0);\r\n\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        return this;\r\n    }\r\n});\r\n\r\nfunction adj(m) { // Compute the adjugate of m\r\n    return [\r\n        m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4],\r\n        m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5],\r\n        m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]\r\n    ];\r\n}\r\n\r\nfunction multmm(a, b) { // multiply two matrices\r\n    var c = Array(9);\r\n    for (var i = 0; i !== 3; ++i) {\r\n        for (var j = 0; j !== 3; ++j) {\r\n            var cij = 0;\r\n            for (var k = 0; k !== 3; ++k) {\r\n                cij += a[3 * i + k] * b[3 * k + j];\r\n            }\r\n            c[3 * i + j] = cij;\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction multmv(m, v) { // multiply matrix and vector\r\n    return [\r\n        m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\r\n        m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\r\n        m[6] * v[0] + m[7] * v[1] + m[8] * v[2]\r\n    ];\r\n}\r\n\r\nfunction basisToPoints(p) {\r\n    var m = [\r\n        p[0], p[2], p[4],\r\n        p[1], p[3], p[5],\r\n        1,  1,  1\r\n    ];\r\n    var v = multmv(adj(m), [p[6], p[7], 1]);\r\n    return multmm(m, [\r\n        v[0], 0, 0,\r\n        0, v[1], 0,\r\n        0, 0, v[2]\r\n    ]);\r\n}\r\n\r\nProjectiveImageWebGL.Utils = {\r\n    general2DProjection: function(from, to) {\r\n        var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\r\n        if (arr[8]) {\r\n            for (var i = 0; i !== 9; ++i) {\r\n                arr[i] = arr[i] / arr[8];\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    getWebGlResources: function(options) {\r\n        var obj = new ProjectiveImageWebGL(options);\r\n        return obj.gl ? obj : null;\r\n    }\r\n};\r\nL.gmx.projectiveImageWebGL = function(options) {\r\n    var res = new ProjectiveImageWebGL(options);\r\n    return res.gl ? res : null;\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImageWebGL.js","(function() {\r\n// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\r\nvar ProjectiveImage = function() {\r\n\tvar cnt = 0,\r\n        limit = 4,\r\n        patchSize = 64,\r\n        transform = null;\r\n\r\n\tvar allocate = function (w, h) {\r\n\t  var values = [];\r\n\t  for (var i = 0; i < h; ++i) {\r\n\t\tvalues[i] = [];\r\n\t\tfor (var j = 0; j < w; ++j) {\r\n\t\t  values[i][j] = 0;\r\n\t\t}\r\n\t  }\r\n\t  return values;\r\n\t};\r\n\r\n\tvar Matrix = function (w, h, values) {\r\n\t  this.w = w;\r\n\t  this.h = h;\r\n\t  this.values = values || allocate(h);\r\n\t};\r\n\r\n\tvar cloneValues = function (values) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0; i < values.length; ++i) {\r\n\t\t\tclone[i] = [].concat(values[i]);\r\n\t\t}\r\n\t\treturn clone;\r\n\t};\r\n\r\n\tMatrix.prototype = {\r\n\t\tadd : function (operand) {\r\n\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix add size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (var x = 0; x < this.w; ++x) {\r\n\t\t\t\t  values[y][x] = this.values[y][x] + operand.values[y][x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t},\r\n\t\ttransformProjectiveVector : function (operand) {\r\n\t\t\tvar out = [], x, y;\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tout[y] = 0;\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar zn = out[out.length - 1];\r\n\t\t\tif (zn) {\r\n\t\t\t\tvar iz = 1 / (out[out.length - 1]);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tout[y] *= iz;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\tmultiply : function (operand) {\r\n\t\t\tvar values, x, y;\r\n\t\t\tif (+operand !== operand) {\r\n\t\t\t\t// Matrix mult\r\n\t\t\t\tif (operand.h !== this.w) {\r\n\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\r\n\t\t\t\t}\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\r\n\t\t\t\t\t\tvar accum = 0;\r\n\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\r\n\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[y][x] = accum;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(operand.w, this.h, values);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Scalar mult\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t\t}\r\n\t\t},\r\n\t\trowEchelon : function () {\r\n\t\t\tif (this.w <= this.h) {\r\n\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = cloneValues(this.values);\r\n\r\n\t\t\t// Do Gauss-Jordan algorithm.\r\n\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\r\n\t\t\t\t// Look up pivot value.\r\n\t\t\t\tvar pivot = temp[yp][yp];\r\n\t\t\t\twhile (pivot === 0) {\r\n\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\r\n\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\r\n\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\r\n\t\t\t\t\t\t\t// Swap rows.\r\n\t\t\t\t\t\t\tvar tmpRow = temp[ys];\r\n\t\t\t\t\t\t\ttemp[ys] = temp[yp];\r\n\t\t\t\t\t\t\ttemp[yp] = tmpRow;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (ys === this.h) {\r\n\t\t\t\t\t\t// No suitable pivot found. Abort.\r\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpivot = temp[yp][yp];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Normalize this row.\r\n\t\t\t\tvar scale = 1 / pivot;\r\n\t\t\t\tfor (var x = yp; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[yp][x] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\t// Subtract this row from all other rows (scaled).\r\n\t\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tif (y === yp) { continue; }\r\n\t\t\t\t\tvar factor = temp[y][yp];\r\n\t\t\t\t\ttemp[y][yp] = 0;\r\n\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\r\n\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t},\r\n\t\tinvert : function () {\r\n\t\t\tvar x, y;\r\n\r\n\t\t\tif (this.w !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix invert size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = allocate(this.w * 2, this.h);\r\n\r\n\t\t\t// Initialize augmented matrix\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[y][x] = this.values[y][x];\r\n\t\t\t\t\ttemp[y][x + this.w] = (x === y) ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\r\n\t\t\ttemp = temp.rowEchelon();\r\n\r\n\t\t\t// Extract right block matrix.\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (y = 0; y < this.w; ++y) {\r\n\t\t\t\t// @todo check if \"x < this.w;\" is mistake\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t}\r\n\t};\r\n\r\n\tvar getProjectiveTransform = function (points) {\r\n\t  var eqMatrix = new Matrix(9, 8, [\r\n\t\t[1, 1, 1,   0, 0, 0, -points[2][0], -points[2][0], -points[2][0]],\r\n\t\t[0, 1, 1,   0, 0, 0,  0, -points[3][0], -points[3][0]],\r\n\t\t[1, 0, 1,   0, 0, 0, -points[1][0], 0, -points[1][0]],\r\n\t\t[0, 0, 1,   0, 0, 0,  0, 0, -points[0][0]],\r\n\r\n\t\t[0, 0, 0,  -1, -1, -1,  points[2][1], points[2][1], points[2][1]],\r\n\t\t[0, 0, 0,   0, -1, -1,  0, points[3][1], points[3][1]],\r\n\t\t[0, 0, 0,  -1,  0, -1,  points[1][1], 0, points[1][1]],\r\n\t\t[0, 0, 0,   0,  0, -1,  0, 0, points[0][1]]\r\n\r\n\t  ]);\r\n\r\n\t  var kernel = eqMatrix.rowEchelon().values;\r\n\t  var transform = new Matrix(3, 3, [\r\n\t\t[-kernel[0][8], -kernel[1][8], -kernel[2][8]],\r\n\t\t[-kernel[3][8], -kernel[4][8], -kernel[5][8]],\r\n\t\t[-kernel[6][8], -kernel[7][8],             1]\r\n\t  ]);\r\n\t  return transform;\r\n\t};\r\n\r\n\tvar divide = function (u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\r\n\t\tif (limit) {\r\n\t\t\t// Measure patch non-affinity.\r\n\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\r\n\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\r\n\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\r\n\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\r\n\r\n\t\t\t// Measure patch area.\r\n\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\r\n\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\r\n\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\r\n\r\n\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\r\n\t\t\t// The non-affinity measure is used as a correction factor.\r\n\t\t\tif ((u1 === 0 && u4 === 1) || ((.25 + r * 5) * area > (patchSize * patchSize))) {\r\n\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\r\n\t\t\t\tvar umid = (u1 + u4) / 2;\r\n\t\t\t\tvar vmid = (v1 + v4) / 2;\r\n\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\r\n\t\t\t\tvar pt   = transform.transformProjectiveVector([umid, v1, 1]);\r\n\t\t\t\tvar pb   = transform.transformProjectiveVector([umid, v4, 1]);\r\n\t\t\t\tvar pl   = transform.transformProjectiveVector([u1, vmid, 1]);\r\n\t\t\t\tvar pr   = transform.transformProjectiveVector([u4, vmid, 1]);\r\n\r\n\t\t\t\t// Subdivide.\r\n\t\t\t\tlimit--;\r\n\t\t\t\tdivide.call(this, u1,   v1, umid, vmid,   p1,   pt,   pl, pmid, limit, attr);\r\n\t\t\t\tdivide.call(this, umid,   v1,   u4, vmid,   pt,   p2, pmid,   pr, limit, attr);\r\n\t\t\t\tdivide.call(this, u1,  vmid, umid,   v4,   pl, pmid,   p3,   pb, limit, attr);\r\n\t\t\t\tdivide.call(this, umid, vmid,   u4,   v4, pmid,   pr,   pb,   p4, limit, attr);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar ctx = attr.ctx;\r\n\r\n\t\t// Get patch edge vectors.\r\n\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\r\n\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\r\n\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\r\n\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\r\n\r\n\t\t// Find the corner that encloses the most area\r\n\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\r\n\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\r\n\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\r\n\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\r\n\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\r\n\t\tvar dx = 0, dy = 0, padx = 0, pady = 0;\r\n\r\n\t\t// Align the transform along this corner.\r\n\t\t// Calculate 1.05 pixel padding on vector basis.\r\n\t\tif (amax === a1) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t} else if (amax === a2) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1],  d24[0],  d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t} else if (amax === a4) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t\t\tdy = -1;\r\n\t\t} else if (amax === a3) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t\t\tdy = -1;\r\n\t\t}\r\n\r\n\t\t// Calculate image padding to match.\r\n\t\tvar du = (u4 - u1);\r\n\t\tvar dv = (v4 - v1);\r\n\t\tpadx++;\r\n\t\tpady++;\r\n\r\n        var iw = attr.imageObj.width,\r\n            ih = attr.imageObj.height,\r\n            sx = Math.floor(u1 * iw),\r\n            sy = Math.floor(v1 * ih),\r\n            sw = Math.floor(Math.min(padx * du, 1) * iw),\r\n            sh = Math.floor(Math.min(pady * dv, 1) * ih);\r\n\r\n\t\tcnt++;\r\n        ctx.drawImage(\r\n            attr.imageObj,\r\n            sx, sy,\r\n            sw, sh,\r\n            dx, dy,\r\n            padx, pady\r\n        );\r\n\t};\r\n\r\n\tthis.getCanvas = function (attr) {\r\n\t\tcnt = 0;\r\n\t\ttransform = getProjectiveTransform(attr.points);\r\n\t\t// Begin subdivision process.\r\n\r\n\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\r\n            ptr = transform.transformProjectiveVector([1, 0, 1]),\r\n            pbl = transform.transformProjectiveVector([0, 1, 1]),\r\n            pbr = transform.transformProjectiveVector([1, 1, 1]);\r\n\r\n\t\tvar canvas = document.createElement('canvas');\r\n\t\tcanvas.width = canvas.height = 256;\r\n\t\tattr.canvas = canvas;\r\n\t\tattr.ctx = canvas.getContext('2d');\r\n\r\n\t\tvar\tboundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\r\n            maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\r\n\r\n\t\tlimit = 'limit' in attr ? attr.limit : (maxSize < 200 ? 1 : 4);\r\n\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\r\n\r\n\t\ttry {\r\n\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\r\n\t\t} catch (e) {\r\n\t\t\tconsole.log('Error: ProjectiveImage event:', e);\r\n\t\t\tcanvas = null;\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tcanvas: canvas,\r\n\t\t\tptl: ptl,\r\n\t\t\tptr: ptr,\r\n\t\t\tpbl: pbl,\r\n\t\t\tpbr: pbr,\r\n\t\t\tcnt: cnt\r\n\t\t};\r\n\t};\r\n};\r\nL.gmx.projectiveImage = function() {\r\n    return new ProjectiveImage();\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImage.js","// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\r\n\r\nL.RotatedMarker = L.Marker.extend({\r\n    options: {\r\n        angle: 0\r\n    },\r\n\r\n    statics: {\r\n        TRANSFORM_ORIGIN: L.DomUtil.testProp(\r\n            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\r\n    },\r\n\r\n    _initIcon: function() {\r\n        L.Marker.prototype._initIcon.call(this);\r\n\r\n        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\r\n    },\r\n\r\n    _getTransformOrigin: function() {\r\n        var iconAnchor = this.options.icon.options.iconAnchor;\r\n\r\n        if (!iconAnchor) {\r\n            return '50% 50%';\r\n        }\r\n\r\n        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\r\n    },\r\n\r\n    _setPos: function(pos) {\r\n        L.Marker.prototype._setPos.call(this, pos);\r\n\r\n        if (L.DomUtil.TRANSFORM) {\r\n            // use the CSS transform rule if available\r\n            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n        } else if (L.Browser.ie) {\r\n            // fallback for IE6, IE7, IE8\r\n            var rad = this.options.angle * (Math.PI / 180),\r\n                costheta = Math.cos(rad),\r\n                sintheta = Math.sin(rad);\r\n            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' +\r\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';\r\n        }\r\n    },\r\n\r\n    setAngle: function(ang) {\r\n        this.options.angle = ang;\r\n    }\r\n});\r\n\r\nL.rotatedMarker = function(pos, options) {\r\n    return new L.RotatedMarker(pos, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/RotatedMarker.js","L.gmx.ExternalLayer = L.Class.extend({\r\n    createExternalLayer: function () {          // extend: must return <ILayer> or null = this.externalLayer\r\n        return null;\r\n    },\r\n\r\n    isExternalVisible: function (/*zoom*/) {    // extend: return true view this.externalLayer, return false view this.parentLayer\r\n        return true;\r\n    },\r\n\r\n    updateData: function (/*data*/) {           // extend: for data update in this.externalLayer\r\n    },\r\n\r\n    setDateInterval: function () {\r\n        if (this._observer) {\r\n            var gmx = this.parentLayer._gmx;\r\n            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\r\n        }\r\n    },\r\n\r\n    options: {\r\n        useDataManager: true,\r\n        observerOptions: {\r\n            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\r\n        }\r\n    },\r\n\r\n    initialize: function (options, layer) {\r\n        L.setOptions(this, options);\r\n        this.parentLayer = layer;\r\n        layer\r\n            .on('add', this._addEvent, this)\r\n            .on('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this.options.useDataManager) {\r\n            this._addObserver(this.options.observerOptions);\r\n        }\r\n\r\n        this.externalLayer = this.createExternalLayer();\r\n\r\n        if (layer._map) {\r\n            this._addEvent({target:{_map: layer._map}});\r\n            this._updateBbox();\r\n        }\r\n    },\r\n\r\n    _addObserver: function (opt) {\r\n        this._items = {};\r\n        this._observer = this.parentLayer.addObserver(\r\n            L.extend({\r\n                bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\r\n                callback: L.bind(this.updateData, this)\r\n            }, opt)\r\n        ).deactivate();\r\n    },\r\n\r\n    unbindLayer: function () {\r\n        this.parentLayer\r\n            .off('add', this._addEvent, this)\r\n            .off('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this._observer) { delete this.parentLayer.repaintObservers[this._observer.id]; }\r\n        var map = this._map || this.parentLayer._map;\r\n        this._onRemove(!map);\r\n        this._removeMapHandlers();\r\n    },\r\n\r\n    _addMapHandlers: function (map) {\r\n        this._map = map;\r\n        this._map.on({\r\n            moveend: this._updateBbox,\r\n            zoomend: this._chkZoom,\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        }, this);\r\n    },\r\n\r\n    _removeMapHandlers: function () {\r\n        if (this._map) {\r\n            this._map.off({\r\n                moveend: this._updateBbox,\r\n                zoomend: this._chkZoom,\r\n                layeradd: this._layeradd,\r\n                layerremove: this._layerremove\r\n            }, this);\r\n        }\r\n        this._map = null;\r\n    },\r\n\r\n    _addEvent: function (ev) {\r\n        this._addMapHandlers(ev.target._map);\r\n        this._updateBbox();\r\n        this._chkZoom();\r\n    },\r\n\r\n    _isParentLayer: function (ev) {\r\n        var layer = ev.layer;\r\n        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\r\n    },\r\n\r\n    _layeradd: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._chkZoom();\r\n        }\r\n    },\r\n\r\n    _layerremove: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._onRemove(true);\r\n            this._removeMapHandlers();\r\n        }\r\n    },\r\n\r\n    _onRemove: function (fromMapFlag) {    // remove external layer from parent layer\r\n        if (this._observer) {\r\n            this._observer.deactivate();\r\n        }\r\n        var map = this._map;\r\n        if (map) {\r\n            if (map.hasLayer(this.externalLayer)) {\r\n                this._chkZoom();\r\n                map.removeLayer(this.externalLayer);\r\n            }\r\n            if (!fromMapFlag) {\r\n                this.parentLayer.onAdd(map);\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkZoom: function () {\r\n        if (!this._map) { return; }\r\n\r\n        var layer = this.parentLayer,\r\n            observer = this._observer,\r\n            map = this._map,\r\n            isExtLayerOnMap = map.hasLayer(this.externalLayer);\r\n\r\n        layer.setCurrentZoom(map);\r\n        if (!this.isExternalVisible(map.getZoom())) {\r\n            if (observer) { observer.deactivate(); }\r\n            if (!layer._map) {\r\n                if (isExtLayerOnMap) {\r\n                    map.removeLayer(this.externalLayer);\r\n                }\r\n                layer.onAdd(map);\r\n            }\r\n            layer.enablePopup();\r\n        } else if (layer._map) {\r\n            layer.onRemove(map);\r\n            if (!isExtLayerOnMap) {\r\n                map.addLayer(this.externalLayer);\r\n            }\r\n            this.setDateInterval();\r\n            if (observer) {\r\n                layer.getIcons(function () {\r\n                    observer.activate();\r\n                }.bind(this));\r\n            }\r\n            layer.disablePopup();\r\n        }\r\n    },\r\n\r\n\r\n    _updateBbox: function () {\r\n        if (!this._map || !this._observer) { return; }\r\n\r\n        var screenBounds = this._map.getBounds(),\r\n            p1 = screenBounds.getNorthWest(),\r\n            p2 = screenBounds.getSouthEast(),\r\n            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\r\n        this._observer.setBounds(bbox);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/ExternalLayer.js","(function() {\r\n    'use strict';\r\n    var BindWMS = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minZoom: 1,\r\n            maxZoom: 6,\r\n            useDataManager: false,\r\n            format: 'png',\r\n            transparent: true\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var poptions = this.parentLayer.options,\r\n                opt = {\r\n                    map: poptions.mapID,\r\n                    layers: poptions.layerID,\r\n                    format: this.options.format,\r\n                    transparent: this.options.transparent\r\n                },\r\n                rawProperties = this.parentLayer.getGmxProperties();\r\n\r\n            if (rawProperties && rawProperties.Temporal) { this._extendOptionsByDateInterval(opt); }\r\n            if (this.options.apikey) { opt.apikey = this.options.apikey; }\r\n            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\r\n        },\r\n\r\n        _extendOptionsByDateInterval: function (options) {\r\n            var dateInterval = this.parentLayer.getDateInterval(),\r\n                beginDate = dateInterval.beginDate,\r\n                endDate = dateInterval.endDate;\r\n            L.extend(options, {\r\n                StartDate: beginDate && beginDate.toLocaleDateString(),\r\n                EndDate: endDate && endDate.toLocaleDateString()\r\n            });\r\n        },\r\n\r\n        setDateInterval: function () {\r\n            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\r\n            this.externalLayer.redraw();\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindWMS: function (options) {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n            }\r\n            this._layerWMS = new BindWMS(options, this);\r\n            this.isExternalVisible = this._layerWMS.isExternalVisible;\r\n            return this;\r\n        },\r\n\r\n        unbindWMS: function () {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n                this._layerWMS = null;\r\n                this.isExternalVisible = null;\r\n                this.enablePopup();\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/BindWMS.js","(function() {\r\n    'use strict';\r\n    var GmxHeatMap = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minHeatMapZoom: 1,\r\n            maxHeatMapZoom: 6,\r\n            intensityField: '',\r\n            intensityScale: 1,\r\n            observerOptions: {\r\n                type: 'resend'\r\n            }\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            return L.heatLayer([], L.extend({\r\n                 // minOpacity: 0.05,\r\n                 // maxZoom: 18,\r\n                 // radius: 25,\r\n                 // blur: 15,\r\n                 // max: 1.0\r\n            }, this.options));\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            if (data.added) {\r\n                var latlngs = [],\r\n                    indexes = this.parentLayer.getTileAttributeIndexes(),\r\n                    altIndex = null,\r\n                    intensityField = this.options.intensityField || '',\r\n                    intensityScale = this.options.intensityScale || 1;\r\n\r\n                if (intensityField && intensityField in indexes) {\r\n                    altIndex = indexes[intensityField];\r\n                }\r\n                for (var i = 0, len = data.added.length; i < len; i++) {\r\n                    var it = data.added[i].properties,\r\n                        alt = altIndex !== null ? it[altIndex] : 1,\r\n                        geo = it[it.length - 1],\r\n                        coord = geo.coordinates,\r\n                        point = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n\r\n                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\r\n                }\r\n                this.externalLayer.setLatLngs(latlngs);\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindHeatMap: function (options) {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                }\r\n                this._heatmap = new GmxHeatMap(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindHeatMap: function () {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                    this._heatmap = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/HeatMap.js","(function() {\r\n    'use strict';\r\n    var _DEFAULTS = {\r\n        radiusFunc: function (count) {\r\n            var r = Math.floor(count / 15);\r\n            if (r > 40) {\r\n                r = 40;\r\n            } else if (r < 20) {\r\n                r = 20;\r\n            }\r\n            return r;\r\n        },\r\n        text: {\r\n            stroke: 'black',\r\n            'stroke-width': 1,\r\n            'text-anchor': 'middle',\r\n            fill: 'white'\r\n        }\r\n    };\r\n    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            observerOptions: {\r\n                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\r\n            },\r\n            spiderfyOnMaxZoom: true,\r\n            minZoom: 1,\r\n            maxZoom: 6\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var mOptions = L.extend({\r\n                showCoverageOnHover: false,\r\n                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\r\n            }, this.options);\r\n\r\n            if ('clusterIconOptions' in this.options) {\r\n                var opt = this.options.clusterIconOptions;\r\n                if ('radialGradient' in opt) {\r\n                    var radialGradient = opt.radialGradient,\r\n                        text = opt.text || _DEFAULTS.text;\r\n                    mOptions.iconCreateFunction = function (cluster) {\r\n                        var childCount = cluster.getChildCount();\r\n\r\n                        text.count = childCount;\r\n                        return  L.gmxUtil.getSVGIcon({\r\n                            type: 'circle',\r\n                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\r\n                            text: text,\r\n                            fillRadialGradient: radialGradient\r\n                        });\r\n                    };\r\n                }\r\n            }\r\n\r\n            if (this.options.clusterclick) {\r\n                mOptions.clusterclick = this.options.clusterclick;\r\n                if (mOptions.clusterclick === true) { mOptions.zoomToBoundsOnClick = false; }\r\n            }\r\n\r\n            this._popup = new L.Popup({maxWidth: 10000, className: 'gmxPopup'});\r\n            var markers = new L.MarkerClusterGroup(mOptions);\r\n\r\n            // текущий развёрнутый кластер\r\n            var currentSpiderfiedCluster = null;\r\n\r\n            markers\r\n                .on('click', function (ev) {\r\n                    var propsArr = ev.layer.options.properties,\r\n                        properties = this.parentLayer.getItemProperties(propsArr),\r\n                        geometry = [propsArr[propsArr.length - 1]],\r\n                        id = propsArr[0];\r\n\r\n                    if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\r\n                        currentSpiderfiedCluster.unspiderfy();\r\n                        markers.once('unspiderfied', function () {\r\n                            this._openPopup(propsArr, ev.latlng);\r\n                        }, this);\r\n                    } else {\r\n                        this._openPopup(propsArr, ev.latlng);\r\n                    }\r\n\r\n                    this.parentLayer.fire('click', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'click',\r\n                        gmx: {\r\n                            id: id,\r\n                            layer: this.parentLayer,\r\n                            properties: properties,\r\n                            target: {\r\n                                id: id,\r\n                                properties: propsArr,\r\n                                geometry: geometry\r\n                            }\r\n                        }\r\n                    }));\r\n                }, this)\r\n                .on('animationend', function () {\r\n                    if (this._popup && this._popup._map) {\r\n                        this._popup._map.removeLayer(this._popup);\r\n                    }\r\n                }, this)\r\n                .on('clusterclick', function (ev) {\r\n                    this.parentLayer.fire('clusterclick', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'clusterclick'\r\n                    }));\r\n                }, this)\r\n                .on('spiderfied', function (ev) {\r\n                    currentSpiderfiedCluster = ev.cluster;\r\n                }, this)\r\n                .on('unspiderfied', function () {\r\n                    currentSpiderfiedCluster = null;\r\n                }, this);\r\n\r\n            if (mOptions.clusterclick) {\r\n                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\r\n                    a.layer.spiderfy();\r\n                });\r\n            }\r\n\r\n            return markers;\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            var arr = [],\r\n                i, len, vectorTileItem, id, marker;\r\n            if (data.removed) {\r\n                for (i = 0, len = data.removed.length; i < len; i++) {\r\n                    vectorTileItem = data.removed[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    if (marker) {\r\n                        arr.push(marker);\r\n                    }\r\n                    delete this._items[id];\r\n                }\r\n                this.externalLayer.removeLayers(arr);\r\n                arr = [];\r\n            }\r\n            if (data.added) {\r\n                for (i = 0, len = data.added.length; i < len; i++) {\r\n                    vectorTileItem = data.added[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    var item = vectorTileItem.properties;\r\n                    if (marker && item.processing) {\r\n                        this.externalLayer.removeLayer(marker);\r\n                        marker = null;\r\n                    }\r\n                    if (!marker) {\r\n                        if (!vectorTileItem.item.parsedStyleKeys) {\r\n                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\r\n                        }\r\n                        var geo = item[item.length - 1],\r\n                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\r\n                            p = geo.coordinates,\r\n                            latlng = L.Projection.Mercator.unproject({x: p[0], y: p[1]}),\r\n                            opt = {\r\n                                properties: vectorTileItem.properties,\r\n                                mPoint: p\r\n                            };\r\n\r\n                        if (this.options.notClusteredIcon) {\r\n                            var icon = this.options.notClusteredIcon;\r\n                            if (icon instanceof L.Icon) {\r\n                                opt.icon = icon;\r\n                            } else {\r\n                                opt.icon = L.icon(icon);\r\n                            }\r\n                        } else if (parsedStyle) {\r\n                            if (parsedStyle.iconUrl) {\r\n                                var iconAnchor = parsedStyle.iconAnchor;\r\n                                if (!iconAnchor) {\r\n                                    var style = this.parentLayer.getItemStyle(id);\r\n                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\r\n                                }\r\n                                opt.icon = L.icon({\r\n                                    iconAnchor: iconAnchor,\r\n                                    iconUrl: parsedStyle.iconUrl\r\n                                });\r\n                            } else {\r\n                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\r\n                            }\r\n                        }\r\n                        if (parsedStyle.rotate) {\r\n                            marker = L.rotatedMarker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        } else {\r\n                            marker = L.marker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        }\r\n                        this._items[id] = marker;\r\n                    }\r\n                    arr.push(marker);\r\n                }\r\n                this.externalLayer.addLayers(arr);\r\n            }\r\n        },\r\n\r\n        _openPopup: function (propsArr, latlng) {\r\n            var gmx = this.parentLayer._gmx,\r\n                id = propsArr[0],\r\n                balloonData = gmx.styleManager.getItemBalloon(id),\r\n                properties = this.parentLayer.getItemProperties(propsArr),\r\n                geometry = [propsArr[propsArr.length - 1]];\r\n\r\n            if (balloonData && !balloonData.DisableBalloonOnClick) {\r\n                var style = this.parentLayer.getItemStyle(id);\r\n                if (style && style.iconAnchor) {\r\n                    var protoOffset = L.Popup.prototype.options.offset;\r\n                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2,\r\n                        protoOffset[1] - style.iconAnchor[1] + style.sy / 2\r\n                    ];\r\n                }\r\n                this._popup\r\n                    .setLatLng(latlng)\r\n                    .setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\r\n                        properties: properties,\r\n                        tileAttributeTypes: gmx.tileAttributeTypes,\r\n                        unitOptions: this._map.options || {},\r\n                        geometries: geometry\r\n                    }))\r\n                    .openOn(this._map);\r\n            }\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindClusters: function (options) {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                }\r\n                this._clusters = new GmxMarkerCluster(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindClusters: function () {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                    this._clusters = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/MarkerCluster.js","L.gmx = L.gmx || {};\r\nimport {gmxAPIutils} from './Utils.js';\r\n\r\nvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\r\nvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\r\n\r\n//Build in layer classes\r\nL.gmx._layerClasses = {\r\n    'Raster': L.gmx.RasterLayer,\r\n    'Vector': L.gmx.VectorLayer,\r\n    'VectorView': L.gmx.DummyLayer\r\n};\r\n\r\nL.gmx._loadingLayerClasses = {};\r\n\r\nL.gmx.addLayerClass = function(type, layerClass) {\r\n    L.gmx._layerClasses[type] = layerClass;\r\n};\r\n\r\nL.gmx._layerClassLoaders = [];\r\n\r\nL.gmx.addLayerClassLoader = function(layerClassLoader) {\r\n    L.gmx._layerClassLoaders.push(layerClassLoader);\r\n\r\n    //delete all loading promises to ensure that new loader will be invoked\r\n    L.gmx._loadingLayerClasses = {};\r\n};\r\n\r\nL.gmx._loadLayerClass = function(type) {\r\n    if (!L.gmx._loadingLayerClasses[type]) {\r\n        var promise = new L.gmx.Deferred();\r\n        promise.resolve();\r\n\r\n        L.gmx._layerClassLoaders.forEach(function(loader) {\r\n            promise = promise.then(function(layerClass) {\r\n                if (layerClass) {\r\n                    L.gmx._layerClasses[type] = layerClass;\r\n                    return layerClass;\r\n                }\r\n\r\n                return loader(type);\r\n            },\r\n            function(){\r\n                //just skip loader errors\r\n            });\r\n        });\r\n\r\n        promise = promise.then(function(layerClass) {\r\n            if (layerClass) {\r\n                L.gmx._layerClasses[type] = layerClass;\r\n                return layerClass;\r\n            }\r\n        }, function(){\r\n            //just skip loader errors\r\n        });\r\n\r\n        L.gmx._loadingLayerClasses[type] = promise;\r\n    }\r\n\r\n    return L.gmx._loadingLayerClasses[type];\r\n};\r\n\r\nL.gmx.loadLayer = function(mapID, layerID, options) {\r\n\r\n    var promise = new L.gmx.Deferred(),\r\n        layerParams = {\r\n            mapID: mapID,\r\n            layerID: layerID\r\n        };\r\n\r\n    options = options || {};\r\n\r\n    for (var p in options) {\r\n        layerParams[p] = options[p];\r\n    }\r\n\r\n    var hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n    layerParams.hostName = hostName;\r\n\r\n    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(\r\n        function() {\r\n            var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\r\n\r\n            if (!layerInfo) {\r\n                promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\r\n                return;\r\n            }\r\n\r\n            //to know from what host the layer was loaded\r\n            layerInfo.properties.hostName = hostName;\r\n\r\n            var type = layerInfo.properties.ContentID || layerInfo.properties.type;\r\n\r\n            var doCreateLayer = function() {\r\n                var layer = L.gmx.createLayer(layerInfo, layerParams);\r\n                if (layer) {\r\n                    promise.resolve(layer);\r\n                } else {\r\n                    promise.reject('Unknown type of layer ' + layerID);\r\n                }\r\n            };\r\n\r\n            if (type in L.gmx._layerClasses) {\r\n                doCreateLayer();\r\n            } else {\r\n                L.gmx._loadLayerClass(type).then(doCreateLayer);\r\n            }\r\n        },\r\n        function(response) {\r\n            promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\r\n        }\r\n    );\r\n\r\n    return promise;\r\n};\r\n\r\nL.gmx.loadLayers = function(layers, globalOptions) {\r\n    var defs = layers.map(function(layerInfo) {\r\n        var options = L.extend({}, globalOptions, layerInfo.options);\r\n        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\r\n    });\r\n\r\n    return L.gmx.Deferred.all.apply(null, defs);\r\n};\r\n\r\nL.gmx.loadMap = function(mapID, options) {\r\n    options = L.extend({}, options);\r\n    options.hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n\r\n    var def = new L.gmx.Deferred();\r\n\r\n    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function(mapInfo) {\r\n        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\r\n\r\n        loadedMap.layersCreated.then(function() {\r\n            if (options.leafletMap || options.setZIndex) {\r\n                var curZIndex = 0,\r\n                    layer, rawProperties;\r\n\r\n                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\r\n                    layer = loadedMap.layers[l];\r\n\t\t\t\t\trawProperties = layer.getGmxProperties();\r\n\t\t\t\t\tif (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\r\n                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\r\n                    }\r\n                    if (options.setZIndex && layer.setZIndex) {\r\n                        layer.setZIndex(++curZIndex);\r\n                    }\r\n\r\n                    if (options.leafletMap && rawProperties.visible) {\r\n                        layer.addTo(options.leafletMap);\r\n                    }\r\n                }\r\n            }\r\n            def.resolve(loadedMap);\r\n        });\r\n    },\r\n    function(response) {\r\n        var errorMessage = (response && response.ErrorInfo && response.ErrorInfo.ErrorMessage) || 'Server error';\r\n        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\r\n    });\r\n    return def;\r\n};\r\n\r\nL.gmx.DummyLayer = function(props) {\r\n    this.onAdd = this.onRemove = function() {};\r\n    this.getGmxProperties = function() { return props; };\r\n};\r\n\r\nL.gmx.createLayer = function(layerInfo, options) {\r\n    if (!layerInfo) { layerInfo = {}; }\r\n    if (!layerInfo.properties) { layerInfo.properties = {type: 'Vector'}; }\r\n\r\n    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\r\n        layer;\r\n\r\n\t\tif (type in L.gmx._layerClasses) {\r\n        try {\r\n            layer = new L.gmx._layerClasses[type](options);\r\n            layer = layer.initFromDescription(layerInfo);\r\n        } catch (e) {\r\n            layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n        }\r\n    } else {\r\n        layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n    }\r\n\r\n    return layer;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/LayerFactory.js"],"sourceRoot":""}