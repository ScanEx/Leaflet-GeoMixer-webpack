{"version":3,"sources":["webpack:///dist/geomixer.js","webpack:///webpack/bootstrap 40e73fdd0b5a98990589","webpack:///./src/includes.js","webpack:///./src/Parsers.js","webpack:///./src/Deferred.js","webpack:///./src/ImageLoader.js","webpack:///./src/Utils.js","webpack:///./src/DrawCanvas.js","webpack:///./src/SessionManager.js","webpack:///./src/MapManager.js","webpack:///./src/GeomixerMap.js","webpack:///./src/DataManager/DataManager.js","webpack:///./src/DataManager/VectorTile.js","webpack:///./src/DataManager/VectorTileLoader.js","webpack:///./src/EventsManager.js","webpack:///./src/Locale.js","webpack:///./src/lang_ru.js","webpack:///./src/lang_en.js","webpack:///./src/DataManager/Observer.js","webpack:///./src/DataManager/TilesTree.js","webpack:///./src/Layer/VectorLayer.js","webpack:///./src/Layer/StyleManager.js","webpack:///./src/Layer/ScreenVectorTile.js","webpack:///./src/Layer/ObjectsReorder.js","webpack:///./src/Layer/VectorLayer.Popup.js","webpack:///./src/Layer/VectorLayer.Hover.js","webpack:///./src/Layer/LayersVersion.js","webpack:///./src/Layer/RasterLayer.js","webpack:///./src/Layer/LabelsLayer.js","webpack:///./src/Layer/ClipPolygon.js","webpack:///./src/Layer/ImageTransform.js","webpack:///./src/Layer/ProjectiveImageWebGL.js","webpack:///./src/Layer/ProjectiveImage.js","webpack:///./src/Layer/external/RotatedMarker.js","webpack:///./src/Layer/external/ExternalLayer.js","webpack:///./src/Layer/external/BindWMS.js","webpack:///./src/Layer/external/HeatMap.js","webpack:///./src/Layer/external/MarkerCluster.js","webpack:///./src/LayerFactory.js","webpack:///./src/Layer/external/GmxVirtualTileLayer.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_MapManager","_Observer","_DataManager","L","gmx","gmxMapManager","observer","options","Observer","DataManager","regexExpression","regexMath","Parsers","functionFromExpression","s","Function","replace","makePair","t1","t2","head","tail","LinkedList","ParserState","fail","failed","state","advance","n","token","tok","len","length","substr","caseInsensitiveToken","toLowerCase","range","startChar","endChar","startCode","charCodeAt","endCode","code","anythingExcept","parser","sequence","parsers","i","choice","newState","nothing","maybe","repeat","minCount","count","separatedList","separator","parser1","whitespace","whitespaceSeparatedList","whitespaceSeparatedSequence","newParsers","push","capture","action","func","oldState","fieldName","fieldNameWithSpaces","quotedFieldName","stringLiteral","digits","numberLiteral","literal","applyParser","opTerm","op","referenceValue","matchPattern","toUpperCase","fieldValue","_matchFrom","referenceIdx","fieldIdx","referenceChar","charAt","fieldChar","props","indexes","types","rValue","gmxUtil","getUnixTimeFromStr","f1","f2","parseFloat","inTerm","node","value","_term","_expression","notTerm","innerTerm","andExpression","flag","orExpression","whereClause","parseSQL","str","result","_additiveExpression","_multiplicativeExpression","pos","term","multiplicativeTerm","res","Math","floor","arithmeticExpression","parseExpression","svgPath","coords","reverse","parseSVGPath","Deferred","cancelFunc","fulfilledData","resolveCallbacks","rejectCallbacks","isFulfilled","isResolved","onceAdded","isCancelled","fulfill","this","_fulfill","resolved","callbacks","slice","arguments","forEach","callback","apply","resolve","concat","reject","cancel","then","resolveCallback","rejectCallback","userFuncDef","def","fulfillFunc","once","onceResolveCallback","always","getFulfilledData","all","defArray","resdef","left","results","Array","ImageRequest","url","_id","imageLoader","_cancelRequest","bind","remove","_removeRequestFromCache","GmxImageLoader","Class","extend","includes","Mixin","Events","statics","MAX_COUNT","initialize","curCount","requests","inProgress","requestsCache","uniqueID","_resolveRequest","request","image","canceled","cache","cacheItem","cacheKey","fire","_imageLoaded","resolveRequest","it","loaderStatus","_nextLoad","shift","k","splice","_loadImage","width","imageObj","Image","_this","crossOrigin","onload","onerror","src","loadingImg","Util","falseFn","emptyImageUrl","_clearCacheItem","Object","keys","_add","atBegin","unshift","defineProperty","_typeof","Symbol","iterator","obj","constructor","prototype","gmxAPIutils","lastMapId","newId","uniqueGlobalName","thing","window","isPageHidden","document","hidden","msHidden","webkitHidden","mozHidden","normalizeHostname","hostName","parsedHost","parseUri","host","directory","substring","getLayerItemFromServer","query","field","req","WrapStyle","geometry","layer","layerID","border","requestJSONP","serverBase","getCadastreFeatures","latlng","text","lat","lng","tolerance","getFormData","json","arr","key","val","JSON","stringify","join","params","script","createElement","setAttribute","callbackParamName","urlParams","syncParams","callbackName","paramsStringItems","encodeURIComponent","indexOf","e","parentNode","removeChild","getElementsByTagName","item","appendChild","getXmlHttp","xmlhttp","XMLHttpRequest","ActiveXObject","E","ph","xhr","open","type","async","headers","setRequestHeader","reqId","withCredentials","onreadystatechange","readyState","status","responseText","onError","getSyncParams","send","Error","tileSizes","getTileNumFromLeaflet","tilePoint","zoom","z","pz","pow","tx","x","ty","y","getTilePosZoomDelta","zoomFrom","zoomTo","dz","size","dx","dy","zDelta","geoItemBounds","geo","bounds","boundsArr","coordinates","b","arr1","j","len1","extendBounds","getUnFlattenGeo","isLikePolygon","coordsOut","isPolygon","ring","unFlattenRing","cnt","geoFlatten","flattenRing","CurArray","Float64Array","isRectangle","getGeometryBounds","pt","getMarkerPolygon","min","max","getQuicklookPointsFromProperties","pArr","tileAttributeIndexes","points","x1","getPropItem","quicklookX1","y1","quicklookY1","x2","quicklookX2","y2","quicklookY2","x3","quicklookX3","y3","quicklookY3","x4","quicklookX4","y4","quicklookY4","quicklookPlatform","merc","Projection","Mercator","project","latLng","getPropertiesHash","properties","dec2rgba","a","r","g","dec2hex","toString","dec2color","oneDay","isTileKeysIntersects","tk1","tk2","t","rotatePoints","angle","iconScale","center","out","PI","sin","cos","getPatternIcon","style","fillPattern","notFunc","pattern","prop","step","patternDefaults","minWidth","maxWidth","minStep","maxStep","patternStepFunction","patternWidthFunction","fillOpacity","opacityFunction","rgb","colors","resColors","col","patternColorsFunction","delta","allSize","rad","hh","ww","flagRotate","console","log","alert","canvas","height","ptx","getContext","clearRect","translate","rotate","beginPath","fillStyle","xx1","moveTo","lineTo","arc","fillRect","closePath","fill","canvas1","ptx1","drawImage","getSVGIcon","svg","Path","SVG_NS","stroke","strokeStyle","strokeWidth","lineWidth","iconOptions","className","iconSize","fillRadialGradient","stopColor","colorStop","addColorStop","html","DivIcon","toPixels","tpx","tpy","mInPixel","px1","py1","getPixelPoint","attr","currentStyle","parsedStyleKeys","iconCenter","sx","sy","weight","iconAnchor","px","py","worldWidthMerc","getImageData","img","isIE9","isIE10","data","DEFAULT_REPLACEMENT_COLOR","isIE","v","getIEversion","gtIE","ua","navigator","userAgent","msie","parseInt","trident","rv","edge","replaceColor","color","fromData","imageData","createImageData","toData","putImageData","drawIconPath","path","isArray","ctx","trFlag","radian","rotateRes","degRad","setTransform","pointToCanvas","pointAttr","px1sx","py1sy","iconPath","iconColor","globalAlpha","opacity","transformFlag","fillColor","circle","rgr","r2","radgrad","createRadialGradient","r1","strokeRect","lineToCanvasAsIcon","pixels","getLineDash","setLineDash","lineToCanvas","lastX","lastY","getCoordsPixels","hiddenLines","hiddenFlag","hash","coords1","hiddenLines1","pixels1","hidden1","j1","getRingPixels","currentZoom","cntHide","vectorSize","lineIsOnEdge","round","polygonToCanvas","polygonToCanvasFill","isPatternNode","HTMLCanvasElement","HTMLImageElement","labelCanvasContext","getLabelWidth","txt","font","split","map","fillText","measureText","setLabel","coord","shadowColor","shadowBlur","strokeText","rMajor","ang","distVincenty","lon1","lat1","lon2","lat2","p1","lon","p2","f","L1","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","lambda","lambdaP","iterLimit","abs","sinLambda","cosLambda","sinSigma","sqrt","cosSigma","sigma","atan2","sinAlpha","cosSqAlpha","cos2SigmaM","isNaN","C","NaN","uSq","A","B","deltaSigma","_vfi","fi","getCircleLatLngs","LatLng","R","d","Rd","VR","latlngs","limit","acos","asin","parseCoordinates","crs","regex","exec","match","ii","mul","SphericalMercator","unproject","Point","_divideBy","pad2","trunc","formatDegrees","format","a1","a2","a3","toPrecision","st","undefined","latLonFormatCoordinates","formatCoordinates","latLonFormatCoordinates2","formatCoordinates2","getPixelScale","forEachPoint","ret","getItemCenter","geoItems","isPoint","geom","dataOption","bbox","contains","len2","getHSegmentsInPolygon","poly","isGt1","isGt2","sort","index","segArr","isPointInPolygonArr","chkPoint","isIn","xmin","xmax","ymax","xinters","isPointInPolygonWithHoles","isClockwise","area","isPointInPolyLine","lineHeight","nullPoint","minx","maxx","miny","maxy","sqDist","LineUtil","_sqClosestPointOnSegment","isPointInLines","point","getLength","isMerc","prettifyDistance","km","gmxLocale","getText","geoJSONGetLength","geoJSON","geometries","features","getRingLength","lnglat","geoJSONGetArea","getRingArea","geoJSONGetLatLng","ipp","lambertCoefX","lambertCoefY","getArea","prettifyArea","km2","geoLength","geometryToGeoJSON","mercFlag","coordsFromMercator","convertGeometry","fromMerc","coordsToMercator","geoJSONtoGeometry","_coordsConvert","toMerc","resCoords","transformGeometry","geoArea","getGeoJSONSummary","unitOptions","units","squareUnit","distanceUnit","getCoordinatesString","num","formats","CRS","EPSG3857","getGeometriesSummary","coordinatesFormat","getGeometrySummary","chkOnEdge","ext","getHidden","tb","prev","getNormalizeBounds","screenBounds","mercDeltaY","northWest","getNorthWest","southEast","getSouthEast","minX","maxX","w","minX1","maxX1","m1","m2","m11","m12","prec","zn","getTileBounds","tileSize","parseTemplate","matches","key1","getDefaultBalloonTemplate","tileAttributeTypes","parseBalloonTemplate","attrToString","summary","styleKeys","marker","server","client","outline","label","styleFuncKeys","iconAngle","styleFuncError","defaultStyles","MinZoom","MaxZoom","Filter","Balloon","DisableBalloonOnMouseMove","DisableBalloonOnClick","RenderStyle","linestring","polygon","getDefaultStyle","from","toServerStyle","fromServerStyle","newKey","Number","trim","Date","UTC","getDateFromStr","dt","getUTCdate","utime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCtime","h","getUTCdateTime","time","getTileAttributes","attributes","attrs","attrTypes","identityField","Bounds","MAX_VALUE","extendArray","addBuffer","dxmin","dymin","dxmax","dymax","getCenter","addOffset","offset","intersects","min2","max2","intersectsWithDelta","isEqual","isNodeIntersect","clipPolygon","cp1","cp2","clip","inside","intersection","dc","dp","n1","n2","n3","outputList","inputList","clipPolyLine","angleFlag","codeB","lastCode","bitCode","getAngle","intersect","codeA","part","o","strictMode","uri","q","name","$0","$1","$2","hostOnly","authority","strict","loose","isIE11","gtIE11","createPostIframe2","uniqueId","lastRequestId","iframe","DomUtil","create","display","parsedURL","origin","protocol","location","processMessage","dataStr","decodeURIComponent","dataObj","parse","ev","Status","ErrorInfo","ErrorMessage","ExceptionType","StackTrace","CallbackName","DomEvent","on","sendCrossDomainPostRequest","baseForm","form","originalFormAction","getAttribute","target","Browser","ielt9","hiddenParamsDiv","paramName","input","body","submit","removeAttribute","_Utils","styleCanvasKeys","styleCanvasKeysLen","setCanvasStyle","valKey","dashArray","dashes","dashOffset","lineDashOffset","lineCap","lineJoin","canvasPattern","createPattern","fillLinearGradient","x1Function","y1Function","x2Function","y2Function","lineargrad","createLinearGradient","arrFunc","addColorStopFunctions","p0","drawGeoItem","geoItem","propsArr","idr","rasters","tbounds","styleHook","styleExtend","lastHover","geoType","dattr","lastImage","lastImageData","pixelsMap","flagPixels","coordsToCanvas","flagFill","bgImage","skipRasters","imagePattern","rasterOpacity","maxSize","save","restore","gmxSessionManager","APIKEY_PARAM","SCRIPT_REGEXP","_scriptSearched","_scriptAPIKey","_searchScriptAPIKey","scripts","parsedParam","requestSessionKey","serverHost","apiKey","_sessionKeys","Key","response","Result","getSessionKey","keyPromise","getMap","mapName","skipTiles","maps","_maps","promise","sessionKey","MapName","ModeKey","setSyncParams","stringFlag","findLayerInfo","mapID","hostMaps","mapInfo","layers","serverData","iterateLayers","layerInfo","treeInfo","iterate","content","children","iterateNode","gmxMap","commonLayerOptions","layersByTitle","layersByID","dataManagers","BaseLayers","rawTree","layersCreated","missingLayerTypes","dataSources","meta","MetaProperties","ContentID","layerOptions","dataSource","parentLayer","Value","info","_layerClasses","addLayer","createLayer","loaders","_loadLayerClass","hosts","opt","pId","pLayer","parentOptions","getGmxProperties","dataManager","prefix","Layer","Layers","ids","addDataManager","DummyLayer","pid","getDataManager","title","removeLayer","addLayersToMap","leafletMap","l","visible","_VectorTile","_VectorTileLoader","ObserverTileLoader","_dataManager","_observerData","_tileData","addObserver","tiles","leftToLoad","loadingState","_updateObserver","removeObserver","obsTiles","tileId","observers","addTile","tile","leftToLoadDelta","loadDef","_tileLoadedCallback","tileObservers","obsInfo","intersectsWithTile","vectorTileKey","removeTile","tileData","observerData","startLoadTiles","_getActiveTileKeys","obsData","load","getTileObservers","getObserverLoadingState","newObserverTiles","tilesVers","LayerVersion","GeoProcessing","Temporal","TemporalColumnName","ZeroDate","TemporalPeriods","TemporalTiles","TemporalVers","isGeneralized","isFlatten","setOptions","_clearProcessing","processingTile","addData","_chkProcessing","optionsLink","_isTemporalLayer","tileAttributes","tileSenderPrefix","_needCheckActiveTiles","_vectorTileDataProviderLoad","gmxVectorTileLoader","dataProvider","clearVersion","_tilesTree","_activeTileKeys","_endDate","_beginDate","_tiles","_filters","_freeSubscrID","_items","_observers","_needCheckDateInterval","_vectorTileDataProvider","_observerTileLoader","event","_updateItemsFromTile","treeNode","getNode","isActive","needRefresh","updateData","getItems","addFilter","unixTimeStamp","dates","dateInterval","beginDate","valueOf","endDate","_chkMaxDateInterval","newTileKeys","initTilesTree","selectTiles","_updateActiveTilesList","initTilesList","_getObserversByFilterName","filterName","oKeys","hasFilter","filterFunc","_triggerObservers","removeFilter","oId","resItems","filters","filter","putData","dataOptions","getItem","isFiltered","tileKey","activeTileKeys","tkey","geomIndex","processing","currentFilter","fromTiles","getMaxDateInterval","newBeginDate","newEndDate","temporalFilter","_waitCheckObservers","checkObserver","getActiveObserversCount","getObserver","getItemsBounds","_itemsBounds","getItemMembers","members","objIndex","getItemGeometries","geomItems","checkObservers","_checkObserversTimer","clearTimeout","setTimeout","_removeDataFromObservers","removeData","preloadTiles","dateBegin","dateEnd","tileKeys","loadingDefs","_getVectorTile","newTilesList","_tileFilteringHook","filteredTilesList","tk","oldTilesList","observersToUpdate","_rasterVectorTile","checkSubscription","vKey","observerIds","sid","_propertiesToArray","fromServerProps","clear","needProcessingFilter","skip","Deleted","Inserted","Updated","enableGeneralization","_resetTilesTree","disableGeneralization","updateVersion","_getDataKeys","chkKeys","_getProcessingTile","VectorTile","vTile","dataBounds","tilesTree","dateZero","createFlag","parseTileKey","_addVectorTile","_getGeneralizedTileKeys","vTilePoint","temp","gKey","newActiveTileKeys","tKey","tHash","vers","generalizedKeys","newTiles","createTileKey","gKeys","gPoint","setTileFilteringHook","filteringHook","removeTileFilteringHook","gmxTilePoint","makeTileKey","_parseItem","needFlatten","edgeBounds","edgeArr","gmxTileKey","boundsFromTileKey","_loadedTiles","_getKey","ti","tileInfo","requestParams","LayerName","Level","Span","gmxAPI","_vectorTileReceiver","level","span","values","GmxEventsManager","Handler","_map","_layers","_lastLayer","_lastId","_drawstart","_lastCursor","isDrawing","gmxControlsManager","drawingControl","get","activeIcon","_container","cursor","getDomIndex","container","childNodes","skipNodeName","IMG","DIV","clearLastHover","gmxEventCheck","eventCheck","skipNode","originalEvent","gmxMouseDown","webkit","which","buttons","nodeName","hasClass","_animatingZoom","_skipClick","layerPoint","_gmxMouseLatLng","gmxMousePos","getPixelOrigin","add","la","lb","oa","ob","za","zIndexOffset","zIndex","zb","foundLayer","_animating","clickable","hasEventListeners","zoomend","click","dblclick","mousedown","mouseup","mousemove","contextmenu","layeradd","_leaflet_id","layerremove","Map","addInitHook","_gmxEventsManager","isGmxDrawing","removeHooks","DEFAULT_LANGUAGE","_setKeyText","lang","setLanguage","_language","getLanguage","language","gmxLocaleMixin","addText","newHash","k1","locale","keyArr","rus","Coordinates","Length","nodeLength","edgeLength","Area","Perimeter","nm","ha","m2html","km2html","eng","_callback","targetZoom","active","setBounds","bbox1","world","_setDateInterval","activate","deactivate","toggleActive","prevItems","newItems","added","removed","items","latLngBounds","sw","getSouthWest","ne","getNorthEast","minY","maxY","di","setDateInterval","isValid","TilesTree","_rootNodes","periods","maxPeriod","smin","getTime","getTimezoneOffset","zeroUT","pd","childrenCount","sChild","ds","pdOneDay","dmax","dmaxOneDay","cs","t1Val","t2Val","minLevel","dateIntervalLength","maxLevel","getCountOfIntersected","tileBounds","selectTilesForNode","nodes","childrenRes","intersectCount","resTilesArr","resNodesArr","resTiles","nodeSelection","resTilesHash","findNode","_StyleManager","_ScreenVectorTile","VectorLayer","TileLayer","Canvas","openPopups","minZoom","useWebGL","initPromise","_drawQueue","_drawQueueHash","_drawInProgress","_anyDrawings","repaintObservers","_gmx","sortItems","styles","tileSubscriptions","_tilesToLoad","shiftXlayer","shiftYlayer","renderHooks","preRenderHooks","_needPopups","_clearTileSubscription","zKey","_removeTile","tileLink","el","onAdd","EPSG3395","shiftY","applyShift","getZoom","styleManager","initStyles","_zoomStart","_zoomEnd","_moveEnd","pointerEvents","balloonEnable","_popup","bindPopup","_onStyleChange","_onVersionChange","layersVersion","onRemove","off","viewreset","_reset","moveend","_update","_animated","zoomanim","_animateZoom","_endZoomAnim","updateWhenIdle","_limitedUpdate","_clearAllSubscriptions","_initContainer","_prpZoomData","setZIndexOffset","_updateZIndex","isExternalVisible","_zoom","deferred","__update","_addTile","myLayer","layerType","isVisibleAtZoom","_tileLoaded","_tileCoordsToKey","isDrawnFirstTime","done","getStyleBounds","_drawTileAsync","_chkDrawingState","_getLoadedTilesPercentage","_tileComplete","addClass","_tileContainer","_setClearBgBuffer","_tileOnLoad","_tileOnError","tileDrawn","_getTiledPixelBounds","shiftPoint","shiftX","pixelCenter","_tileZoom","_floor","halfSize","getSize","divideBy","subtract","_pxBoundsToTileRange","_round","initFromDescription","_initDone","worldSize","rawProperties","_updateProperties","StyleManager","maxZoom","chkUpdate","_objectsReorderInit","clusters","bindClusters","redraw","setRasterOpacity","repaint","getStyles","getIcons","setStyles","clearStyles","setStyle","getStyle","setStyleHook","removeStyleHook","setRasterHook","rasterProcessingHook","removeRasterHook","setFilter","maxShownPeriod","msecPeriod","gmxSkipTiles","UseTiles","now","getDateInterval","setPositionOffset","getPositionOffset","zKeys","redrawItem","gmxTiles","_getTilesByBounds","gmxGetCanvasTile","_getTile","current","_tilePoint","appendTileToContainer","tilePos","_getTilePos","setPosition","chrome","android23","getStylesByProperties","propArray","getCurrentFilters","getItemStyle","getObjStyle","getTileAttributeTypes","getTileAttributeIndexes","getItemBalloon","getItemProperties","addPreRenderHook","renderHook","removePreRenderHook","hook","addRenderHook","removeRenderHook","getBounds","proj","gmxBounds","LatLngBounds","getGeometry","latLngGeometry","subscription","screenTile","destructor","zoomstart","setCurrentZoom","unbindPopup","_updateZoomLevels","labelsLayer","_labelsLayer","parsedKey","_removeInProgressDrawing","queue","isEmpty","drawNextTile","queueItem","drawDef","_gmxDrawTile","tp","gtp","elem","_updateShiftY","deltaY","zd","_clearBgBufferTimer","_bgBuffer","_clearBgBuffer","_getNeedPopups","pixelBounds","tileRange","_getWrapTileNum","_chkTileSubscriptions","_getScreenTile","ScreenVectorTile","cancelled","screenTileDrawPromise","drawTile","minLatLng","maxLatLng","getPixelBounds","minPoint","maxPoint","apikeyRequestHost","GeometryType","minZoomRasters","RCMinZoomForRasters","minZoomQuicklooks","ZIndexField","zIndexField","_objectsReorder","shiftXfield","shiftYfield","multiFilters","IsRasterCatalog","layerLink","GMX_RasterCatalogID","rasterBGfunc","Quicklook","quicklookParams","template","X1","Y1","X2","Y2","X3","Y3","X4","Y4","quicklookBGfunc","reg","imageQuicklookProcessingHook","gmxImageTransform","attribution","Copyright","getViewRasters","itemsView","propArr","_maxVersion","_maxStyleSize","_styles","_deferredIcons","_parserFunctions","_serverStylesParsed","Infinity","_getMaxStyleSize","_needLoadIcons","MAX_STYLE_SIZE","maxShift","mercSize","HoverStyle","_chkReady","_chkStyleFilter","_parseServerStyles","_getImageSize","getStyleKeys","filterFunction","version","common","_changeStylesVersion","_prepareItem","DEFAULT_KEYS","_parseStyle","_checkStyles","templateBalloon","isSummary","test","hoverDiff","styleVersion","parsedStyleHover","_itemStyleParser","iconUrl","fillIconUrl","offsetWidth","offsetHeight","scaleFunction","rotateFunction","toFixed","fnum","curr","needParse","_lastZoom","parsed","parsedHover","styleHover","parsedStyle","DEFAULT_STYLE","gmxStyle","hoveredStyle","thickness","_isLabel","BalloonEnable","checkDiff","renderStyle","fkey","parsePattern","iconCircle","DEFAULT_ICONPATH","parseRadialGradient","parseLinearGradient","labelTemplate","labelField","itemType","iconColorFunction","r1Function","r2Function","r2max","p3","_radialGradientParsed","sizeFunction","colorFunction","fop","fc","fcDec","fillColorFunction","fillOpacityFunction","labelText","labelAnchor","rt","st1","rg","resFunc","lg","utils","showRaster","rasterRequests","_uniqueID","badTiles","_loadTileRecursive","urlFunction","currentUrl","requestPromise","tryLoad","rUrl","tryHigherLevelTile","maxNativeZoom","tileRastersId","_rasterHook","source","sourceTilePoint","destinationTilePoint","destination","quicklook","_defaultRasterHook","sh","dw","dh","_getShiftPixels","_getShiftTilesArray","deltaX","tminX","tminY","rminX","rmaxX","rminY","rmaxY","_getItemRasters","recursiveLoaders","mainRasterLoader","isShift","urlBG","itemImageProcessingHook","isTiles","resCanvas","imageItem","itemRasterPromise","tileToLoadPoints","chkReadyRasters","skipRasterFunc","onLoadFunction","isImage","posInfo","hookResult","resImage","loader","loadResult","imageLoaded","imgAttr","prepareItem","imageElement","_getVisibleItems","_tileCanvas","dm","imageSmoothingEnabled","_getNeedRasterItems","platform","_getTileRasters","itemPromises","itemRasters","needLoadRasters","_chkItems","tLink","getSortedItems","_cancelRastersPromise","rastersPromise","drawPromise","currentDrawPromise","_preRenderPromise","_renderPromise","_drawDone","_zKey","doDraw","hookInfo","hookBgImage","hover","hookTile","_clearCache","MAX","ObjectsReorder","userSetSortFunc","sortFunc","disabled","addToReorder","bottomFlag","clickFunc","ctrlKey","reorder","ap","bp","resetSortFunc","include","getReorderArrays","top","bottom","bringToTopItem","bringToBottomItem","clearReorderArrays","setReorderArrays","setSortFunc","disableFlip","enableFlip","popupOptions","layerId","Popup","setContent","_initContent","_state","_popupHandlersAdded","_openClickPopup","_movePopup","_overPopup","_outPopup","_chkNeedOpenPopup","popupopen","_popupopen","updateLayout","_updateLayout","addPopup","disablePopup","_popupDisabled","enablePopup","openPopup","_latlng","_latlngs","_openPopup","closePopup","_close","popup","_gmxID","_setPopupContent","setLatLng","prevId","_callBalloonHook","div","spans","hooksCount","_balloonHook","hookID","fid","notFound","balloonData","skipSummary","outItem","nodePoint","protoOffset","contentNode","_contentNode","containerPoint","HTMLElement","resStr","contentDiv","innerHTML","getContent","altKey","shiftKey","layerProp","notSkip","_gmxPopups","maxPopupCount","_gmxPopupsInit","_clearPopup","reduce","closeOnClick","autoPan","objectId","addTo","_closeButton","closeStyle","visibility","marginBottom","flagPopup","getPopups","getHoverOption","addPopupHook","stamp","removePopupHook","_gmxFirstObjectsByPoint","mercPoint","radius","objBounds","chktype","pBounds","isPointInClipPolygons","skipOver","chkHover","evType","fromType","_subtract","mercatorPoint","observerOptions","changed","targets","lastMouseover","doubleClickZoom","disable","enable","delay","dataManagersLinks","intervalID","timeoutID","lastLayersStr","isExistsTiles","tilesKey","getParams","layerDateInterval","Name","Version","maxDateInterval","getRequestParams","skipItems","isDataManager","chkVersion","processResponse","curLayer","chkHost","layersStr","Content-type","timeStamp","_stampVersionRequest","removeDataManager","pOptions","_chkVersion","start","stop","clearInterval","msec","setInterval","layerDescription","RasterLayer","vectorProperties","vectorDataProvider","objects","itemBounds","ww2","bboxArr","it1","it2","setZoomBounds","LabelsLayer","pane","_styleManagers","_labels","chkData","labels","fieldType","String","arrTxtWidth","fontSize","labelFontSize","labelStyle","labelHaloColor","labelColor","labelAlign","pstyle","_updateBbox","_layeradd","_layerremove","_frame","requestAnimFrame","_redraw","_addToPane","getPanes","insertBefore","_canvas","firstChild","_initCanvas","zoomAnimation","any3d","animated","southWest","northEast","_ctxShift","mapSize","latLngToContainerPoint","topLeft","containerPointToLayerPoint","w2","width2","size2","scale","getZoomScale","pixelBoundsMin","_getCenterOffset","_multiplyBy","_getMapPanePos","multiplyBy","TRANSFORM","getTranslateString","isBoundsIntersects","clipPolygons","isObserverIntersects","_isPointInClipPolygons","j2","len3","getClipPolygonItem","clipTileByPolygon","i1","_clipPolygons","addClipPolygon","Polygon","toGeoJSON","GeoJSON","getLayers","feature","MultiPolygon","removeClipPolygon","boundsP","itbounds","wMerc","shiftPoints","ProjectiveImage","projectiveImageWebGL","projectiveImage","getCanvas","wView","hView","adj","multmm","cij","multmv","basisToPoints","ProjectiveImageWebGL","antialias","depth","preserveDrawingBuffer","shaderVS","shaderFS","glOpts","gl","glResources","_setupGlContext","_getShader","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","vertices","Float32Array","vertexBuffer","createBuffer","vertAttrib","getAttribLocation","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","transMatUniform","getUniformLocation","samplerUniform","screenTexture","createTexture","_bindTexture","texture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","dstPoints","Utils","general2DProjection","viewport","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","uniformMatrix4fv","activeTexture","TEXTURE0","uniform1i","drawArrays","TRIANGLE_STRIP","to","getWebGlResources","patchSize","transform","allocate","Matrix","cloneValues","clone","operand","transformProjectiveVector","iz","multiply","accum","rowEchelon","yp","pivot","ys","tmpRow","factor","invert","getProjectiveTransform","eqMatrix","kernel","divide","u1","v1","u4","v4","p4","d1","d2","d3","umid","vmid","pmid","pb","pl","pr","d12","d24","d43","d31","a4","amax","padx","pady","du","dv","iw","ih","ptl","ptr","pbl","pbr","RotatedMarker","Marker","TRANSFORM_ORIGIN","testProp","_initIcon","_icon","_getTransformOrigin","icon","_setPos","ie","costheta","sintheta","setAngle","rotatedMarker","ExternalLayer","createExternalLayer","_observer","useDataManager","_addEvent","_addObserver","externalLayer","unbindLayer","_onRemove","_removeMapHandlers","_addMapHandlers","_chkZoom","_isParentLayer","fromMapFlag","hasLayer","isExtLayerOnMap","BindWMS","transparent","poptions","_extendOptionsByDateInterval","apikey","tileLayer","wms","StartDate","toLocaleDateString","EndDate","wmsParams","bindWMS","_layerWMS","unbindWMS","GmxHeatMap","minHeatMapZoom","maxHeatMapZoom","intensityField","intensityScale","heatLayer","altIndex","alt","setLatLngs","bindHeatMap","_heatmap","unbindHeatMap","_DEFAULTS","radiusFunc","stroke-width","text-anchor","GmxMarkerCluster","spiderfyOnMaxZoom","mOptions","showCoverageOnHover","disableClusteringAtZoom","clusterIconOptions","radialGradient","iconCreateFunction","cluster","childCount","getChildCount","clusterclick","zoomToBoundsOnClick","markers","MarkerClusterGroup","currentSpiderfiedCluster","getAllChildMarkers","unspiderfy","eventFrom","originalEventType","spiderfy","vectorTileItem","removeLayers","mPoint","notClusteredIcon","Icon","addLayers","openOn","_clusters","unbindClusters","DEFAULT_HOSTNAME","DEFAULT_VECTOR_LAYER_ZINDEXOFFSET","Raster","Vector","VectorView","_loadingLayerClasses","addLayerClass","layerClass","_layerClassLoaders","addLayerClassLoader","layerClassLoader","loadLayer","layerParams","doCreateLayer","error","loadLayers","globalOptions","defs","loadMap","loadedMap","setZIndex","curZIndex","LayerOrder","errorMessage","GmxVirtualTileLayer","urlTemplate","isMercator","GmxVirtualWMSLayer","WMS_OPTIONS","WMS_OPTIONS_PROCESSORS","baseURL","balloonTemplate","lastOpenedPopup","WMS","I","J","getTileUrl","fetch"],"mappings":"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U,UM9iCU,WN+iCN,MM/iC8B,INijClClY,UMhjCU,WNijCN,MMjjC8B,INmjClCiI,UMljCU,WNmjCN,MMnjCiC,MNqjCrCE,QMpjCQ,WNqjCJ,MMrjC4B,INujChC/G,YMtjCY,WNujCR,MMvjCkC,INyjCtCyF,MMxjCM,WNyjCF,MMzjC6B,MN2jCjCwB,UM1jCU,WN2jCN,MM3jCiC,ON8jCzC+P,eACIC,QM3jCF,EN4jCEC,QM3jCF,GN4jCEC,OM3jCF,GN4jCEC,QM3jCF,GN4jCEC,2BM3jCF,EN4jCEC,uBM3jCF,EN4jCEC,aACIjG,OACI7L,MM3jCD,IN4jCCxB,OM3jCD,EN4jCCpB,SM1jCL,GN4jCC2U,YACI/R,MM3jCD,IN4jCCxB,OM1jCL,GN4jCCwT,SACIhS,MM3jCD,IN4jCCxB,OMvjCb,KN4jCCyT,gBM5jCgB,SAASrf,GN6jCrB,GM5jCGsf,GAAO3jB,EAAYgjB,cACnBlY,EAAM9Y,EAAE0K,UACZinB,EN6jCC,OADA7Y,GM5jCGyY,YAAcI,EAAKJ,YACvBlf,GACHyG,GN8jCA8Y,cM5jCc,SAASzY,GN8jCnB,GM7jCGL,KN+jCH,KM7jCI,GAAIvI,KAAOvC,GAAYuiB,UN+jCvB,IM7jCI,GADDljB,GAAOW,EAAYuiB,UACvBhgB,GAAS3N,EAAI,EAAGhB,EAAMyL,EAAKqjB,OAAO7uB,OAAQe,EAAIhB,EAAKgB,IAC/C,CN6jCC,GM7jCGqtB,GAAO5iB,EAAKqjB,OAChB9tB,EN6jCC,IM7jCGqtB,IAAQ9W,GACR,CAAKL,EAAIvI,KN8jCJuI,EM9jCgBvI,MNgkCpB,IM/jCGqf,GAAKzW,EACT8W,EAAa,aAATA,GAA+B,gBAATA,INgkCrBL,GM9jCJ,KNgkCA9W,EM/jCGvI,GAAKlD,EAAKojB,OAAO7tB,IACxBgtB,GNykCR,MMtkCG,cAAgBzW,KACXL,EAAI0X,SNgkCJ1X,EMhkCkB0X,WNkkCtB1X,EMjkCG0X,OAAOrc,IAAMgF,EAAM+E,WACvB,GNikCCpF,EMjkCG0X,OAAOpc,IAAM+E,EAAM+E,WAC1B,IAEJpF,GNmkCA+Y,gBMjkCgB,SAAS1Y,GNmkCrB,GMlkCGsP,GAAI7lB,EAAGhB,EAAKquB,EACZnX,GNskCCzG,KMrkCS,GNwkCb,KMrkCI,GAAI9B,KAAOvC,GAAYuiB,UACxB,CNqkCC,GMrkCGljB,GAAOW,EAAYuiB,UACvBhgB,ENqkCC,KMrkCI3N,EAAI,EAAGhB,EAAMyL,EAAKqjB,OAAO7uB,OAAQe,EAAIhB,EAAKgB,INskC1CqtB,EMrkCM5iB,EAAKqjB,OACZ9tB,GAAIqtB,IAAQ9W,KNskCPL,EMrkCGmX,GAAQ9W,EACf8W,GNwkCJ,IADAxH,EMrkCItP,EACL5I,GAAIkY,GAAsB,YAAR,mBAAAA,GAAA,YAAA/a,EAAA+a,INskCb,IMrkCI7lB,EAAI,EAAGhB,EAAMyL,EAAKojB,OAAO5uB,OAAQe,EAAIhB,EAAKgB,INukC1C,GADAqtB,EMrkCM5iB,EAAKojB,OACZ7tB,GAAIqtB,IAAQxH,GACR,CNqkCC,GMrkCGqJ,GAASzkB,EAAKqjB,OAAO9tB,GACrBgtB,EAAKnH,EACTwH,ENqkCC,IMrkCmB,gBAARL,INskCP,GMrkCG5hB,EAAY6iB,cAAciB,GNskCzB,GMrkC2B,OAAxBlC,EAAGlI,MAAM,WNskCRkI,EMrkCImC,OACRnC,OACG,CNqkCC,GMrkCG9rB,GAAO9D,EAAEC,IAAIQ,QAAQ2G,gBACzBwoB,EAAa,QAAT9rB,ENskCC8rB,EMrkCI5hB,EAAY+iB,eACpBe,KNskCIhZ,EMrkCG9K,EAAY6iB,cAAciB,IACjChuB,OAGO,YAATmsB,INskCNL,GMpkCJ,INskCA9W,GMrkCGgZ,GACPlC,GNykCZ,GMrkCGzW,EAAMqX,SNskCL/H,EMrkCItP,EACLqX,OAAI,MAAQ/H,IAAM,MAAQA,IACtB,CNqkCC,GMrkCGtU,GAAKsU,EAAGtU,IAAM,EACdC,EAAKqU,EAAGrU,IACZ,CNqkCC0E,GMrkCGoF,aAAe/J,GAAKC,GNwkC/B,MMpkCJ0E,INukCArT,mBMrkCmB,SAASgjB,GNskCxB,GMrkCHnY,GAAMtQ,EAAEgN,KAAKglB,KAAKvJ,GAAIjF,MAC1B,IN0kCO,OALAlT,GMrkCDA,EAAI,GAAGkT,MAEP,KAAsB,IAAlBlT,EAAI,GAAGzO,SNskCNyO,EMrkCJA,EACN/I,WACM0qB,KAAKC,IAAI5hB,EAAI,GAAIA,EAAI,GAAK,EAAGA,EAAI,IACrC,KNukCA6hB,eMrkCe,SAAS1J,GNskCpB,GMrkCHnY,GAAMtQ,EAAEgN,KAAKglB,KAAKvJ,GAAIjF,MAC1B,INqkCOlT,GMrkCDA,EAAI,GAAGkT,MAEP,KAAsB,IAAlBlT,EAAI,GAAGzO,SNskCNyO,EMrkCJA,EACN/I,UNskCM,IMrkCH6qB,GAAK,GAAIH,MAAK3hB,EAAI,GAAIA,EAAI,GAAK,EAAGA,EAChC,GNqkCC,OMpkCJ8hB,INukCAC,WMrkCW,SAASC,GNskChB,GMrkCGF,GAAK,GAAIH,MAEb,IAFkBK,ENukCjB,QMpkCGF,EAAGG,iBACHvkB,EAAYia,KAAKmK,EAAGI,cAAgB,GACpCxkB,EAAYia,KAAKmK,EAAGK,eACtB9hB,KACL,MNmkCA+hB,WMjkCW,SAASJ,GNkkChB,GMjkCGK,GAAI1rB,KAAKC,MAAMorB,EAAQ,MACvB5yB,EAAIuH,KAAKC,OAAOorB,EAAY,KAAJK,GAAY,IACpChyB,EAAIsG,KAAKC,MAAMorB,EAAY,KAAJK,EAE3B,GAFsCjzB,ENmkCrC,QAEAsO,EMjkCeia,KAAK0K,GACjB3kB,EAAYia,KAAKvoB,GACjBsO,EAAYia,KAAKtnB,IACnBgQ,KACL,MNgkCAiiB,eM9jCe,SAASN,GN+jCpB,GM9jCGO,GAAOP,EAAA,KNgkCV,OM9jCGO,IAEI7kB,EAAYqkB,WAAWC,GACvBtkB,EAAY0kB,WAAWJ,EAAA,QACzB3hB,KACL,KACU3C,EAAYqkB,WACtBC,IN8jCJjC,aM3jCa,SAAShe,EAAMtM,GN4jCxB,MM3jCY,SAATsM,EACOtM,EAAQ/F,EAAEwF,QAAQ6sB,WAAWtsB,GACvCA,EAAmB,SAATsM,EACAtM,EAAQ/F,EAAEwF,QAAQktB,WAAW3sB,GACvCA,EAAmB,aAATsM,GACAtM,EAAQ/F,EAAEwF,QAAQotB,eAAe7sB,GAG3CA,GN8jCJ+sB,kBM3jCkB,SAASvZ,GN4jCvB,GM3jCGpD,MACAga,IN4jCH,IM3jCG5W,EAAKwZ,WACL,CN2jCC,GM3jCGC,GAAQzZ,EAAKwZ,WACbE,EAAY1Z,EAAK0Z,WACrB,IAAI1Z,GAAK2Z,gBN4jCJ/c,EM5jC0CoD,EAAK2Z,eAAqB,EN8jCxE,KM7jCI,GAAInb,GAAI,EAAGA,EAAIib,EAAMnxB,OAAQkW,IAC9B,CN6jCC,GM7jCGxH,GAAMyiB,EACVjb,EN6jCC5B,GM7jCoB5F,GAAOwH,EAC5B,EN6jCCoY,EM7jCkB5f,GAAO0iB,EAAYA,EAAUlb,GACnD,UN+jCJ,OACIoY,mBM5jCDA,EN6jCCha,qBM3jCRA,IAGLnI,GAAYue,aAAe,IAAMve,EAAYmW,aAAa,EAAG,EAAG,IAAM,GACtEnW,EAAYwe,aAAe,IAAMxe,EAAYmW,aAAa,EAAG,EAAG,EAAG,KAAQ,IAAMld,KAAK8R,GAEtF,WN+jCK,IM7jCI,GAAIxF,GAAI,EAAGA,EAAI,GAAIA,IN8jCnBvF,EM7jCWmF,UAAUI,GAAK,mBAAqBtM,KAAKwM,IAAI,EAC5DF,MAGLvF,EAAYmlB,OAAS,SAAS7iB,GN8jCzBnI,KM7jCI4N,KN8jCApC,EM7jCEoe,OACHqB,UN6jCCvf,EM7jCEke,OAEPqB,WN6jCCjrB,KM7jCI6N,KN8jCArC,GM7jCGoe,OACJqB,UN6jCCvf,GM7jCGke,OAERqB,WN6jCCjrB,KM7jCIkrB,YACR/iB,IACDtC,EAAYmlB,OAAOplB,WN8jCdrD,OM7jCO,SAASiJ,EAAGE,GN0kCf,MMzkCGF,GAAIxL,KAAK4N,IAAIpC,IN8jCZxL,KM9jCsB4N,IAAIpC,EAAQA,GACnCA,EAAIxL,KAAK6N,IAAIrC,INgkCZxL,KMhkCsB6N,IAAIrC,EAAQA,GACnCE,EAAI1L,KAAK4N,IAAIlC,INkkCZ1L,KMlkCsB4N,IAAIlC,EAAQA,GACnCA,EAAI1L,KAAK6N,IAAInC,INokCZ1L,KMpkCsB6N,IAAInC,EAAQA,GAE1C1L,MNskCA4M,aMrkCa,SAASP,GNskClB,MMrkCMrM,MAAKkrB,cAAc7e,EAAOuB,IAAIpC,EAAGa,EAAOuB,IAAIlC,IAAKW,EAAOwB,IAAIrC,EAAGa,EAAOwB,IAChFnC,MNskCAwf,YMrkCY,SAAS/iB,GNskCjB,IMrkCIA,IAAQA,EAAIzO,ONskCZ,MMtkCoCsG,KNwkCxC,IMvkCGvF,GACJhB,CNukCC,IMvkCqB,gBAAX0O,GAAI,GNwkCV,IMvkCI1N,EAAI,EAAGhB,EAAM0O,EAAIzO,OAAQe,EAAIhB,EAAKgB,GAAK,ENwkCvCuF,KMvkCIuC,OAAO4F,EAAI1N,GAAI0N,EAAI1N,EAC3B,QNykCA,KMvkCIA,EAAI,EAAGhB,EAAM0O,EAAIzO,OAAQe,EAAIhB,EAAKgB,INwkClCuF,KMvkCIuC,OAAO4F,EAAI1N,GAAG,GAAI0N,EAAI1N,GAC9B,GNykCJ,OMtkCJuF,ONwkCAmrB,UMvkCU,SAASC,EAAOC,EAAOC,EAAOC,GN4kCpC,MAJAvrB,MMvkCI4N,IAAIpC,GACT4f,ENukCCprB,KMvkCI4N,IAAIlC,GAAK2f,GACdD,ENukCCprB,KMvkCI6N,IAAIrC,GAAK8f,GACdF,ENukCCprB,KMvkCI6N,IAAInC,GAAK6f,GAASF,GACvBD,EACHprB,MNwkCAqhB,SMvkCS,SAAU8B,GNykCf,GMxkCGvV,GAAM5N,KAAK4N,IAAKC,EAAM7N,KAAK6N,IAC3BrC,EAAI2X,EAAM,GAAIzX,EAAIyX,EACtB,EN0kCC,OM1kCM3X,IAAKoC,EAAIpC,GAAKA,GAAKqC,EAAIrC,GAAKE,GAAKkC,EAAIlC,GAAKA,GAAKmC,EACzDnC,GN2kCA8f,UM1kCU,WN2kCN,GM1kCG5d,GAAM5N,KAAK4N,IAAKC,EAAM7N,KAC1B6N,GN2kCC,SM3kCQD,EAAIpC,EAAIqC,EAAIrC,GAAK,GAAIoC,EAAIlC,EAAImC,EAAInC,GAC7C,IN4kCA+f,UM3kCU,SAAUC,GN8kChB,MAFA1rB,MM3kCI4N,IAAIpC,GAAKkgB,EAAO,GAAI1rB,KAAK6N,IAAIrC,GAAKkgB,EACvC,GN2kCC1rB,KM3kCI4N,IAAIlC,GAAKggB,EAAO,GAAI1rB,KAAK6N,IAAInC,GAAKggB,EACvC,GACH1rB,MN4kCA2rB,WM3kCW,SAAUtf,GN6kCjB,GM5kCGuB,GAAM5N,KAAK4N,IACXC,EAAM7N,KAAK6N,IACX+d,EAAOvf,EAAOuB,IACdie,EAAOxf,EACXwB,GN4kCC,OM5kCMge,GAAKrgB,EAAIoC,EAAIpC,GAAKogB,EAAKpgB,EAAIqC,EAAIrC,GAAKqgB,EAAKngB,EAAIkC,EAAIlC,GAAKkgB,EAAKlgB,EAAImC,EACzEnC,GN6kCAogB,oBM5kCoB,SAAUzf,EAAQL,EAAIC,GN8kCtC,GM7kCG2B,GAAM5N,KAAK4N,IACXC,EAAM7N,KAAK6N,IACXrC,EAAIQ,GAAM,EACVN,EAAIO,GAAM,EACV2f,EAAOvf,EAAOuB,IACdie,EAAOxf,EACXwB,GN6kCC,OM7kCMge,GAAKrgB,EAAIA,EAAIoC,EAAIpC,GAAKogB,EAAKpgB,EAAIA,EAAIqC,EAAIrC,GAAKqgB,EAAKngB,EAAIA,EAAIkC,EAAIlC,GAAKkgB,EAAKlgB,EAAIA,EAAImC,EACzFnC,GN8kCAqgB,QM7kCQ,SAAU1f,GN+kCd,GM9kCGuB,GAAM5N,KAAK4N,IACXC,EAAM7N,KAAK6N,IACX+d,EAAOvf,EAAOuB,IACdie,EAAOxf,EACXwB,GN8kCC,OM9kCMge,GAAKrgB,IAAMqC,EAAIrC,GAAKogB,EAAKpgB,IAAMoC,EAAIpC,GAAKqgB,EAAKngB,IAAMmC,EAAInC,GAAKkgB,EAAKlgB,IAAMkC,EACjFlC,GN+kCAsgB,gBM9kCgB,SAAU7sB,GN+kCtB,IM9kCI,GAAI1E,GAAI,EAAGhB,EAAM0F,EAAOzF,OAAQe,EAAIhB,EAAKgB,IN+kCzC,GM9kCGuF,KAAKqhB,SAASliB,EAAO1E,IN+kCpB,OACImrB,IM7kCDnrB,EN8kCC0oB,MM9kCMhkB,EAEd1E,GNglCJ,OM7kCJ,ON+kCAwxB,YM9kCY,SAAU9sB,GNglClB,GM5kCG+sB,GAAKC,EAAK3zB,EAAG4Q,EAHbwE,EAAM5N,KAAK4N,IACXC,EAAM7N,KAAK6N,IACXue,IAASxe,EAAIpC,EAAGoC,EAAIlC,IAAKmC,EAAIrC,EAAGoC,EAAIlC,IAAKmC,EAAIrC,EAAGqC,EAAInC,IAAKkC,EAAIpC,EAAGqC,EAAInC,IAEpE2gB,EAAS,SAAU50B,GNmlClB,OMllCW00B,EAAI,GAAKD,EAAI,KAAOz0B,EAAE,GAAKy0B,EAAI,KAAOC,EAAI,GAAKD,EAAI,KAAOz0B,EAAE,GAAKy0B,EAC5E,KACDI,EAAe,WNmlCd,GMllCOC,IAAML,EAAI,GAAKC,EAAI,GAAID,EAAI,GAAKC,EAAI,IACpCK,GAAMh0B,EAAE,GAAK4Q,EAAE,GAAI5Q,EAAE,GAAK4Q,EAAE,IAC5BqjB,EAAKP,EAAI,GAAKC,EAAI,GAAKD,EAAI,GAAKC,EAAI,GACpCO,EAAKl0B,EAAE,GAAK4Q,EAAE,GAAK5Q,EAAE,GAAK4Q,EAAE,GAC5BujB,EAAK,GAAOJ,EAAG,GAAKC,EAAG,GAAKD,EAAG,GAAKC,EACxC,GNklCH,SMllCYC,EAAKD,EAAG,GAAKE,EAAKH,EAAG,IAAMI,GAAKF,EAAKD,EAAG,GAAKE,EAAKH,EAAG,IACjEI,IAEDC,EACJztB,CNklCC+sB,GMllCKE,EACN,ENklCC,KMllCI,GAAI1f,GAAI,EAAGA,EAAI,EAAGA,IAAA,CNmlClByf,EMllCKC,EACN1f,ENklCC,IMllCGmgB,GAAYD,EACZnzB,EAAMozB,EACVnzB,MNklCCkzB,MACAp0B,EMllCGq0B,EAAUpzB,EAAM,ENmlCnB,KMllCI,GAAIgB,GAAI,EAAGA,EAAIhB,EAAKgB,INmlCpB2O,EMllCGyjB,EACJpyB,GAAI4xB,EAAOjjB,IACFijB,EAAO7zB,INmlCPo0B,EMnlCwBpxB,KAAuB8wB,KNqlCnDM,EMplCUpxB,KACd4N,IAAUijB,EAAO7zB,INqlCbo0B,EMplCUpxB,KACd8wB,KNqlCA9zB,EMnlCJ4Q,CNqlCA8iB,GMnlCJC,ENqlCA,MMnlCJS,INqlCAE,aMplCa,SAAU3tB,EAAQ4tB,EAAW3a,GNslCtCA,EMrlCOA,GACR,CNqlCC,IMzjCG3X,GAAGmV,EAAGpD,EAAGhV,EAAGw1B,EAEhBC,EA9BIrf,EAAM5N,KAAK4N,IACXC,EAAM7N,KAAK6N,IACXuT,GAAQxT,EAAIpC,EAAI4G,EAAOxE,EAAIlC,EAAI0G,EAAOvE,EAAIrC,EAAI4G,EAAOvE,EAAInC,EAAI0G,GAC7D8a,EAAU,SAAUz1B,GNslCnB,GMrlCO2C,GAEJ,CN2lCH,OM3lCO3C,GAAE,GAAK2pB,EAAK,GAAIhnB,GAAQ,EACnB3C,EAAE,GAAK2pB,EAAK,KAAIhnB,GAAQ,GAE7B3C,EAAE,GAAK2pB,EAAK,GAAIhnB,GAAQ,EACnB3C,EAAE,GAAK2pB,EAAK,KAAIhnB,GAAQ,GAGpCA,GACD+yB,EAAW,SAAUvd,EAAGpD,GNslCvB,MMrlCU1N,MAAK8R,GAAK,EAAI9R,KAAK8e,MAAMpR,EAAE,GAAKoD,EAAE,GAAIA,EAAE,GAAKpD,EACvD,KACD4gB,EAAY,SAAUxd,EAAGpD,EAAG4K,GNslC3B,MMrlCiB,GAAPA,GAAYxH,EAAE,IAAMpD,EAAE,GAAKoD,EAAE,KAAOwR,EAAK,GAAKxR,EAAE,KAAOpD,EAAE,GAAKoD,EAAE,IAAKwR,EAAK,IACnE,ENqlCjBhK,GMrlCsBxH,EAAE,IAAMpD,EAAE,GAAKoD,EAAE,KAAOwR,EAAK,GAAKxR,EAAE,KAAOpD,EAAE,GAAKoD,EAAE,IAAKwR,EAAK,IACnE,ENqlCjBhK,GMrlCsBgK,EAAK,GAAIxR,EAAE,IAAMpD,EAAE,GAAKoD,EAAE,KAAOwR,EAAK,GAAKxR,EAAE,KAAOpD,EAAE,GAAKoD,EAAE,KAClE,ENqlCjBwH,GMrlCsBgK,EAAK,GAAIxR,EAAE,IAAMpD,EAAE,GAAKoD,EAAE,KAAOwR,EAAK,GAAKxR,EAAE,KAAOpD,EAAE,GAAKoD,EAAE,KAEnF,MACDrR,KACA9E,EAAM0F,EAAOzF,OACb2zB,EAAQH,EAAQ/tB,EAAO,GAAIiiB,GAC3BkM,IN6lCH,KM1lCI7yB,EAAI,EAAGA,EAAIhB,EAAKgB,IN6lChB,GAFAmV,EM1lCGzQ,EAAO1E,EACX,GN0lCC+R,EM1lCGrN,EACJ1E,GAAImV,EAAE,KAAOpD,EAAE,IAAMoD,EAAE,KAAOpD,EAAE,GN0lC/B,CAKA,IAFAwgB,EM5lCOC,EAAWC,EAAQ1gB,EAE3B4U,KAEI,CN4lCC,KM5lCKiM,EAAQL,GAAU,CAChBD,IN8lCCnd,EM7lCC,GAAKud,EAASvd,EAChBpD,GN6lCChV,EM7lCG2H,EAAO1E,EACX,GN6lCC+R,EM7lCC,GAAKhV,EAAI21B,EAAS3gB,EAAGhV,GAAKoY,EAC/B,IN8lCA0d,EM7lCI9xB,KAELoU,GAAIod,IAAUC,GN+lCTK,EM9lCI9xB,KAELgR,GAAI/R,EAAIhB,EAAM,INgmCT8E,EM/lCM/C,KACP8xB,GN+lCCA,OM7lCE7yB,IAAMhB,EAAM,GNgmClB6zB,EM/lCI9xB,KACRgR,EAGJ,OApBD,GAoBW6gB,EAAQL,EAGlB,KAAUK,INgmCNzd,EM/lCGwd,EAAUxd,EAAGpD,EAAG6gB,EACpBjM,GN+lCCiM,EM/lCOH,EAAQtd,EAEnBwR,KNgmCI5U,EM/lCG4gB,EAAUxd,EAAGpD,EAAGwgB,EACpB5L,GN+lCC4L,EM/lCOE,EAAQ1gB,EACnB4U,INkmCJiM,EM9lCJJ,ENmmCA,MMjmCGK,GAAK5zB,QAAQ6E,EAAO/C,KAExB8xB,GACH/uB,IAGLsH,EAAYwG,OAAS,SAASlE,GNgmCzB,MM/lCM,IAAItC,GAAYmlB,OAC1B7iB,IAGDtC,EAAYe,SAAW,SAAUtI,GNqmC5B,IALA,GM/lCGivB,GAAM1nB,EAAYe,SAAS3O,QAC3BV,EAAMg2B,EAAEjzB,OAAOizB,EAAEC,WAAa,SAAW,SAASlO,KAAKhhB,GACvDmvB,KACAhzB,EAEJ,GAAOA,KNgmCFgzB,EM/lCGF,EAAEnlB,IAAI3N,IAAMlD,EAAEkD,IACrB,EN2mCA,OAVAgzB,GM/lCGF,EAAEG,EAAEC,SNgmCPF,EM/lCGF,EAAEnlB,IAAI,KAAK1P,QAAQ60B,EAAEG,EAAEpzB,OAAQ,SAAUszB,EAAIC,EAAIC,GAC7CD,INgmCCJ,EMhmCSF,EAAEG,EAAEC,MAAME,GAAWC,KNomCtCL,EMjmCGM,SAAWN,EACf5mB,KNimCC4mB,EMjmCG5mB,KAAO4mB,EAAIO,UAGlBP,GAED5nB,EAAYe,SAAS3O,SNkmChBu1B,YMhmCD,ENimCCplB,KMjmCK,SAAU,WAAY,YAAa,WAAY,OAAQ,WAAY,OAAQ,OAAQ,WAAY,OAAQ,YAAa,OAAQ,QAClI,UNimCCslB,GACIC,KMhmCD,WNimCCrzB,OM/lCL,6BNimCCA,QACI2zB,OMhmCD,sINimCCC,MMjmCO,iMAIXr2B,EAAEwF,UNkmCFxF,EMlmCewF,YAGpBxF,EAAE0K,OAAO1K,EAAEwF,SNomCN0I,MMnmCMF,EACPE,MNmmCCjC,aMnmCa,aNomCbuS,MMnmCMxQ,EAAY4Q,KACnB,GNmmCCH,OMnmCOzQ,EAAY4Q,KACpB,INmmCC0X,OMnmCOtoB,EAAY4Q,KACpB,INmmCC2X,OMnmCOvoB,EAAY+Q,KACpB,INmmCC3O,YMnmCYpC,EACboC,YNmmCCR,aMnmCa5B,EACd4B,aNmmCCE,oBMnmCoB9B,EACrB8B,oBNmmCCvE,QMnmCQyC,EACTzC,QNmmCC4D,uBMnmCuBnB,EACxBmB,uBNmmCC0iB,gBMnmCgB7jB,EACjB6jB,gBNmmCCD,cMnmCc5jB,EACf4jB,cNmmCCF,gBMnmCgB1jB,EACjB0jB,gBNmmCCld,OMnmCOxG,EACRwG,ONmmCCoB,kBMnmCkB5H,EACnB4H,kBNmmCCzC,UMnmCUnF,EACXmF,UNmmCCgf,eMnmCenkB,EAChBmkB,eNmmCC1sB,mBMnmCmBuI,EACpBvI,mBNmmCC4sB,WMnmCWrkB,EACZqkB,WNmmCCK,WMnmCW1kB,EACZ0kB,WNmmCCE,eMnmCe5kB,EAChB4kB,eNmmCCvC,aMnmCariB,EACdqiB,aNmmCCyC,kBMnmCkB9kB,EACnB8kB,kBNmmCClK,kBMnmCkB,SAAU7Y,EAAQsC,GNomChC,MMnmCMrE,GAAY,qBAAuBqE,EAAO,IAAM,KAAKtC,EAAOG,IAAKH,EAC3EE,MNomCAkY,cMnmCcna,EACfma,cNmmCCF,KMnmCKja,EACNia,KNmmCC/P,QMnmCQlK,EACZkK,QNmmCIJ,SMnmCM9J,EACP8J,SNmmCCoQ,MMnmCMla,EACPka,MNmmCCS,wBMnmCwB3a,EACzB2a,wBNmmCCE,yBMnmCyB7a,EAC1B6a,yBNmmCC0C,UMnmCUvd,EACXud,UNmmCCqB,UMnmCU5e,EACX4e,UNmmCCnB,iBMnmCiBzd,EAClByd,iBNmmCCgB,QMnmCQze,EACTye,QNmmCCC,aMnmCa1e,EACd0e,aNmmCCc,QMnmCQxf,EACTwf,QNmmCC4C,qBMnmCqBpiB,EACtBoiB,qBNmmCCjU,WMnmCWnO,EACZmO,WNmmCC2R,qBMnm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EAAMwQ,GAC/BA,EAAKwwB,KfmpMTxwB,EenpMuBwwB,OfqpM3BxwB,EeppMQwwB,GAAMpiC,GACdoB,EfqpMJ3R,GeppMC2rB,WfspMGinB,YeppMY,SAASD,GfqpMjBxqC,KeppMI0qC,UACRF,GfspMAG,YeppMY,WfqpMR,MeppMMzkC,QAAO0kC,UAAY5qC,KAAK0qC,WAClCJ,IfupMJzyC,EeppMCgzC,gBfqpMGC,QeppMQ,WfqpMJ,GeppMGN,GAAOnqC,UAAU,GACjB0qC,EAAU1qC,UACd,EAAyB,KAArBA,UAAU3G,SfqpMTqxC,EenpMDP,EfopMCA,EenpMJ,KfqpMA,KeppMI,GAAIvmC,KAAK8mC,GfqpMT,GeppMY,OAATP,EfqpMC,IeppMI,GAAIQ,KAAMD,GAAQ9mC,GfqpMlBsmC,EeppMWtmC,EAAG+mC,EAAID,EAAQ9mC,GAAG+mC,GACjChrC,UfspMAuqC,GeppMWC,EAAMvmC,EAAG8mC,EAAQ9mC,GAChCjE,KfspMJ,OenpMJA,OfspMAyjB,QeppMQ,SAASrb,GfypMb,IeppMI,GAJDoiC,GAAO3yC,EAAE2rB,UAAUmnB,cACnBM,EAASjrC,KAAKwqC,OAEdU,EAAS9iC,EAAMA,EAAIiT,MAAM,SACpB5gB,EAAI,EAAGhB,EAAMyxC,EAAOxxC,OAAQe,EAAIhB,GAChCwxC,EADqCxwC,IfwpMzCwwC,EetpMQA,EAAOC,EACnBzwC,GfupMA,OerpMJwwC,KfwpMJpzC,EetpMC0K,OAAO1K,EAAE2rB,UAAW3rB,EACzBgzC,oBf0pMK,SAAS1zC,EAAQD,GAEtB,YgB9sMDW,GAAE0K,OAAO1K,EAAE2rB,WhBitMN2nB,KACIC,YgB/sMD,ahBgtMCC,OgB/sMD,QhBgtMCC,WgB/sMD,kBhBgtMCC,WgB/sMD,iBhBgtMCC,KgB/sMD,UhBgtMCC,UgB/sMD,WhBgtMCjmB,OACIjuB,EgB/sMD,IhBgtMCm0C,GgB/sMD,ShBgtMCnoB,GgB/sMD,KhBgtMC8D,GgB/sMD,QhBgtMC7C,IgB/sMD,ShBgtMCmnB,GgB/sMD,KhBgtMCC,OgB/sMD,UhBgtMCC,QgBhtMQ,gBhButMf,SAAS10C,EAAQ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GAAO6xC,EAAS/B,EAAWU,GAAKvvB,EACpCpmB,EnB6hNK,ImB7hNDmF,EnB8hNK,MmB5hNRA,GnBgiNA,MmB5hNR,OnB+hNA9F,GmB7hNHC,IAAI4rC,UAAY,SAASzrC,GnB8hNlB,MmB7hNE,IAAIu1C,GACdv1C,QnBkiNK,SAASd,EAAQD,EAASH,GAE/B,YoB7xNyB,IAAA65B,GAAA75B,EAAA,GACC04C,EAAA14C,EAAA,IACI24C,EAAA34C,EAAA,GAE/Bc,GAAEC,IAAI63C,YAAA93C,EAAgB+3C,UAAUC,OAAOttC,QpBkyNlCtK,SACI63C,cACAC,QoB/xND,EpBgyNC/G,aoB/xND,EpBgyNCrN,eoB/xND,EpBgyNCC,WoB/xND,EpBgyNCoU,UoB/xND,EpBgyNC3G,WoB7xNL,GpBgyNCxmC,WoBhyNW,SAAS5K,GpBiyNhBA,EoBhyNSJ,EAAEgkC,WAAW77B,KAEvB/H,GpBgyNC+H,KoBhyNIiwC,YAAc,GAAIp4C,GAAEC,IAEzBwH,SpBgyNCU,KoBhyNIkwC,cpBiyNJlwC,KoBhyNImwC,kBpBkyNJnwC,KoBhyNIowC,mBpBkyNJpwC,KoBhyNIqwC,cAAe,EpBiyNnBrwC,KoBhyNIswC,mBpBkyNJ,IoBhyNG/rC,GAEJvE,IpBgyNCA,MoBhyNIuwC,MpBiyNA7pC,SoBhyNSkqB,EAAA/qB,YAAYY,kBAAkBxO,EAAQyO,UAChD,uBpBgyNCmuB,QoBhyNQ58B,EACTu9B,MpBgyNCwa,SoBhyNS/3C,EACV+3C,SpBgyNCzoC,QoBhyNQtP,EACTsP,QpBgyNC42B,UoBhyNUlmC,EACXkmC,UpBgyNCE,QoBhyNQpmC,EACTomC,QpBgyNCmS,UoBhyNUv4C,EAAQu4C,WACnB,KpBgyNCC,OoBhyNOx4C,EAAQw4C,WpBiyNfC,qBACAC,aoB/xND,EpBgyNCC,YoB/xND,EpBgyNCC,YoB/xND,EpBgyNCC,eACAC,kBACAC,gBoB9xND/4C,EAAQuM,cpBiyNPxE,KoBhyNIuwC,KAAK/rC,YAAcvM,EAC3BuM,apBkyNAxE,KoBhyNI6vB,GAAG,aAAc,SAASzmB,GpBiyN1B7E,EoBhyNK0sC,uBAAuB7nC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pC,WAAa1pC,EAAI2pC,SpByyNpBzhC,KoBxyNIstC,gBAAgBx1C,EAAI0pC,UAAW1pC,EACvC2pC,SpB0yNAzhC,KoBxyNIiwC,YACLxvC,UACHT,MpB0yNAy4B,eoBxyNe,WpByyNX,MoBxyNAz4B,MAAKuwC,KACTtY,apB0yNA+K,qBoBxyNqB,WACbhjC,KAAK/H,QAAQ0jC,gBpByyNb37B,KoBxyNI/H,QAAQ0jC,eACb,EAAI37B,KAAKuwC,KAAKtY,cpByyNTj4B,KoBvyNDmzC,yBpBwyNCnzC,KoBxyNIuwC,KAAKtY,YACV+K,uBpBwyNChjC,KoBvyNJs2C,YpB4yNRpT,sBoBxyNsB,WACfljC,KAAK/H,QAAQ0jC,gBpByyNZ37B,KoBxyNI/H,QAAQ0jC,eACb,EAAI37B,KAAKuwC,KAAKtY,cpByyNTj4B,KoBvyNDmzC,yBpBwyNCnzC,KoBxyNIuwC,KAAKtY,YACViL,wBpBwyNCljC,KoBvyNJs2C,YpB4yNRC,iBoBxyNiB,SAAU39B,GpByyNvB,GoBxyNGrU,GACJvE,IpB8yNC,OoB9yNGA,MAAKuwC,KAAKhd,gBAAkB3a,IpByyN3B5Y,KoBxyNIuwC,KAAKhd,cACV3a,EpBwyNC5Y,KoBxyNIiwC,YAAYpvC,KAAK,WpByyNjB0D,EoBvyNJiyC,aAGRx2C,MpB0yNAy2C,UoBxyNU,WpByyNN,MoBxyNMz2C,MAAKuwC,KAAKoB,aACpB8E,apB0yNAC,SoBxyNS,SAAUn2C,GpB0yNf,MADAP,MoBxyNIuwC,KAAKoB,aAAa+E,SACvBn2C,GACHP,MpB0yNA22C,UoBxyNU,SAAUlG,GpByyNhB,GoBxyNGlsC,GAEJvE,IpBkzNC,OAVAA,MoBxyNIiwC,YAAYpvC,KAAK,WpByyNjB0D,EoBxyNKgsC,KAAKoB,aACXiF,cAAInG,EpByyNCA,EoBxyNMnwC,QAAQ,SAASuD,EAAIpJ,GpByyNvB8J,EoBxyNKsyC,SAAShzC,EAAIpJ,GACtB,KpB0yNA8J,EoBxyNKb,KACT,iBAGR1D,MpB0yNA82C,SoBxyNS,SAAUlxB,GpByyNf,MoBxyNM5lB,MAAKy2C,YACf7wB,IpB0yNAixB,SoBxyNS,SAAU7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rBtyD,GvBytTK4I,KuBztTA83C,WACL1gD,GACH4I,MvB2tTIuqD,kBuBztTc,SAAUnzD,GvB6tTpB,MAHA4I,MuBxtTLm2C,sBvBytTKn2C,KuBztTAg9C,gBAAgB0M,aAAatyD,GAClC,GvBytTK4I,KuBztTA83C,WACL1gD,GACH4I,MvB2tTIwqD,mBuBztTe,WvB0tTX,GuBztTDxqD,KAAKg9C,gBACL,CvBytTK,GuBztTD8M,GAAU9pD,KACdg9C,evBytTK8M,GuBztTGvoD,OvB0tTHuoD,EuBztTG9uD,MACR,EvBytTKgF,KuBxtTRw2C,UvB0tTI,MuBxtTRx2C,OvB2tTIyqD,iBuBztTa,SAAUL,EAAKC,GvB0tTxBrqD,KuBxtTLm2C,qBvBytTK,IuBztTD2T,GAAU9pD,KACdg9C,evBkuTK,OATA8M,GuBztTGvoD,OvB0tTHuoD,EuBztTG9uD,MACR,EvBytTKqvD,EuBztTE/pD,QAAQ,SAAUlJ,GvB0tThB0yD,EuB1tT8BJ,aAAatyD,GAAY,KvB4tT3DgzD,EuB3tTD9pD,QAAQ,SAAUlJ,GvB4tTb0yD,EuB5tT2BJ,aAAmBtyD,KvB8tTlD4I,KuB5tTLw2C,UACHx2C,MvB+tTIsoD,euB7tTW,SAAUngD,GvB+tTjB,MADAnI,MuB5tTLm2C,sBAAOhuC,EAAIwZ,KAAK9pB,EAAEqK,KAAKlC,KAAKg9C,gBAAgBhiD,MAAQ,EAAIgF,KAAKuwC,KAAKC,UAAYxwC,KAAKg9C,gBAAgBwM,SACtGxpD,QvB+tTI0qD,YuB7tTQ,SAAU/uD,GvB8tTdqE,KuB5tTLm2C,qBvB6tTK,IuB7tTD2T,GAAU9pD,KACdg9C,evBiuTK,OAJA8M,GuB7tTGN,SACR7tD,EvB6tTKmuD,EuB7tTGP,kBAAkB5tD,EvB8tTrBqE,KuB7tTAuwC,KAAKC,UAAYsZ,EACtBtZ,UvB6tTKxwC,KuB5tTLw2C,UACHx2C,MvB8tTI2qD,YuB7tTQ,WvBguTJ,MAFA3qD,MuB5tTLm2C,sBvB6tTKn2C,KuB7tTAg9C,gBAAgByM,UACrB,EACHzpD,MvB8tTI4qD,WuB7tTO,WvBguTH,MAFA5qD,MuB5tTLm2C,sBvB6tTKn2C,KuB7tTAg9C,gBAAgByM,UACrB,EACHzpD,YvBmuTC,SAAS7I,EAAQD,GAEtB,YwBr4TDW,GAAEC,IAAI63C,YAAYua,SxBw4Tb/X,UwBv4TU,SAAUlc,EAASh+B,GxBw4TzB,GwBv4TG4yD,GAAehzD,EAAE0K,QAAQiP,SAAU,IAAOiD,UAAW,WAAYq2C,QAAS9qD,KAAKuwC,KAAKhpC,SAExFtP,ExBg6TC,OwBh6TG+H,MAAKkyC,QxBw4TJlyC,KwBx4TmCq6C,cACpCpkB,YAAmBp+B,GAAEkzD,MxB04TpB/qD,KwBz4TIkyC,OACRjc,GACQj2B,KAAKkyC,SAAUj6C,IxB04Tf+H,KwBz4TIkyC,OAAS,GAAIr6C,GAAEkzD,MACvBF,IxB04TA7qD,KwBz4TIkyC,OAAO8Y,WACf/0B,IxB04TAj2B,KwBz4TIkyC,OAAO+Y,aACZh1B,ExBy4TCj2B,KwBz4TIkyC,OAAOgZ,OAEZ,GAAKlrD,KAAKmrD,sBxB04TLnrD,KwBx4TI6vB,GAAG,QAAS7vB,KAAKorD,gBAAiBprD,MAClC6vB,GAAG,YAAa7vB,KAAKqrD,WAAYrrD,MACjC6vB,GAAG,YAAa7vB,KAAKsrD,WAAYtrD,MACjC6vB,GAAG,WAAY7vB,KAAKurD,UAAWvrD,MAC/B6vB,GAAG,WAAY7vB,KAAKwrD,kBAEzBxrD,MxBo4TCA,KwBp4TImrD,qBACR,GACGN,GAAgBA,EAAaY,YxBq4T5BzrD,KwBp4TI0rD,WAAab,EACrBY,WxBs4TAzrD,KwBp4TIkyC,OAAOyZ,aAAe3rD,KAAKkyC,OAEhC0Z,cACH5rD,MxBs4TAq6C,YwBp4TS,WxB64TL,MwB54THr6C,MAAKkyC,SxBq4TElyC,KwBp4TLkyC,OACL,KxBo4TUlyC,KwBn4TLwyC,IAAI,QAASxyC,KAAKorD,gBAAiBprD,MAC1BwyC,IAAI,YAAaxyC,KAAKqrD,WAAYrrD,MAC3CwyC,IAAI,YAAaxyC,KAAKsrD,WAAYtrD,MACzBwyC,IAAI,WAAYxyC,KAAKurD,UAAWvrD,MAChCwyC,IAAI,WAAYxyC,KAAKwrD,kBAE1BxrD,MxB+3TCA,KwB/3TI0rD,WACd,KxB+3TU1rD,KwB/3TLmrD,qBACL,GxBg4TMnrD,KwB/3TIuwC,KAAK0B,eAChB,EACAjyC,MxBi4TGwrD,kBwB/3TkB,WxBg4Td,IwB/3TI,GAAIp0D,KAAM4I,MAAKuwC,KAAKS,YACjBhxC,KAAKuwC,KAAKS,YAAY55C,KxBg4TrB4I,KwB/3TI6rD,SACLz0D,SAAO4I,MAAKuwC,KAAKS,YACpB55C,KxBm4TR00D,awB/3Ta,WxBi4TT,MADA9rD,MwB/3TI+rD,gBACX,EACG/rD,MxBi4TAgsD,YwB/3TY,WxBi4TR,MADAhsD,MwB/3TI+rD,gBACX,EACG/rD,MxBi4TAisD,UwB/3TO,SAAUrkD,EAAQ3P,GxB04TrB,MwBx4TH+H,MAAKkyC,SxBi4TEtqC,EwB/3TDA,GAAU5H,KAAKksD,SACflsD,KAAKmsD,SAASrtD,KAAKC,MAAMiB,KAAKmsD,SAASzyD,OAEhD,IxB83TUzB,EwB93TAA,MxB+3TAA,EwB93TO2P,OACRA,ExB83TC5H,KwB93TIosD,WACdn0D,IAGD+H,MxBg4TGqsD,WwB93TQ,WxBm4TJ,MwBl4THrsD,MAAKkyC,SxB+3TElyC,KwB93TLkyC,OACIoa,SxB83TCtsD,KwB93TI0D,KAAK,cAAe6oD,MAAOvsD,KACzCkyC,UAEDlyC,MxBg4TGqrD,WwB93TW,SAAUpzD,GxB+3TjB,GwB93T0B,cAAvB+H,KAAKkyC,OAAOgZ,OACZ,CxB83TC,GwB93TG9zD,GAAK4I,KAAKkyC,OAAOj6C,QAAQu0D,SAAU,CACnCp1D,KAAOa,EAAQH,IAAIV,IxB+3TlB4I,KwB93TIysD,iBACRx0D,GxB+3TA+H,KwB93TIkyC,OAAOwa,UAAUz0D,EACzB2P,UxBi4TJ0jD,WwB93TW,SAAUrzD,GxB+3TjB,GwB93TGi6C,GAASlyC,KACbkyC,MAAKA,GAAO5L,KxBi4TPtmC,KwB93TI0D,KAAK,axB+3TL6oD,MwB73TDra,ExB83TCp6C,IwB93TIkI,KAAKysD,iBAAiBx0D,EAElCi6C,KxBw3TIlyC,KwB93TIosD,WACRn0D,GAMqB,cAAlBi6C,EAAOgZ,QxB+3TNhZ,EwB93TMwa,UAAUz0D,EACpB2P,SxBi4TJ2jD,UwB93TU,SAAUl8B,GACU,cAAvBrvB,KAAKkyC,OAAOgZ,QAA2B77B,EAAGv3B,IAAI60D,QxB+3T7C3sD,KwB73TJqsD,cxBi4TJO,iBwB93TiB,SAAU3vD,EAAO4vD,GxBg4T9B,GwB53TGzkD,GAAK3N,EACThB,EAHIqzD,EAAQD,EAAItjD,qBAAqB,QACjCwjD,IxBk4TH,KwBh4TI3kD,IAAOpI,MAAKgtD,aAAmB,CxBk4T/B,GwBj4TGC,GAASjtD,KAAKgtD,aAAa5kD,GAC/B6kD,MxBk4TC,KADAF,EwBj4TU3kD,GACX,EAAK3N,EAAI,EAAGhB,EAAMqzD,EAAMpzD,OAAQe,EAAIhB,EAAKgB,IACjCqyD,EAAMryD,GAAGrD,KAAO61D,GxBk4TfF,EwBh4TJ3kD,KxBq4TR,IwBj4TIA,IAAOpI,MAAKgtD,aACb,CxBi4TC,GwBj4TGzT,GAAOv5C,KAAKgtD,aAAa5kD,GACzB8kD,EAAM3T,EAAK0T,OACXE,GAEJ,CxBi4TC,KwBj4TI1yD,EAAI,EAAGhB,EAAMqzD,EAAMpzD,OAAQe,EAAIhB,EAAKgB,IACrC,CxBi4TC,GwBj4TGkD,GAAOmvD,EACXryD,EAAIkD,GAAKvG,KAAO81D,IxBk4TXC,GwBh4TD,ExBi4TCxvD,EwBj4TIvG,IAAM,IACXqD,ExBi4TC8+C,EwBj4TIh5C,SAAStD,EAAO4vD,EAAKlvD,EAC7BovD,IAEDI,GxBk4TC5T,EwBj4TIh5C,SAAStD,EAAO4vD,EAAK,KAC7BE,KxBq4TRN,iBwBj4TiB,SAAUx0D,EAASi6C,GAC5BA,IxBk4TAA,EwBl4TmBlyC,KAAckyC,OxBo4TrC,IwBn4TGp6C,GAAMG,EAAQH,QACds1D,EAAct1D,EAAIs1D,gBAClB19C,EAAa7X,EAAE0K,UAAWzK,EAAI4X,YAC9BygB,EAASr4B,EAAIq4B,WACb9oB,EAAW8oB,EAAO9oB,aAClBqkB,EAASyE,EAAOzE,OAChB40B,EAAkBpO,EAAO+Y,cAAgBmC,EAAY9M,iBAAmB,GACxEp2C,EAAOjS,EAAQiS,KACfmjD,EAAcrtD,KAAK/H,QAAQ0jC,gBAA2B,cAATzxB,GAAiC,cAATA,GACrEojD,GxBo4TCl2D,GwBn4TOU,EACJV,GxBm4TH8S,KwBl4TGA,ExBm4THqjD,UwBn4Tcz1D,EACXy1D,UxBm4TH3lD,OwBn4TW3P,EACR2P,OxBm4TH8H,WwBl4TGA,ExBm4TH4wC,gBwBh4TLA,ExBm4TC,IwBn4TqB,UAAlBj5C,EAAS6C,KACT,CxBm4TC,GwBn4TGwR,GAAQrU,EACZkF,WxBm4TC+gD,GwBn4TO1lD,OAAS/P,EAAEwX,WAAWC,SAASqQ,WAAWnU,EAAGkQ,EAAM,GAAIhQ,EAAGgQ,EACrE,KxBo4TA,GwBn4TGgQ,EACA,CxBm4TC,GwBn4TG8hC,GAAc31D,EAAEkzD,MAAMnlD,UAAU3N,QACpCyzB,MxBm4TCwmB,GwBn4TMj6C,QAAQyzB,SAAW8hC,EAAY,GAAK9hC,EAAO,GAAI8hC,EAAY,GAAK9hC,EAC1E,IxBq4TA,GwBn4TG1rB,KAAK0rD,WxBo4TJ1rD,KwBn4TI0rD,YxBo4TAa,MwBl4TDra,ExBm4TCtqC,OwBn4TO0lD,EACR1lD,OxBm4TC0gC,WwBn4TWrwC,EACZqwC,WxBm4TCmlB,YwBn4TYvb,EACbwb,axBm4TCC,ewBn4Te11D,EAChB01D,exBm4TC9lB,cwBn4Tc5vC,EACf4vC,cxBm4TC/vC,IwBj4TRw1D,QAAM,MAAMhN,YAA2BzoD,GAAEkzD,OACtC,CxBm4TC,KwBn4TKzK,YAA2BsN,cAC7B,CxBm4TC,GwBn4TGhqC,GACAuE,EAAU,GACV5C,EAAcvlB,KAAKsmC,KAAOtmC,KAAKsmC,KAAKruC,UxBy4TvC,IwBv4TIo1D,IxBo4TAzpC,EwBn4TYuM,EAAO9oB,UAAY8oB,EAAO9oB,UAAavP,EAAI8rB,YAAc5jB,KAAKuwC,KAAKtY,YAAY8I,kBAAkBjpC,EAAIV,QxBo4TjHk2D,EwBn4TOnlC,QAAUA,EAAUtwB,EAAEwF,QAAQ2oB,qBAAqBpC,EAC9D2B,IACGvlB,KAAKgtD,aACL,CAAK1M,IxBo4TAA,EwBn4TiBz6C,YAAYkiB,0BACjCrY,GxBo4TA,KwBn4TI,GAAItH,KAAOpI,MAAKgtD,axBo4ThBt9C,EwBn4TUtH,GAAOvC,YAAY+hB,cAAc5nB,KAAKgtD,aAAa5kD,GAAKylD,OACtEn+C,GxBq4TJ4wC,EAAkBzoD,EwBn4TCwF,QAAQ4qB,qBAAqBq4B,GxBo4T5C5wC,WwBl4TDA,ExBm4TCsY,mBwBn4TmBhoB,KAAKuwC,KACzBvoB,mBxBm4TCzC,YwBl4TDA,ExBm4TC4C,QwBl4TDA,ExBm4TCvE,WwBj4TRA,IxBq4TA,GwBn4TGkqC,GAAaj2D,EAAE42B,QAAQC,OAAO,MAClC,GxBm4TCo/B,GwBn4TUC,UACXzN,ExBm4TCpO,EwBn4TM8Y,WACP8C,GAAI9tD,KAAKgtD,cxBo4TJhtD,KwBn4TI4sD,iBAAiB90D,EAAI4X,WAAYwiC,EACzC8b,cxBu4TJ,MADA9b,GwBn4TMj6C,QAAQu0D,OAAS10D,EACxBV,GACHk2D,GxBq4TAlC,gBwBn4TgB,SAAUnzD,GxBo4TtB,GwBn4TG4vC,GAAgB5vC,EAAQ4vC,kBACxBjF,GAAQ3qC,EAAQH,KAAOkI,KAAK+rD,gBAAkBlkB,EAAcgiB,SAAWhiB,EAAcomB,QAAUpmB,EAEnGqmB,QxBm4TC,KwBn4TItrB,EACD,CxBm4TC,GwBn4TG14B,GAAOjS,EAAQiS,KACfpS,EAAMG,EAAQH,IACds1D,EAAct1D,EAAIs1D,YAClBlvD,EAAgB,UAATgM,GAAoBkjD,EAAY7M,YAAc6M,EAAYjkC,sBACjE3f,EAAO1R,EAEXq4B,MxBm4TC,IwBn4TGjyB,GAAQsL,EAAKvR,QAAQ0jC,gBAAkBnyB,EAAKnC,SAC5C,CxBm4TC,GwBn4TG8mD,GAAYr2D,EAAIwP,MACpB0wB,kBxBm4TCnyB,awBn4TWmB,wBxBo4TP/O,QwBl4TDA,ExBm4TCsP,QwBn4TQ4mD,EACTxgC,KxBm4TC/vB,MwBn4TM4L,EACPpS,GxBm4TC8P,MwBn4TMinD,EAAUpjC,gBAClBlqB,KAAA,SAAcqH,EAAMO,GxBo4TlB,GwBn4TGP,GAAwB,OAAhBA,EAAKonB,QAAmBpnB,EAAKusB,OACrC,CxBm4TC,GwBn4TG1mB,GAAO7F,EAAKusB,OAAO0R,OACvB,ExBm4TC19B,GwBn4TMxQ,QAAQH,IAAIq4B,OAAOsS,gBAC1B10B,ExBm4TCtF,EwBn4TMxQ,QAAQH,IAAIq4B,OAAO9oB,SAAW0G,EAAKA,EAAKrU,OAC/C,GxBm4TCsG,KwBn4TIosD,WAAW3jD,EACnBxQ,WACHiK,KACLlC,WxBo4TIA,MwBn4TIosD,WACRn0D,KxBu4TRm0D,WwBn4TW,SAAUn0D,EAASm2D,GxBo4T1B,GwBn4TG9yC,GAAMtb,KAAKsmC,KACXuB,EAAgB5vC,EAAQ4vC,kBACxBjF,EAAOwrB,GAAWA,EAAUpuD,KAAK+rD,gBAAkBlkB,EAAcgiB,SAAWhiB,EAAcomB,QAAUpmB,EAExGqmB,QxBm4TC,KwBn4TItrB,EACD,CxBm4TC,GwBn4TG14B,GAAOjS,EAAQiS,KACfgoC,EAASlyC,KAAKkyC,OACdp6C,EAAMG,EAAQH,QACds1D,EAAct1D,EAAIs1D,exBq4TrB,IwBn4TY,UAATljD,EACA,CxBm4TC,IwBn4TIkkD,GAAWhB,EAAYjkC,wBAA0BnpB,KAAKspC,kBAAkB,aAAyB,MAEhG,eAAgBhuB,KxBs4TjBA,EwBr4TG+yC,eAEF,iBAAmB/yC,GAAIrjB,UxBs4TxBqjB,EwBt4TwCrjB,QAAQq2D,cAAoB,GACpEtuD,KAAKuwC,KAAKge,iBxBw4TVvuD,KwBv4TIuwC,KAAKge,gBACV,ExBu4TCjzC,EwBv4TGuU,IxBw4TCma,YwBv4TY,SAAU3a,GxBw4TlB,GwBv4TGA,EAAG/nB,gBAAiBzP,GAAEkzD,MxBw4TrB/qD,KwBv4TIwuD,YAAYn/B,EACpB/nB,WAAM,IAAI+nB,EAAG/nB,QAAUtH,KACpB,CxBu4TC,GwBv4TGsb,EAAI+yC,WACJ,CxBu4TC,GwBv4TGvD,GAAU9qD,KAAKuwC,KACnBhpC,OxBu4TC+T,GwBv4TG+yC,WAAA/yC,EAAiB+yC,WAAWI,OAAO,SAASh3D,EAAGD,GxB+4T9C,MwB94TGA,GAAE8uC,OACE9uC,EAAES,QAAQ6yD,UAAYA,ExBw4TrBtzD,EwBx4TkC8uC,KAAK3N,YAAiBnhC,GxB04TxDC,EwBz4TI+D,KAAUhE,IAG1BC,OxB44TJuI,KwBz4TJqsD,gBAGZrsD,OxB44TAA,KwB14TIwuD,YAAY12D,EACjBV,GxB04TC,IwB14TGwgC,GAAM53B,KAAKkyC,OAASlyC,KAAKkyC,OAAOj6C,SAAWuZ,SAAU,IAAOiD,UAAW,WAAYq2C,QAAS9qD,KAAKuwC,KACrGhpC,QxB04TC2qC,GwB14TQ,GAAIr6C,GAAEkzD,MAAMlzD,EAAE0K,UAAWq1B,GAAM82B,aAA4C,IAA9BpzC,EAAIrjB,QAAQq2D,cAAqBK,SAC1F,SAjCD,IAiCoB,cAATzkD,EAQV,MxBm4TI,IwB14TGkjD,EAAYlkC,0BAGf,YxBw4TIgpB,EwB14TMgZ,OACP,GxB44THhZ,GwB14TMj6C,QAAQ02D,SAClB,ExB64TAzc,EwB14TMj6C,QAAQ22D,SAAW92D,EAC1BV,GxB04TC86C,EwB14TMgZ,OACPhhD,CxB04TC,IwB14TGojD,GAAUttD,KAAKysD,iBAAiBx0D,EACpCi6C,ExBw5TC,IAdAA,EwB14TMwa,UAAUY,EAEjB1lD,QxB04TC5H,KwB14TI0D,KAAK,axB24TL6oD,MwBz4TDra,ExB04TCp6C,IwBx4TLw1D,IAAa,UAATpjD,IACIoR,EAAI+yC,WAAW30D,QAAU4hB,EAAIrjB,QAAQq2D,exB24TpChzC,EwB14TGqd,YAAYrd,EAAI+yC,WACvBrqD,SxB24TAsX,EwB14TG+yC,WAAW7yD,KAClB02C,IxB24TAA,EwB14TM2c,MAAMvzC,GAET42B,EAAO4c,aACP,CxB04TC,GwB14TGC,GAAa7c,EAAO4c,aACxB99C,KAAa,eAAT9G,GAAuC,WAAf6kD,GxB24TvBA,EwB14TUC,WACX,SxB04TC9c,EwB14TMjL,WAAWj2B,MAAMi+C,aACxB,MxB04TC/c,EwB14TMjL,WAAWj2B,MAAMghC,cAC3B,QAAmB,UAAT9nC,GAAmC,YAAf6kD,IxB24T1BA,EwB14TUC,WACX,UxB04TC9c,EwB14TMjL,WAAWj2B,MAAMi+C,aACxB,GxB04TC/c,EwB14TMjL,WAAWj2B,MAAMghC,cAC3B,OxB+4TZwc,YwB14TS,SAAUhlD,GxB24Tf,GwB14TG8R,GAAMtb,KACVsmC,IxB04TC,IwB14TGhrB,GAAOA,EAAI+yC,WACX,CxB04TC,GwB14TGvD,GAAU9qD,KAAKuwC,KAAKhpC,QACpB2nD,EAAY1lD,YAAgB3R,GAChCkzD,KxB04TCzvC,GwB14TG+yC,WAAA/yC,EAAiB+yC,WAAWI,OAAO,SAASh3D,EAAGD,GxBo5T9C,MwBn5TGA,GAAE8uC,OACE4oB,GAAa13D,IAAMgS,ExB24TlBhS,EwB34T4B8uC,KAAK3N,YAAiBnhC,GAC9CA,EAAES,QAAQ6yD,UAAYA,GAAWtzD,EAAES,QAAQ22D,WAAaplD,ExB44T5DhS,EwB54TsE8uC,KAAK3N,YAAiBnhC,GxB84T5FC,EwB74TI+D,KAAUhE,IAG1BC,SxBk5TR03D,UwB94TU,SAAUjxD,GxB+4ThB,GwB94TGod,GAAMtb,KAAKsmC,KACX31B,IxB+4TH,IwB94TG2K,GAAOA,EAAI+yC,WACX,CxB84TC,GwB94TGvD,GAAU9qD,KAAKuwC,KACnBhpC,OxB84TC+T,GwB94TG+yC,WAAWI,OAAO,SAASh3D,EAAGD,GxBk5T7B,MwBj5TGA,GAAES,QAAQ6yD,UAAYA,GxB+4TrBrzD,EwB/4TkC+D,KAAK0C,EAAO1G,EAAIA,EAAES,QAAoB22D,UAEhFn3D,GACJkZ,GxBi5TA,MwB/4TJA,IxBk5TAk7C,SwBh5TS,SAAUz0D,GxBi5Tf,GwBh5TGU,GAAMkI,KAAKuwC,KACX/mC,EAAO1R,EAAImgC,YAAYwH,QAC3BroC,ExBg5TC,IwBh5TIoS,GAASxJ,KAAKsmC,KAGf,CxBg5TC,GwBh5TG51B,GAASlH,EAAK6C,OAAOmf,YACrB5jB,EAAS/P,EAAEwX,WAAWC,SAASqQ,UAAU,GAAI9nB,GAAE+nB,MAAMlP,EAAO,GAAIA,EACpE,IxBg5TC1Q,MwBh5TIosD,YxBi5TAliD,KwB/4TD,QxBg5TCtC,OwB/4TDA,ExBg5TC9P,IwBh5TIkI,KAAKovD,eAAe5lD,KAE7B,SAAO1R,GAAIk5C,YACd55C,OxBs4TIU,GwBh5TGk5C,YAAY55C,IACnB,CxB05TA,OwB/4TJ4I,OxBk5TAqvD,awBh5Ta,SAAUjnD,EAAK7H,GxBo5TxB,GwBn5TIP,KAAKgtD,exBi5TLhtD,KwBj5T0BgtD,kBAC1BhtD,KAAKgtD,aAAa5kD,GACnB,CxBk5TC,GwBl5TG6kD,GAAS,IAAMp1D,EAAEy3D,SxBm5TpBtvD,MwBl5TIgtD,aAAa5kD,IxBm5TbA,IwBj5TDA,ExBk5TC6kD,OwBj5TDA,ExBk5TCY,OwBl5TO,aAAeZ,EACvB,YxBk5TC1sD,SwBh5TRA,GxBm5TA,MwBj5TJP,OxBo5TAuvD,gBwBl5TgB,SAASnnD,GxBs5TrB,MwBr5TGpI,MAAKgtD,oBAAuBhtD,MAAKgtD,aAAoB5kD,GAE5DpI,SxBy5TC,SAAS7I,EAAQD,EAASH,GAE/B,YyB7zUyB,IAAA65B,GAAA75B,EAAA,EAE1Bc,GAAEC,IAAI63C,YAAYua,SzBg0UbsF,wByB/zUwB,SAAUxuC,EAAUyuC,EAAWpjD,GzBs0UnD,IyBh0UI,GAHDK,GAGJjT,EALI3B,EAAMkI,KAAKuwC,KACXn7B,EAAWtd,EAAIsd,SAIV3a,EAAIumB,EAAStnB,OAAS,EAAGe,GAAK,EAAGA,IACtC,CzBg0UC,GyBh0UG23B,GAAUpR,EAASvmB,GAAGiV,WACtB4iB,EAAMF,EAAQ,GACdjR,EAAaH,EAASvmB,GAAG0mB,eACzB3X,EAAO1R,EAAImgC,YAAYwH,QAAQnN,GAC/B7c,EAAejM,EAAKiM,cAAgBjM,EAAKkM,oBACzCjF,EAAYgF,EAAahF,WAAa,EACtCkF,EAAaF,EAAaE,WAC1BI,GAAcJ,GAAcF,EAAaM,WAAaN,EAAaM,WAAa,KAChF4rC,EAAc7pD,EAAI65C,aAAaoH,YAAYvvC,GAC3C+K,EAAYkB,EAAalB,WAAaotC,EAAYptC,WAAa,EAC/DqB,EAAKrB,GAAaotC,EAAY/rC,IAAMH,EAAaG,IAAM,GACvDC,EAAKtB,GAAaotC,EAAY9rC,IAAMJ,EAAaI,IAAM,GACvD6V,GACIjb,EAAYmF,EAAK,EACjBnF,EAAYoF,EAAK,GAErBsN,EAAQssC,EACRvuC,EAAOkR,EAAQA,EAAQ14B,OAAS,GAChCwQ,EAAOgX,EAEXhX,IAAa,WAATA,GAAyC,WAArBy3C,EAAYz3C,OzB8zU/BwhB,EyB7zUM,IACP,EzB6zUCA,EyB7zUM,IACV,EzB8zUA,IyB7zUGgkC,GAAShkC,EAAO,GAChBikC,EAAY/+B,EAAA/qB,YAAYwG,SACnBO,aAAauU,EAAW9U,QACxB8e,UAAUO,EAAO,GAAKtW,EAAUsW,EAAO,GAChDtW,EzB+zUC,IyB/zUGW,IzB4zUC2V,GyB1zUG3V,EAAW,GAAK2V,EAAO,GACvB3V,EAAW,GAAK2V,EAEpB,IzBwzUCvI,GyBvzUGssC,EAAU,GAAK/jC,EAAO,GAAKtW,EAC3Bq6C,EAAU,GAAK/jC,EAAO,GAE7BtW,IACIu6C,EAAUtuC,SAAS8B,GzBqzUvB,CAIA,GyBvzUGvP,GAAO6B,EAAapC,WAAaoC,EAAa8b,eAAiBowB,EAAYvuB,SAAWuuB,EAAY7oC,UAClGuP,EAASs5B,GAAeA,EAAYt+C,MAAQs+C,EAAYt+C,MAAQ,KAChEusD,EAAU1lD,EACV4P,EAAcqH,EAAWrH,gBACzBxN,EAAY6U,EAAW7U,UACvBnN,EAAS+hB,EAAK3U,YACdghD,EAAY,KACZxjD,GzBwzUCoZ,MyBtzUGssC,EzBuzUHpjD,OyBtzUGA,EzBuzUHlN,OyBtzUGA,EzBuzUHmN,UyBpzULA,EzBq0UC,IyBr0UY,iBAATpC,GAAoC,YAATA,IACvBme,EzBwzUCunC,EyBtzUJ,QAAWh8C,IACK,YAAT1J,GzBwzUC0lD,EyBtzUD,kBzBuzUC91C,EyBvzUaA,EACjB,IzBwzUI81C,EyBtzUJ,sBzBwzUA7lD,EyBvzUE1D,OACNyT,IAGW,eAAZ81C,GzBwzUC,IyBvzUIh/B,EAAA/qB,YAAY2c,kBAAkBitC,EAAWl7C,EAAYa,EAAUjW,KzBwzU/DouD,EyBvzUW38B,EAAA/qB,YAAYwG,QAAQ8W,IAAQgI,UAAUO,EAAO,GAAKtW,EAAUsW,EAAO,GAAKtW,GAAU4W,gBAC9F7sB,GAAkB,OAAdouD,GAAiC,aAH7C,IAKuB,wBAAZqC,EACP,CzByzUC7lD,EyBzzUEqI,MAAQmC,EACXa,CzByzUC,IyBzzUGlX,IACJ,CzByzUC,KyBzzUIwO,EAAI,EAAGjT,EAAM0F,EAAOzF,OAAQgT,EAAIjT,EAAKiT,IzB6zUrC,GAHA3C,EyBzzUE5K,OAASA,EACZuN,GzByzUC3C,EyBzzUE1D,OAASyT,EAAcA,EAAYpN,GACtC,KzByzUC3C,EyBzzUEuC,UAAYA,EACfI,GAAIkkB,EAAA/qB,YAAYqd,eAAenZ,GAC3B,CzByzUC7L,GyBxzUD,CACH,OzB2zUJ,IyBzzUIA,EAAmB,aAZrB,IAagB,oBAAZ0xD,GzB8zUN,GAFA7lD,EyB3zUEqI,MAAQmC,EACXa,EzB2zUCrL,EyB3zUE1D,OACHyT,GAAK8W,EAAA/qB,YAAYqd,eAAenZ,GAC5B,CzB2zUC,GyB3zUG8lD,GAAUj/B,EAAA/qB,YAAYwG,QAAQ8W,IAAQgI,UAAUO,EAAO,GAAKtW,EAAUsW,EAAO,GACjFtW,EzB2zUC,KyB3zUI1I,EAAI,EAAGjT,EAAM0F,EAAOzF,OAAQgT,EAAIjT,EAAKiT,IzB6zUrC,GADA6gD,EyB3zUWsC,EAAQ7jC,gBAAgB7sB,EACpCuN,IAAkB,OAAd6gD,EACA,CzB2zUCA,EyB3zUStgD,KACVP,CACH,OzB6zUJ,GyB3zUiB,OAAd6gD,EAAiC,cAZtC,IAcgB,iBAAZqC,GAA0C,YAAZA,EACrC,CzB6zUC,GyB7zUG7tC,GACJ0tC,CzBk0UC,KALAvxD,GyB5zUD,EAAgB,YAAZ0xD,IzB8zUCzwD,GyB7zUS+hB,EACV3U,azB6zUCD,GyB7zUY6U,EAChB7U,YACII,EAAI,EAAGjT,EAAM0F,EAAOzF,OAAQgT,EAAIjT,EAAKiT,IzBg0UrC,IyB7zUI,GAFDvE,GAAMhJ,EAAOuN,GACb0U,EAAO9U,EACXI,GAAS2N,EAAK,EAAG1N,EAAOxE,EAAIzO,OAAQ2gB,EAAK1N,EAAM0N,IAC3C,CzB6zUC,GyB7zUG7N,GAAI4U,EACR/G,EzB6zUC,IyB7zUG7N,EAAEmf,WAAWtf,IACTukB,EAAA/qB,YAAYwc,0BAA0BN,EAAU5Z,GAChD,CzB6zUCjK,EyB7zUa,IAAPmc,CAEV,QzBi0UZ,IyB7zUInc,EAAmB,aACrB,IAAgB,UAAZ0xD,GACkB,WAArBjO,EAAYz3C,KACZ,CzB+zUC,GyB/zUGsB,IAAKrM,EAAO,GAAKgkB,EAAM,IAAM/N,EAC7B1J,GAAKvM,EAAO,GAAKgkB,EAAM,IAC3B/N,CzB+zUC,IyB/zUG5J,EAAIA,EAAIE,EAAIA,EAAIgkD,EAASA,EAAqB,SzBo0UzD,GyBj0UI1vD,KAAK8vD,sBAAsBL,GzBq0U/B,OACIr4D,GyBh0UDk7B,EzBi0UC5iB,WyBj0UWlG,EACZkG,WzBi0UCrI,SyBh0UD6Z,EzBi0UC7U,OyBj0UO7C,EACR6C,OzBi0UCkhD,UyBh0UDA,EzBi0UC7hC,OyBj0UO3V,EAAa2V,EACrB,KzBi0UCi2B,YyB/zURA,IzBk0UA,MyBh0UJ,OzBm0UAja,cyBj0Uc,SAAUrY,EAAI0gC,GzBk0UxB,IyBj0UI/vD,KAAKsmC,KzBk0UL,MyBh0UJ,EzBk0UA,IyBj0UGh/B,GAAQtH,KACRlI,EAAMwP,EAAMipC,KACZrmC,EAAOmlB,EAAGnlB,KACVyoB,EAAY76B,EAAI66B,UAChBq9B,EAAW,SAAUC,GACbt9B,GAAsB,cAATzoB,IACT+lD,GAAU3oD,EAAMgiC,kBAAkB2mB,KzBk0UrC5gC,EyBj0UMv3B,IACH66B,EzBi0UHrrB,EyBj0US5D,KAAKusD,EACd5gC,IACGsD,EAAU8tB,WzBk0Ubn5C,EyBl0UgCwwC,WAAWnlB,EAAgBv7B,MAIpE+T,EAAOnL,KAAKsmC,KAChBoL,SzBs0UC,KyBt0UGvmC,EAAOnL,KAAK/H,QAAQg+C,SAAW9qC,EAAOnL,KAAK/H,QAAQ83C,WzBo0UlDggB,GyBl0UJ,GACGA,EACIp9B,IzBo0UCA,EyBp0UsBg6B,OAAgB,MzBs0U1CqD,EyBp0UD,YzBq0UCl4D,EyBr0UG66B,UACP,SAAM,IACH3yB,KAAKspC,kBAAkB,cACvBtpC,KAAKspC,kBAAkB,aACvBtpC,KAAKspC,kBAAkBp/B,IACb,cAATA,GAAoD,WAA5BpS,EAAI4X,WAAWwgD,SAGxC,CzBg0UC,GyBh0UGnoD,GAAMsnB,EAAGznB,OAAOG,IAAM,IACtBH,EAAS,GAAI/P,GAAE6mB,OAAO2Q,EAAGznB,OAAOE,IAAKC,GAAOA,GAAM,IAAO,IAAOA,EAAM,KAAM,IAAO,IACnFob,EAAQtrB,EAAEwX,WAAWC,SAASC,QAAQ3H,GAAQuoD,WACzC3kD,EAAG1T,EAAI84C,aAAe,EAAGllC,EAAG5T,EAAI+4C,aAAe,IAEpDz+B,EAAQtT,KAAK+O,IAAI,EAAG/V,EAAI65C,aAAawN,iBAAiBh0C,IAASrT,EAAIsd,SACnEg7C,GAAiBjtC,EAAM3X,EAAG2X,EAE9BzX,GACI2kD,GzB+zUCnmD,KyB7zUD,SzB8zUCkX,KyB9zUKwP,EAAA/qB,YAAYwG,QAAQ+jD,IAAgBjlC,UAC1C/Y,GzB8zUC8rB,ayB9zU+B,mBAAlBpmC,EAAIg8C,WAAkCh8C,EAAIqmC,UAAWrmC,EAAIumC,SACvE,KzB8zUCgB,SyB9zUS,aAAc,cAAgBvnC,EAAIyP,QAAS,cACrD,czB8zUC0kC,QyB9zUO,EAERjsC,MAAK/H,QAAQ0jC,gBzB+zUZ00B,EyB9zUerkB,WACnB7gC,GzBg0UArT,EyB9zUGmgC,YAAYqB,YAAY+2B,EAE5B,QzB8zUC,IyB9zUGrvC,GAAWlpB,EAAImgC,YAAY6F,SAE/B,QzBg0UC,IAFAhmC,EyB9zUGmgC,YAAY0B,eAEhB,SAAI3Y,GAAYA,EAAStnB,OACrB,CAAIsnB,EAAStnB,OAAS,GAAK5B,EAAI04C,YzB+zU1BxvB,EyB/zUkDhhB,KAAKsoD,eAA2BtnC,GzBk0UtF,IyBh0UGmP,GAASnwB,KAAKwvD,wBAAwBxuC,EAAUovC,EAAeC,EACnEjvC,KzBg0UC,IyBh0UG+O,EACA,CzBg0UC,GyBh0UGmC,GAAMnC,EAAO/4B,GACboS,EAAO1R,EAAImgC,YAAYwH,QAAQnN,GAC/Bq6B,EAASh6B,EAAYA,EAAUv7B,GAAK,KACpCk5D,GAAW39B,GAAaA,EAAUv7B,KACtCk7B,CzBg0UC,IyBh0UY,cAATpoB,GAAwByoB,EACxB,CzBg0UC,IyBh0UI29B,EzBm0UA,MAFAjhC,GyBh0UEv3B,IACH66B,EzBg0UC3yB,KyBh0UI0D,KAAKwG,EACVmlB,GACHiD,CzBi0UA09B,GyBh0UQxmD,EAAKw2B,gBAAkBrN,EAAUqN,cAAgB,WAC1D,IzBg0UCloC,EyBh0UG66B,UACP,KzBi1UA,MAfAtD,GyBh0UEv3B,IAAAD,EAAQ0K,OAAOvC,KAAKovD,eAAe5lD,IzBi0UjC+mD,QyB/zUDvvC,EzBg0UCusC,UyBh0UUp9B,EACXo9B,UzBg0UCZ,OyB/zUDA,EzBg0UClM,UyBh0UUj3C,EAEfi3C,YAAIzgD,KAAKspC,kBAAkBp/B,IzBi0UtBlK,KyBj0UoC0D,KAAKwG,EAAYmlB,GAC7C,cAATnlB,GAAwBomD,IzBm0UvB39B,EyBl0UW76B,EAAI66B,UAAYtD,EAC5Bv3B,IzBk0UCk4D,EyBj0UD,azBk0UCl4D,EyBl0UG04D,cAAgB14D,EACvB66B,WzBm0UA3yB,KyBl0UIsmC,KAAKmqB,gBACVC,UACHp+B,IzBw0UR,MyBr0UGtyB,MAAKsmC,MzBm0UJtmC,KyBl0UIsmC,KAAKmqB,gBACbE,SAEJ,GzBo0UAvB,eyBl0Ue,SAAU5lD,GzBm0UrB,OACIlC,MyBj0UDtH,KzBk0UCmwB,OyBj0UD3mB,EzBk0UC4jD,YyBl0UYptD,KAAKuwC,KAAKoB,aAAauH,eAAe1vC,EACnDpS,IzBk0UCsY,WyBl0UW1P,KAAKm5C,kBAAkB3vC,EACnCkG,YzBk0UCswB,cyBl0Ucx2B,EAAKw2B,eACpB,EzBk0UC5oC,GyBl0UGoS,EAEXpS,QzBu0UC,SAASD,EAAQD,EAASH,GAE/B,Y0BllVyB,IAAA65B,GAAA75B,EAAA,IAE1B,W1BqlVK,G0BplVD65D,GAAQ,IACRj7B,KACAk7B,KACAnoD,EAAS,2BACTooD,EAAa,KACbC,EAAY,KACZC,EAEJ,GAAIC,EAAgB,SAAS7/C,G1BqlVpB,G0BplVD8/C,GAAW9/C,EAAKiqB,SAAW,gBAC/B,O1BolVK,O0BplVE61B,KACV9/C,IACG+/C,EAAY,SAAS//C,EAAMw2C,EAAIwJ,G1BqlV1B,G0BplVD1jD,I1BqlVK2jD,K0BplVCjgD,EACNuc,K1BolVK2jC,Q0BplVIL,EAAc7/C,GAAQA,EAAK+pB,cAAe,E1BslVlD,I0BplVJysB,IAAOx2C,EAAKomC,YAAa,GAAiC,eAAxBtxC,OAAOqxC,cAC5C,C1BolVW,G0BplVPga,GAAkB3J,EAAG1nB,qBACxB/B,EAAYozB,EAAgBpzB,WAAaizB,EAAkBjzB,UAC3DE,EAAUkzB,EAAgBlzB,SAAW+yB,EAChC/yB,OAAIF,K1BqlVKzwB,E0BrlVW8zB,UAAY1iC,KAAKC,MAAMo/B,EAAU0P,UAAoB,MACrExP,I1BulVK3wB,E0BvlVS+zB,QAAU3iC,KAAKC,MAAMs/B,EAAQwP,UAAoB,M1B0lVlE,M0BvlVRngC,IACG8jD,EAAmB,SAASlqD,G1BylVvB,G0BvlVD8J,GAAM1K,EAAUkhD,EACpBwJ,EAFIz5B,I1B6lVC,I0B3lVDrwB,EACIA,YAAiBzP,GAAEC,IAAIK,a1B4lVlByvD,E0B1lVdtgD,E1B2lVc8J,E0B3lVPw2C,EACP3vD,U1B4lVcmZ,E0B3lVP9J,EAAMipC,KACb7gC,W1B2lVck4C,E0B3lVTtgD,EAAMipC,KACXtY,Y1B2lVcm5B,E0B3lVM9pD,EACpBipC,M1B4lVU7pC,E0B3lVM0K,EAAK1K,UAAYY,EAAMipC,KACxC7pC,S1B2lVWixB,E0B3lVLjxB,IAAayqD,EAAU//C,EAAMw2C,EAChCwJ,QACG,C1B2lVK,G0B3lVDK,K1B4lVC,K0B3lVA,GAAIr6D,KAAMu+B,GACX,C1B2lVK,G0B3lVDjwB,GAAMiwB,EAAOv+B,GACzBs6D,EAAgBhsD,YAAe7N,GAAEC,IACzBK,W1B2lVK,I0B3lVDuN,EAAIzN,QAAQi+C,WAAawb,EACrC,C1B2lViB9J,E0B3lVZ8J,EAAgBhsD,EAAMA,EAAI6qC,KACnBtY,Y1B2lVK7mB,E0B3lVEsgD,EAAgBhsD,EAAIzN,QAAUyN,EAAI6qC,KACrD7gC,W1B2lViB0hD,E0B3lVGM,EAAgBhsD,EAAMA,EAC9B6qC,K1B2lVK7pC,E0B3lVM0K,EAAK1K,UAAYhB,EAAI6qC,KAChC7pC,Q1B2lVK,I0B3lVDgH,GAAKyjD,EAAU//C,EAAMw2C,EAAIwJ,GACzBhpD,EAAMsF,EAAG2jD,KAAO3jD,EACpB4jD,OAAKG,GAAUrpD,KACPuvB,EAAMjxB,G1B4lVDixB,E0B5lVoBjxB,GAAUlL,KAAWkS,G1B8lVzCiqB,E0B7lVIjxB,IAAmBgH,I1BgmV/B+jD,E0B9lVKrpD,IACb,I1BimVJ,M0B7lVRuvB,IAEGg6B,EAAa,SAAUrqD,EAAO/G,G1B+lVzB,G0B9lVDqxD,GAAkB,SAAS/yD,G1B+lVtB,G0B9lVDA,GAAsB,OAAfA,EAAIywB,QAAmBzwB,EAAI41B,O1B+lV7B,I0B9lVA,GAAIh6B,GAAI,EAAGhB,EAAMoF,EAAI41B,OAAO/6B,OAAQe,EAAIhB,EAAKgB,IAC9C,C1B8lVK,G0B9lVD+O,GAAO3K,EAAI41B,OAAOh6B,GAClBrD,EAAKoS,EAAKkG,WAE1Bie,IAAIrmB,IAASA,EAAMipC,KAAK7gC,WAAWie,OAASv2B,GAAM,iBAAmBkQ,I1B+lVhDA,E0B/lV+D67B,cAAsB35B,E1BimVzF,K0BhmVA,GAAIpB,KAAOutB,GACZ,C1BgmVK,G0BhmVDk8B,GAAWl8B,EAC9BvtB,EAAId,IAASA,IAAUuqD,IACJA,EAASthB,MAAQshB,EAASthB,KAAK7gC,WAAWie,OAASv2B,GAAM,iBAAmBy6D,G1BomVvEA,E0BnmVd1uB,cACT35B,GAAUqoD,YAAoBh6D,GAAEC,IAAIK,aAAe05D,EAAS55D,QAAQ01B,OAASv2B,G1BqmVtDy6D,E0BpmVd1uB,cAAc35B,EACvBkG,c1BwmVOshD,E0BnmVL,GAAIzwD,G1BqmVKA,E0BrmVuB1B,G1BymV/B,I0BtmVDuH,SAASqqB,OAASG,EAAA/qB,YAAYM,eAC9B,C1BsmVK,G0BtmVDwxB,GAAQ65B,EAAiBlqD,GACzBwqD,EAAU,SAASprD,G1BumVd,G0BtmVG5E,GAAM,UAAY4E,EAAWgC,EAC7BqpD,EAAYzpD,KAAKC,UAAUovB,EAE/BjxB,G1BsmVC,I0BtmVGsqD,IAAkBe,EAClB,C1BsmVCf,E0BrmVDe,EAAI,YAAc7rD,Q1BumVb0qB,EAAO/qB,Y0BtmVIzC,S1BumVPtB,I0BrmVDA,E1BsmVCqI,O0BrmVD,E1BsmVCC,SACI4nD,e0BpmVL,qC1BsmVC9nD,K0BrmVD,O1BsmVCzB,O0BtmVO,yBAA2BS,mBACnC6oD,G1BsmVCxnD,iB0BrmVD,E1BsmVChK,S0BtmVS,SAASi0B,G1BumVdo9B,E0BtmVetpD,KAAK8mB,MACxBoF,K1BumVA5pB,Q0BtmVQ,SAAS4pB,G1BumVb9hB,Q0BtmVOC,IAAI,uBACf6hB,M1BymVJ5D,EAAO/qB,Y0BtmVIiqB,2BAA2BhuB,G1BumVlCsF,U0BrmVD,U1BsmVCuuB,O0BtmVOo8B,GAEfH,E1BumVA,I0BtmVGK,GAAYnoC,KAChB2tB,K1BsmVC,K0BtmVI,GAAIrvC,KAAOutB,GACZ,C1BsmVC,G0BtmVG9xB,GAAK8xB,EACTvtB,GAAInQ,EAAU4L,EAAG0sC,MAAQ1sC,EACzB5L,OAAIA,GAAQyO,WAAaA,I1BumVpBzO,E0BvmVwCi6D,qBAAmCD,K1B4mV3F,K0BxmVA,GAAIvrD,KAAYixB,G1BymVZm6B,E0BvmVRprD,KAIL4rC,G1B0mVKha,e0BxmVW,SAASL,G1BymVhB,G0BxmVD7gC,GAAK6gC,EAAYhgC,QACrB01B,IAAIv2B,KAAMu+B,K1B2mVLsC,E0BxmVCpI,GAAG,iBAAkB8hC,EAAWzvD,KAC5C+1B,I1BwmVWtC,E0BxmVJv+B,GACJ6gC,I1B0mVIk6B,kB0BxmVc,SAASl6B,G1BymVnB,G0BxmVD7gC,GAAK6gC,EAAYhgC,QACrB01B,IAAIv2B,KAAMu+B,K1BymVDsC,E0BxmVFua,IAAI,iBAAkBmf,EAAWzvD,KAC7C+1B,UAAOtC,GACPv+B,K1B2mVM+K,O0BxmVG,SAASmF,SACNquB,GAAOruB,EACdyiC,Y1BwmVK,I0BxmVDwG,GAAOjpC,EAAMipC,KACtB6hB,EAAW9qD,EAAMrP,QAClB8/B,a1BwmVW,I0BxmVPq6B,EACH,C1BwmVc,G0BxmVVv6B,GAAMu6B,EACVzkC,IAAIkjC,GAAkBh5B,WACdg5B,GAAkBh5B,GAAK0Y,EAAK7gC,WACnCie,MAAK1oB,OAAOC,KAAK2rD,EAAkBh5B,IAAMn+B,S1BymVpB44C,E0BxmVN6f,kBAAkB5hB,EAChCtY,mBAAO44B,GACPh5B,S1B2mVY0Y,G0BxmVTtY,YAAYua,IAAI,iBAAkBjC,EACvC8hB,c1B2mVM3pB,I0BxmVA,SAASphC,G1BymVL,G0BxmVDlQ,GAAKkQ,EACTyiC,W1BwmVK,M0BxmVD3yC,IAAMu+B,I1BwmVL,CAIA,G0BxmVD4a,GAAOjpC,EAAMipC,KACbn/B,EAAOm/B,EACX7gC,U1BwmVK,I0BxmVD,gBAAkB0B,GAClB,C1BwmVKukB,E0BxmVEv+B,GACPkQ,E1BwmVKipC,E0BxmVA8hB,YAAc,W1BymVVV,E0BvmVRrqD,I1BymVIipC,E0BxmVAtY,YAAYpI,GAAG,iBAAkB0gB,EAC/C8hB,Y1BwmVc,I0BxmVVD,GAAW9qD,EAAMrP,QACrB8/B,a1BwmVc,I0BxmVVq6B,EACH,C1BwmViB,G0BxmVbv6B,GAAMu6B,EACVzkC,I1BwmViB2kB,G0BxmVHha,eAAeiY,EAC7BtY,aAAK44B,EAAkBh5B,K1BymVFg5B,E0BzmV4Bh5B,O1B2mVhCg5B,E0B1mVCh5B,GAAKzmB,EAAKuc,MAC5BrmB,E1B4mVagrC,E0BzmVLggB,UAAK/hB,EAAK2hB,sBAAwB3hB,EAAK2hB,qBAAuBpoC,KAAK2tB,MAAQ,OAAUwZ,EAAc7/C,K1B2mV1FkhC,E0BzmVRmF,S1B8mVJka,W0BxmVLA,E1B0mVKla,I0B1mVA,WACHsZ,G1B2mVW5vB,a0B3mV4B4vB,G1B6mVhCA,E0B5mVC3vB,WAAWuwB,EACpB,I1B8mVIY,K0B5mVC,WACEzB,G1B6mVK0B,c0B7mVqC1B,G1B+mVzCA,E0B7mVR,M1BgnVIwB,M0B9mVE,SAASG,GACRA,I1B+mVK7B,E0B/mVkB6B,G1BinVtBngB,E0B/mVLigB,O1BgnVKzB,E0BhnVQ4B,YAAYf,EAC5Bf,IAGA/4D,GAAEC,M1BinVED,E0BjnVOC,Q1BmnVXD,E0BlnVHC,IAAIw6C,cAENA,E1BknVKz6C,E0BlnVHC,IAAI63C,YAAYua,S1BmnVT/mB,c0BlnVU,SAAUwvB,G1BmnVhB,G0BlnVDA,EACA,C1BknVK,G0BlnVD76D,GAAMkI,KACVuwC,IAAIoiB,GAAiBtrD,W1BmnVZvP,E0BlnVDuP,SAAWsrD,EAClBtrD,UACGsrD,EAAiBjjD,a1BmnVZ7X,E0BlnVH0K,OAAOzK,EAAI4X,WAAYijD,EACzBjjD,Y1BknVK5X,E0BlnVD4X,WAAW0rB,cAAgBu3B,EAAiBjjD,WAChD0rB,c1BknVKtjC,E0BlnVDg+C,cAAgBh+C,EACpB4X,W1BknVK1P,K0BlnVA0D,KACjB,iBAAK5L,EAAIo/B,Y1BmnVYp/B,E0BlnVhBmgC,YAAYkL,cAAcrr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","file":"./dist/geomixer.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\tvar _MapManager = __webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(10);\n\t\n\tvar _Observer = __webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\tvar _DataManager = __webpack_require__(9);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(20);\n\t\n\t__webpack_require__(21);\n\t\n\t__webpack_require__(19);\n\t\n\t__webpack_require__(22);\n\t\n\t__webpack_require__(23);\n\t\n\t__webpack_require__(24);\n\t\n\t__webpack_require__(25);\n\t\n\t__webpack_require__(26);\n\t\n\t__webpack_require__(27);\n\t\n\t__webpack_require__(28);\n\t\n\t__webpack_require__(29);\n\t\n\t__webpack_require__(30);\n\t\n\t__webpack_require__(31);\n\t\n\t__webpack_require__(32);\n\t\n\t__webpack_require__(33);\n\t\n\t__webpack_require__(34);\n\t\n\t__webpack_require__(35);\n\t\n\t__webpack_require__(36);\n\t\n\t__webpack_require__(37);\n\t\n\tL.gmx = L.gmx || {};\n\t\n\t// import './commonjs.js';\n\tL.gmx.gmxMapManager = _MapManager.gmxMapManager;\n\tL.gmx.observer = function (options) {\n\t  return new _Observer.Observer(options);\n\t};\n\tL.gmx.DataManager = _DataManager.DataManager;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t   Single-pass recursive descent PEG parser library:\r\n\t      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n\t   Inspired by Chris Double's parser combinator library in JavaScript:\r\n\t      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t\t+ Добавлены функции: Math.floor\r\n\t*/\n\t(function () {\n\t\tvar regexExpression = /\\[(.+?)\\]/g,\n\t\t    regexMath = /(floor\\()/g;\n\t\tvar Parsers = { // Парсеры\n\t\t\tfunctionFromExpression: function functionFromExpression(s) {\n\t\t\t\t/*eslint-disable no-new-func*/\n\t\t\t\treturn new Function(\n\t\t\t\t/*eslint-enable */\n\t\t\t\t'props', 'indexes', 'return ' + s.replace(regexExpression, 'props[indexes[\"$1\"]]').replace(regexMath, 'Math.$1') + ';');\n\t\t\t}\n\t\t};\n\t\n\t\tvar makePair = function makePair(t1, t2) {\n\t\t\treturn { head: t1, tail: t2 };\n\t\t};\n\t\n\t\t// C-style linked list via recursive typedef.\n\t\t//   Used purely functionally to get shareable sublists.\n\t\t//typedef LinkedList = Pair<Dynamic, LinkedList>;\n\t\tvar LinkedList = function LinkedList(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser state contains position in string and some accumulated data.\n\t\t//typedef ParserState = Pair<Int, LinkedList>;\n\t\tvar ParserState = function ParserState(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser accepts string and state, returns another state.\n\t\t//typedef Parser = String->ParserState->ParserState;\n\t\n\t\t// A parser state that indicates failure.\n\t\tvar fail = new ParserState(-1, null);\n\t\n\t\t// Check for failure.\n\t\tvar failed = function failed(state) {\n\t\t\treturn state.head === -1;\n\t\t};\n\t\n\t\t// Advance a parser state by n characters.\n\t\tvar advance = function advance(state, n) {\n\t\t\treturn new ParserState(state.head + n, state.tail);\n\t\t};\n\t\n\t\t// Match a specified string.\n\t\tvar token = function token(tok) {\n\t\t\tvar len = tok.length;\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len) === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a string without regard to case.\n\t\tvar caseInsensitiveToken = function caseInsensitiveToken(tok) {\n\t\t\tvar len = tok.length;\n\t\t\ttok = tok.toLowerCase();\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len).toLowerCase() === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a single character in a specified range.\n\t\tvar range = function range(startChar, endChar) {\n\t\t\tvar startCode = startChar.charCodeAt(0);\n\t\t\tvar endCode = endChar.charCodeAt(0);\n\t\t\treturn function (s, state) {\n\t\t\t\tvar code = s.charCodeAt(state.head);\n\t\t\t\treturn code >= startCode && code <= endCode ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match any character outside a certain set.\n\t\t//   This combinator is intended only for single character parsers.\n\t\tvar anythingExcept = function anythingExcept(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.length > state.head && failed(parser(s, state)) ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, then thing2, ..., then thingN.\n\t\tvar sequence = function sequence(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tstate = parsers[i](s, state);\n\t\t\t\t\tif (failed(state)) {\n\t\t\t\t\t\treturn fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn state;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, or thing2, ..., or thingN.\n\t\tvar choice = function choice(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tvar newState = parsers[i](s, state);\n\t\t\t\t\tif (!failed(newState)) {\n\t\t\t\t\t\treturn newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match immediately, without regard to what's in the string.\n\t\tvar nothing = function nothing(s, state) {\n\t\t\treturn state;\n\t\t};\n\t\n\t\t// Match this thing or nothing.\n\t\tvar maybe = function maybe(parser) {\n\t\t\treturn choice([parser, nothing]);\n\t\t};\n\t\n\t\t// Match minCount or more repetitions of this thing.\n\t\tvar repeat = function repeat(minCount, parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar count = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tvar newState = parser(s, state);\n\t\t\t\t\tif (failed(newState)) {\n\t\t\t\t\t\treturn count >= minCount ? state : fail;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// return fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a list of minCount or more instances of thing1, separated by thing2.\n\t\tvar separatedList = function separatedList(minCount, parser, separator) {\n\t\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\n\t\t\treturn minCount > 0 ? parser1 : choice([parser1, nothing]);\n\t\t};\n\t\n\t\tvar whitespace = repeat(0, choice([token(' '), token('\\t'), token('\\n')]));\n\t\n\t\t// Same as separatedList, but can have whitespace between items and separators.\n\t\tvar whitespaceSeparatedList = function whitespaceSeparatedList(minCount, parser, separator) {\n\t\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\n\t\t};\n\t\n\t\t// Same as sequence, but can have whitespace between items.\n\t\tvar whitespaceSeparatedSequence = function whitespaceSeparatedSequence(parsers) {\n\t\t\tvar newParsers = [];\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\tif (newParsers.length > 0) {\n\t\t\t\t\tnewParsers.push(whitespace);\n\t\t\t\t}\n\t\t\t\tnewParsers.push(parsers[i]);\n\t\t\t}\n\t\t\treturn sequence(newParsers);\n\t\t};\n\t\n\t\t// This combinator captures the string that the parser matched\n\t\t//   and adds it to the current parser state, consing a new state.\n\t\tvar capture = function capture(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar newState = parser(s, state);\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// This combinator passes the accumulated parser state to a given\n\t\t//  function for processing. The result goes into the new state.\n\t\tvar action = function action(parser, func) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar oldState = state;\n\t\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// Define a syntactic subset of SQL WHERE clauses.\n\t\tvar fieldName = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('а', 'я'), range('А', 'Я'), range('0', '9'), token('_')])));\n\t\n\t\tvar fieldNameWithSpaces = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('а', 'я'), range('А', 'Я'), range('0', '9'), token('_'), token(' ')])));\n\t\n\t\tvar quotedFieldName = choice([fieldName, sequence([token('\"'), fieldNameWithSpaces, token('\"')]), sequence([token('`'), fieldNameWithSpaces, token('`')])]);\n\t\n\t\tvar stringLiteral = sequence([token('\\''), capture(repeat(0, anythingExcept(token('\\'')))), token('\\'')]);\n\t\n\t\tvar digits = repeat(1, range('0', '9'));\n\t\n\t\tvar numberLiteral = capture(sequence([maybe(token('-')), digits, maybe(sequence([token('.'), digits]))]));\n\t\n\t\tvar literal = choice([numberLiteral, stringLiteral]);\n\t\n\t\tvar applyParser = function applyParser(s, parser) {\n\t\t\treturn parser(s, new ParserState(0, null));\n\t\t};\n\t\n\t\t// Order is important here: longer ops should be tried first.\n\t\tvar opTerm = action(whitespaceSeparatedSequence([quotedFieldName, capture(choice([token('=='), token('!='), token('<>'), token('<='), token('>='), token('='), token('<'), token('>'), caseInsensitiveToken('LIKE')])), choice([literal, quotedFieldName])]), function (state) {\n\t\t\t// Linked list contains fieldname, operation, value\n\t\t\t// (in reverse order).\n\t\n\t\t\tvar fieldName = state.tail.tail.head;\n\t\t\tvar op = state.tail.head;\n\t\t\tvar referenceValue = state.head;\n\t\n\t\t\tvar matchPattern = null;\n\t\t\tif (op.toUpperCase() === 'LIKE') {\n\t\t\t\tmatchPattern = function matchPattern(fieldValue) {\n\t\t\t\t\tvar _matchFrom = null;\n\t\t\t\t\t_matchFrom = function matchFrom(referenceIdx, fieldIdx) {\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\n\t\t\t\t\t\tif (referenceChar === '') {\n\t\t\t\t\t\t\treturn fieldChar === '';\n\t\t\t\t\t\t} else if (referenceChar === '%') {\n\t\t\t\t\t\t\treturn _matchFrom(referenceIdx + 1, fieldIdx) || fieldChar !== '' && _matchFrom(referenceIdx, fieldIdx + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn referenceChar === fieldChar && _matchFrom(referenceIdx + 1, fieldIdx + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn _matchFrom(0, 0);\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\n\t\t\t\t    rValue = referenceValue;\n\t\t\t\tif (referenceValue in indexes) {\n\t\t\t\t\trValue = props[indexes[rValue]];\n\t\t\t\t}\n\t\t\t\tif (types[fieldName] === 'date' && typeof rValue === 'string') {\n\t\t\t\t\trValue = L.gmxUtil.getUnixTimeFromStr(rValue);\n\t\t\t\t}\n\t\t\t\tif (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\n\t\t\t\t\tfieldValue = fieldValue ? 'True' : 'False';\n\t\t\t\t}\n\t\t\t\tif (fieldValue === null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (matchPattern !== null) {\n\t\t\t\t\treturn matchPattern(fieldValue);\n\t\t\t\t\t/*eslint-disable eqeqeq */\n\t\t\t\t} else if (op === '=' || op === '==') {\n\t\t\t\t\treturn fieldValue == rValue;\n\t\t\t\t} else if (op === '!=' || op === '<>') {\n\t\t\t\t\treturn fieldValue != rValue;\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t} else {\n\t\t\t\t\tvar f1, f2;\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\n\t\t\t\t\t\tf2 = parseFloat(rValue);\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf1 = fieldValue;\n\t\t\t\t\t\tf2 = rValue;\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\tvar inTerm = action(whitespaceSeparatedSequence([quotedFieldName, caseInsensitiveToken('IN'), token('('), whitespaceSeparatedList(0, literal, token(',')), token(')')]), function (state) {\n\t\t\t// Linked list contains fieldname and multiple values\n\t\t\t//   (in reverse order).\n\t\n\t\t\tvar node = state;\n\t\t\twhile (node.tail != null) {\n\t\t\t\tnode = node.tail;\n\t\t\t}\n\t\t\tvar fieldName = node.head;\n\t\n\t\t\treturn function (props, indexes) {\n\t\t\t\tvar value = props[indexes[fieldName]];\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node.tail !== null) {\n\t\t\t\t\tif (node.head === value) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\t});\n\t\n\t\t// Forward declarations to allow mutually recursive grammar definitions.\n\t\tvar _term = function term(s, state) {\n\t\t\treturn _term(s, state);\n\t\t};\n\t\tvar _expression = function expression(s, state) {\n\t\t\treturn _expression(s, state);\n\t\t};\n\t\n\t\tvar notTerm = action(whitespaceSeparatedSequence([caseInsensitiveToken('NOT'), _term]), function (state) {\n\t\t\t// Linked list contains only processed inner term.\n\t\t\tvar innerTerm = state.head;\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn !innerTerm(props, indexes, types);\n\t\t\t};\n\t\t});\n\t\n\t\t_term = choice([notTerm, opTerm, inTerm, whitespaceSeparatedSequence([token('('), _expression, token(')')])]);\n\t\n\t\t// AND and OR expressions must have at least 2 terms,\n\t\t//   to disambiguate them from a single term.\n\t\n\t\tvar andExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('AND')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = true;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\tvar orExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('OR')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = false;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\t// Order is important here: term should be tried last,\n\t\t//   because andExpression and orExpression start with it.\n\t\t_expression = choice([andExpression, orExpression, _term]);\n\t\n\t\tvar whereClause = sequence([whitespace, _expression, whitespace]);\n\t\n\t\tParsers.parseSQL = function (str) {\n\t\t\tvar result = applyParser(str, whereClause);\n\t\t\treturn result.head === str.length ? result.tail.head : applyParser(str, whitespace).head === str.length ? function () /*props*/{\n\t\t\t\treturn true;\n\t\t\t} : null;\n\t\t};\n\t\n\t\tvar _additiveExpression = function additiveExpression(s, state) {\n\t\t\treturn _additiveExpression(s, state);\n\t\t};\n\t\tvar _multiplicativeExpression = function multiplicativeExpression(s, state) {\n\t\t\treturn _multiplicativeExpression(s, state);\n\t\t};\n\t\t_additiveExpression = action(whitespaceSeparatedList(1, _multiplicativeExpression, capture(choice([token('+'), token('-')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 0.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm += pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '-') {\n\t\t\t\t\t\t\tterm = -term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tvar multiplicativeTerm = choice([action(numberLiteral, function (state) {\n\t\t\treturn function () /*props, indexes, types*/{\n\t\t\t\treturn parseFloat(state.head);\n\t\t\t};\n\t\t}), action(sequence([token('floor('), _additiveExpression, token(')')]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar res = state.head(props, indexes, types);\n\t\t\t\treturn Math.floor(res);\n\t\t\t};\n\t\t}), action(sequence([token('['), fieldName, token(']')]), function (state) {\n\t\t\treturn function (props, indexes) {\n\t\t\t\treturn parseFloat(props[indexes[state.head]]);\n\t\t\t};\n\t\t}), whitespaceSeparatedSequence([token('('), _additiveExpression, token(')')])]);\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\t_multiplicativeExpression = action(whitespaceSeparatedList(1, multiplicativeTerm, capture(choice([token('*'), token('/')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 1.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '/') {\n\t\t\t\t\t\t\tterm = 1.0 / term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\n\t\tvar arithmeticExpression = sequence([whitespace, _additiveExpression, whitespace]);\n\t\tParsers.parseExpression = function (s) {\n\t\t\tvar result = applyParser(s, arithmeticExpression);\n\t\t\treturn result.head === s.length ? result.tail.head : null;\n\t\t\t// return result.head === s.length ? Parsers.functionFromExpression(s) : null;\n\t\t};\n\t\n\t\tvar svgPath = action(repeat(0, choice([numberLiteral, token(','), token('M'), token('C'), repeat(1, choice([token(' '), token('\\t'), token('\\r'), token('\\n')]))])), function (state) {\n\t\t\tvar coords = [];\n\t\t\twhile (state !== null) {\n\t\t\t\tcoords.push(parseFloat(state.head));\n\t\t\t\tstate = state.tail;\n\t\t\t}\n\t\t\tcoords.reverse();\n\t\t\treturn coords;\n\t\t});\n\t\n\t\tParsers.parseSVGPath = function (s) {\n\t\t\tvar result = applyParser(s, svgPath);\n\t\t\tif (result.head === s.length) {\n\t\t\t\treturn result.tail.head;\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t\n\t\t//extend L.gmx namespace\n\t\tL.gmx = L.gmx || {};\n\t\tL.gmx.Parsers = Parsers;\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t//all the methods can be called without instance itself\n\t//For example:\n\t//\n\t// var def = new Deferred();\n\t// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\n\tvar Deferred = function Deferred(cancelFunc) {\n\t    var resolveCallbacks = [],\n\t        rejectCallbacks = [],\n\t        isFulfilled = false,\n\t        isResolved = false,\n\t        fulfilledData,\n\t        onceAdded = false,\n\t        isCancelled = false;\n\t\n\t    var fulfill = this._fulfill = function (resolved /*, data*/) {\n\t        if (isFulfilled) {\n\t            return;\n\t        }\n\t        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\n\t        fulfilledData = [].slice.call(arguments, 1);\n\t        isFulfilled = true;\n\t        isResolved = resolved;\n\t\n\t        callbacks.forEach(function (callback) {\n\t            callback.apply(null, fulfilledData);\n\t        });\n\t        resolveCallbacks = rejectCallbacks = [];\n\t    };\n\t\n\t    this.resolve = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    this.reject = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    var cancel = this.cancel = function () {\n\t        if (!isCancelled && !isFulfilled) {\n\t            isCancelled = true;\n\t            cancelFunc && cancelFunc();\n\t        }\n\t    };\n\t\n\t    var then = this.then = function (resolveCallback, rejectCallback) {\n\t        if (isCancelled) {\n\t            return null;\n\t        }\n\t\n\t        var userFuncDef = null;\n\t        var def = new Deferred(function () {\n\t            cancel();\n\t            userFuncDef && userFuncDef.cancel();\n\t        });\n\t\n\t        var fulfillFunc = function fulfillFunc(func, resolved) {\n\t            return function () /*data*/{\n\t                if (!func) {\n\t                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\n\t                } else {\n\t                    var res = func.apply(null, arguments);\n\t                    if (res instanceof Deferred) {\n\t                        userFuncDef = res;\n\t                        res.then(def.resolve, def.reject);\n\t                    } else {\n\t                        def.resolve(res);\n\t                    }\n\t                }\n\t            };\n\t        };\n\t\n\t        if (isFulfilled) {\n\t            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\n\t        } else {\n\t            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\n\t            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\n\t        }\n\t        return def;\n\t    };\n\t\n\t    this.once = function (onceResolveCallback) {\n\t        if (!onceAdded) {\n\t            onceAdded = true;\n\t            then(onceResolveCallback);\n\t        }\n\t    };\n\t\n\t    this.always = function (callback) {\n\t        then(callback, callback);\n\t    };\n\t\n\t    this.getFulfilledData = function () {\n\t        return fulfilledData;\n\t    };\n\t};\n\t\n\tDeferred.all = function () {\n\t    var defArray = [].slice.apply(arguments);\n\t    var resdef = new Deferred();\n\t    var left = defArray.length;\n\t    var results = new Array(defArray.length);\n\t\n\t    if (left) {\n\t        defArray.forEach(function (def, i) {\n\t            def.then(function (res) {\n\t                results[i] = res;\n\t                left--;\n\t                if (left === 0) {\n\t                    resdef.resolve.apply(resdef, results);\n\t                }\n\t            }, function () {\n\t                resdef.reject();\n\t            });\n\t        });\n\t    } else {\n\t        resdef.resolve();\n\t    }\n\t\n\t    return resdef;\n\t};\n\t\n\tL.gmx = L.gmx || {};\n\tL.gmx.Deferred = Deferred;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\n\t    var ImageRequest = function ImageRequest(id, url, options) {\n\t        this._id = id;\n\t        this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\n\t        this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\n\t        this.url = url;\n\t        this.options = options || {};\n\t    };\n\t\n\t    var GmxImageLoader = L.Class.extend({\n\t        includes: L.Mixin.Events,\n\t        statics: {\n\t            MAX_COUNT: 20 // max number of parallel requests\n\t        },\n\t\n\t        initialize: function initialize() {\n\t            this.curCount = 0; // number of currently processing requests (number of items in \"inProgress\")\n\t            this.requests = []; // not yet processed image requests\n\t            this.inProgress = {}; // hash of in progress image loadings\n\t            this.requestsCache = {}; // for requests cache by uniqueID\n\t            this.uniqueID = 0;\n\t        },\n\t\n\t        _resolveRequest: function _resolveRequest(request, image, canceled) {\n\t            var def = request.def;\n\t            if (image) {\n\t                if (!canceled && request.options.cache) {\n\t                    var url = request.url,\n\t                        cacheItem = this.requestsCache[url],\n\t                        cacheKey = request._id;\n\t                    if (!cacheItem) {\n\t                        cacheItem = this.requestsCache[url] = { image: image, requests: {} };\n\t                    }\n\t                    if (!cacheItem.requests[cacheKey]) {\n\t                        cacheItem.requests[cacheKey] = request;\n\t                    }\n\t                }\n\t                def.resolve(image);\n\t            } else if (!canceled) {\n\t                def.reject();\n\t            }\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _imageLoaded: function _imageLoaded(url, image, canceled) {\n\t            if (url in this.inProgress) {\n\t                var resolveRequest = function resolveRequest(it) {\n\t                    this._resolveRequest(it, image, canceled);\n\t                };\n\t                this.inProgress[url].requests.forEach(resolveRequest.bind(this));\n\t                --this.curCount;\n\t                delete this.inProgress[url];\n\t            }\n\t            L.gmxUtil.loaderStatus(url, true);\n\t            this.fire('imageloaded', { url: url });\n\t            this._nextLoad();\n\t        },\n\t\n\t        _nextLoad: function _nextLoad() {\n\t            // загрузка следующего\n\t            if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\n\t                return;\n\t            }\n\t\n\t            var request = this.requests.shift(),\n\t                url = request.url;\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                var requests = [request];\n\t                this.inProgress[url] = { requests: requests };\n\t                ++this.curCount;\n\t\n\t                for (var k = this.requests.length - 1; k >= 0; k--) {\n\t                    if (this.requests[k].url === url) {\n\t                        requests.push(this.requests[k]);\n\t                        this.requests.splice(k, 1);\n\t                    }\n\t                }\n\t\n\t                var image = this._loadImage(request);\n\t                if (!image.width) {\n\t                    L.gmxUtil.loaderStatus(url);\n\t                }\n\t\n\t                //theoretically image loading can be synchronous operation\n\t                if (this.inProgress[url]) {\n\t                    this.inProgress[url].image = image;\n\t                }\n\t            }\n\t        },\n\t\n\t        _loadImage: function _loadImage(request) {\n\t            var imageObj = new Image(),\n\t                url = request.url,\n\t                _this = this;\n\t\n\t            if (request.options.crossOrigin) {\n\t                imageObj.crossOrigin = request.options.crossOrigin;\n\t            }\n\t\n\t            imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\n\t            imageObj.onerror = function () {\n\t                _this._imageLoaded(url);\n\t            };\n\t            imageObj.src = url;\n\t\n\t            this.fire('imageloadstart', { url: url });\n\t\n\t            return imageObj;\n\t        },\n\t\n\t        _cancelRequest: function _cancelRequest(request) {\n\t            var id = request._id,\n\t                url = request.url,\n\t                i = 0,\n\t                len;\n\t            if (url in this.inProgress) {\n\t                var loadingImg = this.inProgress[url],\n\t                    requests = loadingImg.requests;\n\t\n\t                len = requests.length;\n\t                if (len === 1 && requests[0]._id === id) {\n\t                    loadingImg.image.onload = L.Util.falseFn;\n\t                    loadingImg.image.onerror = L.Util.falseFn;\n\t                    loadingImg.image.src = L.Util.emptyImageUrl;\n\t                    this._imageLoaded(url, null, true);\n\t                } else {\n\t                    for (i = 0; i < len; i++) {\n\t                        if (requests[i]._id === id) {\n\t                            requests.splice(i, 1);\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (i = 0, len = this.requests.length; i < len; i++) {\n\t                    if (this.requests[i]._id === id) {\n\t                        this.requests.splice(i, 1);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _removeRequestFromCache: function _removeRequestFromCache(request) {\n\t            // remove request from cache\n\t            this._cancelRequest(request);\n\t            this._clearCacheItem(request.url, request._id);\n\t        },\n\t\n\t        _clearCacheItem: function _clearCacheItem(url, cacheKey) {\n\t            // remove cache item\n\t            if (this.requestsCache[url]) {\n\t                var cacheItem = this.requestsCache[url];\n\t                delete cacheItem.requests[cacheKey];\n\t                if (Object.keys(cacheItem.requests).length === 0) {\n\t                    delete this.requestsCache[url];\n\t                }\n\t            }\n\t        },\n\t        _add: function _add(atBegin, url, options) {\n\t            var id = 'id' + ++this.uniqueID,\n\t                request = new ImageRequest(id, url, options);\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                atBegin ? this.requests.unshift(request) : this.requests.push(request);\n\t                this._nextLoad();\n\t            }\n\t\n\t            this.fire('request', { request: request });\n\t\n\t            return request;\n\t        },\n\t\n\t        push: function push(url, options) {\n\t            // добавить запрос в конец очереди\n\t            return this._add(false, url, options);\n\t        },\n\t\n\t        unshift: function unshift(url, options) {\n\t            // добавить запрос в начало очереди\n\t            return this._add(true, url, options);\n\t        }\n\t    });\n\t\n\t    L.gmx.imageLoader = new GmxImageLoader();\n\t})();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\r\n\t* @name L.gmxUtil\r\n\t* @namespace\r\n\t*/\n\tvar gmxAPIutils = {\n\t    lastMapId: 0,\n\t\n\t    newId: function newId() {\n\t        gmxAPIutils.lastMapId += 1;\n\t        return '_' + gmxAPIutils.lastMapId;\n\t    },\n\t\n\t    uniqueGlobalName: function uniqueGlobalName(thing) {\n\t        var id = gmxAPIutils.newId();\n\t        window[id] = thing;\n\t        return id;\n\t    },\n\t\n\t    isPageHidden: function isPageHidden() {\n\t        // Видимость окна браузера\n\t        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\n\t    },\n\t\n\t    normalizeHostname: function normalizeHostname(hostName) {\n\t        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\n\t\n\t        hostName = parsedHost.host + parsedHost.directory;\n\t\n\t        if (hostName[hostName.length - 1] === '/') {\n\t            hostName = hostName.substring(0, hostName.length - 1);\n\t        }\n\t\n\t        return hostName;\n\t    },\n\t\n\t    getLayerItemFromServer: function getLayerItemFromServer(options) {\n\t        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\n\t            req = {\n\t            WrapStyle: 'func',\n\t            geometry: true,\n\t            layer: options.layerID,\n\t            query: query\n\t        };\n\t        if (options.border) {\n\t            req.border = options.border;\n\t        }\n\t        return gmxAPIutils.requestJSONP(options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx', req, options);\n\t    },\n\t\n\t    getCadastreFeatures: function getCadastreFeatures(options) {\n\t        // example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\n\t        if (options.latlng) {\n\t            var latlng = options.latlng,\n\t                req = {\n\t                WrapStyle: 'func',\n\t                text: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\n\t                tolerance: options.tolerance || 0\n\t            };\n\t            return gmxAPIutils.requestJSONP(options.url || 'http://pkk5.rosreestr.ru/api/features/', req, options);\n\t        } else {\n\t            return null;\n\t        }\n\t    },\n\t\n\t    getFormData: function getFormData(json) {\n\t        var arr = [];\n\t        for (var key in json) {\n\t            var val = json[key];\n\t            arr.push(key + '=' + ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val) : val));\n\t        }\n\t        return arr.join('&');\n\t    },\n\t\n\t    /** Sends JSONP requests\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} url - request URL\r\n\t     * @param {Object} params - request params\r\n\t     * @param {Object} [options] - additional request options\r\n\t     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n\t       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n\t     * @return {Deferred} Promise with server JSON response or with error status\r\n\t    */\n\t    requestJSONP: function requestJSONP(url, params, options) {\n\t        options = options || {};\n\t        var def = new L.gmx.Deferred();\n\t\n\t        var script = document.createElement('script');\n\t        script.setAttribute('charset', 'UTF-8');\n\t        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\n\t        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\n\t\n\t        if (callbackParamName) {\n\t            var callbackName = gmxAPIutils.uniqueGlobalName(function (obj) {\n\t                delete window[callbackName];\n\t                def.resolve(obj, options);\n\t            });\n\t\n\t            urlParams[callbackParamName] = callbackName;\n\t        }\n\t\n\t        var paramsStringItems = [];\n\t\n\t        for (var p in urlParams) {\n\t            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\n\t        }\n\t\n\t        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\n\t\n\t        script.onerror = function (e) {\n\t            def.reject(e);\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        script.onload = function () {\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        L.gmxUtil.loaderStatus(src, null, 'vector');\n\t        script.setAttribute('src', src);\n\t\n\t        document.getElementsByTagName('head').item(0).appendChild(script);\n\t        return def;\n\t    },\n\t    getXmlHttp: function getXmlHttp() {\n\t        var xmlhttp;\n\t        if (typeof XMLHttpRequest !== 'undefined') {\n\t            xmlhttp = new XMLHttpRequest();\n\t        } else {\n\t            try {\n\t                xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\n\t            } catch (e) {\n\t                try {\n\t                    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n\t                } catch (E) {\n\t                    xmlhttp = false;\n\t                }\n\t            }\n\t        }\n\t        return xmlhttp;\n\t    },\n\t    request: function request(ph) {\n\t        // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\n\t        var xhr = gmxAPIutils.getXmlHttp();\n\t        if (xhr) {\n\t            xhr.open(ph.type ? ph.type : 'GET', ph.url, ph.async || false);\n\t            if (ph.headers) {\n\t                for (var key in ph.headers) {\n\t                    xhr.setRequestHeader(key, ph.headers[key]);\n\t                }\n\t            }\n\t            var reqId = L.gmxUtil.loaderStatus();\n\t            if (ph.async) {\n\t                if (ph.withCredentials) {\n\t                    xhr.withCredentials = true;\n\t                }\n\t                xhr.onreadystatechange = function () {\n\t                    if (xhr.readyState === 4) {\n\t                        L.gmxUtil.loaderStatus(reqId, true);\n\t                        if (xhr.status === 200) {\n\t                            ph.callback(xhr.responseText);\n\t                            xhr = null;\n\t                        } else if (ph.onError) {\n\t                            ph.onError(xhr);\n\t                        }\n\t                    }\n\t                };\n\t            }\n\t            var params = null;\n\t            if (ph.params) {\n\t                params = ph.params;\n\t                var syncParams = L.gmx.gmxMapManager.getSyncParams(true);\n\t                if (syncParams) {\n\t                    params += '&' + syncParams;\n\t                }\n\t            }\n\t            xhr.send(params);\n\t            if (!ph.async && xhr.status === 200) {\n\t                ph.callback(xhr.responseText);\n\t                L.gmxUtil.loaderStatus(reqId, true);\n\t                return xhr.status;\n\t            }\n\t            return true;\n\t        }\n\t        if (ph.onError) {\n\t            ph.onError({ Error: 'bad XMLHttpRequest!' });\n\t        }\n\t        return false;\n\t    },\n\t\n\t    tileSizes: [], // Размеры тайла по zoom\n\t    getTileNumFromLeaflet: function getTileNumFromLeaflet(tilePoint, zoom) {\n\t        if ('z' in tilePoint) {\n\t            zoom = tilePoint.z;\n\t        }\n\t        var pz = Math.pow(2, zoom),\n\t            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\n\t            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\n\t        return {\n\t            z: zoom,\n\t            x: tx % pz - pz / 2,\n\t            y: pz / 2 - 1 - ty % pz\n\t        };\n\t    },\n\t\n\t    getTilePosZoomDelta: function getTilePosZoomDelta(tilePoint, zoomFrom, zoomTo) {\n\t        // получить смещение тайла на меньшем zoom\n\t        var dz = Math.pow(2, zoomFrom - zoomTo),\n\t            size = 256 / dz,\n\t            dx = tilePoint.x % dz,\n\t            dy = tilePoint.y % dz;\n\t        return {\n\t            size: size,\n\t            zDelta: dz,\n\t            x: size * (dx < 0 ? dz + dx : dx),\n\t            y: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\n\t        };\n\t    },\n\t\n\t    geoItemBounds: function geoItemBounds(geo) {\n\t        // get item bounds array by geometry\n\t        if (!geo) {\n\t            return {\n\t                bounds: null,\n\t                boundsArr: []\n\t            };\n\t        }\n\t        var type = geo.type,\n\t            coords = geo.coordinates,\n\t            b = null,\n\t            i = 0,\n\t            len = 0,\n\t            bounds = null,\n\t            boundsArr = [];\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr1 = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    b = gmxAPIutils.bounds(coords[i][j]);\n\t                    arr1.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                }\n\t                boundsArr.push(arr1);\n\t            }\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                boundsArr.push(b);\n\t                if (i === 0) {\n\t                    bounds.extendBounds(b);\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds([coords[i]]);\n\t                bounds.extendBounds(b);\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = gmxAPIutils.bounds(coords);\n\t            //boundsArr.push(bounds);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                bounds.extendBounds(b);\n\t                //boundsArr.push(b);\n\t            }\n\t        }\n\t        return {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t    },\n\t\n\t    getUnFlattenGeo: function getUnFlattenGeo(geo) {\n\t        // get unFlatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            coords = geo.coordinates,\n\t            coordsOut = coords;\n\t\n\t        if (isLikePolygon) {\n\t            coordsOut = [];\n\t            var isPolygon = type === 'POLYGON' || type === 'Polygon';\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                var ring = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\n\t                }\n\t                coordsOut.push(ring);\n\t            }\n\t            if (isPolygon) {\n\t                coordsOut = coordsOut[0];\n\t            }\n\t        }\n\t        return { type: type, coordinates: coordsOut };\n\t    },\n\t\n\t    unFlattenRing: function unFlattenRing(arr) {\n\t        if (typeof arr[0] !== 'number') {\n\t            return arr;\n\t        }\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            res = new Array(len / 2);\n\t\n\t        for (var i = 0; i < len; i += 2) {\n\t            res[cnt++] = [arr[i], arr[i + 1]];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    geoFlatten: function geoFlatten(geo) {\n\t        // get flatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates;\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    flattenRing: function flattenRing(arr) {\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\n\t            res = new CurArray(2 * len);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            res[cnt++] = arr[i][0];\n\t            res[cnt++] = arr[i][1];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    /** Check rectangle type by coordinates\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n\t     * @return {Boolean}\r\n\t    */\n\t    isRectangle: function isRectangle(coords) {\n\t        return coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4) && (coords[0][0][0] === coords[0][1][0] || coords[0][0][1] === coords[0][1][1]) && (coords[0][1][0] === coords[0][2][0] || coords[0][1][1] === coords[0][2][1]) && (coords[0][2][0] === coords[0][3][0] || coords[0][2][1] === coords[0][3][1]) && (coords[0][3][0] === coords[0][0][0] || coords[0][3][1] === coords[0][0][1]);\n\t    },\n\t\n\t    /** Get bounds from geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n\t     * @return {Object} bounds\r\n\t    */\n\t    getGeometryBounds: function getGeometryBounds(geo) {\n\t        var pt = gmxAPIutils.geoItemBounds(geo);\n\t        return pt.bounds;\n\t    },\n\t\n\t    getMarkerPolygon: function getMarkerPolygon(bounds, dx, dy) {\n\t        var x = (bounds.min.x + bounds.max.x) / 2,\n\t            y = (bounds.min.y + bounds.max.y) / 2;\n\t        return [[x - dx, y - dy], [x - dx, y + dy], [x + dx, y + dy], [x + dx, y - dy], [x - dx, y - dy]];\n\t    },\n\t\n\t    getQuicklookPointsFromProperties: function getQuicklookPointsFromProperties(pArr, gmx) {\n\t        var indexes = gmx.tileAttributeIndexes;\n\t        var points = {\n\t            x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\n\t            y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\n\t            x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\n\t            y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\n\t            x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\n\t            y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\n\t            x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\n\t            y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\n\t        },\n\t            bounds = gmxAPIutils.bounds([[points.x1, points.y1], [points.x2, points.y2], [points.x3, points.y3], [points.x4, points.y4]]);\n\t\n\t        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\n\t            return null;\n\t        }\n\t\n\t        if (!gmx.quicklookPlatform) {\n\t            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\n\t            points.x1 = merc.x;points.y1 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\n\t            points.x2 = merc.x;points.y2 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\n\t            points.x3 = merc.x;points.y3 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\n\t            points.x4 = merc.x;points.y4 = merc.y;\n\t        }\n\t\n\t        return points;\n\t    },\n\t\n\t    /** Get hash properties from array properties\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} properties in Array format\r\n\t     * @param {Object} keys indexes\r\n\t     * @return {Object} properties in Hash format\r\n\t    */\n\t    getPropertiesHash: function getPropertiesHash(arr, indexes) {\n\t        var properties = {};\n\t        for (var key in indexes) {\n\t            properties[key] = arr[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, arr, indexes) {\n\t        return key in indexes ? arr[indexes[key]] : '';\n\t    },\n\t\n\t    dec2rgba: function dec2rgba(i, a) {\n\t        // convert decimal to rgb\n\t        var r = i >> 16 & 255,\n\t            g = i >> 8 & 255,\n\t            b = i & 255;\n\t        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\n\t    },\n\t\n\t    dec2hex: function dec2hex(i) {\n\t        // convert decimal to hex\n\t        return (i + 0x1000000).toString(16).substr(-6);\n\t    },\n\t\n\t    dec2color: function dec2color(i, a) {\n\t        // convert decimal to canvas color\n\t        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\n\t    },\n\t\n\t    oneDay: 60 * 60 * 24, // один день\n\t\n\t    isTileKeysIntersects: function isTileKeysIntersects(tk1, tk2) {\n\t        // пересечение по номерам двух тайлов\n\t        if (tk1.z < tk2.z) {\n\t            var t = tk1;tk1 = tk2;tk2 = t;\n\t        }\n\t\n\t        var dz = tk1.z - tk2.z;\n\t        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\n\t    },\n\t\n\t    rotatePoints: function rotatePoints(arr, angle, iconScale, center) {\n\t        // rotate - массива точек\n\t        var out = [];\n\t        angle *= Math.PI / 180.0;\n\t        var sin = Math.sin(angle);\n\t        var cos = Math.cos(angle);\n\t        if (!iconScale) {\n\t            iconScale = 1;\n\t        }\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var x = iconScale * arr[i].x - center.x;\n\t            var y = iconScale * arr[i].y - center.y;\n\t            out.push({\n\t                'x': cos * x - sin * y + center.x,\n\t                'y': sin * x + cos * y + center.y\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t    getPatternIcon: function getPatternIcon(item, style, indexes) {\n\t        // получить bitmap стиля pattern\n\t        if (!style.fillPattern) {\n\t            return null;\n\t        }\n\t\n\t        var notFunc = true,\n\t            pattern = style.fillPattern,\n\t            prop = item ? item.properties : null,\n\t            step = pattern.step > 0 ? pattern.step : 0,\n\t            patternDefaults = {\n\t            minWidth: 1,\n\t            maxWidth: 1000,\n\t            minStep: 0,\n\t            maxStep: 1000\n\t        };\n\t        if (pattern.patternStepFunction && prop !== null) {\n\t            step = pattern.patternStepFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (step > patternDefaults.maxStep) {\n\t            step = patternDefaults.maxStep;\n\t        } else if (step < patternDefaults.minStep) {\n\t            step = patternDefaults.minStep;\n\t        }\n\t\n\t        var size = pattern.width > 0 ? pattern.width : 8;\n\t        if (pattern.patternWidthFunction && prop !== null) {\n\t            size = pattern.patternWidthFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (size > patternDefaults.maxWidth) {\n\t            size = patternDefaults.maxWidth;\n\t        } else if (size < patternDefaults.minWidth) {\n\t            size = patternDefaults.minWidth;\n\t        }\n\t\n\t        var op = style.fillOpacity;\n\t        if (style.opacityFunction && prop !== null) {\n\t            op = style.opacityFunction(prop, indexes) / 100;\n\t            notFunc = false;\n\t        }\n\t\n\t        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\n\t            arr = pattern.colors != null ? pattern.colors : rgb,\n\t            count = arr.length,\n\t            resColors = [],\n\t            i = 0;\n\t\n\t        for (i = 0; i < count; i++) {\n\t            var col = arr[i];\n\t            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\n\t                col = prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3];\n\t                notFunc = false;\n\t            }\n\t            resColors.push(col);\n\t        }\n\t        if (count === 0) {\n\t            resColors = [0];op = 0;count = 1;\n\t        } // pattern without colors\n\t\n\t        var delta = size + step,\n\t            allSize = delta * count,\n\t            center = 0,\n\t\n\t\n\t        //radius,\n\t        rad = 0,\n\t            hh = allSize,\n\t\n\t        // высота битмапа\n\t        ww = allSize,\n\t\n\t        // ширина битмапа\n\t        type = pattern.style || 'horizontal',\n\t            flagRotate = false;\n\t\n\t        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\n\t            flagRotate = true;\n\t        } else if (type === 'circle') {\n\t            ww = hh = 2 * delta;\n\t            center = Math.floor(ww / 2); // центр круга\n\t            //radius = Math.floor(size / 2);\t// радиус\n\t            rad = 2 * Math.PI / count; // угол в рад.\n\t        } else if (type === 'vertical') {\n\t            hh = 1;\n\t        } else if (type === 'horizontal') {\n\t            ww = 1;\n\t        }\n\t        if (ww * hh > patternDefaults.maxWidth) {\n\t            console.log({ 'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big' });\n\t            return null;\n\t        }\n\t\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.clearRect(0, 0, canvas.width, canvas.height);\n\t        if (type === 'diagonal2' || type === 'vertical') {\n\t            ptx.translate(ww, 0);\n\t            ptx.rotate(Math.PI / 2);\n\t        }\n\t\n\t        for (i = 0; i < count; i++) {\n\t            ptx.beginPath();\n\t            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\n\t            ptx.fillStyle = fillStyle;\n\t\n\t            if (flagRotate) {\n\t                var x1 = i * delta;var xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t\n\t                x1 += allSize;xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t                if (type === 'cross' || type === 'cross1') {\n\t                    x1 = i * delta;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t\n\t                    x1 += allSize;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t                }\n\t            } else if (type === 'circle') {\n\t                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\n\t                ptx.lineTo(center, center);\n\t            } else {\n\t                ptx.fillRect(0, i * delta, ww, size);\n\t            }\n\t            ptx.closePath();\n\t            ptx.fill();\n\t        }\n\t        var canvas1 = document.createElement('canvas');\n\t        canvas1.width = ww;\n\t        canvas1.height = hh;\n\t        var ptx1 = canvas1.getContext('2d');\n\t        ptx1.drawImage(canvas, 0, 0, ww, hh);\n\t        return { 'notFunc': notFunc, 'canvas': canvas1 };\n\t    },\n\t\n\t    getSVGIcon: function getSVGIcon(options) {\n\t        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\n\t            type = options.type,\n\t            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\n\t            stroke = options.strokeStyle || '#0000ff',\n\t            strokeWidth = options.lineWidth || 2,\n\t            iconOptions = {\n\t            className: 'gmx-svg-icon'\n\t        };\n\t\n\t        if (options.className) {\n\t            iconOptions.className = options.className;\n\t        }\n\t        var size = options.iconSize;\n\t        iconOptions.iconSize = [size, size];\n\t        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\n\t\n\t        if (type === 'circle') {\n\t            if (options.fillRadialGradient) {\n\t                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\n\t                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop || [// [%, color, opacity]\n\t                [0, '#ffff00', 0.8], [1, '#ff0000', 0.8]];\n\t\n\t                for (var i = 0, len = stopColor.length; i < len; i++) {\n\t                    var it = stopColor[i];\n\t                    svg += '<stop offset=\"' + 100 * it[0] + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\n\t                }\n\t                svg += '</radialGradient></defs>';\n\t                fill = 'url(#myRadialGradient4)';\n\t                stroke = strokeWidth = null;\n\t            }\n\t            size /= 2;\n\t            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:\"' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:\"' + strokeWidth + ';';\n\t            }\n\t            svg += ';\" />';\n\t        } else if (type === 'square') {\n\t            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:' + 2 * strokeWidth + ';';\n\t            }\n\t            svg += '\" />';\n\t        }\n\t        if (options.text) {\n\t            var text = options.text;\n\t            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\n\t            for (var key in text) {\n\t                if (key !== 'count') {\n\t                    svg += ' ' + key + '=\"' + text[key] + '\"';\n\t                }\n\t            }\n\t            svg += '>' + text.count + '</text>';\n\t        }\n\t        svg += '</g></svg>';\n\t        iconOptions.html = svg;\n\t\n\t        return new L.DivIcon(iconOptions);\n\t    },\n\t\n\t    toPixels: function toPixels(p, tpx, tpy, mInPixel) {\n\t        // get pixel point\n\t        var px1 = p[0] * mInPixel;px1 = 0.5 + px1 << 0;\n\t        var py1 = p[1] * mInPixel;py1 = 0.5 + py1 << 0;\n\t        return [px1 - tpx, tpy - py1].concat(p.slice(2));\n\t    },\n\t\n\t    getPixelPoint: function getPixelPoint(attr, coords) {\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t            style = attr.style || {},\n\t            iconScale = currentStyle.iconScale || 1,\n\t            iconCenter = currentStyle.iconCenter || false,\n\t            sx = currentStyle.sx || style.sx || 4,\n\t            sy = currentStyle.sy || style.sy || 4,\n\t            weight = currentStyle.weight || style.weight || 0,\n\t            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy;\n\t\n\t        if (!iconCenter && iconAnchor) {\n\t            px1 -= iconAnchor[0];\n\t            py1 -= iconAnchor[1];\n\t        }\n\t        sx *= iconScale;\n\t        sy *= iconScale;\n\t        sx += weight;\n\t        sy += weight;\n\t\n\t        var py1 = py - coords[1] * mInPixel,\n\t            px1 = coords[0] * mInPixel - px;\n\t\n\t        if (px1 - sx > 256) {\n\t            px1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        } else if (px1 < -sx) {\n\t            px1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        }\n\t\n\t        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0 ? null : {\n\t            sx: sx,\n\t            sy: sy,\n\t            px1: 0.5 + px1 << 0,\n\t            py1: 0.5 + py1 << 0\n\t        };\n\t    },\n\t    getImageData: function getImageData(img) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return null;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.drawImage(img, 0, 0);\n\t        return ptx.getImageData(0, 0, ww, hh).data;\n\t    },\n\t    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\n\t    isIE: function isIE(v) {\n\t        return v === gmxAPIutils.getIEversion();\n\t    },\n\t    gtIE: function gtIE(v) {\n\t        return v < gmxAPIutils.getIEversion();\n\t    },\n\t\n\t    getIEversion: function getIEversion() {\n\t        var ua = navigator.userAgent || '',\n\t            msie = ua.indexOf('MSIE ');\n\t        if (msie > 0) {\n\t            // IE 10 or older => return version number\n\t            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t        }\n\t\n\t        var trident = ua.indexOf('Trident/');\n\t        if (trident > 0) {\n\t            // IE 11 => return version number\n\t            var rv = ua.indexOf('rv:');\n\t            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t        }\n\t\n\t        var edge = ua.indexOf('Edge/');\n\t        if (edge > 0) {\n\t            // Edge (IE 12+) => return version number\n\t            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t        }\n\t\n\t        // other browser\n\t        return -1;\n\t    },\n\t\n\t    replaceColor: function replaceColor(img, color, fromData) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return img;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var flag = false,\n\t            imageData,\n\t            ptx = canvas.getContext('2d');\n\t\n\t        if (typeof color === 'string') {\n\t            color = parseInt('0x' + color.replace(/#/, ''));\n\t        }\n\t        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\n\t            var r = color >> 16 & 255,\n\t                g = color >> 8 & 255,\n\t                b = color & 255;\n\t\n\t            if (fromData) {\n\t                imageData = ptx.createImageData(ww, hh);\n\t            } else {\n\t                ptx.drawImage(img, 0, 0);\n\t                imageData = ptx.getImageData(0, 0, ww, hh);\n\t                fromData = imageData.data;\n\t            }\n\t            var toData = imageData.data;\n\t            for (var i = 0, len = fromData.length; i < len; i += 4) {\n\t                if ((fromData[i] === 0xff || fromData[i] === 238) && fromData[i + 1] === 0 && fromData[i + 2] === 0xff) {\n\t                    toData[i] = r;\n\t                    toData[i + 1] = g;\n\t                    toData[i + 2] = b;\n\t                    toData[i + 3] = fromData[i + 3];\n\t                    flag = true;\n\t                }\n\t            }\n\t        }\n\t        if (flag) {\n\t            ptx.putImageData(imageData, 0, 0);\n\t        } else {\n\t            ptx.drawImage(img, 0, 0);\n\t        }\n\t        return canvas;\n\t    },\n\t\n\t    drawIconPath: function drawIconPath(path, attr) {\n\t        // draw iconPath in canvas\n\t        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) {\n\t            return;\n\t        }\n\t        var trFlag = false,\n\t            ctx = attr.ctx,\n\t            rad = attr.radian;\n\t\n\t        if (attr.px || attr.py) {\n\t            ctx.translate(attr.px || 0, attr.py || 0);trFlag = true;\n\t        }\n\t        if (!rad && attr.rotateRes) {\n\t            rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes);\n\t        }\n\t        if (rad) {\n\t            ctx.rotate(rad);trFlag = true;\n\t        }\n\t        ctx.moveTo(path[0], path[1]);\n\t        for (var i = 2, len = path.length; i < len; i += 2) {\n\t            ctx.lineTo(path[i], path[i + 1]);\n\t        }\n\t        if (trFlag) {\n\t            ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t        }\n\t    },\n\t\n\t    pointToCanvas: function pointToCanvas(attr) {\n\t        // Точку в canvas\n\t        var gmx = attr.gmx,\n\t            pointAttr = attr.pointAttr,\n\t            style = attr.style || {},\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconScale = currentStyle.iconScale || 1,\n\t            image = currentStyle.image,\n\t            sx = pointAttr.sx,\n\t            sy = pointAttr.sy,\n\t            px1 = pointAttr.px1,\n\t            py1 = pointAttr.py1,\n\t            px1sx = px1,\n\t            py1sy = py1,\n\t            ctx = attr.ctx;\n\t\n\t        if (currentStyle.type === 'image') {\n\t            sx = style.sx;\n\t            sy = style.sy;\n\t            image = style.image;\n\t        }\n\t        if (currentStyle.iconCenter) {\n\t            px1sx -= sx / 2;\n\t            py1sy -= sy / 2;\n\t        } else if (style.type === 'circle') {\n\t            px1 += sx / 2;\n\t            py1 += sy / 2;\n\t        }\n\t        if (currentStyle.iconPath) {\n\t            attr.px = px1;\n\t            attr.py = py1;\n\t            attr.rotateRes = currentStyle.rotate || 0;\n\t        }\n\t        if (image) {\n\t            if ('iconColor' in currentStyle) {\n\t                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\n\t            }\n\t            style.rotateRes = currentStyle.rotate || 0;\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = currentStyle.opacity || style.opacity;\n\t            }\n\t            if (gmx.transformFlag) {\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\n\t                ctx.drawImage(image, px1, -py1, sx, sy);\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\n\t            } else {\n\t                if (iconScale !== 1) {\n\t                    sx *= iconScale;\n\t                    sy *= iconScale;\n\t                    px1 = pointAttr.px1;\n\t                    py1 = pointAttr.py1;\n\t                    px1sx = px1;\n\t                    py1sy = py1;\n\t                    if (currentStyle.iconCenter) {\n\t                        px1sx -= sx / 2;\n\t                        py1sy -= sy / 2;\n\t                    }\n\t                }\n\t                if (style.rotateRes) {\n\t                    ctx.translate(px1, py1);\n\t                    ctx.rotate(gmxAPIutils.degRad(style.rotateRes));\n\t                    ctx.translate(-px1, -py1);\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                } else {\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                }\n\t            }\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = 1;\n\t            }\n\t        } else if (style.fillColor || currentStyle.fillRadialGradient) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\n\t                var circle = style.iconSize / 2;\n\t                if (currentStyle.fillRadialGradient) {\n\t                    var rgr = currentStyle.fillRadialGradient;\n\t                    circle = rgr.r2 * iconScale;\n\t                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\n\t                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\n\t                        var arr = rgr.addColorStop[i];\n\t                        radgrad.addColorStop(arr[0], arr[1]);\n\t                    }\n\t                    ctx.fillStyle = radgrad;\n\t                }\n\t                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.fillRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.fill();\n\t        }\n\t        if (currentStyle.strokeStyle) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle') {\n\t                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.strokeRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.stroke();\n\t        }\n\t    },\n\t    lineToCanvasAsIcon: function lineToCanvasAsIcon(pixels, attr) {\n\t        // add line(as icon) to canvas\n\t        var len = pixels.length,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconPath = currentStyle.iconPath;\n\t\n\t        if (len > 0) {\n\t            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t                ctx.setLineDash([]);\n\t            }\n\t            ctx.beginPath();\n\t            for (var i = 0, p; i < len; i++) {\n\t                p = pixels[i];\n\t                gmxAPIutils.drawIconPath(iconPath, { ctx: ctx, px: p.x, py: p.y, radian: p.radian });\n\t            }\n\t            if (currentStyle.strokeStyle) {\n\t                ctx.stroke();\n\t            }\n\t            if (currentStyle.fillStyle) {\n\t                ctx.fill();\n\t            }\n\t        }\n\t    },\n\t    lineToCanvas: function lineToCanvas(attr) {\n\t        // Lines in canvas\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            pixels = currentStyle.iconPath ? [] : null;\n\t\n\t        var lastX = null,\n\t            lastY = null;\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\n\t                x = p[0],\n\t                y = p[1];\n\t            if (lastX !== x || lastY !== y) {\n\t                if (pixels) {\n\t                    pixels.push({ x: x, y: y, radian: p[2] });\n\t                }\n\t                if (i === 0) {\n\t                    ctx.moveTo(x, y);\n\t                } else {\n\t                    ctx.lineTo(x, y);\n\t                }\n\t                lastX = x;lastY = y;\n\t            }\n\t        }\n\t        ctx.stroke();\n\t        return pixels;\n\t    },\n\t\n\t    getCoordsPixels: function getCoordsPixels(attr) {\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || [],\n\t            pixels = [],\n\t            hidden = [],\n\t            hiddenFlag = false,\n\t            hash = {\n\t            gmx: gmx,\n\t            tpx: attr.tpx,\n\t            tpy: attr.tpy,\n\t            coords: null,\n\t            hiddenLines: null\n\t        };\n\t        for (var j = 0, len = coords.length; j < len; j++) {\n\t            var coords1 = coords[j],\n\t                hiddenLines1 = hiddenLines[j] || [],\n\t                pixels1 = [],\n\t                hidden1 = [];\n\t            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\n\t                hash.coords = coords1[j1];\n\t                hash.hiddenLines = hiddenLines1[j1] || [];\n\t                var res = gmxAPIutils.getRingPixels(hash);\n\t                pixels1.push(res.coords);\n\t                hidden1.push(res.hidden);\n\t                if (res.hidden) {\n\t                    hiddenFlag = true;\n\t                }\n\t            }\n\t            pixels.push(pixels1);\n\t            hidden.push(hidden1);\n\t        }\n\t        return { coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom };\n\t    },\n\t\n\t    getRingPixels: function getRingPixels(attr) {\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            lastX = null,\n\t            lastY = null,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            pixels = [],\n\t            hidden = [];\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var lineIsOnEdge = false;\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x1 = c[0] * mInPixel,\n\t                y1 = c[1] * mInPixel,\n\t                x2 = Math.round(x1 - px),\n\t                y2 = Math.round(py - y1);\n\t\n\t            if (lastX !== x2 || lastY !== y2) {\n\t                lastX = x2;lastY = y2;\n\t                if (lineIsOnEdge) {\n\t                    hidden.push(cnt);\n\t                }\n\t                pixels[cnt++] = x1;\n\t                pixels[cnt++] = y1;\n\t            }\n\t        }\n\t        return { coords: pixels, hidden: hidden.length ? hidden : null };\n\t    },\n\t\n\t    polygonToCanvas: function polygonToCanvas(attr) {\n\t        // Polygons in canvas\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var hiddenLines = attr.hiddenLines || null,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            lastX = null,\n\t            lastY = null;\n\t\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x = Math.round(c[0] - px),\n\t                y = Math.round(py - c[1]),\n\t                lineIsOnEdge = false;\n\t\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t\n\t            if (lastX !== x || lastY !== y) {\n\t                ctx[lineIsOnEdge ? 'moveTo' : 'lineTo'](x, y);\n\t                lastX = x;lastY = y;\n\t                cnt++;\n\t            }\n\t        }\n\t        if (cnt === 1) {\n\t            ctx.lineTo(lastX + 1, lastY);\n\t        }\n\t        ctx.stroke();\n\t    },\n\t\n\t    polygonToCanvasFill: function polygonToCanvasFill(attr) {\n\t        // Polygon fill\n\t        if (attr.coords.length < 3) {\n\t            return;\n\t        }\n\t        var coords = attr.coords,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            vectorSize = 1,\n\t            ctx = attr.ctx;\n\t\n\t        ctx.lineWidth = 0;\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\n\t        } else {\n\t            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\n\t        }\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\n\t        }\n\t    },\n\t\n\t    isPatternNode: function isPatternNode(it) {\n\t        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\n\t    },\n\t    labelCanvasContext: null, // 2dContext canvas for Label size\n\t    getLabelWidth: function getLabelWidth(txt, style) {\n\t        // Get label size Label\n\t        if (style) {\n\t            if (!gmxAPIutils.labelCanvasContext) {\n\t                var canvas = document.createElement('canvas');\n\t                canvas.width = canvas.height = 512;\n\t                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\n\t            }\n\t            var ptx = gmxAPIutils.labelCanvasContext;\n\t            ptx.clearRect(0, 0, 512, 512);\n\t\n\t            if (ptx.font !== style.font) {\n\t                ptx.font = style.font;\n\t            }\n\t            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\n\t            if (ptx.fillStyle !== style.fillStyle) {\n\t                ptx.fillStyle = style.fillStyle;\n\t            }\n\t            var arr = txt.split('\\n');\n\t            return arr.map(function (it) {\n\t                ptx.fillText(it, 0, 0);\n\t                return [it, ptx.measureText(it).width];\n\t            });\n\t        }\n\t        return 0;\n\t    },\n\t    setLabel: function setLabel(ctx, txt, coord, style) {\n\t        var x = coord[0],\n\t            y = coord[1];\n\t\n\t        if (ctx.shadowColor !== style.strokeStyle) {\n\t            ctx.shadowColor = style.strokeStyle;\n\t        }\n\t        if (ctx.shadowBlur !== style.shadowBlur) {\n\t            ctx.shadowBlur = style.shadowBlur;\n\t        }\n\t        if (ctx.font !== style.font) {\n\t            ctx.font = style.font;\n\t        }\n\t        if (ctx.strokeStyle !== style.strokeStyle) {\n\t            ctx.strokeStyle = style.strokeStyle;\n\t        }\n\t        if (ctx.fillStyle !== style.fillStyle) {\n\t            ctx.fillStyle = style.fillStyle;\n\t        }\n\t        ctx.strokeText(txt, x, y);\n\t        ctx.fillText(txt, x, y);\n\t    },\n\t    worldWidthMerc: 20037508,\n\t    rMajor: 6378137.000,\n\t    degRad: function degRad(ang) {\n\t        return ang * (Math.PI / 180.0);\n\t    },\n\t\n\t    distVincenty: function distVincenty(lon1, lat1, lon2, lat2) {\n\t        var p1 = {\n\t            lon: gmxAPIutils.degRad(lon1),\n\t            lat: gmxAPIutils.degRad(lat1)\n\t        },\n\t            p2 = {\n\t            lon: gmxAPIutils.degRad(lon2),\n\t            lat: gmxAPIutils.degRad(lat2)\n\t        },\n\t            a = gmxAPIutils.rMajor,\n\t            b = 6356752.3142,\n\t            f = 1 / 298.257223563; // WGS-84 ellipsiod\n\t\n\t        var L1 = p2.lon - p1.lon,\n\t            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\n\t            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\n\t            sinU1 = Math.sin(U1),\n\t            cosU1 = Math.cos(U1),\n\t            sinU2 = Math.sin(U2),\n\t            cosU2 = Math.cos(U2),\n\t            lambda = L1,\n\t            lambdaP = 2 * Math.PI,\n\t            iterLimit = 20;\n\t        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n\t            var sinLambda = Math.sin(lambda),\n\t                cosLambda = Math.cos(lambda),\n\t                sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n\t            if (sinSigma === 0) {\n\t                return 0;\n\t            }\n\t            var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\n\t                sigma = Math.atan2(sinSigma, cosSigma),\n\t                sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\n\t                cosSqAlpha = 1 - sinAlpha * sinAlpha,\n\t                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n\t            if (isNaN(cos2SigmaM)) {\n\t                cos2SigmaM = 0;\n\t            }\n\t            var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n\t            lambdaP = lambda;\n\t            lambda = L1 + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n\t        }\n\t        if (iterLimit === 0) {\n\t            return NaN;\n\t        }\n\t\n\t        var uSq = cosSqAlpha * (a * a / (b * b) - 1),\n\t\n\t\n\t        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\n\t        A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\n\t            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\n\t            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\n\t            s = b * A * (sigma - deltaSigma);\n\t\n\t        //s = s.toFixed(3);\n\t        return s;\n\t    },\n\t\n\t    _vfi: function _vfi(fi, a, b) {\n\t        return [-Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a), Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a), -Math.sin(fi) * Math.cos(b)];\n\t    },\n\t\n\t    getCircleLatLngs: function getCircleLatLngs(latlng, r) {\n\t        // Get latlngs for circle\n\t        var x = 0,\n\t            y = 0;\n\t        if (latlng instanceof L.LatLng) {\n\t            x = latlng.lng;\n\t            y = latlng.lat;\n\t        } else if (L.Util.isArray(latlng)) {\n\t            x = latlng[1];\n\t            y = latlng[0];\n\t        } else {\n\t            return null;\n\t        }\n\t\n\t        var rad = Math.PI / 180,\n\t            a = x * rad,\n\t\n\t        //долгота центра окружности в радианах\n\t        b = y * rad,\n\t\n\t        //широта центра окружности в радианах\n\t        R = gmxAPIutils.rMajor,\n\t            d = R * Math.sin(r / R),\n\t            Rd = R * Math.cos(r / R),\n\t            VR = [Rd * Math.cos(b) * Math.cos(a), Rd * Math.cos(b) * Math.sin(a), Rd * Math.sin(b)],\n\t            latlngs = [];\n\t\n\t        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\n\t            var v = gmxAPIutils._vfi(fi, a, b),\n\t                circle = [];\n\t            for (var i = 0; i < 3; i++) {\n\t                circle[i] = VR[i] + d * v[i];\n\t            }\n\t\n\t            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\n\t            if (circle[1] < 0) {\n\t                t2 = -t2;\n\t            }\n\t\n\t            if (t2 < x - 180) {\n\t                t2 += 360;\n\t            } else if (t2 > x + 180) {\n\t                t2 -= 360;\n\t            }\n\t            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\n\t        }\n\t        return latlngs;\n\t    },\n\t\n\t    /** Get point coordinates from string\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} text - point coordinates in following formats:\r\n\t         <br/><i>55.74312, 37.61558</i>\r\n\t         <br/><i>55°44'35\" N, 37°36'56\" E</i>\r\n\t         <br/><i>4187347, 7472103</i>\r\n\t         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n\t         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n\t     * @return {Array} [lat, lng] or null\r\n\t    */\n\t    parseCoordinates: function parseCoordinates(text) {\n\t        var crs = null,\n\t            regex = /\\(EPSG:(\\d+)\\)/g,\n\t            t = regex.exec(text);\n\t\n\t        if (t) {\n\t            crs = t[1];\n\t            text = text.replace(regex, '');\n\t        }\n\t\n\t        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\n\t            return null;\n\t        }\n\t\n\t        //there should be a separator in the string (exclude strings like \"11E11\")\n\t        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\n\t            return null;\n\t        }\n\t\n\t        if (text.indexOf(' ') !== -1) {\n\t            text = text.replace(/,/g, '.');\n\t        }\n\t        var results = [];\n\t        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\n\t        t = regex.exec(text);\n\t        while (t) {\n\t            results.push(t[1]);\n\t            t = regex.exec(text);\n\t        }\n\t        if (results.length < 2) {\n\t            return null;\n\t        }\n\t        var ii = Math.floor(results.length / 2),\n\t            y = 0,\n\t            mul = 1,\n\t            i;\n\t        for (i = 0; i < ii; i++) {\n\t            y += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t        var x = 0;\n\t        mul = 1;\n\t        for (i = ii; i < results.length; i++) {\n\t            x += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t\n\t        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\n\t            t = x;\n\t            x = y;\n\t            y = t;\n\t        }\n\t\n\t        var pos;\n\t        if (crs === '3857') {\n\t            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\n\t            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t\n\t        if (text.indexOf('W') !== -1) {\n\t            x = -x;\n\t        }\n\t\n\t        if (text.indexOf('S') !== -1) {\n\t            y = -y;\n\t        }\n\t        return [y, x];\n\t    },\n\t\n\t    pad2: function pad2(t) {\n\t        return t >= 0 && t < 10 ? '0' + t : '' + t;\n\t    },\n\t\n\t    trunc: function trunc(x) {\n\t        return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\n\t    },\n\t\n\t    formatDegrees: function formatDegrees(angle, format) {\n\t        angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\n\t        var a1 = Math.floor(angle),\n\t            a2 = Math.floor(60 * (angle - a1)),\n\t            a3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\n\t            st = gmxAPIutils.pad2(a1) + '°';\n\t\n\t        if (format === undefined) {\n\t            format = 2;\n\t        }\n\t        if (format > 0) {\n\t            st += gmxAPIutils.pad2(a2) + '\\'';\n\t        }\n\t        if (format > 1) {\n\t            st += gmxAPIutils.pad2(a3) + '\"';\n\t        }\n\t        return st;\n\t    },\n\t\n\t    /** Get point coordinates in string format with degrees\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format with degrees\r\n\t    */\n\t    latLonFormatCoordinates: function latLonFormatCoordinates(x, y) {\n\t        x %= 360;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        } else if (x < -180) {\n\t            x += 360;\n\t        }\n\t        return gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t\n\t    formatCoordinates: function formatCoordinates(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates(x, y);\n\t    },\n\t\n\t    /** Get point coordinates in string format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format\r\n\t    */\n\t    latLonFormatCoordinates2: function latLonFormatCoordinates2(x, y) {\n\t        return gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t    formatCoordinates2: function formatCoordinates2(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates2(x, y);\n\t    },\n\t\n\t    getPixelScale: function getPixelScale(zoom) {\n\t        return 256 / gmxAPIutils.tileSizes[zoom];\n\t    },\n\t\n\t    forEachPoint: function forEachPoint(coords, callback) {\n\t        if (!coords || coords.length === 0) {\n\t            return [];\n\t        }\n\t        var i,\n\t            len,\n\t            ret = [];\n\t        if (!coords[0].length) {\n\t            if (coords.length === 2) {\n\t                return callback(coords);\n\t            } else {\n\t                for (i = 0, len = coords.length / 2; i < len; i++) {\n\t                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\n\t                }\n\t            }\n\t        } else {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                if (typeof coords[i] !== 'string') {\n\t                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    },\n\t    /*\r\n\t    \tgetQuicklookPoints: function(coord) { // получить 4 точки привязки снимка\r\n\t    \t\tvar d1 = Number.MAX_VALUE;\r\n\t    \t\tvar d2 = Number.MAX_VALUE;\r\n\t    \t\tvar d3 = Number.MAX_VALUE;\r\n\t    \t\tvar d4 = Number.MAX_VALUE;\r\n\t    \t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t    \t\tthis.forEachPoint(coord, function(p) {\r\n\t    \t\t\tvar x = p[0];\r\n\t    \t\t\tvar y = p[1];\r\n\t    \t\t\tif ((x - y) < d1) {\r\n\t    \t\t\t\td1 = x - y;\r\n\t    \t\t\t\tx1 = p[0];\r\n\t    \t\t\t\ty1 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x - y) < d2) {\r\n\t    \t\t\t\td2 = -x - y;\r\n\t    \t\t\t\tx2 = p[0];\r\n\t    \t\t\t\ty2 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x + y) < d3) {\r\n\t    \t\t\t\td3 = -x + y;\r\n\t    \t\t\t\tx3 = p[0];\r\n\t    \t\t\t\ty3 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((x + y) < d4) {\r\n\t    \t\t\t\td4 = x + y;\r\n\t    \t\t\t\tx4 = p[0];\r\n\t    \t\t\t\ty4 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t});\r\n\t    \t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t    \t},\r\n\t    */\n\t    getItemCenter: function getItemCenter(item, geoItems) {\n\t        var bounds = item.bounds,\n\t            min = bounds.min,\n\t            max = bounds.max,\n\t            type = item.type,\n\t            isPoint = type === 'POINT' || type === 'MULTIPOINT',\n\t            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t\n\t        if (type === 'MULTIPOLYGON') {\n\t            return center;\n\t        } else if (type === 'POLYGON') {\n\t            for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                var it = geoItems[i],\n\t                    geom = it.geo,\n\t                    coords = geom.coordinates,\n\t                    dataOption = it.dataOption,\n\t                    bbox = dataOption.bounds;\n\t\n\t                if (bbox.contains(center)) {\n\t                    if (geom.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                    }\n\t                    for (var j = 0, len1 = coords.length; j < len1; j++) {\n\t                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\n\t                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\n\t                            if (pt) {\n\t                                return pt.max.center;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'MULTIPOINT') {\n\t            return center;\n\t        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\n\t            return center;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    getHSegmentsInPolygon: function getHSegmentsInPolygon(y, poly) {\n\t        var s = [],\n\t            i,\n\t            len,\n\t            out,\n\t            vectorSize = 1,\n\t            p1 = poly[0];\n\t\n\t        if (typeof poly[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [poly[0], poly[1]];\n\t        }\n\t        var isGt1 = y > p1[1];\n\t        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\n\t                isGt2 = y > p2[1];\n\t            if (isGt1 !== isGt2) {\n\t                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\n\t            }\n\t            p1 = p2;\n\t            isGt1 = isGt2;\n\t        }\n\t        len = s.length;\n\t        if (len) {\n\t            s = s.sort();\n\t            var max = 0,\n\t                index = -1;\n\t            for (i = 1; i < len; i += 2) {\n\t                var j = i - 1,\n\t                    d = Math.abs(s[i] - s[j]);\n\t                if (d > max) {\n\t                    max = d;\n\t                    index = j;\n\t                }\n\t            }\n\t            out = {\n\t                y: y,\n\t                segArr: s,\n\t                max: {\n\t                    width: max,\n\t                    center: [(s[index] + s[index + 1]) / 2, y]\n\t                }\n\t            };\n\t        }\n\t        return out;\n\t    },\n\t\n\t    isPointInPolygonArr: function isPointInPolygonArr(chkPoint, coords) {\n\t        // Проверка точки на принадлежность полигону в виде массива\n\t        var isIn = false,\n\t            x = chkPoint[0],\n\t            y = chkPoint[1],\n\t            vectorSize = 1,\n\t            p1 = coords[0];\n\t\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [coords[0], coords[1]];\n\t        }\n\t\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                xmin = Math.min(p1[0], p2[0]),\n\t                xmax = Math.max(p1[0], p2[0]),\n\t                ymax = Math.max(p1[1], p2[1]);\n\t            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\n\t                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\n\t                if (p1[1] === p2[1] || y <= xinters) {\n\t                    isIn = !isIn;\n\t                }\n\t            }\n\t            p1 = p2;\n\t        }\n\t        return isIn;\n\t    },\n\t\n\t    /** Is point in polygon with holes\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {chkPoint} chkPoint - point in [x, y] format\r\n\t     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if polygon contain chkPoint\r\n\t    */\n\t    isPointInPolygonWithHoles: function isPointInPolygonWithHoles(chkPoint, coords) {\n\t        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) {\n\t            return false;\n\t        }\n\t        for (var j = 1, len = coords.length; j < len; j++) {\n\t            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /** Is polygon clockwise\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {ring} ring - ring from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if ring is clockwise\r\n\t    */\n\t    isClockwise: function isClockwise(ring) {\n\t        var area = 0;\n\t        for (var i = 0, j, len = ring.length; i < len; i++) {\n\t            j = (i + 1) % len;\n\t            area += ring[i][0] * ring[j][1];\n\t            area -= ring[j][0] * ring[i][1];\n\t        }\n\t        return area < 0;\n\t    },\n\t\n\t    isPointInPolyLine: function isPointInPolyLine(chkPoint, lineHeight, coords, hiddenLines) {\n\t        // Проверка точки(с учетом размеров) на принадлежность линии\n\t        var dx = chkPoint[0],\n\t            dy = chkPoint[1],\n\t            nullPoint = { x: dx, y: dy },\n\t            minx = dx - lineHeight,\n\t            maxx = dx + lineHeight,\n\t            miny = dy - lineHeight,\n\t            maxy = dy + lineHeight,\n\t            cntHide = 0;\n\t\n\t        lineHeight *= lineHeight;\n\t        for (var i = 1, len = coords.length; i < len; i++) {\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                cntHide++;\n\t            } else {\n\t                var p1 = coords[i - 1],\n\t                    p2 = coords[i],\n\t                    x1 = p1[0],\n\t                    y1 = p1[1],\n\t                    x2 = p2[0],\n\t                    y2 = p2[1];\n\t\n\t                if (!(Math.max(x1, x2) < minx || Math.min(x1, x2) > maxx || Math.max(y1, y2) < miny || Math.min(y1, y2) > maxy)) {\n\t                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, { x: x1, y: y1 }, { x: x2, y: y2 }, true);\n\t                    if (sqDist < lineHeight) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    isPointInLines: function isPointInLines(attr) {\n\t        var arr = attr.coords,\n\t            point = attr.point,\n\t            delta = attr.delta,\n\t            boundsArr = attr.boundsArr,\n\t            hidden = attr.hidden;\n\t        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\n\t            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\n\t            if (flag && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /** Get length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} latlngs array\r\n\t     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n\t     * @return {Number} length\r\n\t    */\n\t    getLength: function getLength(latlngs, isMerc) {\n\t        var length = 0;\n\t        if (latlngs && latlngs.length) {\n\t            var lng = false,\n\t                lat = false;\n\t\n\t            isMerc = isMerc === undefined || isMerc;\n\t            latlngs.forEach(function (latlng) {\n\t                if (L.Util.isArray(latlng)) {\n\t                    if (L.Util.isArray(latlng[0])) {\n\t                        length += gmxAPIutils.getLength(latlng, isMerc);\n\t                        return length;\n\t                    } else if (isMerc) {\n\t                        // From Mercator array\n\t                        latlng = L.Projection.Mercator.unproject({ x: latlng[0], y: latlng[1] });\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\n\t                }\n\t                lng = latlng.lng;\n\t                lat = latlng.lat;\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get prettify length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area\r\n\t     * @param {String} type: ('km', 'm', 'nm')\r\n\t     * @return {String} prettify length\r\n\t    */\n\t    prettifyDistance: function prettifyDistance(length, type) {\n\t        var km = ' ' + L.gmxLocale.getText('units.km');\n\t        if (type === 'nm') {\n\t            return Math.round(0.539956803 * length) / 1000 + ' ' + L.gmxLocale.getText('units.nm');\n\t        } else if (type === 'km') {\n\t            return Math.round(length) / 1000 + km;\n\t        } else if (length < 2000 || type === 'm') {\n\t            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\n\t        } else if (length < 200000) {\n\t            return Math.round(length / 10) / 100 + km;\n\t        }\n\t        return Math.round(length / 1000) + km;\n\t    },\n\t\n\t    /** Get geoJSON length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} length\r\n\t    */\n\t    geoJSONGetLength: function geoJSONGetLength(geoJSON) {\n\t        var out = 0,\n\t            i,\n\t            j,\n\t            len,\n\t            len1,\n\t            coords;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\n\t        }if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'LineString') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingLength(coords[i]);\n\t            }\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                for (j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    out += gmxAPIutils.getRingLength(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getRingLength: function getRingLength(coords) {\n\t        var length = 0;\n\t        if (coords && coords.length) {\n\t            var lng = false,\n\t                lat = false;\n\t            coords.forEach(function (lnglat) {\n\t                if (L.Util.isArray(lnglat)) {\n\t                    if (lnglat.length > 2) {\n\t                        length += gmxAPIutils.getRingLength(lnglat);\n\t                        return length;\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\n\t                }\n\t                lng = lnglat[0];\n\t                lat = lnglat[1];\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get geoJSON area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoJSONGetArea: function geoJSONGetArea(geoJSON) {\n\t        var out = 0;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            var coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingArea(coords[i][0]);\n\t                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\n\t                    out -= gmxAPIutils.getRingArea(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    geoJSONGetLatLng: function geoJSONGetLatLng(geoJSON) {\n\t        if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'Point') {\n\t            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\n\t        } else {\n\t            throw new Error('cannot get ' + geoJSON.type + ' latLng');\n\t        }\n\t    },\n\t\n\t    getRingArea: function getRingArea(coords) {\n\t        var area = 0;\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = coords[i],\n\t                p2 = coords[ipp];\n\t            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\n\t        }\n\t        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t        return out;\n\t    },\n\t\n\t    /** Get area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} L.latLng array\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    getArea: function getArea(arr) {\n\t        var area = 0;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = arr[i],\n\t                p2 = arr[ipp];\n\t            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\n\t        }\n\t        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t    },\n\t\n\t    /** Get prettified size of area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area in square meters\r\n\t     * @param {String} type: ('km2', 'ha', 'm2')\r\n\t     * @return {String} prettified area\r\n\t    */\n\t    prettifyArea: function prettifyArea(area, type) {\n\t        var km2 = ' ' + L.gmxLocale.getText('units.km2');\n\t\n\t        if (type === 'km2') {\n\t            return '' + Math.round(area / 100) / 10000 + km2;\n\t        } else if (type === 'ha') {\n\t            return '' + Math.round(area / 100) / 100 + ' ' + L.gmxLocale.getText('units.ha');\n\t        } else if (area < 100000 || type === 'm2') {\n\t            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\n\t        } else if (area < 3000000) {\n\t            return ('' + Math.round(area / 1000) / 1000).replace('.', ',') + km2;\n\t        } else if (area < 30000000) {\n\t            return ('' + Math.round(area / 10000) / 100).replace('.', ',') + km2;\n\t        } else if (area < 300000000) {\n\t            return ('' + Math.round(area / 100000) / 10).replace('.', ',') + km2;\n\t        }\n\t        return Math.round(area / 1000000) + km2;\n\t    },\n\t\n\t    geoLength: function geoLength(geom) {\n\t        var ret = 0,\n\t            type = geom.type;\n\t        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoLength({ type: 'LINESTRING', coordinates: geom.coordinates[i] });\n\t            }\n\t            return ret;\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            ret = gmxAPIutils.getLength(geom.coordinates);\n\t        }\n\t        return ret;\n\t    },\n\t\n\t    /** Converts Geomixer geometry to geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - Geomixer geometry\r\n\t     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n\t     * @return {Object} geoJSON geometry\r\n\t    */\n\t    geometryToGeoJSON: function geometryToGeoJSON(geom, mercFlag) {\n\t        if (!geom) {\n\t            return null;\n\t        }\n\t\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    convertGeometry: function convertGeometry(geom, fromMerc) {\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (fromMerc) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        } else {\n\t            coords = gmxAPIutils.coordsToMercator(type, coords);\n\t        }\n\t        return {\n\t            type: geom.type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    /** Converts GeoJSON object into GeoMixer format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - GeoJSON object\r\n\t     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n\t     * @return {Object} Geometry in GeoMixer format\r\n\t    */\n\t    geoJSONtoGeometry: function geoJSONtoGeometry(geoJSON, mercFlag) {\n\t        if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        }\n\t\n\t        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON' : geoJSON.type === 'Polygon' ? 'POLYGON' : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING' : geoJSON.type === 'LineString' ? 'LINESTRING' : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT' : geoJSON.type === 'Point' ? 'POINT' : geoJSON.type,\n\t            coords = geoJSON.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    _coordsConvert: function _coordsConvert(type, coords, toMerc) {\n\t        var i,\n\t            len,\n\t            p,\n\t            resCoords = [];\n\t        if (type === 'Point') {\n\t            if (toMerc) {\n\t                p = L.Projection.Mercator.project({ lat: coords[1], lng: coords[0] });\n\t                resCoords = [p.x, p.y];\n\t            } else {\n\t                p = L.Projection.Mercator.unproject({ y: coords[1], x: coords[0] });\n\t                resCoords = [p.lng, p.lat];\n\t            }\n\t        } else if (type === 'LineString' || type === 'MultiPoint') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'Polygon' || type === 'MultiLineString') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'MultiPolygon') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\n\t            }\n\t        }\n\t        return resCoords;\n\t    },\n\t\n\t    coordsFromMercator: function coordsFromMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, false);\n\t    },\n\t\n\t    coordsToMercator: function coordsToMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, true);\n\t    },\n\t\n\t    transformGeometry: function transformGeometry(geom, callback) {\n\t        return !geom ? geom : {\n\t            type: geom.type,\n\t            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function (p) {\n\t                return callback(p);\n\t            })\n\t        };\n\t    },\n\t\n\t    /** Get area for geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry\r\n\t     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoArea: function geoArea(geom, isMerc) {\n\t        var i,\n\t            len,\n\t            ret = 0,\n\t            type = geom.type || '';\n\t        isMerc = isMerc === undefined || isMerc;\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            for (i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoArea({ type: 'POLYGON', coordinates: geom.coordinates[i] }, isMerc);\n\t            }\n\t            return ret;\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\n\t            for (i = 1, len = geom.coordinates.length; i < len; i++) {\n\t                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\n\t            }\n\t            return ret;\n\t        } else if (geom.length) {\n\t            var latlngs = [],\n\t                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\n\t\n\t            for (i = 0, len = geom.length; i < len; i += vectorSize) {\n\t                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\n\t                latlngs.push(isMerc ? L.Projection.Mercator.unproject({ y: p[1], x: p[0] }) : { lat: p[1], lng: p[0] });\n\t            }\n\t            return gmxAPIutils.getArea(latlngs);\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    /** Get summary for geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON geometry\r\n\t     * @param {Object} unitOptions {\r\n\t     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n\t     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n\t     *               }\r\n\t     * @return {String} Summary string for geometry\r\n\t    */\n\t    getGeoJSONSummary: function getGeoJSONSummary(geom, unitOptions) {\n\t        var type = geom.type,\n\t            units = unitOptions || {},\n\t            out = 0,\n\t            i,\n\t            len,\n\t            coords;\n\t        if (type === 'Point') {\n\t            coords = geom.coordinates;\n\t            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\n\t        } else if (type === 'Polygon') {\n\t            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\n\t        } else if (type === 'MultiPolygon') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoArea({ type: 'Polygon', coordinates: coords[i] }, false);\n\t            }\n\t            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\n\t        } else if (type === 'LineString') {\n\t            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\n\t        } else if (type === 'MultiLineString') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoJSONGetLength({ type: 'LineString', coordinates: coords[i] });\n\t            }\n\t            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for point\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {latlng} point\r\n\t     * @param {num} format number:\r\n\t     *         0: 62°52'30.68\" N, 22°48'27.42\" E\r\n\t     *         1: 62.875188 N, 22.807617 E\r\n\t     *         2: 2538932, 9031643 (EPSG:3395)\r\n\t     *         3: 2538932, 9069712 (EPSG:3857)\r\n\t     * @return {String} Summary string for LatLng point\r\n\t    */\n\t    getCoordinatesString: function getCoordinatesString(latlng, num) {\n\t        var x = latlng.lng,\n\t            y = latlng.lat,\n\t            formats = ['', '', ' (EPSG:3395)', ' (EPSG:3857)'],\n\t            len = formats.length,\n\t            merc,\n\t            out = '';\n\t        num = num || 0;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        }\n\t        if (x < -180) {\n\t            x += 360;\n\t        }\n\t        if (num % len === 0) {\n\t            out = gmxAPIutils.formatCoordinates2(x, y);\n\t        } else if (num % len === 1) {\n\t            out = gmxAPIutils.formatCoordinates(x, y);\n\t        } else if (num % len === 2) {\n\t            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\n\t        } else {\n\t            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for geometries array\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} geometries array in Geomixer format\r\n\t     * @param {Object} units Options for length and area\r\n\t     * @return {String} Summary string for geometries array\r\n\t    */\n\t    getGeometriesSummary: function getGeometriesSummary(arr, unitOptions) {\n\t        var out = '',\n\t            type = '',\n\t            res = 0;\n\t        if (!unitOptions) {\n\t            unitOptions = {};\n\t        }\n\t        if (arr) {\n\t            arr.forEach(function (geom) {\n\t                if (geom) {\n\t                    type = geom.type.toUpperCase();\n\t                    if (type.indexOf('POINT') !== -1) {\n\t                        var latlng = L.Projection.Mercator.unproject({ y: geom.coordinates[1], x: geom.coordinates[0] });\n\t                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: ' + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\n\t                    } else if (type.indexOf('LINESTRING') !== -1) {\n\t                        res += gmxAPIutils.geoLength(geom);\n\t                    } else if (type.indexOf('POLYGON') !== -1) {\n\t                        res += gmxAPIutils.geoArea(geom);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        if (!out) {\n\t            if (type.indexOf('LINESTRING') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: ' + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\n\t            } else if (type.indexOf('POLYGON') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: ' + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getGeometrySummary: function getGeometrySummary(geom, unitOptions) {\n\t        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\n\t    },\n\t\n\t    chkOnEdge: function chkOnEdge(p1, p2, ext) {\n\t        // отрезок на границе\n\t        if (p1[0] < ext.min.x && p2[0] < ext.min.x || p1[0] > ext.max.x && p2[0] > ext.max.x) {\n\t            return true;\n\t        }\n\t        if (p1[1] < ext.min.y && p2[1] < ext.min.y || p1[1] > ext.max.y && p2[1] > ext.max.y) {\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getHidden: function getHidden(coords, tb) {\n\t        // массив точек на границах тайлов\n\t        var hiddenLines = [],\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            prev = null;\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\n\t                hiddenLines.push(i);\n\t            }\n\t            prev = p;\n\t        }\n\t        return hiddenLines;\n\t    },\n\t\n\t    getNormalizeBounds: function getNormalizeBounds(screenBounds, mercDeltaY) {\n\t        // get bounds array from -180 180 lng\n\t        var northWest = screenBounds.getNorthWest(),\n\t            southEast = screenBounds.getSouthEast(),\n\t            minX = northWest.lng,\n\t            maxX = southEast.lng,\n\t            w = (maxX - minX) / 2,\n\t            minX1 = null,\n\t            maxX1 = null,\n\t            out = [];\n\t\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = { x: minX, y: southEast.lat },\n\t            m2 = { x: maxX, y: northWest.lat };\n\t\n\t        if (mercDeltaY !== undefined) {\n\t            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\n\t            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\n\t            m1.y -= mercDeltaY;\n\t            m2.y -= mercDeltaY;\n\t        }\n\t        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\n\t\n\t        if (minX1) {\n\t            var m11 = { x: minX1, y: southEast.lat },\n\t                m12 = { x: maxX1, y: northWest.lat };\n\t            if (mercDeltaY !== undefined) {\n\t                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\n\t                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\n\t                m11.y -= mercDeltaY;\n\t                m12.y -= mercDeltaY;\n\t            }\n\t            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\n\t        }\n\t        return out;\n\t    },\n\t\n\t    toPrecision: function toPrecision(x, prec) {\n\t        var zn = Math.pow(10, prec ? prec : 4);\n\t        return Math.round(zn * x) / zn;\n\t    },\n\t\n\t    getTileBounds: function getTileBounds(x, y, z) {\n\t        //x, y, z - GeoMixer tile coordinates\n\t        var tileSize = gmxAPIutils.tileSizes[z],\n\t            minx = x * tileSize,\n\t            miny = y * tileSize;\n\t        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\n\t    },\n\t\n\t    parseTemplate: function parseTemplate(str, properties) {\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = key in properties ? properties[key] : '';\n\t\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    getDefaultBalloonTemplate: function getDefaultBalloonTemplate(properties, tileAttributeTypes) {\n\t        var str = '';\n\t        for (var key in properties) {\n\t            if (!tileAttributeTypes || key in tileAttributeTypes) {\n\t                str += '<b>' + key + ':</b> [' + key + ']<br />';\n\t            }\n\t        }\n\t        str += '<br />[SUMMARY]<br />';\n\t        return str;\n\t    },\n\t\n\t    parseBalloonTemplate: function parseBalloonTemplate(str, options) {\n\t        var properties = options.properties;\n\t\n\t        if (!str) {\n\t            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\n\t        }\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            var tileAttributeTypes = options.tileAttributeTypes,\n\t                unitOptions = options.unitOptions,\n\t                geometries = options.geometries;\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = '';\n\t\n\t                if (key in properties) {\n\t                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\n\t                } else if (key === 'SUMMARY') {\n\t                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    styleKeys: {\n\t        marker: {\n\t            server: ['image', 'angle', 'scale', 'minScale', 'maxScale', 'size', 'circle', 'center', 'color'],\n\t            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\n\t        },\n\t        outline: {\n\t            server: ['color', 'opacity', 'thickness', 'dashes'],\n\t            client: ['color', 'opacity', 'weight', 'dashArray']\n\t        },\n\t        fill: {\n\t            server: ['color', 'opacity', 'image', 'pattern', 'radialGradient', 'linearGradient'],\n\t            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\n\t        },\n\t        label: {\n\t            server: ['text', 'field', 'template', 'color', 'haloColor', 'size', 'spacing', 'align'],\n\t            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\n\t        }\n\t    },\n\t    styleFuncKeys: {\n\t        iconSize: 'iconSizeFunction',\n\t        iconAngle: 'rotateFunction',\n\t        iconScale: 'scaleFunction',\n\t        iconColor: 'iconColorFunction',\n\t        opacity: 'opacityFunction',\n\t        fillOpacity: 'fillOpacityFunction',\n\t        color: 'colorFunction',\n\t        fillColor: 'fillColorFunction'\n\t    },\n\t    styleFuncError: {\n\t        iconSize: function iconSize() {\n\t            return 8;\n\t        },\n\t        iconAngle: function iconAngle() {\n\t            return 0;\n\t        },\n\t        iconScale: function iconScale() {\n\t            return 1;\n\t        },\n\t        iconColor: function iconColor() {\n\t            return 0xFF;\n\t        },\n\t        opacity: function opacity() {\n\t            return 1;\n\t        },\n\t        fillOpacity: function fillOpacity() {\n\t            return 0.5;\n\t        },\n\t        color: function color() {\n\t            return 0xFF;\n\t        },\n\t        fillColor: function fillColor() {\n\t            return 0xFF;\n\t        }\n\t    },\n\t    defaultStyles: {\n\t        MinZoom: 1,\n\t        MaxZoom: 21,\n\t        Filter: '',\n\t        Balloon: '',\n\t        DisableBalloonOnMouseMove: true,\n\t        DisableBalloonOnClick: false,\n\t        RenderStyle: {\n\t            point: { // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\n\t                color: 0xFF,\n\t                weight: 1,\n\t                iconSize: 8\n\t            },\n\t            linestring: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            },\n\t            polygon: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            }\n\t        }\n\t    },\n\t\n\t    getDefaultStyle: function getDefaultStyle(type) {\n\t        var from = gmxAPIutils.defaultStyles,\n\t            out = L.extend({}, from);\n\t        out.RenderStyle = from.RenderStyle[type];\n\t        return out;\n\t    },\n\t\n\t    toServerStyle: function toServerStyle(style) {\n\t        // Style leaflet->Scanex\n\t        var out = {};\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (var i = 0, len = keys.client.length; i < len; i++) {\n\t                var key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    if (!out[key]) {\n\t                        out[key] = {};\n\t                    }\n\t                    var zn = style[key1];\n\t                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\n\t                        zn *= 100;\n\t                    }\n\t                    out[key][keys.server[i]] = zn;\n\t                }\n\t            }\n\t        }\n\t        if ('iconAnchor' in style) {\n\t            if (!out.marker) {\n\t                out.marker = {};\n\t            }\n\t            out.marker.dx = -style.iconAnchor[0];\n\t            out.marker.dy = -style.iconAnchor[1];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    fromServerStyle: function fromServerStyle(style) {\n\t        // Style Scanex->leaflet\n\t        var st,\n\t            i,\n\t            len,\n\t            key1,\n\t            out = {\n\t            type: '' // 'polygon', 'line', 'circle', 'square', 'image'\n\t        };\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (i = 0, len = keys.client.length; i < len; i++) {\n\t                key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    out[key1] = style[key1];\n\t                }\n\t            }\n\t            st = style[key];\n\t            if (st && (typeof st === 'undefined' ? 'undefined' : _typeof(st)) === 'object') {\n\t                for (i = 0, len = keys.server.length; i < len; i++) {\n\t                    key1 = keys.server[i];\n\t                    if (key1 in st) {\n\t                        var newKey = keys.client[i],\n\t                            zn = st[key1];\n\t                        if (typeof zn === 'string') {\n\t                            if (gmxAPIutils.styleFuncKeys[newKey]) {\n\t                                if (zn.match(/[^\\d\\.]/) === null) {\n\t                                    zn = Number(zn);\n\t                                } else {\n\t                                    var func = L.gmx.Parsers.parseExpression(zn);\n\t                                    if (func === null) {\n\t                                        zn = gmxAPIutils.styleFuncError[newKey]();\n\t                                    } else {\n\t                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\n\t                                    }\n\t                                }\n\t                            }\n\t                        } else if (key1 === 'opacity') {\n\t                            zn /= 100;\n\t                        }\n\t                        out[newKey] = zn;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (style.marker) {\n\t            st = style.marker;\n\t            if ('dx' in st || 'dy' in st) {\n\t                var dx = st.dx || 0,\n\t                    dy = st.dy || 0;\n\t                out.iconAnchor = [-dx, -dy]; // For leaflet type iconAnchor\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getUnixTimeFromStr: function getUnixTimeFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        return Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\n\t    },\n\t\n\t    getDateFromStr: function getDateFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        var dt = new Date(arr[0], arr[1] - 1, arr[2]);\n\t        return dt;\n\t    },\n\t\n\t    getUTCdate: function getUTCdate(utime) {\n\t        var dt = new Date(utime * 1000);\n\t\n\t        return [dt.getUTCFullYear(), gmxAPIutils.pad2(dt.getUTCMonth() + 1), gmxAPIutils.pad2(dt.getUTCDate())].join('.');\n\t    },\n\t\n\t    getUTCtime: function getUTCtime(utime) {\n\t        var h = Math.floor(utime / 3600),\n\t            m = Math.floor((utime - h * 3600) / 60),\n\t            s = Math.floor(utime - h * 3600 - m * 60);\n\t\n\t        return [\n\t        //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\n\t        gmxAPIutils.pad2(h), gmxAPIutils.pad2(m), gmxAPIutils.pad2(s)].join(':');\n\t    },\n\t\n\t    getUTCdateTime: function getUTCdateTime(utime) {\n\t        var time = utime % (3600 * 24);\n\t\n\t        if (time) {\n\t            return [gmxAPIutils.getUTCdate(utime), gmxAPIutils.getUTCtime(utime % (3600 * 24))].join(' ');\n\t        } else {\n\t            return gmxAPIutils.getUTCdate(utime);\n\t        }\n\t    },\n\t\n\t    attrToString: function attrToString(type, value) {\n\t        if (type === 'date') {\n\t            return value ? L.gmxUtil.getUTCdate(value) : value;\n\t        } else if (type === 'time') {\n\t            return value ? L.gmxUtil.getUTCtime(value) : value;\n\t        } else if (type === 'datetime') {\n\t            return value ? L.gmxUtil.getUTCdateTime(value) : value;\n\t        } else {\n\t            return value;\n\t        }\n\t    },\n\t\n\t    getTileAttributes: function getTileAttributes(prop) {\n\t        var tileAttributeIndexes = {},\n\t            tileAttributeTypes = {};\n\t        if (prop.attributes) {\n\t            var attrs = prop.attributes,\n\t                attrTypes = prop.attrTypes || null;\n\t            if (prop.identityField) {\n\t                tileAttributeIndexes[prop.identityField] = 0;\n\t            }\n\t            for (var a = 0; a < attrs.length; a++) {\n\t                var key = attrs[a];\n\t                tileAttributeIndexes[key] = a + 1;\n\t                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\n\t            }\n\t        }\n\t        return {\n\t            tileAttributeTypes: tileAttributeTypes,\n\t            tileAttributeIndexes: tileAttributeIndexes\n\t        };\n\t    }\n\t};\n\t\n\tgmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0); // 111319.5;\n\tgmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI; // 6335440.712613423;\n\t\n\t(function () {\n\t    //pre-calculate tile sizes\n\t    for (var z = 0; z < 30; z++) {\n\t        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\n\t    }\n\t})();\n\t\n\tgmxAPIutils.Bounds = function (arr) {\n\t    this.min = {\n\t        x: Number.MAX_VALUE,\n\t        y: Number.MAX_VALUE\n\t    };\n\t    this.max = {\n\t        x: -Number.MAX_VALUE,\n\t        y: -Number.MAX_VALUE\n\t    };\n\t    this.extendArray(arr);\n\t};\n\tgmxAPIutils.Bounds.prototype = {\n\t    extend: function extend(x, y) {\n\t        if (x < this.min.x) {\n\t            this.min.x = x;\n\t        }\n\t        if (x > this.max.x) {\n\t            this.max.x = x;\n\t        }\n\t        if (y < this.min.y) {\n\t            this.min.y = y;\n\t        }\n\t        if (y > this.max.y) {\n\t            this.max.y = y;\n\t        }\n\t        return this;\n\t    },\n\t    extendBounds: function extendBounds(bounds) {\n\t        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\n\t    },\n\t    extendArray: function extendArray(arr) {\n\t        if (!arr || !arr.length) {\n\t            return this;\n\t        }\n\t        var i, len;\n\t        if (typeof arr[0] === 'number') {\n\t            for (i = 0, len = arr.length; i < len; i += 2) {\n\t                this.extend(arr[i], arr[i + 1]);\n\t            }\n\t        } else {\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                this.extend(arr[i][0], arr[i][1]);\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t    addBuffer: function addBuffer(dxmin, dymin, dxmax, dymax) {\n\t        this.min.x -= dxmin;\n\t        this.min.y -= dymin || dxmin;\n\t        this.max.x += dxmax || dxmin;\n\t        this.max.y += dymax || dymin || dxmin;\n\t        return this;\n\t    },\n\t    contains: function contains(point) {\n\t        // ([x, y]) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = point[0],\n\t            y = point[1];\n\t        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\n\t    },\n\t    getCenter: function getCenter() {\n\t        var min = this.min,\n\t            max = this.max;\n\t        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t    },\n\t    addOffset: function addOffset(offset) {\n\t        this.min.x += offset[0];this.max.x += offset[0];\n\t        this.min.y += offset[1];this.max.y += offset[1];\n\t        return this;\n\t    },\n\t    intersects: function intersects(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\n\t    },\n\t    intersectsWithDelta: function intersectsWithDelta(bounds, dx, dy) {\n\t        // (Bounds, dx, dy) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = dx || 0,\n\t            y = dy || 0,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\n\t    },\n\t    isEqual: function isEqual(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\n\t    },\n\t    isNodeIntersect: function isNodeIntersect(coords) {\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            if (this.contains(coords[i])) {\n\t                return {\n\t                    num: i,\n\t                    point: coords[i]\n\t                };\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t    clipPolygon: function clipPolygon(coords) {\n\t        // (coords) -> clip coords\n\t        var min = this.min,\n\t            max = this.max,\n\t            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\n\t            cp1,\n\t            cp2,\n\t            s,\n\t            e,\n\t            inside = function inside(p) {\n\t            return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\n\t        },\n\t            intersection = function intersection() {\n\t            var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\n\t                dp = [s[0] - e[0], s[1] - e[1]],\n\t                n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n\t                n2 = s[0] * e[1] - s[1] * e[0],\n\t                n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n\t            return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\n\t        };\n\t\n\t        var outputList = coords;\n\t        cp1 = clip[3];\n\t        for (var j = 0; j < 4; j++) {\n\t            cp2 = clip[j];\n\t            var inputList = outputList,\n\t                len = inputList.length;\n\t            outputList = [];\n\t            s = inputList[len - 1]; //last on the input list\n\t            for (var i = 0; i < len; i++) {\n\t                e = inputList[i];\n\t                if (inside(e)) {\n\t                    if (!inside(s)) {\n\t                        outputList.push(intersection());\n\t                    }\n\t                    outputList.push(e);\n\t                } else if (inside(s)) {\n\t                    outputList.push(intersection());\n\t                }\n\t                s = e;\n\t            }\n\t            cp1 = cp2;\n\t        }\n\t        return outputList;\n\t    },\n\t    clipPolyLine: function clipPolyLine(coords, angleFlag, delta) {\n\t        // (coords) -> clip coords\n\t        delta = delta || 0;\n\t        var min = this.min,\n\t            max = this.max,\n\t            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\n\t            bitCode = function bitCode(p) {\n\t            var code = 0;\n\t\n\t            if (p[0] < bbox[0]) code |= 1; // left\n\t            else if (p[0] > bbox[2]) code |= 2; // right\n\t\n\t            if (p[1] < bbox[1]) code |= 4; // bottom\n\t            else if (p[1] > bbox[3]) code |= 8; // top\n\t\n\t            return code;\n\t        },\n\t            getAngle = function getAngle(a, b) {\n\t            return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\n\t        },\n\t            intersect = function intersect(a, b, edge) {\n\t            return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\n\t            edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\n\t            edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\n\t            edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\n\t            null;\n\t        },\n\t            result = [],\n\t            len = coords.length,\n\t            codeA = bitCode(coords[0], bbox),\n\t            part = [],\n\t            i,\n\t            a,\n\t            b,\n\t            c,\n\t            codeB,\n\t            lastCode;\n\t\n\t        for (i = 1; i < len; i++) {\n\t            a = coords[i - 1];\n\t            b = coords[i];\n\t            if (a[0] === b[0] && a[1] === b[1]) {\n\t                continue;\n\t            }\n\t            codeB = lastCode = bitCode(b, bbox);\n\t\n\t            while (true) {\n\t\n\t                if (!(codeA | codeB)) {\n\t                    // accept\n\t                    if (angleFlag) {\n\t                        a[2] = getAngle(a, b);\n\t                        c = coords[i + 1];\n\t                        b[2] = c ? getAngle(b, c) : a[2];\n\t                    }\n\t                    part.push(a);\n\t\n\t                    if (codeB !== lastCode) {\n\t                        // segment went outside\n\t                        part.push(b);\n\t\n\t                        if (i < len - 1) {\n\t                            // start a new line\n\t                            result.push(part);\n\t                            part = [];\n\t                        }\n\t                    } else if (i === len - 1) {\n\t                        part.push(b);\n\t                    }\n\t                    break;\n\t                } else if (codeA & codeB) {\n\t                    // trivial reject\n\t                    break;\n\t                } else if (codeA) {\n\t                    // a outside, intersect with clip edge\n\t                    a = intersect(a, b, codeA, bbox);\n\t                    codeA = bitCode(a, bbox);\n\t                } else {\n\t                    // b outside\n\t                    b = intersect(a, b, codeB, bbox);\n\t                    codeB = bitCode(b, bbox);\n\t                }\n\t            }\n\t\n\t            codeA = lastCode;\n\t        }\n\t\n\t        if (part.length) result.push(part);\n\t\n\t        return result;\n\t    }\n\t};\n\t\n\tgmxAPIutils.bounds = function (arr) {\n\t    return new gmxAPIutils.Bounds(arr);\n\t};\n\t\n\t//скопирована из API для обеспечения независимости от него\n\tgmxAPIutils.parseUri = function (str) {\n\t    var o = gmxAPIutils.parseUri.options,\n\t        m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\n\t        uri = {},\n\t        i = 14;\n\t\n\t    while (i--) {\n\t        uri[o.key[i]] = m[i] || '';\n\t    }\n\t\n\t    uri[o.q.name] = {};\n\t    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n\t        if ($1) {\n\t            uri[o.q.name][$1] = $2;\n\t        }\n\t    });\n\t\n\t    uri.hostOnly = uri.host;\n\t    uri.host = uri.authority; // HACK\n\t\n\t    return uri;\n\t};\n\t\n\tgmxAPIutils.parseUri.options = {\n\t    strictMode: false,\n\t    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n\t    q: {\n\t        name: 'queryKey',\n\t        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n\t    },\n\t    parser: {\n\t        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n\t        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n\t    }\n\t};\n\t\n\tif (!L.gmxUtil) {\n\t    L.gmxUtil = {};\n\t}\n\t\n\t//public interface\n\tL.extend(L.gmxUtil, {\n\t    newId: gmxAPIutils.newId,\n\t    loaderStatus: function loaderStatus() {},\n\t    isIE9: gmxAPIutils.isIE(9),\n\t    isIE10: gmxAPIutils.isIE(10),\n\t    isIE11: gmxAPIutils.isIE(11),\n\t    gtIE11: gmxAPIutils.gtIE(11),\n\t    getFormData: gmxAPIutils.getFormData,\n\t    requestJSONP: gmxAPIutils.requestJSONP,\n\t    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\n\t    request: gmxAPIutils.request,\n\t    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\n\t    fromServerStyle: gmxAPIutils.fromServerStyle,\n\t    toServerStyle: gmxAPIutils.toServerStyle,\n\t    getDefaultStyle: gmxAPIutils.getDefaultStyle,\n\t    bounds: gmxAPIutils.bounds,\n\t    getGeometryBounds: gmxAPIutils.getGeometryBounds,\n\t    tileSizes: gmxAPIutils.tileSizes,\n\t    getDateFromStr: gmxAPIutils.getDateFromStr,\n\t    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\n\t    getUTCdate: gmxAPIutils.getUTCdate,\n\t    getUTCtime: gmxAPIutils.getUTCtime,\n\t    getUTCdateTime: gmxAPIutils.getUTCdateTime,\n\t    attrToString: gmxAPIutils.attrToString,\n\t    getTileAttributes: gmxAPIutils.getTileAttributes,\n\t    formatCoordinates: function formatCoordinates(latlng, type) {\n\t        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\n\t    },\n\t    formatDegrees: gmxAPIutils.formatDegrees,\n\t    pad2: gmxAPIutils.pad2,\n\t    dec2hex: gmxAPIutils.dec2hex,\n\t    dec2rgba: gmxAPIutils.dec2rgba,\n\t    trunc: gmxAPIutils.trunc,\n\t    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\n\t    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\n\t    getLength: gmxAPIutils.getLength,\n\t    geoLength: gmxAPIutils.geoLength,\n\t    prettifyDistance: gmxAPIutils.prettifyDistance,\n\t    getArea: gmxAPIutils.getArea,\n\t    prettifyArea: gmxAPIutils.prettifyArea,\n\t    geoArea: gmxAPIutils.geoArea,\n\t    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\n\t    getSVGIcon: gmxAPIutils.getSVGIcon,\n\t    getCoordinatesString: gmxAPIutils.getCoordinatesString,\n\t    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\n\t    getGeometrySummary: gmxAPIutils.getGeometrySummary,\n\t    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\n\t    getPropertiesHash: gmxAPIutils.getPropertiesHash,\n\t    distVincenty: gmxAPIutils.distVincenty,\n\t    parseCoordinates: gmxAPIutils.parseCoordinates,\n\t    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\n\t    convertGeometry: gmxAPIutils.convertGeometry,\n\t    transformGeometry: gmxAPIutils.transformGeometry,\n\t    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\n\t    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\n\t    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\n\t    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\n\t    parseUri: gmxAPIutils.parseUri,\n\t    isRectangle: gmxAPIutils.isRectangle,\n\t    isClockwise: gmxAPIutils.isClockwise,\n\t    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\n\t    getPatternIcon: gmxAPIutils.getPatternIcon,\n\t    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\n\t    normalizeHostname: gmxAPIutils.normalizeHostname,\n\t    getTileBounds: gmxAPIutils.getTileBounds,\n\t    parseTemplate: gmxAPIutils.parseTemplate\n\t});\n\t\n\t(function () {\n\t    var requests = {};\n\t    var lastRequestId = 0;\n\t\n\t    var processMessage = function processMessage(e) {\n\t\n\t        if (!(e.origin in requests)) {\n\t            return;\n\t        }\n\t\n\t        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\n\t        try {\n\t            var dataObj = JSON.parse(dataStr);\n\t        } catch (ev) {\n\t            console.log({ Status: 'error', ErrorInfo: { ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr } });\n\t        }\n\t        var request = requests[e.origin][dataObj.CallbackName];\n\t        if (!request) {\n\t            return; // message от других запросов\n\t        }\n\t\n\t        delete requests[e.origin][dataObj.CallbackName];\n\t        delete dataObj.CallbackName;\n\t\n\t        if (request.iframe.parentNode) {\n\t            request.iframe.parentNode.removeChild(request.iframe);\n\t        }\n\t        if ('callback' in request) {\n\t            request.callback(dataObj);\n\t        }\n\t    };\n\t\n\t    L.DomEvent.on(window, 'message', processMessage);\n\t\n\t    function createPostIframe2(id, callback, url) {\n\t        var uniqueId = 'gmxAPIutils_id' + lastRequestId++,\n\t            iframe = L.DomUtil.create('iframe');\n\t\n\t        iframe.style.display = 'none';\n\t        iframe.setAttribute('id', id);\n\t        iframe.setAttribute('name', id); /*eslint-disable no-script-url */\n\t        iframe.src = 'javascript:true'; /*eslint-enable */\n\t        iframe.callbackName = uniqueId;\n\t\n\t        var parsedURL = gmxAPIutils.parseUri(url);\n\t        var origin = (parsedURL.protocol ? parsedURL.protocol + ':' : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\n\t\n\t        requests[origin] = requests[origin] || {};\n\t        requests[origin][uniqueId] = { callback: callback, iframe: iframe };\n\t\n\t        return iframe;\n\t    }\n\t\n\t    //расширяем namespace\n\t    gmxAPIutils.createPostIframe2 = createPostIframe2;\n\t})();\n\t\n\t// кроссдоменный POST запрос\n\t(function () {\n\t    /** Посылает кроссдоменный POST запрос\r\n\t    * @namespace L.gmxUtil\r\n\t       * @ignore\r\n\t    * @function\r\n\t    *\r\n\t    * @param url {string} - URL запроса\r\n\t    * @param params {object} - хэш параметров-запросов\r\n\t    * @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные\r\n\t    * @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл.\r\n\t    *                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.\r\n\t    */\n\t    function sendCrossDomainPostRequest(url, params, callback, baseForm) {\n\t        var form,\n\t            id = '$$iframe_' + gmxAPIutils.newId();\n\t\n\t        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\n\t            originalFormAction;\n\t\n\t        if (baseForm) {\n\t            form = baseForm;\n\t            originalFormAction = form.getAttribute('action');\n\t            form.setAttribute('action', url);\n\t            form.target = id;\n\t        } else if (L.Browser.ielt9) {\n\t            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\n\t            form = document.createElement(str);\n\t        } else {\n\t            form = document.createElement('form');\n\t            form.style.display = 'none';\n\t            form.setAttribute('enctype', 'multipart/form-data');\n\t            form.target = id;\n\t            form.setAttribute('method', 'POST');\n\t            form.setAttribute('action', url);\n\t            form.id = id;\n\t        }\n\t\n\t        var hiddenParamsDiv = document.createElement('div');\n\t        hiddenParamsDiv.style.display = 'none';\n\t\n\t        if (params.WrapStyle === 'window') {\n\t            params.WrapStyle = 'message';\n\t        }\n\t\n\t        if (params.WrapStyle === 'message') {\n\t            params.CallbackName = iframe.callbackName;\n\t        }\n\t\n\t        for (var paramName in params) {\n\t            var input = document.createElement('input');\n\t            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\n\t            input.setAttribute('type', 'hidden');\n\t            input.setAttribute('name', paramName);\n\t            input.setAttribute('value', value);\n\t            hiddenParamsDiv.appendChild(input);\n\t        }\n\t\n\t        form.appendChild(hiddenParamsDiv);\n\t\n\t        if (!baseForm) {\n\t            document.body.appendChild(form);\n\t        }\n\t        document.body.appendChild(iframe);\n\t\n\t        form.submit();\n\t\n\t        if (baseForm) {\n\t            form.removeChild(hiddenParamsDiv);\n\t            if (originalFormAction !== null) {\n\t                form.setAttribute('action', originalFormAction);\n\t            } else {\n\t                form.removeAttribute('action');\n\t            }\n\t        } else {\n\t            form.parentNode.removeChild(form);\n\t        }\n\t    }\n\t    //расширяем namespace\n\t    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\n\t})();\n\texports.gmxAPIutils = gmxAPIutils;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\n\t    styleCanvasKeysLen = styleCanvasKeys.length;\n\t\n\tvar setCanvasStyle = function setCanvasStyle(prop, indexes, ctx, style) {\n\t    for (var i = 0; i < styleCanvasKeysLen; i++) {\n\t        var key = styleCanvasKeys[i],\n\t            valKey = style[key];\n\t        if (valKey !== ctx[key]) {\n\t            ctx[key] = valKey;\n\t        }\n\t    }\n\t    if (style.dashArray) {\n\t        var dashes = style.dashArray,\n\t            dashOffset = style.dashOffset || 0;\n\t        if ('setLineDash' in ctx) {\n\t            ctx.setLineDash(dashes);\n\t            if (ctx.lineDashOffset !== dashOffset) {\n\t                ctx.lineDashOffset = dashOffset;\n\t            }\n\t        }\n\t    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t        ctx.setLineDash([]);\n\t    }\n\t    if (ctx.lineCap !== 'round') {\n\t        ctx.lineCap = 'round';\n\t    }\n\t    if (ctx.lineJoin !== 'round') {\n\t        ctx.lineJoin = 'round';\n\t    }\n\t\n\t    if (style.canvasPattern) {\n\t        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\n\t    } else if (style.fillLinearGradient) {\n\t        var rgr = style.fillLinearGradient,\n\t            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\n\t            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\n\t        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\n\t            var arr1 = rgr.addColorStop[j],\n\t                arrFunc = rgr.addColorStopFunctions[j],\n\t                p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0],\n\t                p2 = arr1.length < 3 ? 100 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2],\n\t                p1 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\n\t            lineargrad.addColorStop(p0, p1);\n\t        }\n\t        ctx.fillStyle = style.fillStyle = lineargrad;\n\t    }\n\t};\n\t\n\t/*\r\n\tgeoItem\r\n\t     properties: объект (в формате векторного тайла)\r\n\t     dataOption: дополнительные свойства объекта\r\n\titem\r\n\t     skipRasters: скрыть растр\r\n\t     currentStyle: текущий canvas стиль объекта\r\n\t     parsedStyleKeys: стиль прошедший парсинг\r\n\toptions\r\n\t     ctx: canvas context\r\n\t     tbounds: tile bounds\r\n\t     tpx: X смещение тайла\r\n\t     tpy: Y смещение тайла\r\n\t     gmx: ссылка на layer._gmx\r\n\t        gmx.currentZoom\r\n\t        gmx.lastHover\r\n\t        gmx.tileAttributeIndexes\r\n\t     bgImage: растр для background\r\n\t     rasters: растры по объектам для background\r\n\tcurrentStyle\r\n\t    текущий стиль\r\n\tstyle\r\n\t    стиль в новом формате\r\n\t    style.image - для type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n\t*/\n\tL.gmxUtil.drawGeoItem = function (geoItem, item, options, currentStyle, style) {\n\t    var propsArr = geoItem.properties,\n\t        idr = propsArr[0],\n\t        i,\n\t        len,\n\t        j,\n\t        len1,\n\t        gmx = options.gmx,\n\t        ctx = options.ctx,\n\t        geom = propsArr[propsArr.length - 1],\n\t        coords = null,\n\t        dataOption = geoItem.dataOption,\n\t        rasters = options.rasters || {},\n\t        tbounds = options.tbounds;\n\t\n\t    item.currentStyle = L.extend({}, currentStyle);\n\t    if (style) {\n\t        if (gmx.styleHook) {\n\t            if (!geoItem.styleExtend) {\n\t                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\n\t            }\n\t            if (geoItem.styleExtend) {\n\t                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\n\t            } else {\n\t                return false;\n\t            }\n\t        }\n\t        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\n\t    } else {\n\t        style = {};\n\t    }\n\t\n\t    var geoType = geom.type,\n\t        dattr = {\n\t        gmx: gmx,\n\t        item: item,\n\t        style: style,\n\t        styleExtend: geoItem.styleExtend || {},\n\t        ctx: ctx,\n\t        tpx: options.tpx,\n\t        tpy: options.tpy\n\t    };\n\t    if (geoType === 'POINT') {\n\t        dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, geom.coordinates);\n\t        if (!dattr.pointAttr) {\n\t            return false;\n\t        } // point not in canvas tile\n\t    }\n\t    if (geoType === 'POINT' || geoType === 'MULTIPOINT') {\n\t        // Отрисовка геометрии точек\n\t        coords = geom.coordinates;\n\t        if ('iconColor' in style && style.image) {\n\t            if (style.lastImage !== style.image) {\n\t                style.lastImage = style.image;\n\t                style.lastImageData = _Utils.gmxAPIutils.getImageData(style.image);\n\t            }\n\t            dattr.imageData = style.lastImageData;\n\t        }\n\t\n\t        if (geoType === 'MULTIPOINT') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                dattr.coords = coords[i];\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            dattr.coords = coords;\n\t            _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t        }\n\t    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\n\t        if (style.image) {\n\t            // set MULTIPOLYGON as marker\n\t            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\n\t            dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, dattr.coords);\n\t            if (dattr.pointAttr) {\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            coords = geom.coordinates;\n\t            if (geoType === 'POLYGON') {\n\t                coords = [coords];\n\t            }\n\t\n\t            var hiddenLines = dataOption.hiddenLines || [],\n\t                pixelsMap = dataOption.pixels,\n\t                flagPixels = true;\n\t\n\t            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\n\t                pixelsMap = dataOption.pixels = _Utils.gmxAPIutils.getCoordsPixels({\n\t                    gmx: gmx,\n\t                    coords: coords,\n\t                    tpx: options.tpx,\n\t                    tpy: options.tpy,\n\t                    hiddenLines: hiddenLines\n\t                });\n\t            }\n\t\n\t            var coordsToCanvas = function coordsToCanvas(func, flagFill) {\n\t                coords = pixelsMap.coords;\n\t                hiddenLines = pixelsMap.hidden || [];\n\t                dattr.flagPixels = flagPixels;\n\t                for (i = 0, len = coords.length; i < len; i++) {\n\t                    var coords1 = coords[i];\n\t                    var hiddenLines1 = hiddenLines[i] || [];\n\t                    ctx.beginPath();\n\t                    for (j = 0, len1 = coords1.length; j < len1; j++) {\n\t                        dattr.coords = coords1[j];\n\t                        dattr.hiddenLines = hiddenLines1[j] || [];\n\t                        func(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    if (flagFill) {\n\t                        ctx.fill();\n\t                    }\n\t                }\n\t            };\n\t            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\n\t                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\n\t            if (strokeStyle && lineWidth) {\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvas);\n\t            }\n\t            if (options.bgImage) {\n\t                dattr.bgImage = options.bgImage;\n\t            } else if (rasters[idr]) {\n\t                dattr.bgImage = rasters[idr];\n\t            }\n\t            if (dattr.styleExtend.skipRasters || item.skipRasters) {\n\t                delete dattr.bgImage;\n\t            }\n\t            if (style.imagePattern) {\n\t                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\n\t            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                if (_Utils.gmxAPIutils.isPatternNode(dattr.bgImage)) {\n\t                    if ('rasterOpacity' in gmx) {\n\t                        ctx.globalAlpha = gmx.rasterOpacity;\n\t                    }\n\t                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\n\t                    style.bgImage = true;\n\t                }\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t                ctx.globalAlpha = 1;\n\t            }\n\t            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\n\t                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t            }\n\t        }\n\t    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\n\t        coords = geom.coordinates;\n\t        if (geoType === 'LINESTRING') {\n\t            coords = [coords];\n\t        }\n\t        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\n\t        for (i = 0, len = coords.length; i < len; i++) {\n\t            var arr = tbounds.clipPolyLine(coords[i], true, size);\n\t            for (j = 0, len1 = arr.length; j < len1; j++) {\n\t                dattr.coords = arr[j];\n\t                var pixels = _Utils.gmxAPIutils.lineToCanvas(dattr);\n\t                if (pixels) {\n\t                    ctx.save();\n\t                    _Utils.gmxAPIutils.lineToCanvasAsIcon(pixels, dattr);\n\t                    ctx.restore();\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return true;\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n\t*/\n\tvar gmxSessionManager = {\n\t    APIKEY_PARAM: 'key',\n\t    SCRIPT_REGEXP: [/\\bleaflet-geomixer(-\\w*)?\\.js\\b/, /\\bgeomixer(-\\w*)?\\.js\\b/],\n\t    _scriptSearched: false,\n\t    _scriptAPIKey: null,\n\t    _searchScriptAPIKey: function _searchScriptAPIKey() {\n\t        var _this = this;\n\t        if (this._scriptSearched) {\n\t            return this._scriptAPIKey;\n\t        }\n\t\n\t        var scripts = document.getElementsByTagName('script');\n\t        for (var i = 0; i < scripts.length; i++) {\n\t            var src = scripts[i].getAttribute('src'),\n\t                arr = this.SCRIPT_REGEXP;\n\t            for (var j = 0, len = arr.length; j < len; j++) {\n\t                if (arr[j].exec(src)) {\n\t                    var query = src.split('?')[1];\n\t\n\t                    if (query) {\n\t                        var params = query.split('&');\n\t                        for (var p = 0; p < params.length; p++) {\n\t                            var parsedParam = params[p].split('=');\n\t                            if (parsedParam[0] === _this.APIKEY_PARAM) {\n\t                                _this._scriptAPIKey = parsedParam[1];\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t            if (_this._scriptAPIKey) {\n\t                break;\n\t            }\n\t        }\n\t        this._scriptSearched = true;\n\t        return this._scriptAPIKey;\n\t    },\n\t\n\t    //we will search apiKey in script tags iff apiKey parameter is undefined.\n\t    //if it is defined as falsy (null, '', etc), we won't send any requests to server\n\t    requestSessionKey: function requestSessionKey(serverHost, apiKey) {\n\t        var keys = this._sessionKeys;\n\t\n\t        if (!(serverHost in keys)) {\n\t            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\n\t            keys[serverHost] = new L.gmx.Deferred();\n\t            if (apiKey) {\n\t                gmxAPIutils.requestJSONP('http://' + serverHost + '/ApiKey.ashx', {\n\t                    WrapStyle: 'func',\n\t                    Key: apiKey\n\t                }).then(function (response) {\n\t                    if (response && response.Status === 'ok') {\n\t                        keys[serverHost].resolve(response.Result.Key);\n\t                    } else {\n\t                        keys[serverHost].reject();\n\t                    }\n\t                }, keys[serverHost].reject);\n\t            } else {\n\t                keys[serverHost].resolve('');\n\t            }\n\t        }\n\t        return keys[serverHost];\n\t    },\n\t\n\t    //get already received session key\n\t    getSessionKey: function getSessionKey(serverHost) {\n\t        var keyPromise = this._sessionKeys[serverHost];\n\t\n\t        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\n\t    },\n\t    _sessionKeys: {} //deferred for each host\n\t};\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxSessionManager = gmxSessionManager;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.gmxMapManager = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxMapManager = {\n\t    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\n\t    getMap: function getMap(serverHost, apiKey, mapName, skipTiles) {\n\t        var maps = this._maps;\n\t        if (!maps[serverHost] || !maps[serverHost][mapName]) {\n\t            var def = new L.gmx.Deferred();\n\t            maps[serverHost] = maps[serverHost] || {};\n\t            maps[serverHost][mapName] = { promise: def };\n\t\n\t            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function (sessionKey) {\n\t                _Utils.gmxAPIutils.requestJSONP('http://' + serverHost + '/TileSender.ashx', {\n\t                    WrapStyle: 'func',\n\t                    skipTiles: skipTiles || 'None', // All, NotVisible, None\n\t                    key: sessionKey,\n\t                    MapName: mapName,\n\t                    ModeKey: 'map'\n\t                }).then(function (json) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        json.Result.properties.hostName = serverHost;\n\t                        def.resolve(json.Result);\n\t                    } else {\n\t                        def.reject(json);\n\t                    }\n\t                }, def.reject);\n\t            }, def.reject);\n\t        }\n\t        return maps[serverHost][mapName].promise;\n\t    },\n\t\n\t    syncParams: {},\n\t    // установка дополнительных параметров для серверных запросов\n\t    setSyncParams: function setSyncParams(hash) {\n\t        this.syncParams = hash;\n\t    },\n\t    getSyncParams: function getSyncParams(stringFlag) {\n\t        var res = this.syncParams;\n\t        if (stringFlag) {\n\t            var arr = [];\n\t            for (var key in res) {\n\t                arr.push(key + '=' + res[key]);\n\t            }\n\t            res = arr.join('&');\n\t        }\n\t        return res;\n\t    },\n\t\n\t    //we will (lazy) create index by layer name to speed up multiple function calls\n\t    findLayerInfo: function findLayerInfo(serverHost, mapID, layerID) {\n\t        var hostMaps = this._maps[serverHost],\n\t            mapInfo = hostMaps && hostMaps[mapID];\n\t\n\t        if (!mapInfo) {\n\t            return null;\n\t        }\n\t\n\t        if (mapInfo.layers) {\n\t            return mapInfo.layers[layerID];\n\t        }\n\t\n\t        var serverData = mapInfo.promise.getFulfilledData();\n\t\n\t        if (!serverData) {\n\t            return null;\n\t        }\n\t\n\t        mapInfo.layers = {};\n\t\n\t        //create index by layer name\n\t        gmxMapManager.iterateLayers(serverData[0], function (layerInfo) {\n\t            mapInfo.layers[layerInfo.properties.name] = layerInfo;\n\t        });\n\t\n\t        return mapInfo.layers[layerID];\n\t    },\n\t    iterateLayers: function iterateLayers(treeInfo, callback) {\n\t        var iterate = function iterate(arr) {\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var layer = arr[i];\n\t\n\t                if (layer.type === 'group') {\n\t                    iterate(layer.content.children);\n\t                } else if (layer.type === 'layer') {\n\t                    callback(layer.content);\n\t                }\n\t            }\n\t        };\n\t\n\t        treeInfo && iterate(treeInfo.children);\n\t    },\n\t    iterateNode: function iterateNode(treeInfo, callback) {\n\t        var iterate = function iterate(node) {\n\t            var arr = node.children;\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var layer = arr[i];\n\t\n\t                callback(layer);\n\t                if (layer.type === 'group') {\n\t                    iterate(layer.content);\n\t                    // } else if (layer.type === 'layer') {\n\t                }\n\t            }\n\t        };\n\t\n\t        treeInfo && iterate(treeInfo);\n\t    },\n\t    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\n\t}; /** Asynchronously request information about map given server host and map name\r\n\t   */\n\texports.gmxMapManager = gmxMapManager;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _DataManager = __webpack_require__(9);\n\t\n\tvar gmxMap = L.Class.extend({\n\t\tincludes: L.Mixin.Events,\n\t\n\t\tinitialize: function initialize(mapInfo, commonLayerOptions) {\n\t\t\tthis.layers = [];\n\t\t\tthis.layersByTitle = {};\n\t\t\tthis.layersByID = {};\n\t\t\tthis.dataManagers = {};\n\t\n\t\t\tvar _this = this;\n\t\n\t\t\tthis.properties = L.extend({}, mapInfo.properties);\n\t\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\n\t\t\tthis.rawTree = mapInfo;\n\t\n\t\t\tthis.layersCreated = new L.gmx.Deferred();\n\t\n\t\t\tvar missingLayerTypes = {},\n\t\t\t    dataSources = {};\n\t\n\t\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function (layerInfo) {\n\t\t\t\tvar props = layerInfo.properties,\n\t\t\t\t    meta = props.MetaProperties || {},\n\t\t\t\t    options = {\n\t\t\t\t\tmapID: mapInfo.properties.name,\n\t\t\t\t\tlayerID: props.name\n\t\t\t\t};\n\t\n\t\t\t\tprops.hostName = mapInfo.properties.hostName;\n\t\n\t\t\t\tvar type = props.ContentID || props.type,\n\t\t\t\t    layerOptions = L.extend(options, commonLayerOptions);\n\t\n\t\t\t\tif (props.dataSource || 'parentLayer' in meta) {\n\t\t\t\t\t// Set dataSource layer\n\t\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\n\t\t\t\t\tif ('parentLayer' in meta) {\n\t\t\t\t\t\t// todo удалить после изменений вов вьювере\n\t\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\n\t\t\t\t\t}\n\t\t\t\t\tdataSources[options.layerID] = {\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t};\n\t\t\t\t} else if (type in L.gmx._layerClasses) {\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\n\t\t\t\t} else {\n\t\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\n\t\t\t\t\tmissingLayerTypes[type].push({\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t//load missing layer types\n\t\t\tvar loaders = [];\n\t\t\tfor (var type in missingLayerTypes) {\n\t\t\t\tloaders.push(L.gmx._loadLayerClass(type).then( /*eslint-disable no-loop-func */function (type) {\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t\tvar it = missingLayerTypes[type];\n\t\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\n\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\n\t\t\t\t\t}\n\t\t\t\t}.bind(null, type)));\n\t\t\t}\n\t\t\tvar hosts = {},\n\t\t\t    host,\n\t\t\t    id,\n\t\t\t    it;\n\t\t\tfor (id in dataSources) {\n\t\t\t\tit = dataSources[id];\n\t\t\t\tvar opt = it.options,\n\t\t\t\t    pId = opt.parentLayer,\n\t\t\t\t    pLayer = this.layersByID[pId];\n\t\t\t\tif (pLayer) {\n\t\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\n\t\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new _DataManager.DataManager(it.options.parentOptions, true);\n\t\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\n\t\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\n\t\t\t\t} else {\n\t\t\t\t\thost = opt.hostName;\n\t\t\t\t\tif (!hosts[host]) {\n\t\t\t\t\t\thosts[host] = {};\n\t\t\t\t\t}\n\t\t\t\t\tif (!hosts[host][pId]) {\n\t\t\t\t\t\thosts[host][pId] = [];\n\t\t\t\t\t}\n\t\t\t\t\thosts[host][pId].push(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (host in hosts) {\n\t\t\t\tvar arr = [],\n\t\t\t\t    prefix = 'http://' + host;\n\t\t\t\tfor (id in hosts[host]) {\n\t\t\t\t\tarr.push({ Layer: id });\n\t\t\t\t}\n\t\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx', {\n\t\t\t\t\tWrapStyle: 'func',\n\t\t\t\t\tLayers: JSON.stringify(arr)\n\t\t\t\t}, {\n\t\t\t\t\tids: hosts[host]\n\t\t\t\t}).then(function (json, opt) {\n\t\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\n\t\t\t\t\t\tjson.Result.forEach(function (it) {\n\t\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\n\t\t\t\t\t\t\t    props = it.properties,\n\t\t\t\t\t\t\t    pId = props.name;\n\t\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\tvar pt = dataSources[id];\n\t\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\n\t\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\n\t\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\n\t\t\t\t\t\tif (opt && opt.ids) {\n\t\t\t\t\t\t\tfor (var pId in opt.ids) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\n\t\t},\n\t\n\t\taddDataManager: function addDataManager(it) {\n\t\t\tvar pid = it.properties.name;\n\t\t\tif (!this.dataManagers[pid]) {\n\t\t\t\tthis.dataManagers[pid] = new _DataManager.DataManager(it.properties);\n\t\t\t}\n\t\t\treturn this.dataManagers[pid];\n\t\t},\n\t\tgetDataManager: function getDataManager(id) {\n\t\t\treturn this.dataManagers[id];\n\t\t},\n\t\n\t\taddLayer: function addLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tthis.layers.push(layer);\n\t\t\tthis.layersByTitle[props.title] = layer;\n\t\t\tthis.layersByID[props.name] = layer;\n\t\t\tthis.fire('layeradd', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveLayer: function removeLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tfor (var i = 0; i < this.layers.length; i++) {\n\t\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\n\t\t\t\t\tthis.layers.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tdelete this.layersByTitle[props.title];\n\t\t\tdelete this.layersByID[props.name];\n\t\t\tthis.fire('layerremove', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\taddLayersToMap: function addLayersToMap(leafletMap) {\n\t\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\n\t\t\t\tvar layer = this.layers[l];\n\t\t\t\tif (layer.getGmxProperties().visible) {\n\t\t\t\t\tleafletMap.addLayer(layer);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t}); //Helper class, that represents layers of single Geomixer's map\n\t//Creates layers from given map description\n\t\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxMap = gmxMap;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.DataManager = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _VectorTile = __webpack_require__(10);\n\t\n\tvar _VectorTileLoader = __webpack_require__(11);\n\t\n\tvar ObserverTileLoader = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    initialize: function initialize(dataManager) {\n\t        this._dataManager = dataManager;\n\t        this._observerData = {};\n\t        this._tileData = {};\n\t    },\n\t\n\t    addObserver: function addObserver(observer) {\n\t        this._observerData[observer.id] = {\n\t            observer: observer,\n\t            tiles: {},\n\t            leftToLoad: 0,\n\t            loadingState: false //are we loading any tiles for this observer?\n\t        };\n\t\n\t        observer.on('update', this._updateObserver.bind(this, observer));\n\t\n\t        this._updateObserver(observer);\n\t\n\t        return this;\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        var obsTiles = this._observerData[id].tiles;\n\t\n\t        for (var tileId in obsTiles) {\n\t            delete this._tileData[tileId].observers[id];\n\t        }\n\t\n\t        delete this._observerData[id];\n\t\n\t        return this;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\n\t        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\n\t\n\t        var tileObservers = {};\n\t\n\t        for (var key in this._observerData) {\n\t            var obsInfo = this._observerData[key];\n\t\n\t            if (obsInfo.observer.intersectsWithTile(tile)) {\n\t                obsInfo.tiles[tile.vectorTileKey] = true;\n\t                obsInfo.leftToLoad += leftToLoadDelta;\n\t                tileObservers[key] = true;\n\t            }\n\t        }\n\t\n\t        this._tileData[tile.vectorTileKey] = {\n\t            observers: tileObservers,\n\t            tile: tile\n\t        };\n\t\n\t        return this;\n\t    },\n\t\n\t    removeTile: function removeTile(tileId) {\n\t        var tileData = this._tileData[tileId],\n\t            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\n\t\n\t        for (var id in tileData.observers) {\n\t            var observerData = this._observerData[id];\n\t            observerData.leftToLoad -= leftToLoadDelta;\n\t            delete observerData.tiles[tileId];\n\t        }\n\t\n\t        delete this._tileData[tileId];\n\t\n\t        return this;\n\t    },\n\t\n\t    startLoadTiles: function startLoadTiles(observer) {\n\t\n\t        //force active tile list update\n\t        this._dataManager._getActiveTileKeys();\n\t\n\t        var obsData = this._observerData[observer.id];\n\t        if (obsData.leftToLoad === 0) {\n\t            this.fire('observertileload', { observer: observer });\n\t            return this;\n\t        }\n\t\n\t        if (!obsData.loadingState) {\n\t            obsData.loadingState = true;\n\t            observer.fire('startLoadingTiles');\n\t        }\n\t\n\t        for (var tileId in obsData.tiles) {\n\t            this._tileData[tileId].tile.load();\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getTileObservers: function getTileObservers(tileId) {\n\t        return this._tileData[tileId].observers;\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerData[observer.id].loadingState;\n\t    },\n\t\n\t    _updateObserver: function _updateObserver(observer) {\n\t        var obsData = this._observerData[observer.id],\n\t            newObserverTiles = {},\n\t            leftToLoad = 0,\n\t            key;\n\t\n\t        for (key in this._tileData) {\n\t            var tile = this._tileData[key].tile;\n\t            if (observer.intersectsWithTile(tile)) {\n\t                newObserverTiles[key] = true;\n\t                if (tile.state !== 'loaded') {\n\t                    leftToLoad++;\n\t                }\n\t                this._tileData[key].observers[observer.id] = true;\n\t            }\n\t        }\n\t\n\t        for (key in obsData.tiles) {\n\t            if (!(key in newObserverTiles)) {\n\t                delete this._tileData[key].observers[observer.id];\n\t            }\n\t        }\n\t\n\t        obsData.tiles = newObserverTiles;\n\t        obsData.leftToLoad = leftToLoad;\n\t    },\n\t\n\t    _tileLoadedCallback: function _tileLoadedCallback(tile) {\n\t        this.fire('tileload', { tile: tile });\n\t\n\t        if (!(tile.vectorTileKey in this._tileData)) {\n\t            return;\n\t        }\n\t\n\t        var tileObservers = this._tileData[tile.vectorTileKey].observers;\n\t        for (var id in tileObservers) {\n\t            var obsData = this._observerData[id];\n\t            obsData.leftToLoad--;\n\t\n\t            if (obsData.leftToLoad === 0) {\n\t                if (obsData.loadingState) {\n\t                    obsData.loadingState = false;\n\t                    obsData.observer.fire('stopLoadingTiles');\n\t                }\n\t                this.fire('observertileload', { observer: obsData.observer });\n\t            }\n\t        }\n\t    }\n\t});\n\t\n\tvar DataManager = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t\n\t    options: {\n\t        name: null, // layer ID\n\t        identityField: '', // attribute name for identity items\n\t        attributes: [], // attributes names\n\t        attrTypes: [], // attributes types\n\t        tiles: null, // tiles array for nontemporal data\n\t        tilesVers: null, // tiles version array for nontemporal data\n\t        LayerVersion: -1, // layer version\n\t        GeoProcessing: null, // processing data\n\t        Temporal: false, // only for temporal data\n\t        TemporalColumnName: '', // temporal attribute name\n\t        ZeroDate: '01.01.2008', // 0 date string\n\t        TemporalPeriods: [], // temporal periods\n\t        TemporalTiles: [], // temporal tiles array\n\t        TemporalVers: [], // temporal version array\n\t        hostName: 'maps.kosmosnimki.ru', // default hostName\n\t        sessionKey: '', // session key\n\t        isGeneralized: false, // flag for use generalized tiles\n\t        isFlatten: false // flag for flatten geometry\n\t    },\n\t\n\t    setOptions: function setOptions(options) {\n\t        this._clearProcessing();\n\t        if (options.GeoProcessing) {\n\t            this.processingTile = this.addData([]);\n\t            this._chkProcessing(options.GeoProcessing);\n\t        }\n\t        L.setOptions(this, options);\n\t        this.optionsLink = options;\n\t\n\t        this._isTemporalLayer = this.options.Temporal;\n\t\n\t        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\n\t        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\n\t        var hostName = this.options.hostName,\n\t            sessionKey = this.options.sessionKey;\n\t        if (!sessionKey) {\n\t            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\n\t        }\n\t        this.tileSenderPrefix = 'http://' + hostName + '/' + 'TileSender.ashx?WrapStyle=None' + '&key=' + encodeURIComponent(sessionKey);\n\t\n\t        this._needCheckActiveTiles = true;\n\t    },\n\t\n\t    _vectorTileDataProviderLoad: function _vectorTileDataProviderLoad(x, y, z, v, s, d, callback) {\n\t        var _this = this;\n\t        _VectorTileLoader.gmxVectorTileLoader.load(_this.tileSenderPrefix, { x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name }).then(callback, function () {\n\t            console.log('Error loading vector tile');\n\t            callback([]);\n\t            _this.fire('chkLayerUpdate', { dataProvider: _this }); //TODO: do we really need event here?\n\t        });\n\t    },\n\t\n\t    initialize: function initialize(options, clearVersion) {\n\t        this._tilesTree = null;\n\t        this._activeTileKeys = {};\n\t        this._endDate = null;\n\t        this._beginDate = null;\n\t\n\t        this._tiles = {};\n\t        this._filters = {};\n\t        this._freeSubscrID = 0;\n\t        this._items = {};\n\t        this._observers = {};\n\t\n\t        this._needCheckDateInterval = false;\n\t        this._needCheckActiveTiles = true;\n\t\n\t        var _this = this;\n\t        this._vectorTileDataProvider = {\n\t            load: this._vectorTileDataProviderLoad.bind(this)\n\t        };\n\t\n\t        this._observerTileLoader = new ObserverTileLoader(this);\n\t        this._observerTileLoader.on('tileload', function (event) {\n\t            var tile = event.tile;\n\t            _this._updateItemsFromTile(tile);\n\t\n\t            if (_this._tilesTree) {\n\t                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\n\t                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\n\t            }\n\t        });\n\t\n\t        this._observerTileLoader.on('observertileload', function (event) {\n\t            var observer = event.observer;\n\t            if (observer.isActive()) {\n\t                observer.needRefresh = false;\n\t                observer.updateData(_this.getItems(observer.id));\n\t            }\n\t        });\n\t        this.setOptions(options);\n\t        if (clearVersion) {\n\t            this.options.LayerVersion = -1;\n\t        }\n\t        if (this._isTemporalLayer) {\n\t            this.addFilter('TemporalFilter', function (item, tile, observer) {\n\t                var unixTimeStamp = item.options.unixTimeStamp,\n\t                    dates = observer.dateInterval;\n\t                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\n\t            });\n\t        }\n\t    },\n\t\n\t    _getActiveTileKeys: function _getActiveTileKeys() {\n\t\n\t        this._chkMaxDateInterval();\n\t        if (!this._needCheckActiveTiles) {\n\t            return this._activeTileKeys;\n\t        }\n\t\n\t        this._needCheckActiveTiles = false;\n\t\n\t        if (this._isTemporalLayer) {\n\t            var newTileKeys = {};\n\t            if (this._beginDate && this._endDate) {\n\t                if (!this._tilesTree) {\n\t                    this.initTilesTree();\n\t                }\n\t\n\t                /*var commonBounds = L.gmxUtil.bounds();\r\n\t                for (var obs in this._observers) {\r\n\t                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n\t                }*/\n\t\n\t                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\n\t            }\n\t            this._updateActiveTilesList(newTileKeys);\n\t        } else {\n\t            this.initTilesList();\n\t        }\n\t\n\t        return this._activeTileKeys;\n\t    },\n\t\n\t    _getObserversByFilterName: function _getObserversByFilterName(filterName) {\n\t        var oKeys = {};\n\t        for (var id in this._observers) {\n\t            if (this._observers[id].hasFilter(filterName)) {\n\t                oKeys[id] = true;\n\t            }\n\t        }\n\t        return oKeys;\n\t    },\n\t\n\t    addFilter: function addFilter(filterName, filterFunc) {\n\t        this._filters[filterName] = filterFunc;\n\t        this._triggerObservers(this._getObserversByFilterName(filterName));\n\t    },\n\t\n\t    removeFilter: function removeFilter(filterName) {\n\t        if (this._filters[filterName]) {\n\t            var oKeys = this._getObserversByFilterName(filterName);\n\t            delete this._filters[filterName];\n\t            this._triggerObservers(oKeys);\n\t        }\n\t    },\n\t\n\t    getItems: function getItems(oId) {\n\t        var resItems = [],\n\t            observer = this._observers[oId];\n\t\n\t        if (!observer) {\n\t            return [];\n\t        }\n\t\n\t        //add internal filters\n\t        var filters = observer.filters.concat('processingFilter');\n\t        this._isTemporalLayer && filters.push('TemporalFilter');\n\t\n\t        filters = filters.filter(function (filter) {\n\t            return filter in this._filters;\n\t        }.bind(this));\n\t\n\t        var _this = this,\n\t            putData = function putData(tile) {\n\t            var data = tile.data;\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var dataOption = tile.dataOptions[i];\n\t                if (!observer.intersects(dataOption.bounds)) {\n\t                    continue;\n\t                }\n\t\n\t                var it = data[i],\n\t                    id = it[0],\n\t                    item = _this.getItem(id);\n\t\n\t                var geom = it[it.length - 1],\n\t                    isFiltered = false;\n\t\n\t                for (var f = 0; f < filters.length; f++) {\n\t                    var filterFunc = _this._filters[filters[f]];\n\t                    if (!filterFunc(item, tile, observer, geom, dataOption)) {\n\t                        isFiltered = true;\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (!isFiltered) {\n\t                    resItems.push({\n\t                        id: id,\n\t                        properties: it,\n\t                        item: item,\n\t                        dataOption: dataOption,\n\t                        tileKey: tile.vectorTileKey\n\t                    });\n\t                }\n\t            }\n\t        };\n\t        var activeTileKeys = this._getActiveTileKeys();\n\t        for (var tkey in activeTileKeys) {\n\t            var tile = _this._tiles[tkey].tile;\n\t            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\n\t                putData(tile);\n\t            }\n\t        }\n\t\n\t        return resItems;\n\t    },\n\t\n\t    _updateItemsFromTile: function _updateItemsFromTile(tile) {\n\t        var vectorTileKey = tile.vectorTileKey,\n\t            data = tile.data || [],\n\t            len = data.length,\n\t            geomIndex = data[0] && data[0].length - 1;\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            var it = data[i],\n\t                geom = it[geomIndex],\n\t                id = it[0],\n\t                item = this._items[id];\n\t            if (item) {\n\t                if (!item.processing) {\n\t                    item.properties = it;\n\t                    if (item.type.indexOf('MULTI') === -1) {\n\t                        item.type = 'MULTI' + item.type;\n\t                    }\n\t                } else {\n\t                    tile.data[i] = item.properties;\n\t                }\n\t                delete item.bounds;\n\t                item.currentFilter = null;\n\t            } else {\n\t                item = {\n\t                    id: id,\n\t                    type: geom.type,\n\t                    properties: it,\n\t                    options: {\n\t                        fromTiles: {}\n\t                    }\n\t                };\n\t                this._items[id] = item;\n\t            }\n\t            item.options.fromTiles[vectorTileKey] = i;\n\t            if (tile.isGeneralized) {\n\t                item.options.isGeneralized = true;\n\t            }\n\t\n\t            if (this.options.TemporalColumnName) {\n\t                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\n\t                item.options.unixTimeStamp = zn * 1000;\n\t            }\n\t        }\n\t        return len;\n\t    },\n\t\n\t    getMaxDateInterval: function getMaxDateInterval() {\n\t        this._chkMaxDateInterval();\n\t        return {\n\t            beginDate: this._beginDate,\n\t            endDate: this._endDate\n\t        };\n\t    },\n\t\n\t    _chkMaxDateInterval: function _chkMaxDateInterval() {\n\t        if (this._isTemporalLayer && this._needCheckDateInterval) {\n\t            this._needCheckDateInterval = false;\n\t            var observers = this._observers,\n\t                newBeginDate = null,\n\t                newEndDate = null;\n\t            for (var oId in observers) {\n\t                var observer = observers[oId],\n\t                    dateInterval = observer.dateInterval;\n\t\n\t                if (!dateInterval) {\n\t                    continue;\n\t                }\n\t\n\t                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\n\t                    newBeginDate = dateInterval.beginDate;\n\t                }\n\t\n\t                if (!newEndDate || dateInterval.endDate > newEndDate) {\n\t                    newEndDate = dateInterval.endDate;\n\t                }\n\t            }\n\t            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\n\t                this._beginDate = newBeginDate;\n\t                this._endDate = newEndDate;\n\t                this._needCheckActiveTiles = true;\n\t            }\n\t        }\n\t    },\n\t\n\t    addObserver: function addObserver(options, id) {\n\t        id = id || 's' + ++this._freeSubscrID;\n\t        var _this = this,\n\t            observer = L.gmx.observer(options);\n\t\n\t        observer.id = id;\n\t        observer.needRefresh = true;\n\t        this._observerTileLoader.addObserver(observer);\n\t\n\t        observer.on('update', function (ev) {\n\t            observer.needRefresh = true;\n\t            if (ev.temporalFilter) {\n\t                _this._needCheckDateInterval = true;\n\t            }\n\t\n\t            _this._waitCheckObservers();\n\t        }).on('activate', function () {\n\t            _this.fire('observeractivate');\n\t            _this.checkObserver(observer);\n\t        });\n\t\n\t        _this._needCheckDateInterval = true;\n\t        this._observers[id] = observer;\n\t        this._waitCheckObservers();\n\t\n\t        if (observer.isActive()) {\n\t            this.fire('observeractivate');\n\t        }\n\t\n\t        return observer;\n\t    },\n\t\n\t    getActiveObserversCount: function getActiveObserversCount() {\n\t        var count = 0;\n\t        for (var k in this._observers) {\n\t            if (this._observers[k].isActive()) {\n\t                count++;\n\t            }\n\t        }\n\t        return count;\n\t    },\n\t\n\t    getObserver: function getObserver(id) {\n\t        return this._observers[id];\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        if (this._observers[id]) {\n\t            this._observerTileLoader.removeObserver(id);\n\t            var isActive = this._observers[id].isActive();\n\t\n\t            delete this._observers[id];\n\t\n\t            if (isActive) {\n\t                this.fire('observeractivate');\n\t            }\n\t        }\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerTileLoader.getObserverLoadingState(observer);\n\t    },\n\t\n\t    getItemsBounds: function getItemsBounds() {\n\t        if (!this._itemsBounds) {\n\t            this._itemsBounds = _Utils.gmxAPIutils.bounds();\n\t            for (var id in this._items) {\n\t                var item = this.getItem(id);\n\t                this._itemsBounds.extendBounds(item.bounds);\n\t            }\n\t        }\n\t        return this._itemsBounds;\n\t    },\n\t\n\t    //combine and return all parts of geometry\n\t    getItem: function getItem(id) {\n\t        var item = this._items[id];\n\t        if (item && !item.bounds) {\n\t            var fromTiles = item.options.fromTiles,\n\t                arr = [];\n\t            for (var key in fromTiles) {\n\t                // get full object bounds\n\t                if (this._tiles[key]) {\n\t                    var num = fromTiles[key],\n\t                        tile = this._tiles[key].tile;\n\t                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\n\t                        arr.push(tile.dataOptions[num].bounds);\n\t                    } else {\n\t                        delete fromTiles[key];\n\t                    }\n\t                }\n\t            }\n\t            if (arr.length === 1) {\n\t                item.bounds = arr[0];\n\t            } else {\n\t                item.bounds = _Utils.gmxAPIutils.bounds();\n\t                var w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var it = arr[i];\n\t                    if (item.bounds.max.x - it.min.x > w) {\n\t                        it = _Utils.gmxAPIutils.bounds([[it.min.x + 2 * w, it.min.y], [it.max.x + 2 * w, it.max.y]]);\n\t                    }\n\t                    item.bounds.extendBounds(it);\n\t                }\n\t            }\n\t        }\n\t        return item;\n\t    },\n\t\n\t    getItemMembers: function getItemMembers(id) {\n\t        var fromTiles = this._items[id].options.fromTiles,\n\t            members = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key]) {\n\t                var tile = this._tiles[key].tile;\n\t                if (tile.data) {\n\t                    var objIndex = fromTiles[key],\n\t                        props = tile.data[objIndex],\n\t                        dataOption = tile.dataOptions[objIndex],\n\t                        bbox = dataOption.bounds;\n\t\n\t                    members.push({\n\t                        geo: props[props.length - 1],\n\t                        width: bbox.max.x - bbox.min.x,\n\t                        dataOption: dataOption\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        return members.sort(function (a, b) {\n\t            return b.width - a.width;\n\t        });\n\t    },\n\t\n\t    getItemGeometries: function getItemGeometries(id) {\n\t        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\n\t            geomItems = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key] && this._tiles[key].tile.data) {\n\t                var tileData = this._tiles[key].tile.data,\n\t                    props = tileData[fromTiles[key]];\n\t\n\t                geomItems.push(_Utils.gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\n\t            }\n\t        }\n\t        return geomItems;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        this._tiles[tile.vectorTileKey] = { tile: tile };\n\t        this._getActiveTileKeys()[tile.vectorTileKey] = true;\n\t        this._observerTileLoader.addTile(tile);\n\t        this.checkObservers();\n\t    },\n\t\n\t    checkObserver: function checkObserver(observer) {\n\t        if (observer.needRefresh && observer.isActive()) {\n\t            this._observerTileLoader.startLoadTiles(observer);\n\t        }\n\t    },\n\t\n\t    checkObservers: function checkObservers() {\n\t        var observers = this._observers;\n\t        for (var id in this._observers) {\n\t            this.checkObserver(observers[id]);\n\t        }\n\t    },\n\t\n\t    _waitCheckObservers: function _waitCheckObservers() {\n\t        //TODO: refactor\n\t        if (this._checkObserversTimer) {\n\t            clearTimeout(this._checkObserversTimer);\n\t        }\n\t\n\t        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\n\t    },\n\t\n\t    _triggerObservers: function _triggerObservers(oKeys) {\n\t        var keys = oKeys || this._observers;\n\t\n\t        for (var id in keys) {\n\t            if (this._observers[id]) {\n\t                this._observers[id].needRefresh = true;\n\t            }\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    _removeDataFromObservers: function _removeDataFromObservers(data) {\n\t        var keys = this._observers;\n\t        for (var id in keys) {\n\t            this._observers[id].removeData(data);\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    preloadTiles: function preloadTiles(dateBegin, dateEnd, bounds) {\n\t        var tileKeys = {};\n\t        if (this._isTemporalLayer) {\n\t            if (!this._tilesTree) {\n\t                this.initTilesTree();\n\t            }\n\t            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\n\t        } else {\n\t            this._needCheckActiveTiles = true;\n\t            tileKeys = this._getActiveTileKeys();\n\t        }\n\t\n\t        var loadingDefs = [];\n\t        for (var key in tileKeys) {\n\t            var tile = this._getVectorTile(key, true).tile;\n\t\n\t            if (tile.state !== 'notLoaded') {\n\t                continue;\n\t            }\n\t\n\t            if (bounds && !bounds.intersects(tile.bounds)) {\n\t                continue;\n\t            }\n\t\n\t            var loadDef = tile.load();\n\t            loadingDefs.push(loadDef);\n\t        }\n\t\n\t        return Deferred.all.apply(null, loadingDefs);\n\t    },\n\t\n\t    _updateActiveTilesList: function _updateActiveTilesList(newTilesList) {\n\t\n\t        if (this._tileFilteringHook) {\n\t            var filteredTilesList = {};\n\t            for (var tk in newTilesList) {\n\t                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\n\t                    filteredTilesList[tk] = true;\n\t                }\n\t            }\n\t            newTilesList = filteredTilesList;\n\t        }\n\t\n\t        var oldTilesList = this._activeTileKeys || {};\n\t\n\t        var observersToUpdate = {},\n\t            _this = this,\n\t            key;\n\t\n\t        if (this.processingTile) {\n\t            newTilesList[this.processingTile.vectorTileKey] = true;\n\t        }\n\t        if (this._rasterVectorTile) {\n\t            key = this._rasterVectorTile.vectorTileKey;\n\t            newTilesList[key] = true;\n\t            this._tiles[key] = { tile: this._rasterVectorTile };\n\t        }\n\t\n\t        var checkSubscription = function checkSubscription(vKey) {\n\t            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\n\t            for (var sid in observerIds) {\n\t                observersToUpdate[sid] = true;\n\t            }\n\t        };\n\t\n\t        for (key in newTilesList) {\n\t            if (!oldTilesList[key]) {\n\t                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\n\t                checkSubscription(key);\n\t            }\n\t        }\n\t\n\t        for (key in oldTilesList) {\n\t            if (!newTilesList[key]) {\n\t                checkSubscription(key);\n\t                this._observerTileLoader.removeTile(key);\n\t            }\n\t        }\n\t\n\t        this._activeTileKeys = newTilesList;\n\t\n\t        this._triggerObservers(observersToUpdate);\n\t    },\n\t\n\t    _propertiesToArray: function _propertiesToArray(it) {\n\t        var prop = it.properties,\n\t            indexes = this.tileAttributeIndexes,\n\t            arr = [];\n\t\n\t        for (var key in indexes) {\n\t            arr[indexes[key]] = prop[key];\n\t        }arr[arr.length] = it.geometry;\n\t        arr[0] = it.id;\n\t        return arr;\n\t    },\n\t\n\t    _clearProcessing: function _clearProcessing() {\n\t        if (this.processingTile) {\n\t            var _items = this._items,\n\t                tile = this.processingTile,\n\t                vKey = tile.vectorTileKey,\n\t                data = tile.data || [];\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i][0];\n\t                if (_items[id]) {\n\t                    var item = _items[id];\n\t                    item.processing = null;\n\t                    item.currentFilter = null;\n\t                    delete item.options.fromTiles[vKey];\n\t                    delete item.fromServerProps;\n\t                    delete item.geometry;\n\t                }\n\t            }\n\t            tile.clear();\n\t        }\n\t    },\n\t\n\t    _chkProcessing: function _chkProcessing(processing) {\n\t        var _items = this._items,\n\t            needProcessingFilter = false,\n\t            skip = {},\n\t            id,\n\t            i,\n\t            len,\n\t            it,\n\t            data;\n\t\n\t        if (processing) {\n\t            if (processing.Deleted) {\n\t                for (i = 0, len = processing.Deleted.length; i < len; i++) {\n\t                    id = processing.Deleted[i];\n\t                    skip[id] = true;\n\t                    if (_items[id]) {\n\t                        _items[id].processing = true;\n\t                        _items[id].currentFilter = null;\n\t                    }\n\t                    if (len > 0) {\n\t                        needProcessingFilter = true;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var out = {};\n\t            if (processing.Inserted) {\n\t                for (i = 0, len = processing.Inserted.length; i < len; i++) {\n\t                    it = processing.Inserted[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (processing.Updated) {\n\t                for (i = 0, len = processing.Updated.length; i < len; i++) {\n\t                    it = processing.Updated[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t                if (!needProcessingFilter && len > 0) {\n\t                    needProcessingFilter = true;\n\t                }\n\t            }\n\t\n\t            data = [];\n\t            for (id in out) {\n\t                if (this._items[id]) {\n\t                    this._items[id].properties = out[id];\n\t                    this._items[id].processing = true;\n\t                    this._items[id].currentFilter = null;\n\t                }\n\t                data.push(out[id]);\n\t            }\n\t\n\t            if (data.length > 0) {\n\t                this.processingTile = this.addData(data);\n\t            }\n\t        }\n\t        if (needProcessingFilter) {\n\t            this.addFilter('processingFilter', function (item, tile) {\n\t                return tile.z === 0 || !item.processing;\n\t            });\n\t        } else {\n\t            this.removeFilter('processingFilter');\n\t        }\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    _resetTilesTree: function _resetTilesTree() {\n\t        this._tilesTree = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    updateVersion: function updateVersion(options) {\n\t        if (options) {\n\t            this.setOptions(options);\n\t        }\n\t        this._resetTilesTree();\n\t        // this.fire('versionchange');\n\t    },\n\t\n\t    _getDataKeys: function _getDataKeys(data) {\n\t        var chkKeys = {};\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            chkKeys[data[i][0]] = true;\n\t        }\n\t        return chkKeys;\n\t    },\n\t\n\t    _getProcessingTile: function _getProcessingTile() {\n\t        if (!this.processingTile) {\n\t            var x = -0.5,\n\t                y = -0.5,\n\t                z = 0,\n\t                v = 0,\n\t                s = -1,\n\t                d = -1,\n\t                isFlatten = this.options.isFlatten;\n\t\n\t            this.processingTile = new _VectorTile.VectorTile({ load: function load(x, y, z, v, s, d, callback) {\n\t                    callback([]);\n\t                } }, { x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten });\n\t\n\t            this.addTile(this.processingTile);\n\t        }\n\t        return this.processingTile;\n\t    },\n\t\n\t    addData: function addData(data) {\n\t        if (!data) {\n\t            data = [];\n\t        }\n\t        var vTile = this._getProcessingTile(),\n\t            chkKeys = this._getDataKeys(data),\n\t            dataBounds = vTile.addData(data, chkKeys);\n\t\n\t        if (this._itemsBounds) {\n\t            this._itemsBounds.extendBounds(dataBounds);\n\t        }\n\t        this._updateItemsFromTile(vTile);\n\t        this._triggerObservers();\n\t        return vTile;\n\t    },\n\t\n\t    removeData: function removeData(data) {\n\t        this._itemsBounds = null;\n\t        var vTile = this.processingTile;\n\t        if (vTile) {\n\t            var chkKeys = {};\n\t\n\t            if (!data || !data.length) {\n\t                return vTile;\n\t            }\n\t\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i];\n\t                chkKeys[id] = true;\n\t                delete this._items[id];\n\t            }\n\t            this._removeDataFromObservers(chkKeys);\n\t            vTile.removeData(chkKeys, true);\n\t            this._updateItemsFromTile(vTile);\n\t\n\t            this._triggerObservers();\n\t        }\n\t\n\t        return vTile;\n\t    },\n\t\n\t    initTilesTree: function initTilesTree() {\n\t        this._tilesTree = L.gmx.tilesTree(this.options);\n\t        this.options.TemporalTiles = this.options.TemporalVers = null;\n\t\n\t        if ('TemporalTiles' in this.optionsLink) {\n\t            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\n\t        }\n\t        this.dateZero = this._tilesTree.dateZero;\n\t        if (this.processingTile) {\n\t            this._tiles[this.processingTile.vectorTileKey] = {\n\t                tile: this.processingTile\n\t            };\n\t        }\n\t    },\n\t\n\t    _getVectorTile: function _getVectorTile(vKey, createFlag) {\n\t        if (!this._tiles[vKey] && createFlag) {\n\t            var info = _VectorTile.VectorTile.parseTileKey(vKey);\n\t            info.dateZero = this.dateZero;\n\t            this._addVectorTile(info);\n\t        }\n\t        return this._tiles[vKey];\n\t    },\n\t\n\t    _addVectorTile: function _addVectorTile(info) {\n\t        info.isFlatten = this.options.isFlatten;\n\t        var tile = new _VectorTile.VectorTile(this._vectorTileDataProvider, info),\n\t            vKey = tile.vectorTileKey;\n\t\n\t        this._tiles[vKey] = { tile: tile };\n\t        return vKey;\n\t    },\n\t\n\t    _getGeneralizedTileKeys: function _getGeneralizedTileKeys(vTilePoint) {\n\t        var dz = vTilePoint.z % 2 ? 1 : 2,\n\t            pz = Math.pow(2, dz),\n\t            z = vTilePoint.z - dz,\n\t            x = Math.floor(vTilePoint.x / pz),\n\t            y = Math.floor(vTilePoint.y / pz),\n\t            temp = { v: vTilePoint.v, s: -1, d: -1, isGeneralized: true },\n\t            keys = {};\n\t\n\t        while (z > 1) {\n\t            var gKey = [z, x, y].join('_');\n\t            keys[gKey] = L.extend({}, temp, { x: x, y: y, z: z });\n\t            z -= 2;\n\t            x = Math.floor(x / 4);\n\t            y = Math.floor(y / 4);\n\t        }\n\t        return keys;\n\t    },\n\t\n\t    initTilesList: function initTilesList() {\n\t        // For non temporal layers we create all Vector tiles\n\t        var newActiveTileKeys = {};\n\t        if (this.options.tiles) {\n\t            var arr = this.options.tiles || [],\n\t                vers = this.options.tilesVers,\n\t                generalizedKeys = this.options.isGeneralized ? {} : null,\n\t                newTiles = {},\n\t                gKey,\n\t                tKey,\n\t                info,\n\t                tHash;\n\t\n\t            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\n\t                info = {\n\t                    x: Number(arr[i]),\n\t                    y: Number(arr[i + 1]),\n\t                    z: Number(arr[i + 2]),\n\t                    v: Number(vers[cnt]),\n\t                    s: -1,\n\t                    d: -1\n\t                };\n\t\n\t                tHash = this._getVectorTile(_VectorTile.VectorTile.createTileKey(info), true);\n\t                tKey = tHash.tile.vectorTileKey;\n\t                newTiles[tKey] = tHash;\n\t                newActiveTileKeys[tKey] = true;\n\t                if (generalizedKeys) {\n\t                    var gKeys = this._getGeneralizedTileKeys(info);\n\t                    for (gKey in gKeys) {\n\t                        var gPoint = gKeys[gKey];\n\t                        if (generalizedKeys[gKey]) {\n\t                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\n\t                        } else {\n\t                            generalizedKeys[gKey] = gPoint;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if (generalizedKeys) {\n\t                for (gKey in generalizedKeys) {\n\t                    info = generalizedKeys[gKey];\n\t                    tKey = _VectorTile.VectorTile.createTileKey(info);\n\t                    if (!newTiles[tKey]) {\n\t                        if (!this._tiles[tKey]) {\n\t                            this._addVectorTile(info);\n\t                        }\n\t                        newTiles[tKey] = this._tiles[tKey];\n\t                        newActiveTileKeys[tKey] = true;\n\t                    }\n\t                }\n\t            }\n\t            this._tiles = newTiles;\n\t            if (this.processingTile) {\n\t                this._tiles[this.processingTile.vectorTileKey] = {\n\t                    tile: this.processingTile\n\t                };\n\t            }\n\t        }\n\t        this._updateActiveTilesList(newActiveTileKeys);\n\t    },\n\t\n\t    //Tile filtering hook filters out active vector tiles.\n\t    //Can be used to prevent loading data from some spatial-temporal region\n\t    setTileFilteringHook: function setTileFilteringHook(filteringHook) {\n\t        this._tileFilteringHook = filteringHook;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    removeTileFilteringHook: function removeTileFilteringHook() {\n\t        this._tileFilteringHook = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    }\n\t\n\t});\n\texports.DataManager = DataManager;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.VectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t//Single vector tile, received from GeoMixer server\n\t//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\n\t//      - {Object[]} data - information about vector objects in tile\n\t//      - {Number[4]} [bbox] - optional bbox of objects in tile\n\t//  options:\n\t//      x, y, z, v, s, d: GeoMixer vector tile point\n\t//      dateZero: zero Date for temporal layers\n\t//      isGeneralized: flag for generalized tile\n\tvar VectorTile = function VectorTile(dataProvider, options) {\n\t    this.dataProvider = dataProvider;\n\t    this.loadDef = new L.gmx.Deferred();\n\t    this.data = null;\n\t    this.dataOptions = null;\n\t\n\t    this.x = options.x;\n\t    this.y = options.y;\n\t    this.z = options.z;\n\t    this.v = options.v;\n\t    this.s = options.s || -1;\n\t    this.d = options.d || -1;\n\t    this.isGeneralized = options.isGeneralized;\n\t    this.isFlatten = options.isFlatten;\n\t    this.bounds = _Utils.gmxAPIutils.getTileBounds(this.x, this.y, this.z);\n\t    this.gmxTilePoint = { x: this.x, y: this.y, z: this.z, s: this.s, d: this.d };\n\t    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\n\t\n\t    if (this.s >= 0 && options.dateZero) {\n\t        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t    }\n\t\n\t    this.state = 'notLoaded'; //notLoaded, loading, loaded\n\t};\n\t\n\tVectorTile.prototype = {\n\t    addData: function addData(data, keys) {\n\t\n\t        if (keys) {\n\t            this.removeData(keys, true);\n\t        }\n\t\n\t        var len = data.length,\n\t            dataOptions = new Array(len),\n\t            dataBounds = _Utils.gmxAPIutils.bounds();\n\t        for (var i = 0; i < len; i++) {\n\t            var dataOption = this._parseItem(data[i]);\n\t            dataOptions[i] = dataOption;\n\t            dataBounds.extendBounds(dataOption.bounds);\n\t        }\n\t\n\t        if (!this.data) {\n\t            this.data = data;\n\t            this.dataOptions = dataOptions;\n\t        } else {\n\t            this.data = this.data.concat(data);\n\t            this.dataOptions = this.dataOptions.concat(dataOptions);\n\t        }\n\t\n\t        this.state = 'loaded';\n\t\n\t        this.loadDef.resolve(this.data);\n\t        return dataBounds;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\n\t            if (keys[arr[i][0]]) {\n\t                arr.splice(i, 1);\n\t                if (this.dataOptions) {\n\t                    this.dataOptions.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    load: function load() {\n\t        if (this.state === 'notLoaded') {\n\t            this.state = 'loading';\n\t            var _this = this;\n\t            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function (data, bbox) {\n\t                _this.bbox = bbox;\n\t                _this.addData(data);\n\t            });\n\t        }\n\t\n\t        return this.loadDef;\n\t    },\n\t\n\t    clear: function clear() {\n\t        this.state = 'notLoaded';\n\t        this.data = null;\n\t        this.dataOptions = null;\n\t\n\t        this.loadDef = new L.gmx.Deferred();\n\t    },\n\t\n\t    _parseItem: function _parseItem(it) {\n\t        var len = it.length,\n\t            i;\n\t\n\t        // TODO: old properties null = ''\n\t        for (i = 0; i < len; i++) {\n\t            if (it[i] === null) {\n\t                it[i] = '';\n\t            }\n\t        }\n\t\n\t        var geo = it[len - 1],\n\t            needFlatten = this.isFlatten,\n\t            type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates,\n\t            hiddenLines = [],\n\t            bounds = null,\n\t            boundsArr = [];\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            var edgeBounds = _Utils.gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\n\t                hiddenFlag = false;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr = [],\n\t                    hiddenLines1 = [];\n\t\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\n\t                        coords[i][j] = _Utils.gmxAPIutils.flattenRing(coords[i][j]);\n\t                    }\n\t                    var b = _Utils.gmxAPIutils.bounds(coords[i][j]);\n\t                    arr.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                    // EdgeLines calc\n\t                    var edgeArr = _Utils.gmxAPIutils.getHidden(coords[i][j], edgeBounds);\n\t                    hiddenLines1.push(edgeArr);\n\t                    if (edgeArr.length) {\n\t                        hiddenFlag = true;\n\t                    }\n\t                }\n\t                boundsArr.push(arr);\n\t                hiddenLines.push(hiddenLines1);\n\t            }\n\t            if (!hiddenFlag) {\n\t                hiddenLines = null;\n\t            }\n\t            if (isPolygon) {\n\t                boundsArr = boundsArr[0];\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = _Utils.gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds([coords[i]]));\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds(coords);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds(coords[i]));\n\t            }\n\t        }\n\t        var dataOption = {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t        if (hiddenLines) {\n\t            dataOption.hiddenLines = hiddenLines;\n\t        }\n\t        return dataOption;\n\t    }\n\t};\n\t//class methods\n\t\n\tVectorTile.makeTileKey = function (x, y, z, v, s, d) {\n\t    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\n\t};\n\t\n\tVectorTile.createTileKey = function (opt) {\n\t    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\n\t};\n\t\n\tVectorTile.parseTileKey = function (gmxTileKey) {\n\t    var p = gmxTileKey.split('_').map(function (it) {\n\t        return Number(it);\n\t    });\n\t    return { z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5] };\n\t};\n\t\n\tVectorTile.boundsFromTileKey = function (gmxTileKey) {\n\t    var p = VectorTile.parseTileKey(gmxTileKey);\n\t    return _Utils.gmxAPIutils.getTileBounds(p.x, p.y, p.z);\n\t};\n\texports.VectorTile = VectorTile;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.gmxVectorTileLoader = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxVectorTileLoader = {\n\t    _loadedTiles: {},\n\t    _getKey: function _getKey(ti) {\n\t        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\n\t    },\n\t    load: function load(tileSenderPrefix, tileInfo) {\n\t        var key = gmxVectorTileLoader._getKey(tileInfo);\n\t\n\t        if (!this._loadedTiles[key]) {\n\t            var def = new L.gmx.Deferred();\n\t            this._loadedTiles[key] = def;\n\t\n\t            var requestParams = {\n\t                ModeKey: 'tile',\n\t                r: 'j',\n\t                LayerName: tileInfo.layerID,\n\t                z: tileInfo.z,\n\t                x: tileInfo.x,\n\t                y: tileInfo.y,\n\t                v: tileInfo.v\n\t            };\n\t\n\t            if (tileInfo.d !== -1) {\n\t                requestParams.Level = tileInfo.d;\n\t                requestParams.Span = tileInfo.s;\n\t            }\n\t\n\t            _Utils.gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, { callbackParamName: null }).then(null, function () {\n\t                def.reject();\n\t            });\n\t        }\n\t\n\t        return this._loadedTiles[key];\n\t    }\n\t};\n\t\n\twindow.gmxAPI = window.gmxAPI || {};\n\twindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function (data) {\n\t    var key = gmxVectorTileLoader._getKey({\n\t        layerID: data.LayerName,\n\t        x: data.x,\n\t        y: data.y,\n\t        z: data.z,\n\t        d: data.level,\n\t        s: data.span,\n\t        v: data.v\n\t    });\n\t\n\t    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\n\t};\n\texports.gmxVectorTileLoader = gmxVectorTileLoader;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * gmxEventsManager - handlers manager\r\n\t */\n\tvar GmxEventsManager = L.Handler.extend({\n\t    options: {},\n\t\n\t    initialize: function initialize(map) {\n\t        this._map = map;\n\t        this._layers = {};\n\t        this._lastLayer = null;\n\t        this._lastId = null;\n\t        var _this = this;\n\t        this._drawstart = null;\n\t        this._lastCursor = '';\n\t\n\t        var isDrawing = function isDrawing() {\n\t            if (_this._drawstart) {\n\t                return true;\n\t            } else if (_this._drawstart === null) {\n\t                if (map.gmxControlsManager) {\n\t                    var drawingControl = map.gmxControlsManager.get('drawing');\n\t                    if (drawingControl) {\n\t                        drawingControl.on('activechange', function (ev) {\n\t                            _this._drawstart = ev.activeIcon;\n\t                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\n\t                        });\n\t                    }\n\t                }\n\t                _this._drawstart = false;\n\t            }\n\t            return false;\n\t        };\n\t\n\t        var getDomIndex = function getDomIndex(layer) {\n\t            var container = layer._container;\n\t            if (container) {\n\t                var arr = container.parentNode.childNodes;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    if (container === arr[i]) {\n\t                        return i;\n\t                    }\n\t                }\n\t            }\n\t            return 0;\n\t        };\n\t\n\t        var skipNodeName = {\n\t            IMG: true,\n\t            DIV: true,\n\t            path: true\n\t        };\n\t\n\t        var clearLastHover = function clearLastHover() {\n\t            if (_this._lastLayer) {\n\t                _this._lastLayer.gmxEventCheck({ type: 'mousemove' }, true);\n\t                _this._lastLayer = null;\n\t            }\n\t        };\n\t\n\t        var eventCheck = function eventCheck(ev) {\n\t            var type = ev.type,\n\t                map = _this._map,\n\t                skipNode = false;\n\t            if (ev.originalEvent) {\n\t                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\n\t                var target = ev.originalEvent.target;\n\t                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\n\t            }\n\t            if (map._animatingZoom || isDrawing() || skipNode || type === 'click' && map._skipClick || // from drawing\n\t            type === 'mousemove' && map.gmxMouseDown) {\n\t                clearLastHover();\n\t                map._skipClick = false;\n\t                return;\n\t            }\n\t            if (ev.layerPoint) {\n\t                map._gmxMouseLatLng = ev.latlng;\n\t                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\n\t            }\n\t\n\t            var arr = Object.keys(_this._layers).sort(function (a, b) {\n\t                var la = map._layers[a],\n\t                    lb = map._layers[b];\n\t                if (la && lb) {\n\t                    var oa = la.options,\n\t                        ob = lb.options,\n\t                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\n\t                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\n\t                        delta = zb - za;\n\t                    return delta ? delta : _this._layers[b] - _this._layers[a];\n\t                }\n\t                return 0;\n\t            });\n\t\n\t            var layer,\n\t                foundLayer = null,\n\t                cursor = '';\n\t\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var id = arr[i];\n\t                layer = map._layers[id];\n\t                if (layer && layer._map && !layer._animating && layer.options.clickable) {\n\t                    if (layer.gmxEventCheck(ev)) {\n\t                        if (layer.hasEventListeners('mouseover')) {\n\t                            cursor = 'pointer';\n\t                        }\n\t                        foundLayer = layer;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            if (_this._lastCursor !== cursor && !isDrawing()) {\n\t                map._container.style.cursor = cursor;\n\t            }\n\t            _this._lastCursor = cursor;\n\t\n\t            if (type !== 'zoomend') {\n\t                if (foundLayer) {\n\t                    if (_this._lastLayer !== foundLayer) {\n\t                        clearLastHover();\n\t                    }\n\t                    _this._lastLayer = foundLayer;\n\t                } else {\n\t                    clearLastHover();\n\t                }\n\t            }\n\t        };\n\t\n\t        map.on({\n\t            zoomend: function zoomend() {\n\t                if (map._gmxMouseLatLng) {\n\t                    setTimeout(function () {\n\t                        eventCheck({ type: 'mousemove', latlng: map._gmxMouseLatLng });\n\t                    }, 0);\n\t                }\n\t            },\n\t            click: eventCheck,\n\t            dblclick: eventCheck,\n\t            mousedown: eventCheck,\n\t            mouseup: eventCheck,\n\t            mousemove: eventCheck,\n\t            contextmenu: eventCheck,\n\t            layeradd: function layeradd(ev) {\n\t                var layer = ev.layer;\n\t                if ('gmxEventCheck' in layer && layer.options.clickable) {\n\t                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\n\t                }\n\t            },\n\t            layerremove: function layerremove(ev) {\n\t                var id = ev.layer._leaflet_id;\n\t                delete _this._layers[id];\n\t                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\n\t                    _this._lastLayer = null;\n\t                    _this._lastId = 0;\n\t                }\n\t            }\n\t        }, this);\n\t    }\n\t});\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if handler has already been initialized.\n\t    if (!this._gmxEventsManager) {\n\t        this._gmxEventsManager = new GmxEventsManager(this);\n\t        this.isGmxDrawing = function () {\n\t            return this._gmxEventsManager._drawstart;\n\t        };\n\t\n\t        this.on('remove', function () {\n\t            if (this._gmxEventsManager) {\n\t                this._gmxEventsManager.removeHooks();\n\t            }\n\t        });\n\t    }\n\t});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var DEFAULT_LANGUAGE = 'rus',\n\t        _setKeyText = function _setKeyText(lang, key, item, hash) {\n\t        if (!hash[lang]) {\n\t            hash[lang] = {};\n\t        }\n\t        hash[lang][key] = item;\n\t    };\n\t    L.gmxLocale = {\n\t\n\t        setLanguage: function setLanguage(lang) {\n\t            this._language = lang;\n\t        },\n\t\n\t        getLanguage: function getLanguage() {\n\t            return window.language || this._language || DEFAULT_LANGUAGE;\n\t        }\n\t    };\n\t\n\t    L.gmxLocaleMixin = {\n\t        addText: function addText() {\n\t            var lang = arguments[0],\n\t                newHash = arguments[1];\n\t            if (arguments.length === 1) {\n\t                newHash = lang;\n\t                lang = null;\n\t            }\n\t            for (var k in newHash) {\n\t                if (lang === null) {\n\t                    for (var k1 in newHash[k]) {\n\t                        _setKeyText(k, k1, newHash[k][k1], this);\n\t                    }\n\t                } else {\n\t                    _setKeyText(lang, k, newHash[k], this);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getText: function getText(key) {\n\t            var lang = L.gmxLocale.getLanguage(),\n\t                locale = this[lang] || {};\n\t\n\t            var keyArr = key ? key.split(/\\./) : [];\n\t            for (var i = 0, len = keyArr.length; i < len; i++) {\n\t                if (!locale) {\n\t                    break;\n\t                }\n\t                locale = locale[keyArr[i]];\n\t            }\n\t            return locale;\n\t        }\n\t    };\n\t    L.extend(L.gmxLocale, L.gmxLocaleMixin);\n\t})();\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    rus: {\n\t        Coordinates: 'Координаты',\n\t        Length: 'Длина',\n\t        nodeLength: 'Длина от начала',\n\t        edgeLength: 'Длина сегмента',\n\t        Area: 'Площадь',\n\t        Perimeter: 'Периметр',\n\t        units: {\n\t            m: 'м',\n\t            nm: 'м.мили',\n\t            km: 'км',\n\t            m2: 'кв. м',\n\t            km2: 'кв. км',\n\t            ha: 'га',\n\t            m2html: 'м<sup>2',\n\t            km2html: 'км<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    eng: {\n\t        Coordinates: 'Coordinates',\n\t        Length: 'Length',\n\t        nodeLength: 'From start point',\n\t        edgeLength: 'Segment length',\n\t        Area: 'Area',\n\t        Perimeter: 'Perimeter',\n\t        units: {\n\t            m: 'm',\n\t            nm: 'nmi',\n\t            km: 'km',\n\t            m2: 'sq. m',\n\t            km2: 'sq. km',\n\t            ha: 'ha',\n\t            m2html: 'm<sup>2',\n\t            km2html: 'km<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Observer = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar Observer = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    /* options : {\r\n\t            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n\t                                        // `update` - send only changed data\r\n\t            callback: Func,             // will be called when layer's data for this observer is changed\r\n\t            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n\t            bbox: bbox,                 // bbox to observe on Mercator\r\n\t            filters: [String]           // filter keys array\r\n\t            active: [Boolean=true]      // is this observer active\r\n\t            targetZoom: [Number]        // for zoom generalized type default(null)\r\n\t        }\r\n\t    */\n\t    initialize: function initialize(options) {\n\t        this.type = options.type || 'update';\n\t        this._callback = options.callback;\n\t        this._items = null;\n\t        this.bbox = options.bbox; // set bbox by Mercator bounds\n\t        this.filters = options.filters || [];\n\t        this.targetZoom = options.targetZoom || null;\n\t        this.active = 'active' in options ? options.active : true;\n\t\n\t        if (options.bounds) {\n\t            // set bbox by LatLngBounds\n\t            this.setBounds(options.bounds);\n\t        }\n\t\n\t        var w = _Utils.gmxAPIutils.worldWidthMerc,\n\t            dx;\n\t        if (!this.bbox) {\n\t            this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t            this.world = true;\n\t        } else if (this.bbox.max.x > w) {\n\t            dx = this.bbox.max.x - w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\n\t        } else if (this.bbox.min.x < -w) {\n\t            dx = this.bbox.min.x + w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\n\t        }\n\t\n\t        if (options.dateInterval) {\n\t            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\n\t        }\n\t    },\n\t\n\t    hasFilter: function hasFilter(filterName) {\n\t        for (var i = 0, len = this.filters.length; i < len; i++) {\n\t            if (this.filters[i] === filterName) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    activate: function activate() {\n\t        if (!this.active) {\n\t            this.active = true;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    deactivate: function deactivate() {\n\t        if (this.active) {\n\t            this.active = false;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    toggleActive: function toggleActive(isActive) {\n\t        return isActive ? this.activate() : this.deactivate();\n\t    },\n\t\n\t    isActive: function isActive() {\n\t        return this.active;\n\t    },\n\t\n\t    updateData: function updateData(data) {\n\t        var len = data.length,\n\t            out = { count: len };\n\t\n\t        if (this.type === 'update') {\n\t            //calculate difference with previous data\n\t            if (!this._items) {\n\t                this._items = {};\n\t            }\n\t            var prevItems = this._items,\n\t                newItems = {},\n\t                added = [],\n\t                removed = [],\n\t                key;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                var it = data[i];\n\t\n\t                key = it.id + '_' + it.tileKey;\n\t\n\t                newItems[key] = it;\n\t\n\t                if (!prevItems[key]) {\n\t                    added.push(it);\n\t                }\n\t            }\n\t\n\t            for (key in prevItems) {\n\t                if (!newItems[key]) {\n\t                    removed.push(prevItems[key]);\n\t                }\n\t            }\n\t\n\t            if (added.length) {\n\t                out.added = added;\n\t            }\n\t            if (removed.length) {\n\t                out.removed = removed;\n\t            }\n\t\n\t            this._items = newItems;\n\t        } else {\n\t            out.added = data;\n\t        }\n\t        this._callback(out);\n\t        out = null;\n\t        data = null;\n\t\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        if (this.type !== 'update' || !this._items) {\n\t            return this;\n\t        }\n\t\n\t        var items = this._items,\n\t            removed = [];\n\t\n\t        for (var id in keys) {\n\t            if (items[id]) {\n\t                removed.push(items[id]);\n\t                delete items[id];\n\t            }\n\t        }\n\t\n\t        if (removed.length) {\n\t            this._callback({ removed: removed });\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    /*setFilter: function (func) {\r\n\t        this._filters.userFilter = func;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },\r\n\t      removeFilter: function () {\r\n\t        delete this._filters.userFilter;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },*/\n\t\n\t    setBounds: function setBounds(bounds) {\n\t        var w;\n\t        if (!bounds) {\n\t            if (!this.world) {\n\t                w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t                this.bbox1 = null;\n\t                this.world = true;\n\t                this.fire('update');\n\t            }\n\t            return this;\n\t        }\n\t\n\t        var min = bounds.min,\n\t            max = bounds.max;\n\t        if (!min || !max) {\n\t            var latLngBounds = L.latLngBounds(bounds),\n\t                sw = latLngBounds.getSouthWest(),\n\t                ne = latLngBounds.getNorthEast();\n\t            min = { x: sw.lng, y: sw.lat };\n\t            max = { x: ne.lng, y: ne.lat };\n\t        }\n\t        var minX = min.x,\n\t            maxX = max.x,\n\t            minY = min.y,\n\t            maxY = max.y,\n\t            minX1 = null,\n\t            maxX1 = null;\n\t\n\t        this.world = false;\n\t        w = (maxX - minX) / 2;\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t            this.world = true;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        this.bbox1 = null;\n\t        if (minX1) {\n\t            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        }\n\t\n\t        this.fire('update');\n\t        return this;\n\t    },\n\t\n\t    intersects: function intersects(bounds) {\n\t        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\n\t    },\n\t\n\t    intersectsWithTile: function intersectsWithTile(tile) {\n\t        if (this.targetZoom) {\n\t            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\n\t            if (tile.isGeneralized && tile.z !== z || tile.z > z) {\n\t                return false;\n\t            }\n\t        }\n\t        var di = this.dateInterval;\n\t        return this.intersects(tile.bounds) && (!tile.beginDate || di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate);\n\t    },\n\t\n\t    _setDateInterval: function _setDateInterval(beginDate, endDate) {\n\t        if (beginDate && endDate) {\n\t            // var beginValue = beginDate.valueOf(),\n\t            // endValue = endDate.valueOf();\n\t            this.dateInterval = {\n\t                beginDate: beginDate,\n\t                endDate: endDate\n\t            };\n\t        } else {\n\t            this.dateInterval = null;\n\t        }\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var isValid = beginDate && endDate;\n\t\n\t        if (!this.dateInterval !== !isValid || isValid && (this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() || this.dateInterval.endDate.valueOf() !== endDate.valueOf())) {\n\t            this._setDateInterval(beginDate, endDate);\n\t            this.fire('update', { temporalFilter: true });\n\t        }\n\t        return this;\n\t    }\n\t}); //Single observer with vector data\n\texports.Observer = Observer;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    //tree for fast tiles selection inside temporal interval\n\t    //  options:\n\t    //      TemporalTiles: tilePoints array\n\t    //      TemporalVers: tiles version array\n\t    //      TemporalPeriods: periods\n\t    //      ZeroDate: start Date\n\t    var TilesTree = function TilesTree(options) {\n\t        var _rootNodes = [],\n\t            tiles = options.TemporalTiles || [],\n\t            vers = options.TemporalVers || [],\n\t            periods = options.TemporalPeriods || [],\n\t            maxPeriod = periods[periods.length - 1],\n\t            smin = Number.MAX_VALUE,\n\t            arr = options.ZeroDate.split('.'),\n\t            zn = new Date(arr.length > 2 ? arr[2] : 2008, arr.length > 1 ? arr[1] - 1 : 0, arr.length > 0 ? arr[0] : 1),\n\t            dateZero = new Date(zn.getTime() - zn.getTimezoneOffset() * 60000),\n\t            zeroUT = dateZero.getTime() / 1000;\n\t\n\t        this.dateZero = dateZero;\n\t\n\t        var addTile = function addTile(node, tile, key) {\n\t            var d = node.d;\n\t            if (tile.d === periods[d]) {\n\t                node.count++;\n\t                node.tiles.push(key);\n\t                return;\n\t            }\n\t\n\t            var pd = periods[d - 1],\n\t                childrenCount = periods[d] / pd;\n\t\n\t            if (!('children' in node)) {\n\t                node.children = new Array(childrenCount);\n\t            }\n\t\n\t            var sChild = Math.floor(tile.s * tile.d / pd),\n\t                ds = sChild - node.s * childrenCount;\n\t\n\t            if (!node.children[ds]) {\n\t                var pdOneDay = pd * gmxAPIutils.oneDay,\n\t                    t1 = sChild * pdOneDay + zeroUT;\n\t                node.children[ds] = {\n\t                    d: d - 1,\n\t                    s: sChild,\n\t                    t1: t1,\n\t                    t2: t1 + pdOneDay,\n\t                    count: 0,\n\t                    children: [],\n\t                    tiles: []\n\t                };\n\t            }\n\t\n\t            addTile(node.children[ds], tile, key);\n\t        };\n\t\n\t        var dmax = periods.length - 1,\n\t            dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\n\t            i,\n\t            len;\n\t\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var s = Number(arr[1]),\n\t                d = Number(arr[0]);\n\t\n\t            if (d === maxPeriod) {\n\t                smin = Math.min(smin, s);\n\t            }\n\t        }\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var t = {\n\t                x: Number(arr[2]),\n\t                y: Number(arr[3]),\n\t                z: Number(arr[4]),\n\t                v: Number(vers[i]),\n\t                s: Number(arr[1]),\n\t                d: Number(arr[0])\n\t            };\n\t            if (t.d < 0) {\n\t                continue;\n\t            }\n\t\n\t            var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\n\t                cs = ds + smin;\n\t\n\t            _rootNodes[ds] = _rootNodes[ds] || {\n\t                d: dmax,\n\t                s: cs,\n\t                t1: cs * dmaxOneDay + zeroUT,\n\t                t2: (cs + 1) * dmaxOneDay + zeroUT,\n\t                count: 0,\n\t                tiles: []\n\t            };\n\t            var key = VectorTile.createTileKey(t);\n\t\n\t            addTile(_rootNodes[ds], t, key);\n\t        }\n\t        tiles = vers = null;\n\t\n\t        //options: bounds (in mercator projection)\n\t        this.selectTiles = function (t1, t2, options) {\n\t\n\t            options = options || {};\n\t\n\t            var t1Val = t1.valueOf() / 1000,\n\t                t2Val = t2.valueOf() / 1000;\n\t\n\t            // We will restrict tile levels by the nearest two levels to target date interval length\n\t            // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\n\t            var minLevel = 0,\n\t                dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\n\t\n\t            for (var i = 0; i < periods.length; i++) {\n\t                if (periods[i] > dateIntervalLength) {\n\t                    minLevel = Math.max(0, i - 1);\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (periods[periods.length - 1] <= dateIntervalLength) {\n\t                minLevel = periods.length - 1;\n\t            }\n\t\n\t            var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\n\t\n\t            var getCountOfIntersected = function getCountOfIntersected(tileBounds, bounds) {\n\t                var count = 0;\n\t                for (var t = 0; t < tileBounds.length; t++) {\n\t                    if (tileBounds[t].intersects(bounds)) {\n\t                        count++;\n\t                    }\n\t                }\n\t\n\t                return count;\n\t            };\n\t\n\t            // --------------------\n\t            var selectTilesForNode = function selectTilesForNode(node, t1, t2) {\n\t                if (t1 >= node.t2 || t2 <= node.t1) {\n\t                    return { count: 0, tiles: [], nodes: [] };\n\t                }\n\t\n\t                if (options.bounds && !node.tileBounds) {\n\t                    node.tileBounds = node.tiles.map(function (it) {\n\t                        return VectorTile.boundsFromTileKey(it);\n\t                    });\n\t                }\n\t\n\t                if (node.d === minLevel) {\n\t                    var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: count,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t\n\t                var childrenCount = 0,\n\t\n\t                //number of tiles if we use shorter intervals\n\t                childrenRes = [],\n\t                    len = node.children ? node.children.length : 0,\n\t                    ds;\n\t\n\t                for (ds = 0; ds < len; ds++) {\n\t                    if (node.children[ds]) {\n\t                        childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\n\t                    } else {\n\t                        childrenRes[ds] = { count: 0, tiles: [], nodes: [] };\n\t                    }\n\t                    childrenCount += childrenRes[ds].count;\n\t                }\n\t\n\t                var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t\n\t                if (node.d > maxLevel || childrenCount < intersectCount) {\n\t                    var resTilesArr = [],\n\t                        resNodesArr = [];\n\t                    for (ds = 0; ds < childrenRes.length; ds++) {\n\t                        resNodesArr.push(childrenRes[ds].nodes);\n\t                        resTilesArr.push(childrenRes[ds].tiles);\n\t                    }\n\t\n\t                    return {\n\t                        tiles: [].concat.apply([], resTilesArr),\n\t                        count: childrenCount,\n\t                        nodes: [].concat.apply([], resNodesArr)\n\t                    };\n\t                } else {\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: intersectCount,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t            };\n\t\n\t            var resTiles = [];\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                if (_rootNodes[ds]) {\n\t                    var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\n\t                    if (nodeSelection.tiles.length) {\n\t                        resTiles = resTiles.concat(nodeSelection.tiles);\n\t                    }\n\t                }\n\t            }\n\t\n\t            var resTilesHash = {};\n\t            for (var t = 0; t < resTiles.length; t++) {\n\t                resTilesHash[resTiles[t]] = true;\n\t            }\n\t\n\t            return { tiles: resTilesHash };\n\t        };\n\t\n\t        this.getNode = function (d, s) {\n\t            if (d < 0 || s < 0) {\n\t                return null;\n\t            }\n\t\n\t            var findNode = function findNode(node, d, s) {\n\t                if (!node) {\n\t                    return null;\n\t                }\n\t\n\t                if (periods[node.d] === d) {\n\t                    return node.s === s ? node : null;\n\t                }\n\t\n\t                var childrenCount = periods[node.d] / periods[node.d - 1];\n\t                var sChild = Math.floor(s * d / periods[node.d - 1]);\n\t                var ds = sChild - node.s * childrenCount;\n\t\n\t                return node.children[ds] ? findNode(node.children[ds], d, s) : null;\n\t            };\n\t\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                var node = findNode(_rootNodes[ds], d, s);\n\t                if (node) {\n\t                    return node;\n\t                }\n\t            }\n\t\n\t            return null;\n\t        };\n\t    };\n\t    L.gmx.tilesTree = function (options) {\n\t        return new TilesTree(options);\n\t    };\n\t})();\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _StyleManager = __webpack_require__(19);\n\t\n\tvar _ScreenVectorTile = __webpack_require__(20);\n\t\n\tL.gmx.VectorLayer = L.TileLayer.Canvas.extend({\n\t    options: {\n\t        openPopups: [],\n\t        minZoom: 1,\n\t        zIndexOffset: 0,\n\t        isGeneralized: true,\n\t        isFlatten: false,\n\t        useWebGL: false,\n\t        clickable: true\n\t    },\n\t\n\t    initialize: function initialize(options) {\n\t        options = L.setOptions(this, options);\n\t\n\t        this.initPromise = new L.gmx.Deferred();\n\t\n\t        this._drawQueue = [];\n\t        this._drawQueueHash = {};\n\t\n\t        this._drawInProgress = {};\n\t\n\t        this._anyDrawings = false; //are we drawing something?\n\t        this.repaintObservers = {}; // external observers like screen\n\t\n\t        var _this = this;\n\t\n\t        this._gmx = {\n\t            hostName: _Utils.gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\n\t            mapName: options.mapID,\n\t            useWebGL: options.useWebGL,\n\t            layerID: options.layerID,\n\t            beginDate: options.beginDate,\n\t            endDate: options.endDate,\n\t            sortItems: options.sortItems || null,\n\t            styles: options.styles || [],\n\t            tileSubscriptions: {},\n\t            _tilesToLoad: 0,\n\t            shiftXlayer: 0,\n\t            shiftYlayer: 0,\n\t            renderHooks: [],\n\t            preRenderHooks: [],\n\t            _needPopups: {}\n\t        };\n\t        if (options.crossOrigin) {\n\t            this._gmx.crossOrigin = options.crossOrigin;\n\t        }\n\t\n\t        this.on('tileunload', function (e) {\n\t            _this._clearTileSubscription(e.tile.zKey);\n\t        });\n\t    },\n\t\n\t    // extended from L.TileLayer.Canvas\n\t    _removeTile: function _removeTile(zKey) {\n\t        var tileLink = this._tiles[zKey];\n\t        if (tileLink) {\n\t            var tile = tileLink.el;\n\t            if (tile && tile.parentNode) {\n\t                tile.parentNode.removeChild(tile);\n\t            }\n\t\n\t            delete this._tiles[zKey];\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\n\t            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\n\t        }\n\t        var gmx = this._gmx;\n\t\n\t        gmx.shiftY = 0;\n\t        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\n\t        gmx.currentZoom = map.getZoom();\n\t        gmx.styleManager.initStyles();\n\t\n\t        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\n\t\n\t        map.on('zoomstart', this._zoomStart, this);\n\t        map.on('zoomend', this._zoomEnd, this);\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.on('moveend', this._moveEnd, this);\n\t        }\n\t        if (this.options.clickable === false) {\n\t            this._container.style.pointerEvents = 'none';\n\t        }\n\t        if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        this.on('stylechange', this._onStyleChange, this);\n\t        this.on('versionchange', this._onVersionChange, this);\n\t\n\t        // this._zIndexOffsetCheck();\n\t        L.gmx.layersVersion.add(this);\n\t        this.fire('add');\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._container) {\n\t            this._container.parentNode.removeChild(this._container);\n\t        }\n\t\n\t        map.off({\n\t            'viewreset': this._reset,\n\t            'moveend': this._update\n\t        }, this);\n\t\n\t        if (this._animated) {\n\t            map.off({\n\t                'zoomanim': this._animateZoom,\n\t                'zoomend': this._endZoomAnim\n\t            }, this);\n\t        }\n\t\n\t        if (!this.options.updateWhenIdle) {\n\t            map.off('move', this._limitedUpdate, this);\n\t        }\n\t        this._container = null;\n\t        this._map = null;\n\t\n\t        this._clearAllSubscriptions();\n\t        map.off('zoomstart', this._zoomStart, this);\n\t        map.off('zoomend', this._zoomEnd, this);\n\t        this.off('stylechange', this._onStyleChange, this);\n\t\n\t        var gmx = this._gmx;\n\t\n\t        delete gmx.map;\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.off('moveend', this._moveEnd, this);\n\t        }\n\t        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\n\t            L.gmx.layersVersion.remove(this);\n\t        }\n\t        this.fire('remove');\n\t    },\n\t\n\t    _initContainer: function _initContainer() {\n\t        L.TileLayer.Canvas.prototype._initContainer.call(this);\n\t        this._prpZoomData();\n\t        this.setZIndexOffset();\n\t    },\n\t\n\t    _updateZIndex: function _updateZIndex() {\n\t        if (this._container) {\n\t            var options = this.options,\n\t                zIndex = options.zIndex || 0,\n\t                zIndexOffset = options.zIndexOffset || 0;\n\t\n\t            this._container.style.zIndex = zIndexOffset + zIndex;\n\t        }\n\t    },\n\t\n\t    _update: function _update() {\n\t        if (!this._map || this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\n\t        ) {\n\t                this._clearAllSubscriptions();\n\t                return;\n\t            }\n\t        this._gmx.styleManager.deferred.then(this.__update.bind(this));\n\t    },\n\t\n\t    _addTile: function _addTile(tilePoint) {\n\t        var myLayer = this,\n\t            zoom = this._map._zoom,\n\t            gmx = this._gmx;\n\t\n\t        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\n\t            this._tileLoaded();\n\t            return;\n\t        }\n\t\n\t        var zKey = this._tileCoordsToKey(tilePoint, zoom);\n\t        if (!gmx.tileSubscriptions[zKey]) {\n\t            gmx._tilesToLoad++;\n\t            var isDrawnFirstTime = false,\n\t                gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\n\t                done = function done() {\n\t                if (!isDrawnFirstTime) {\n\t                    gmx._tilesToLoad--;\n\t                    myLayer._tileLoaded();\n\t                    isDrawnFirstTime = true;\n\t                }\n\t            },\n\t                attr = {\n\t                type: 'resend',\n\t                active: false,\n\t                bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                callback: function callback(data) {\n\t                    myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\n\t                }\n\t            };\n\t            if (this.options.isGeneralized) {\n\t                attr.targetZoom = zoom;\n\t            }\n\t            if (gmx.layerType === 'VectorTemporal') {\n\t                attr.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t\n\t            var observer = gmx.dataManager.addObserver(attr, zKey);\n\t            observer.on('activate', function () {\n\t                //if observer is deactivated before drawing,\n\t                //we can consider corresponding tile as already drawn\n\t                if (!observer.isActive()) {\n\t                    done();\n\t                }\n\t            });\n\t\n\t            observer.on('startLoadingTiles', this._chkDrawingState, this);\n\t\n\t            gmx.tileSubscriptions[zKey] = {\n\t                z: zoom,\n\t                x: tilePoint.x,\n\t                y: tilePoint.y,\n\t                px: 256 * gmxTilePoint.x,\n\t                py: 256 * (1 + gmxTilePoint.y)\n\t            };\n\t            observer.activate();\n\t        }\n\t    },\n\t\n\t    _chkDrawingState: function _chkDrawingState() {\n\t        var gmx = this._gmx,\n\t            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\n\t\n\t        if (!isDrawing) {\n\t            for (var key in gmx.tileSubscriptions) {\n\t                var observer = gmx.dataManager.getObserver(key);\n\t                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\n\t                    isDrawing = true;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (!isDrawing && this._anyDrawings) {\n\t            this.fire('doneDraw');\n\t        } else if (isDrawing && !this._anyDrawings) {\n\t            this.fire('startDraw');\n\t        }\n\t\n\t        this._anyDrawings = isDrawing;\n\t    },\n\t\n\t    _getLoadedTilesPercentage: function _getLoadedTilesPercentage(container) {\n\t        if (!container) {\n\t            return 0;\n\t        }\n\t        var len = 0,\n\t            count = 0;\n\t        var arr = ['img', 'canvas'];\n\t        for (var key in arr) {\n\t            var tiles = container.getElementsByTagName(arr[key]);\n\t            if (tiles && tiles.length > 0) {\n\t                len += tiles.length;\n\t                for (var i = 0, len1 = tiles.length; i < len1; i++) {\n\t                    if (tiles[i]._tileComplete) {\n\t                        count++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (len < 1) {\n\t            return 0;\n\t        }\n\t        return count / len;\n\t    },\n\t\n\t    _tileLoaded: function _tileLoaded() {\n\t        if (this._animated) {\n\t            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\n\t        }\n\t        if (this._gmx._tilesToLoad === 0) {\n\t            this.fire('load');\n\t\n\t            if (this._animated) {\n\t                // clear scaled tiles after all new tiles are loaded (for performance)\n\t                this._setClearBgBuffer(0);\n\t            }\n\t        }\n\t    },\n\t\n\t    _tileOnLoad: function _tileOnLoad(tile) {\n\t        if (tile) {\n\t            L.DomUtil.addClass(tile, 'leaflet-tile-loaded');\n\t        }\n\t        this._tileLoaded();\n\t    },\n\t\n\t    _tileOnError: function _tileOnError() {},\n\t\n\t    tileDrawn: function tileDrawn(tile) {\n\t        this._tileOnLoad(tile);\n\t    },\n\t\n\t    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\n\t    // converts tile coordinates to key for the tile cache\n\t    _tileCoordsToKey: function _tileCoordsToKey(coords, zoom) {\n\t        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\n\t    },\n\t\n\t    _getTiledPixelBounds: function _getTiledPixelBounds(center) {\n\t        var map = this._map,\n\t            gmx = this._gmx,\n\t            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\n\t            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\n\t            halfSize = map.getSize().divideBy(2);\n\t\n\t        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n\t    },\n\t\n\t    _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {\n\t        var tileSize = this.options.tileSize;\n\t        return new L.Bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._round());\n\t    },\n\t\n\t    // original for L.gmx.VectorLayer\n\t\n\t    //public interface\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var gmx = this._gmx;\n\t\n\t        gmx.properties = ph.properties;\n\t        gmx.geometry = ph.geometry;\n\t\n\t        if (gmx.properties._initDone) {\n\t            // need delete tiles key\n\t            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\n\t        }\n\t        gmx.properties._initDone = true;\n\t\n\t        if (!gmx.geometry) {\n\t            var worldSize = _Utils.gmxAPIutils.tileSizes[1];\n\t            gmx.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        // Original properties from the server.\n\t        // Descendant classes can override this property\n\t        // Not so good solution, but it works\n\t        gmx.rawProperties = ph.rawProperties || ph.properties;\n\t\n\t        this._updateProperties(ph.properties);\n\t\n\t        ph.properties.isGeneralized = this.options.isGeneralized;\n\t        ph.properties.isFlatten = this.options.isFlatten;\n\t\n\t        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\n\t\n\t        if (this.options.parentOptions) {\n\t            if (!ph.properties.styles) {\n\t                ph.properties.styles = this.options.parentOptions.styles;\n\t            }\n\t            gmx.dataManager.on('versionchange', this._onVersionChange, this);\n\t        }\n\t\n\t        gmx.styleManager = new _StyleManager.StyleManager(gmx);\n\t        this.options.minZoom = gmx.styleManager.minZoom;\n\t        this.options.maxZoom = gmx.styleManager.maxZoom;\n\t\n\t        gmx.dataManager.on('observeractivate', function () {\n\t            if (gmx.dataManager.getActiveObserversCount()) {\n\t                L.gmx.layersVersion.add(this);\n\t            } else {\n\t                L.gmx.layersVersion.remove(this);\n\t            }\n\t        }, this);\n\t\n\t        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\n\t            this.options.chkUpdate = true; //Check updates for vector layers by default\n\t        }\n\t        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\n\t            this._objectsReorderInit(this);\n\t        }\n\t\n\t        if (gmx.clusters) {\n\t            this.bindClusters(JSON.parse(gmx.clusters));\n\t        }\n\t        if (gmx.filter) {\n\t            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (func) {\n\t                gmx.dataManager.addFilter('userFilter_' + gmx.layerID, function (item) {\n\t                    return gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\n\t                }.bind(this));\n\t            }\n\t        }\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\n\t        }\n\t\n\t        this.initPromise.resolve();\n\t        return this;\n\t    },\n\t\n\t    getDataManager: function getDataManager() {\n\t        return this._gmx.dataManager;\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.enableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.disableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    setRasterOpacity: function setRasterOpacity(opacity) {\n\t        var _this = this;\n\t        if (this._gmx.rasterOpacity !== opacity) {\n\t            this._gmx.rasterOpacity = opacity;\n\t            this.initPromise.then(function () {\n\t                _this.repaint();\n\t            });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        return this._gmx.styleManager.getStyles();\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        this._gmx.styleManager.getIcons(callback);\n\t        return this;\n\t    },\n\t\n\t    setStyles: function setStyles(styles) {\n\t        var _this = this;\n\t\n\t        this.initPromise.then(function () {\n\t            _this._gmx.styleManager.clearStyles();\n\t            if (styles) {\n\t                styles.forEach(function (it, i) {\n\t                    _this.setStyle(it, i, true);\n\t                });\n\t            } else {\n\t                _this.fire('stylechange');\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    getStyle: function getStyle(num) {\n\t        return this.getStyles()[num];\n\t    },\n\t\n\t    setStyle: function setStyle(style, num, createFlag) {\n\t        var _this = this,\n\t            gmx = this._gmx;\n\t        this.initPromise.then(function () {\n\t            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\n\t                _this.fire('stylechange', { num: num || 0 });\n\t            });\n\t        });\n\t        return this;\n\t    },\n\t\n\t    setStyleHook: function setStyleHook(func) {\n\t        this._gmx.styleHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeStyleHook: function removeStyleHook() {\n\t        this._gmx.styleHook = null;\n\t        return this;\n\t    },\n\t\n\t    setRasterHook: function setRasterHook(func) {\n\t        this._gmx.rasterProcessingHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeRasterHook: function removeRasterHook() {\n\t        this._gmx.rasterProcessingHook = null;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    setFilter: function setFilter(func) {\n\t        var gmx = this._gmx;\n\t        gmx.dataManager.addFilter('userFilter', function (item) {\n\t            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\n\t        }.bind(this));\n\t        return this;\n\t    },\n\t\n\t    removeFilter: function removeFilter() {\n\t        this._gmx.dataManager.removeFilter('userFilter');\n\t        return this;\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var gmx = this._gmx;\n\t\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            beginDate = gmx.dateBegin;\n\t            endDate = gmx.dateEnd;\n\t        }\n\t\n\t        //check that something changed\n\t        if (!gmx.beginDate !== !beginDate || !gmx.endDate !== !endDate || beginDate && gmx.beginDate.valueOf() !== beginDate.valueOf() || endDate && gmx.endDate.valueOf() !== endDate.valueOf()) {\n\t            if (gmx.rawProperties.maxShownPeriod && beginDate) {\n\t                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\n\t                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\n\t            }\n\t\n\t            gmx.beginDate = beginDate;\n\t            gmx.endDate = endDate;\n\t\n\t            var observer = null,\n\t                dataManager = gmx.dataManager;\n\t            for (var key in gmx.tileSubscriptions) {\n\t                observer = dataManager.getObserver(key);\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            observer = dataManager.getObserver('_Labels');\n\t            if (observer) {\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            if (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\n\t                gmx.properties.LayerVersion = -1;\n\t                dataManager.setOptions({ LayerVersion: -1 });\n\t                if (this._map) {\n\t                    L.gmx.layersVersion.now();\n\t                }\n\t            }\n\t            this.fire('dateIntervalChanged');\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getDateInterval: function getDateInterval() {\n\t        return {\n\t            beginDate: this._gmx.beginDate,\n\t            endDate: this._gmx.endDate\n\t        };\n\t    },\n\t\n\t    addObserver: function addObserver(options) {\n\t        return this._gmx.dataManager.addObserver(options);\n\t    },\n\t\n\t    removeObserver: function removeObserver(observer) {\n\t        return this._gmx.dataManager.removeObserver(observer.id);\n\t    },\n\t\n\t    setPositionOffset: function setPositionOffset(dx, dy) {\n\t        var gmx = this._gmx;\n\t        gmx.shiftXlayer = dx;\n\t        gmx.shiftYlayer = dy;\n\t        this._update();\n\t        return this;\n\t    },\n\t\n\t    getPositionOffset: function getPositionOffset() {\n\t        var gmx = this._gmx;\n\t        return { shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer };\n\t    },\n\t\n\t    setZIndexOffset: function setZIndexOffset(offset) {\n\t        if (arguments.length) {\n\t            this.options.zIndexOffset = offset;\n\t        }\n\t        this._updateZIndex();\n\t        return this;\n\t    },\n\t\n\t    repaint: function repaint(zKeys) {\n\t        if (this._map) {\n\t            if (!zKeys) {\n\t                zKeys = {};\n\t                for (var key in this._gmx.tileSubscriptions) {\n\t                    zKeys[key] = true;\n\t                }\n\t                L.extend(zKeys, this.repaintObservers);\n\t            }\n\t            this._gmx.dataManager._triggerObservers(zKeys);\n\t        }\n\t    },\n\t\n\t    redrawItem: function redrawItem(id) {\n\t        if (this._map) {\n\t            var item = this._gmx.dataManager.getItem(id),\n\t                gmxTiles = this._getTilesByBounds(item.bounds);\n\t\n\t            this.repaint(gmxTiles);\n\t        }\n\t    },\n\t\n\t    gmxGetCanvasTile: function gmxGetCanvasTile(tilePoint) {\n\t        var zKey = this._tileCoordsToKey(tilePoint);\n\t\n\t        if (zKey in this._tiles) {\n\t            return this._tiles[zKey];\n\t        }\n\t        // save tile in cache\n\t        var tile = this._getTile();\n\t        this._tiles[zKey] = {\n\t            el: tile,\n\t            coords: tilePoint,\n\t            current: true\n\t        };\n\t\n\t        // tile._zKey = zKey;\n\t        tile._zoom = this._map._zoom;\n\t        tile._tileComplete = true;\n\t        tile._tilePoint = tilePoint;\n\t        this.tileDrawn(tile);\n\t        return this._tiles[zKey];\n\t    },\n\t\n\t    appendTileToContainer: function appendTileToContainer(tile) {\n\t        this._tileContainer.appendChild(tile);\n\t        var tilePos = this._getTilePos(tile._tilePoint);\n\t        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\n\t    },\n\t\n\t    addData: function addData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.addData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.removeData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStylesByProperties: function getStylesByProperties(propArray, zoom) {\n\t        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\n\t    },\n\t\n\t    getItemStyle: function getItemStyle(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        return gmx.styleManager.getObjStyle(item);\n\t    },\n\t\n\t    getTileAttributeTypes: function getTileAttributeTypes() {\n\t        return this._gmx.tileAttributeTypes;\n\t    },\n\t\n\t    getTileAttributeIndexes: function getTileAttributeIndexes() {\n\t        return this._gmx.tileAttributeIndexes;\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id),\n\t            styles = this.getStyles(),\n\t            out = '';\n\t\n\t        if (item && styles[item.currentFilter]) {\n\t            var propsArr = item.properties;\n\t            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\n\t                properties: this.getItemProperties(propsArr),\n\t                geometries: [propsArr[propsArr.length - 1]],\n\t                tileAttributeTypes: gmx.tileAttributeTypes,\n\t                unitOptions: this._map ? this._map.options : {}\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getItemProperties: function getItemProperties(propArray) {\n\t        var properties = {},\n\t            indexes = this._gmx.tileAttributeIndexes;\n\t        for (var key in indexes) {\n\t            properties[key] = propArray[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    addPreRenderHook: function addPreRenderHook(renderHook) {\n\t        this._gmx.preRenderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removePreRenderHook: function removePreRenderHook(hook) {\n\t        var arr = this._gmx.preRenderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    addRenderHook: function addRenderHook(renderHook) {\n\t        this._gmx.renderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removeRenderHook: function removeRenderHook(hook) {\n\t        var arr = this._gmx.renderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    //get original properties from the server\n\t    getGmxProperties: function getGmxProperties() {\n\t        return this._gmx.rawProperties;\n\t    },\n\t\n\t    //returns L.LatLngBounds\n\t    getBounds: function getBounds() {\n\t        var proj = L.Projection.Mercator,\n\t            gmxBounds = this._gmx.layerID ? _Utils.gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\n\t\n\t        if (gmxBounds) {\n\t            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\n\t        } else {\n\t            return new L.LatLngBounds();\n\t        }\n\t    },\n\t\n\t    getGeometry: function getGeometry() {\n\t        if (!this._gmx.latLngGeometry) {\n\t            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\n\t        }\n\t\n\t        return this._gmx.latLngGeometry;\n\t    },\n\t\n\t    // internal methods\n\t    _clearTileSubscription: function _clearTileSubscription(zKey) {\n\t        var gmx = this._gmx;\n\t\n\t        if (zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            delete gmx.tileSubscriptions[zKey];\n\t            this._removeTile(zKey);\n\t\n\t            if (this._anyDrawings) {\n\t                this._chkDrawingState();\n\t            }\n\t        }\n\t\n\t        if (zKey in this._drawQueueHash) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t    },\n\t\n\t    _clearAllSubscriptions: function _clearAllSubscriptions() {\n\t        while (this._drawQueue.length) {\n\t            this._drawQueue[0].def.cancel();\n\t        }\n\t\n\t        var gmx = this._gmx;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            gmx.dataManager.removeObserver(zKey);\n\t            delete gmx.tileSubscriptions[zKey];\n\t            delete this._tiles[zKey];\n\t        }\n\t\n\t        if (this._anyDrawings) {\n\t            this._chkDrawingState();\n\t        }\n\t\n\t        gmx._tilesToLoad = 0;\n\t    },\n\t\n\t    _zoomStart: function _zoomStart() {\n\t        this._gmx.zoomstart = true;\n\t    },\n\t\n\t    _zoomEnd: function _zoomEnd() {\n\t        this._gmx.zoomstart = false;\n\t        this.setCurrentZoom(this._map);\n\t        // this._zIndexOffsetCheck();\n\t    },\n\t\n\t    _moveEnd: function _moveEnd() {\n\t        if ('dataManager' in this._gmx) {\n\t            this._gmx.dataManager.fire('moveend');\n\t        }\n\t    },\n\t\n\t    _onStyleChange: function _onStyleChange() {\n\t        var gmx = this._gmx;\n\t        if (!gmx.balloonEnable && this._popup) {\n\t            this.unbindPopup();\n\t        } else if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        if (this._map) {\n\t            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\n\t                this.options.minZoom = gmx.styleManager.minZoom;\n\t                this.options.maxZoom = gmx.styleManager.maxZoom;\n\t                this._map._updateZoomLevels();\n\t            }\n\t            if (gmx.labelsLayer) {\n\t                this._map._labelsLayer.add(this);\n\t            } else if (!gmx.labelsLayer) {\n\t                this._map._labelsLayer.remove(this);\n\t            }\n\t            if (Object.keys(gmx.tileSubscriptions).length > 0) {\n\t                for (var key in gmx.tileSubscriptions) {\n\t                    // recheck bbox on screen observers\n\t                    var observer = gmx.dataManager.getObserver(key),\n\t                        parsedKey = gmx.tileSubscriptions[key],\n\t                        gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\n\t                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\n\t                    if (!observer.bbox.isEqual(bbox)) {\n\t                        var proj = L.Projection.Mercator;\n\t                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\n\t                    }\n\t                }\n\t            } else {\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    _removeInProgressDrawing: function _removeInProgressDrawing(zKey) {\n\t        delete this._drawInProgress[zKey];\n\t        this._chkDrawingState();\n\t    },\n\t\n\t    _drawTileAsync: function _drawTileAsync(tilePoint, zoom, data) {\n\t        var queue = this._drawQueue,\n\t            isEmpty = queue.length === 0,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            _this = this;\n\t\n\t        if (this._drawQueueHash[zKey]) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t\n\t        var drawNextTile = function drawNextTile() {\n\t            _this._chkDrawingState();\n\t\n\t            if (!queue.length) {\n\t                return;\n\t            }\n\t\n\t            var queueItem = queue.shift();\n\t            delete _this._drawQueueHash[queueItem.zKey];\n\t            if (_this._map && queueItem.z === _this._map._zoom) {\n\t                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\n\t\n\t                _this._drawInProgress[queueItem.zKey] = true;\n\t\n\t                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\n\t\n\t                queueItem.drawDef.then(queueItem.def.resolve.bind(queueItem.def, queueItem.data), queueItem.def.reject);\n\t            } else {\n\t                queueItem.def.reject();\n\t            }\n\t            setTimeout(drawNextTile, 0);\n\t        };\n\t\n\t        var gtp = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\n\t        var queueItem = { gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data };\n\t        var def = queueItem.def = new L.gmx.Deferred(function () {\n\t            queueItem.drawDef && queueItem.drawDef.cancel();\n\t\n\t            _this._removeInProgressDrawing(zKey);\n\t\n\t            delete _this._drawQueueHash[zKey];\n\t            for (var i = queue.length - 1; i >= 0; i--) {\n\t                var elem = queue[i];\n\t                if (elem.zKey === zKey) {\n\t                    queue.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        queue.push(queueItem);\n\t\n\t        this._drawQueueHash[zKey] = def;\n\t\n\t        if (isEmpty) {\n\t            setTimeout(drawNextTile, 0);\n\t        }\n\t\n\t        return def;\n\t    },\n\t\n\t    _updateShiftY: function _updateShiftY() {\n\t        var gmx = this._gmx,\n\t            map = this._map,\n\t            deltaY = 0;\n\t\n\t        if (map) {\n\t            var pos = map.getCenter();\n\t            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\n\t        }\n\t\n\t        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\n\t        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\n\t        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY); // Сдвиг слоя\n\t\n\t        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\n\t    },\n\t\n\t    _prpZoomData: function _prpZoomData() {\n\t        this.setCurrentZoom(this._map);\n\t        // this.repaint();\n\t    },\n\t\n\t    setCurrentZoom: function setCurrentZoom(map) {\n\t        var gmx = this._gmx;\n\t        gmx.currentZoom = map._zoom;\n\t        gmx.tileSize = _Utils.gmxAPIutils.tileSizes[gmx.currentZoom];\n\t        gmx.mInPixel = 256 / gmx.tileSize;\n\t    },\n\t\n\t    // _zIndexOffsetCheck: function() {\n\t    // var gmx = this._gmx;\n\t    // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\n\t    // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\n\t    // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\n\t    // if (zIndexOffset !== this.options.zIndexOffset) {\n\t    // this.setZIndexOffset(zIndexOffset);\n\t    // }\n\t    // }\n\t    // },\n\t\n\t    _setClearBgBuffer: function _setClearBgBuffer(zd) {\n\t        if (this._clearBgBufferTimer) {\n\t            clearTimeout(this._clearBgBufferTimer);\n\t        }\n\t        var _this = this;\n\t        this._clearBgBufferTimer = setTimeout(function () {\n\t            if (_this._bgBuffer) {\n\t                _this._clearBgBuffer();\n\t            }\n\t        }, zd || 0);\n\t    },\n\t\n\t    _getNeedPopups: function _getNeedPopups() {\n\t        var out = {},\n\t            openPopups = this.options.openPopups;\n\t        for (var i = 0, len = openPopups.length; i < len; i++) {\n\t            out[openPopups[i]] = false;\n\t        }\n\t        return out;\n\t    },\n\t\n\t    __update: function __update() {\n\t        var map = this._map;\n\t        if (!map) {\n\t            return;\n\t        }\n\t        var zoom = map.getZoom(),\n\t            center = map.getCenter();\n\t\n\t        if (this._gmx.applyShift) {\n\t            this._updateShiftY();\n\t        }\n\t        this._tileZoom = zoom;\n\t        if (this.options.openPopups.length) {\n\t            this._gmx._needPopups = this._getNeedPopups();\n\t            this.options.openPopups = [];\n\t        }\n\t\n\t        var pixelBounds = this._getTiledPixelBounds(center),\n\t            tileRange = this._pxBoundsToTileRange(pixelBounds),\n\t            limit = this._getWrapTileNum();\n\t\n\t        if (tileRange.min.y < 0) {\n\t            tileRange.min.y = 0;\n\t        }\n\t        if (tileRange.max.y >= limit.y) {\n\t            tileRange.max.y = limit.y - 1;\n\t        }\n\t\n\t        this._chkTileSubscriptions(zoom, tileRange);\n\t\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            this._setClearBgBuffer(500);\n\t            return;\n\t        }\n\t\n\t        // create a queue of coordinates to load tiles from\n\t        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n\t            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n\t                var coords = new L.Point(i, j);\n\t                coords.z = this._tileZoom;\n\t\n\t                if (!this._tiles[this._tileCoordsToKey(coords)]) {\n\t                    this._addTile(coords);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkTileSubscriptions: function _chkTileSubscriptions(zoom, tileRange) {\n\t        //L.TileVector will remove all tiles from other zooms.\n\t        //But it will not remove subscriptions without tiles - we should do it ourself\n\t        var gmx = this._gmx,\n\t            min = tileRange.min,\n\t            max = tileRange.max;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.z !== zoom || subscription.x < min.x || subscription.x > max.x || subscription.y < min.y || subscription.y > max.y) {\n\t                this._clearTileSubscription(zKey);\n\t            }\n\t        }\n\t    },\n\t\n\t    _getScreenTile: function _getScreenTile(tilePoint, zoom) {\n\t        var gmx = this._gmx,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            subscription = gmx.tileSubscriptions[zKey],\n\t            screenTile = null;\n\t        if (subscription) {\n\t            if (subscription.screenTile) {\n\t                screenTile = subscription.screenTile;\n\t            } else {\n\t                subscription.screenTile = screenTile = new _ScreenVectorTile.ScreenVectorTile(this, tilePoint, zoom);\n\t            }\n\t        }\n\t        return screenTile;\n\t    },\n\t\n\t    _gmxDrawTile: function _gmxDrawTile(tilePoint, zoom, data) {\n\t        var gmx = this._gmx,\n\t            cancelled = false,\n\t            screenTileDrawPromise = null,\n\t            def = new L.gmx.Deferred(function () {\n\t            cancelled = true;\n\t            screenTileDrawPromise && screenTileDrawPromise.cancel();\n\t        });\n\t\n\t        if (!this._map) {\n\t            def.reject();\n\t            return def;\n\t        }\n\t        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\n\t        if (screenTile) {\n\t            gmx.styleManager.deferred.then(function () {\n\t                if (!cancelled) {\n\t                    screenTileDrawPromise = screenTile.drawTile(data);\n\t                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\n\t                }\n\t            });\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _getTilesByBounds: function _getTilesByBounds(bounds) {\n\t        // Получить список gmxTiles по bounds\n\t        var gmx = this._gmx,\n\t            zoom = this._map._zoom,\n\t            shiftX = gmx.shiftX || 0,\n\t\n\t        // Сдвиг слоя\n\t        shiftY = gmx.shiftY || 0,\n\t\n\t        // Сдвиг слоя + OSM\n\t        minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\n\t            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\n\t            screenBounds = this._map.getBounds(),\n\t            sw = screenBounds.getSouthWest(),\n\t            ne = screenBounds.getNorthEast(),\n\t            dx = 0;\n\t\n\t        if (ne.lng - sw.lng < 360) {\n\t            if (maxLatLng.lng < sw.lng) {\n\t                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\n\t            } else if (minLatLng.lng > ne.lng) {\n\t                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\n\t            }\n\t        }\n\t        minLatLng.lng += dx;\n\t        maxLatLng.lng += dx;\n\t\n\t        var pixelBounds = this._map.getPixelBounds(),\n\t            minPoint = this._map.project(minLatLng),\n\t            maxPoint = this._map.project(maxLatLng);\n\t\n\t        var minY, maxY, minX, maxX;\n\t        if (pixelBounds) {\n\t            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\n\t            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\n\t            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\n\t            minX = Math.floor((minX + shiftX) / 256);\n\t            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\n\t            maxX = Math.floor((maxX + shiftX) / 256);\n\t        } else {\n\t            minY = Math.floor((maxPoint.y + shiftY) / 256);\n\t            maxY = Math.floor((minPoint.y + shiftY) / 256);\n\t            minX = Math.floor((minPoint.x + shiftX) / 256);\n\t            maxX = Math.floor((maxPoint.x + shiftX) / 256);\n\t        }\n\t        var gmxTiles = {};\n\t        for (var x = minX; x <= maxX; x++) {\n\t            for (var y = minY; y <= maxY; y++) {\n\t                var zKey = this._tileCoordsToKey({ x: x, y: y }, zoom);\n\t                gmxTiles[zKey] = true;\n\t            }\n\t        }\n\t        return gmxTiles;\n\t    },\n\t\n\t    _updateProperties: function _updateProperties(prop) {\n\t        var gmx = this._gmx,\n\t            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\n\t\n\t        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\n\t\n\t        if (this.options.parentOptions) {\n\t            prop = this.options.parentOptions;\n\t        }\n\t\n\t        gmx.identityField = prop.identityField; // ogc_fid\n\t        gmx.GeometryType = (prop.GeometryType || '').toLowerCase(); // тип геометрий обьектов в слое\n\t        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1; // мин. zoom для растров\n\t        gmx.minZoomQuicklooks = gmx.minZoomRasters; // по умолчанию minZoom для квиклуков и КР равны\n\t\n\t        var type = prop.type || 'Vector';\n\t        if (prop.Temporal) {\n\t            type += 'Temporal';\n\t        }\n\t        gmx.layerType = type; // VectorTemporal Vector\n\t        gmx.items = {};\n\t\n\t        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\n\t        if (gmx.dataManager) {\n\t            gmx.dataManager.setOptions(prop);\n\t        }\n\t        if ('ZIndexField' in prop) {\n\t            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\n\t                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField]; // sort field index\n\t            }\n\t        }\n\t        if (this._objectsReorder) {\n\t            this._objectsReorder.initialize();\n\t        }\n\t\n\t        // if ('clusters' in prop) {\n\t        // gmx.clusters = prop.clusters;\n\t        // }\n\t\n\t        gmx.filter = prop.filter; // for dataSource attr\n\t        gmx.dateBegin = prop.dateBegin;\n\t        gmx.dateEnd = prop.dateEnd;\n\t        gmx.dataSource = prop.dataSource;\n\t        if ('MetaProperties' in gmx.rawProperties) {\n\t            var meta = gmx.rawProperties.MetaProperties;\n\t            if ('parentLayer' in meta) {\n\t                // фильтр слоя\t\t// todo удалить после изменений вов вьювере\n\t                gmx.dataSource = meta.parentLayer.Value || '';\n\t            }\n\t            if ('filter' in meta) {\n\t                // фильтр слоя\n\t                gmx.filter = meta.filter.Value || '';\n\t            }\n\t            if ('dateBegin' in meta) {\n\t                // фильтр для мультивременного слоя\n\t                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\n\t            }\n\t            if ('dateEnd' in meta) {\n\t                // фильтр для мультивременного слоя\n\t                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\n\t            }\n\t            if ('shiftX' in meta || 'shiftY' in meta) {\n\t                // сдвиг всего слоя\n\t                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\n\t                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\n\t            }\n\t            if ('shiftXfield' in meta || 'shiftYfield' in meta) {\n\t                // поля сдвига растров объектов слоя\n\t                if (meta.shiftXfield) {\n\t                    gmx.shiftXfield = meta.shiftXfield.Value;\n\t                }\n\t                if (meta.shiftYfield) {\n\t                    gmx.shiftYfield = meta.shiftYfield.Value;\n\t                }\n\t            }\n\t            if ('quicklookPlatform' in meta) {\n\t                // тип спутника\n\t                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\n\t                if (gmx.quicklookPlatform === 'image') {\n\t                    delete gmx.quicklookPlatform;\n\t                }\n\t            }\n\t            if ('quicklookX1' in meta) {\n\t                gmx.quicklookX1 = meta.quicklookX1.Value;\n\t            }\n\t            if ('quicklookY1' in meta) {\n\t                gmx.quicklookY1 = meta.quicklookY1.Value;\n\t            }\n\t            if ('quicklookX2' in meta) {\n\t                gmx.quicklookX2 = meta.quicklookX2.Value;\n\t            }\n\t            if ('quicklookY2' in meta) {\n\t                gmx.quicklookY2 = meta.quicklookY2.Value;\n\t            }\n\t            if ('quicklookX3' in meta) {\n\t                gmx.quicklookX3 = meta.quicklookX3.Value;\n\t            }\n\t            if ('quicklookY3' in meta) {\n\t                gmx.quicklookY3 = meta.quicklookY3.Value;\n\t            }\n\t            if ('quicklookX4' in meta) {\n\t                gmx.quicklookX4 = meta.quicklookX4.Value;\n\t            }\n\t            if ('quicklookY4' in meta) {\n\t                gmx.quicklookY4 = meta.quicklookY4.Value;\n\t            }\n\t\n\t            if ('multiFilters' in meta) {\n\t                // проверка всех фильтров для обьектов слоя\n\t                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\n\t            }\n\t            if ('isGeneralized' in meta) {\n\t                // Set generalization\n\t                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\n\t            }\n\t            if ('isFlatten' in meta) {\n\t                // Set flatten geometry\n\t                this.options.isFlatten = meta.isFlatten.Value !== 'false';\n\t            }\n\t        }\n\t        if (prop.Temporal) {\n\t            // Clear generalization flag for Temporal layers\n\t            this.options.isGeneralized = false;\n\t        }\n\t\n\t        if (prop.IsRasterCatalog) {\n\t            gmx.IsRasterCatalog = prop.IsRasterCatalog;\n\t            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\n\t            if (layerLink) {\n\t                gmx.rasterBGfunc = function (x, y, z, item) {\n\t                    var properties = item.properties;\n\t                    return 'http://' + gmx.hostName + '/TileSender.ashx?ModeKey=tile' + '&x=' + x + '&y=' + y + '&z=' + z + '&LayerName=' + properties[layerLink] + '&key=' + encodeURIComponent(gmx.sessionKey);\n\t                };\n\t            }\n\t        }\n\t        if (prop.Quicklook) {\n\t            var quicklookParams;\n\t\n\t            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом\n\t            if (prop.Quicklook[0] === '{') {\n\t                quicklookParams = JSON.parse(prop.Quicklook);\n\t            } else {\n\t                quicklookParams = {\n\t                    minZoom: gmx.minZoomRasters,\n\t                    template: prop.Quicklook\n\t                };\n\t            }\n\t\n\t            if ('X1' in quicklookParams) {\n\t                gmx.quicklookX1 = quicklookParams.X1;\n\t            }\n\t            if ('Y1' in quicklookParams) {\n\t                gmx.quicklookY1 = quicklookParams.Y1;\n\t            }\n\t            if ('X2' in quicklookParams) {\n\t                gmx.quicklookX2 = quicklookParams.X2;\n\t            }\n\t            if ('Y2' in quicklookParams) {\n\t                gmx.quicklookY2 = quicklookParams.Y2;\n\t            }\n\t            if ('X3' in quicklookParams) {\n\t                gmx.quicklookX3 = quicklookParams.X3;\n\t            }\n\t            if ('Y3' in quicklookParams) {\n\t                gmx.quicklookY3 = quicklookParams.Y3;\n\t            }\n\t            if ('X4' in quicklookParams) {\n\t                gmx.quicklookX4 = quicklookParams.X4;\n\t            }\n\t            if ('Y4' in quicklookParams) {\n\t                gmx.quicklookY4 = quicklookParams.Y4;\n\t            }\n\t\n\t            var template = gmx.Quicklook = quicklookParams.template;\n\t            if ('minZoom' in quicklookParams) {\n\t                gmx.minZoomQuicklooks = quicklookParams.minZoom;\n\t            }\n\t            gmx.quicklookBGfunc = function (item) {\n\t                var url = template,\n\t                    reg = /\\[([^\\]]+)\\]/,\n\t                    matches = reg.exec(url);\n\t                while (matches && matches.length > 1) {\n\t                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\n\t                    matches = reg.exec(url);\n\t                }\n\t                return url;\n\t            };\n\t            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\n\t        }\n\t        this.options.attribution = prop.Copyright || '';\n\t    },\n\t\n\t    _onVersionChange: function _onVersionChange() {\n\t        this._updateProperties(this._gmx.rawProperties);\n\t    },\n\t\n\t    getViewRasters: function getViewRasters() {\n\t        var gmx = this._gmx,\n\t            hash = {},\n\t            out = [];\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey],\n\t                screenTile = subscription.screenTile;\n\t            if (screenTile) {\n\t                screenTile.itemsView.forEach(function (it) {\n\t                    hash[it.id] = true;\n\t                });\n\t            }\n\t        }\n\t        for (var id in hash) {\n\t            out.push(id);\n\t        }\n\t\n\t        return out;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, propArr) {\n\t        return _Utils.gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\n\t    }\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.StyleManager = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar StyleManager = function StyleManager(gmx) {\n\t    this.gmx = gmx;\n\t    this.deferred = new L.gmx.Deferred();\n\t\n\t    this._maxVersion = 0;\n\t    this._maxStyleSize = 0;\n\t    this._styles = [];\n\t    this._deferredIcons = [];\n\t    this._parserFunctions = {};\n\t    this._serverStylesParsed = false;\n\t\n\t    var minZoom = Infinity,\n\t        maxZoom = -Infinity,\n\t        arr = gmx.properties.styles || [];\n\t\n\t    for (var i = 0, len = arr.length; i < len; i++) {\n\t        var st = arr[i];\n\t        minZoom = Math.min(minZoom, st.MinZoom);\n\t        maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t    }\n\t    this.minZoom = minZoom === Infinity ? 0 : minZoom;\n\t    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\n\t};\n\tStyleManager.prototype = {\n\t    _getMaxStyleSize: function _getMaxStyleSize(zoom) {\n\t        // estimete style size for arbitrary object\n\t        var maxSize = 0;\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom > style.MaxZoom || zoom < style.MinZoom) {\n\t                continue;\n\t            }\n\t            var RenderStyle = style.RenderStyle;\n\t            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\n\t            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\n\t                maxSize = StyleManager.MAX_STYLE_SIZE;\n\t                break;\n\t            }\n\t            var maxShift = 0;\n\t            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\n\t                maxShift = Math.max(Math.abs(RenderStyle.iconAnchor[0]), Math.abs(RenderStyle.iconAnchor[1]));\n\t            }\n\t            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\n\t        }\n\t        return maxSize;\n\t    },\n\t\n\t    getStyleBounds: function getStyleBounds(gmxTilePoint) {\n\t        if (!gmxTilePoint) {\n\t            return _Utils.gmxAPIutils.bounds();\n\t        }\n\t\n\t        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\n\t\n\t        var mercSize = 2 * this._maxStyleSize * _Utils.gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\n\t        return _Utils.gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\n\t    },\n\t\n\t    //is any style is visible at given zoom?\n\t    isVisibleAtZoom: function isVisibleAtZoom(zoom) {\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        var _this = this;\n\t        this.deferred.then(function () {\n\t            var out = [];\n\t            for (var i = 0, len = _this._styles.length; i < len; i++) {\n\t                var style = _this._styles[i],\n\t                    pt = {};\n\t                if (style.RenderStyle) {\n\t                    pt.RenderStyle = { image: style.RenderStyle.image };\n\t                }\n\t                if (style.HoverStyle) {\n\t                    pt.HoverStyle = { image: style.HoverStyle.image };\n\t                }\n\t                out.push(pt);\n\t            }\n\t            if (callback) {\n\t                callback(out);\n\t            }\n\t        });\n\t        this.initStyles();\n\t    },\n\t\n\t    _chkReady: function _chkReady() {\n\t        if (this._needLoadIcons < 1) {\n\t            var _this = this;\n\t            if (this.gmx.dataManager) {\n\t                this.gmx.dataManager.addFilter('styleFilter', function (it) {\n\t                    return _this._chkStyleFilter(it);\n\t                });\n\t            }\n\t            this.deferred.resolve();\n\t        }\n\t    },\n\t\n\t    initStyles: function initStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\n\t            this._getImageSize(this._deferredIcons[i]);\n\t        }\n\t        this._deferredIcons = [];\n\t        this._chkReady();\n\t        return this.deferred;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        var out = [];\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = L.extend({}, this._styles[i]);\n\t            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\n\t            if (style.HoverStyle) {\n\t                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\n\t            }\n\t            delete style.filterFunction;\n\t            delete style.version;\n\t            delete style.common;\n\t            delete style.type;\n\t            out.push(style);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    clearStyles: function clearStyles() {\n\t        this._styles = [];\n\t        this.gmx.balloonEnable = false;\n\t        this.gmx.labelsLayer = false;\n\t    },\n\t\n\t    _changeStylesVersion: function _changeStylesVersion() {\n\t        var _this = this;\n\t        this._styles.map(function (it) {\n\t            it.version = ++_this._maxVersion;\n\t        });\n\t    },\n\t\n\t    setStyle: function setStyle(st, num, createFlag) {\n\t        num = num || 0;\n\t        if (num < this._styles.length || createFlag) {\n\t            var style = this._styles[num];\n\t            if (!style) {\n\t                style = this._prepareItem({});\n\t                this._styles[num] = style;\n\t            }\n\t            this.deferred = new L.gmx.Deferred();\n\t            style.version = ++this._maxVersion;\n\t            if ('Filter' in st) {\n\t                style.Filter = st.Filter;\n\t                var type = _typeof(st.Filter);\n\t                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"')) : type === 'function' ? style.Filter : null;\n\t\n\t                this._changeStylesVersion();\n\t            }\n\t            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\n\t                var key = StyleManager.DEFAULT_KEYS[i];\n\t                if (key in st) {\n\t                    style[key] = st[key];\n\t                }\n\t            }\n\t            if (st.RenderStyle) {\n\t                style.RenderStyle = this._parseStyle(st.RenderStyle);\n\t            }\n\t            if (st.HoverStyle) {\n\t                style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle);\n\t            }\n\t            this._checkStyles();\n\t        }\n\t        return this.initStyles();\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var item = this.gmx.dataManager.getItem(id),\n\t            currentFilter = item ? item.currentFilter : 0,\n\t            style = this._styles[currentFilter];\n\t        return style ? {\n\t            DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\n\t            DisableBalloonOnClick: style.DisableBalloonOnClick || false,\n\t            templateBalloon: style.Balloon || null,\n\t            isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\n\t        } : null;\n\t    },\n\t\n\t    // apply styleHook func\n\t    // applyStyleHook: function(item, hoverFlag) {\n\t    // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\n\t    // },\n\t\n\t    getObjStyle: function getObjStyle(item) {\n\t        this._chkStyleFilter(item);\n\t        var style = this._styles[item.currentFilter],\n\t            version;\n\t\n\t        if (!style) {\n\t            return null;\n\t        }\n\t        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\n\t            if (style.HoverStyle) {\n\t                version = style.HoverStyle.version || -1;\n\t                if (version !== item.styleVersion) {\n\t                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\n\t                }\n\t                return style.HoverStyle;\n\t            } else {\n\t                delete item.parsedStyleHover;\n\t            }\n\t            return null;\n\t        }\n\t        version = style.version || -1;\n\t        if (version !== item.styleVersion) {\n\t            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\n\t        }\n\t        return style.RenderStyle;\n\t    },\n\t\n\t    _needLoadIcons: 0,\n\t    _getImageSize: function _getImageSize(pt) {\n\t        // check image size\n\t        var url = pt.iconUrl || pt.fillIconUrl,\n\t            opt = pt.iconAngle || pt.iconScale ? { crossOrigin: 'anonymous' } : {},\n\t            _this = this;\n\t\n\t        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t            opt = {}; // skip bug in IE11\n\t        }\n\t        opt.layerID = this.gmx.layerID;\n\t        ++this._needLoadIcons;\n\t        L.gmx.imageLoader.unshift(url, opt).def.then(function (it) {\n\t            pt.version = ++_this._maxVersion;\n\t            if (pt.fillIconUrl) {\n\t                pt.imagePattern = it;\n\t            } else {\n\t                var w = it.width,\n\t                    h = it.height;\n\t                if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t                    // skip bug in IE11\n\t                    document.body.appendChild(it);\n\t                    w = it.offsetWidth;\n\t                    h = it.offsetHeight;\n\t                    document.body.removeChild(it);\n\t                }\n\t                pt.sx = w;\n\t                pt.sy = h;\n\t                pt.image = it;\n\t                var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\n\t                if (!pt.scaleFunction && !pt.rotateFunction) {\n\t                    if (pt.iconScale || pt.iconScale === 1) {\n\t                        maxSize *= pt.iconScale;\n\t                    }\n\t                    pt.common = true;\n\t                }\n\t                pt.maxSize = Number(maxSize.toFixed());\n\t            }\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t        }, function () {\n\t            pt.version = ++_this._maxVersion;\n\t            pt.sx = 1;\n\t            pt.sy = 0;\n\t            pt.image = null;\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t            console.log({ url: url, func: '_getImageSize', Error: 'image not found' });\n\t        });\n\t    },\n\t\n\t    getCurrentFilters: function getCurrentFilters(propArray, zoom) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            types = gmx.tileAttributeTypes,\n\t            z = zoom || 1,\n\t            out = [];\n\t\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t            if (z > st.MaxZoom || z < st.MinZoom || st.filterFunction && !st.filterFunction(propArray, indexes, types)) {\n\t                continue;\n\t            }\n\t            out.push(i);\n\t            if (!gmx.multiFilters) {\n\t                break;\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    _chkStyleFilter: function _chkStyleFilter(item) {\n\t        var gmx = this.gmx,\n\t            zoom = gmx.currentZoom,\n\t            fnum = gmx.multiFilters ? -1 : item.currentFilter,\n\t            curr = this._styles[fnum],\n\t            needParse = !curr || curr.version !== item.styleVersion;\n\t\n\t        if (needParse || item._lastZoom !== zoom) {\n\t            item.currentFilter = -1;\n\t            item.multiFilters = [];\n\t            var filters = this.getCurrentFilters(item.properties, zoom);\n\t            for (var i = 0, len = filters.length; i < len; i++) {\n\t                var num = filters[i],\n\t                    st = this._styles[num];\n\t                item.hoverDiff = st.hoverDiff;\n\t                item.currentFilter = num;\n\t                if (needParse || fnum !== num) {\n\t                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\n\t                        parsedHover = null;\n\t\n\t                    item.parsedStyleKeys = parsed;\n\t                    if (st.HoverStyle) {\n\t                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\n\t                        item.parsedStyleHover = parsedHover;\n\t                    }\n\t                    if (gmx.multiFilters) {\n\t                        item.multiFilters.push({\n\t                            style: st.RenderStyle,\n\t                            styleHover: st.HoverStyle,\n\t                            parsedStyle: parsed,\n\t                            parsedStyleHover: parsedHover\n\t                        });\n\t                    }\n\t                }\n\t                item.styleVersion = st.version;\n\t                if (!gmx.multiFilters) {\n\t                    break;\n\t                }\n\t            }\n\t            item._lastZoom = zoom;\n\t        }\n\t        if (this._styles[item.currentFilter]) {\n\t            return true;\n\t        } else {\n\t            item.currentFilter = -1;\n\t            return false;\n\t        }\n\t    },\n\t\n\t    _parseServerStyles: function _parseServerStyles() {\n\t        var gmx = this.gmx,\n\t            props = gmx.properties,\n\t            arr = props.styles || [{ MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE }],\n\t            len = Math.max(arr.length, gmx.styles.length);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            if (!this._styles[i]) {\n\t                var gmxStyle = gmx.styles[i] || arr[i];\n\t                if (!gmxStyle.RenderStyle) {\n\t                    gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE;\n\t                }\n\t                if (gmxStyle.HoverStyle === undefined) {\n\t                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\n\t                    if (hoveredStyle.outline) {\n\t                        hoveredStyle.outline.thickness += 1;\n\t                    }\n\t                    gmxStyle.HoverStyle = hoveredStyle;\n\t                } else if (gmxStyle.HoverStyle === null) {\n\t                    delete gmxStyle.HoverStyle;\n\t                }\n\t                var pt = this._prepareItem(gmxStyle);\n\t                this._styles.push(pt);\n\t                if (this._isLabel(pt.RenderStyle)) {\n\t                    gmx.labelsLayer = true;\n\t                }\n\t            }\n\t        }\n\t        this._checkStyles();\n\t        this._serverStylesParsed = true;\n\t    },\n\t\n\t    _checkStyles: function _checkStyles() {\n\t        var minZoom = Infinity,\n\t            maxZoom = -Infinity,\n\t            balloonEnable = false,\n\t            labelsLayer = false;\n\t\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t\n\t            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\n\t            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\n\t            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\n\t                balloonEnable = true;\n\t                st.BalloonEnable = true;\n\t            }\n\t            st.hoverDiff = null;\n\t            st.common = {};\n\t            if (st.RenderStyle) {\n\t                if (!labelsLayer) {\n\t                    if (this._isLabel(st.RenderStyle)) {\n\t                        labelsLayer = true;\n\t                    }\n\t                }\n\t                if (st.RenderStyle.common) {\n\t                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\n\t                }\n\t                if (st.HoverStyle) {\n\t                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\n\t                }\n\t            }\n\t            if (st.HoverStyle && st.HoverStyle.common) {\n\t                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\n\t            }\n\t            minZoom = Math.min(minZoom, st.MinZoom);\n\t            maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t        }\n\t        if (this.minZoom !== Infinity) {\n\t            this.minZoom = minZoom;\n\t        }\n\t        if (this.maxZoom !== -Infinity) {\n\t            this.maxZoom = maxZoom;\n\t        }\n\t        this.gmx.balloonEnable = balloonEnable;\n\t        this.gmx.labelsLayer = labelsLayer;\n\t    },\n\t\n\t    _parseStyle: function _parseStyle(st, renderStyle) {\n\t        if (st) {\n\t            st.common = true;\n\t            for (var key in st) {\n\t                if (_Utils.gmxAPIutils.styleFuncKeys[key]) {\n\t                    var fkey = _Utils.gmxAPIutils.styleFuncKeys[key],\n\t                        val = st[key];\n\t                    if (typeof val === 'string') {\n\t                        st.common = false;\n\t                        if (renderStyle && renderStyle[key] === val) {\n\t                            st[fkey] = renderStyle[fkey];\n\t                        } else {\n\t                            if (!this._parserFunctions[val]) {\n\t                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\n\t                            }\n\t                            st[fkey] = this._parserFunctions[val];\n\t                        }\n\t                    } else if (typeof val === 'function') {\n\t                        st.common = false;\n\t                        st[fkey] = val;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var type = '';\n\t            if ('iconUrl' in st) {\n\t                type = 'image';\n\t                if (st.iconUrl) {\n\t                    st.maxSize = 256;\n\t                    this._deferredIcons.push(st);\n\t                }\n\t            } else if (st.fillIconUrl) {\n\t                type = 'square';\n\t                this._deferredIcons.push(st);\n\t            } else if (st.fillPattern) {\n\t                type = 'square';\n\t                st.common = StyleManager.parsePattern(st.fillPattern);\n\t                st.canvasPattern = _Utils.gmxAPIutils.getPatternIcon(null, st);\n\t            } else if (st.iconCircle) {\n\t                type = 'circle';\n\t                if (!('iconSize' in st)) {\n\t                    st.iconSize = 4;\n\t                }\n\t            } else if (st.iconPath) {\n\t                type = 'iconPath';\n\t                var iconSize = 0,\n\t                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\n\t                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function (it, i) {\n\t                    var z = arr[i] || it;\n\t                    iconSize = Math.max(iconSize, z);\n\t                    return z;\n\t                });\n\t                st.iconSize = 2 * iconSize;\n\t            } else if (st.fillRadialGradient) {\n\t                type = 'circle';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\n\t                if (size === null) {\n\t                    st.common = false;\n\t                } else {\n\t                    st.iconSize = size;\n\t                }\n\t            } else if (st.fillLinearGradient) {\n\t                type = 'square';\n\t                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\n\t            } else if (st.iconSize) {\n\t                type = 'square';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t            }\n\t            st.type = type;\n\t            if (st.common && !st.maxSize) {\n\t                st.maxSize = st.iconSize || 0;\n\t                st.maxSize += st.weight ? st.weight : 0;\n\t                if ('iconScale' in st) {\n\t                    st.maxSize *= st.iconScale;\n\t                }\n\t            }\n\t        }\n\t        return st;\n\t    },\n\t\n\t    _prepareItem: function _prepareItem(style) {\n\t        // Style Scanex->leaflet\n\t        var pt = {\n\t            MinZoom: style.MinZoom || 0,\n\t            MaxZoom: style.MaxZoom || 18,\n\t            Filter: style.Filter || null,\n\t            Balloon: style.Balloon || '',\n\t            RenderStyle: style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {},\n\t            version: ++this._maxVersion\n\t        };\n\t        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\n\t        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\n\t        if (style.HoverStyle) {\n\t            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\n\t        }\n\t\n\t        if ('Filter' in style) {\n\t            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (ph) {\n\t                pt.filterFunction = ph;\n\t            }\n\t        }\n\t        return pt;\n\t    },\n\t\n\t    _isLabel: function _isLabel(st) {\n\t        var indexes = this.gmx.tileAttributeIndexes;\n\t        return st && (st.labelTemplate || st.labelField && st.labelField in indexes);\n\t    },\n\t\n\t    _itemStyleParser: function _itemStyleParser(item, pt) {\n\t        pt = pt || {};\n\t        var out = {},\n\t            arr,\n\t            i,\n\t            len,\n\t            indexes = this.gmx.tileAttributeIndexes,\n\t            prop = item.properties || {},\n\t            itemType = item.type,\n\t            type = pt.type,\n\t            color = 'color' in pt ? pt.color : 255,\n\t            opacity = 'opacity' in pt ? pt.opacity : 1;\n\t\n\t        out.sx = pt.sx;\n\t        out.sy = pt.sy;\n\t        if (pt.maxSize) {\n\t            out.maxSize = pt.maxSize;\n\t        }\n\t        if (pt.iconAngle) {\n\t            var rotateRes = pt.iconAngle || 0;\n\t            if (rotateRes && typeof rotateRes === 'string') {\n\t                rotateRes = pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0;\n\t            }\n\t            out.rotate = rotateRes || 0;\n\t        }\n\t        if ('iconColor' in pt) {\n\t            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\n\t        }\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if (type === 'image') {\n\t            out.type = type;\n\t            if (pt.iconUrl) {\n\t                out.iconUrl = pt.iconUrl;\n\t            }\n\t            if (pt.image) {\n\t                out.image = pt.image;\n\t            }\n\t        } else if (pt.fillRadialGradient) {\n\t            var rgr = pt.fillRadialGradient,\n\t                r1 = rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1,\n\t                r2 = rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2,\n\t                x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t                y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t                x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t                y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2;\n\t            if (rgr.r2max) {\n\t                r2 = Math.min(r2, rgr.r2max);\n\t            }\n\t            var colorStop = [];\n\t            len = rgr.addColorStop.length;\n\t            if (!rgr.addColorStopFunctions) {\n\t                rgr.addColorStopFunctions = new Array(len);\n\t            }\n\t            for (i = 0; i < len; i++) {\n\t                arr = rgr.addColorStop[i];\n\t                var arrFunc = rgr.addColorStopFunctions[i] || [],\n\t                    p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0],\n\t                    p3 = arr[3];\n\t                if (arr.length < 4) {\n\t                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\n\t                    p3 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\n\t                }\n\t                colorStop.push([p0, p3]);\n\t            }\n\t            out.maxSize = out.sx = out.sy = out.iconSize = r2;\n\t            out.fillRadialGradient = {\n\t                x1: x1, y1: y1, r1: r1, x2: x2, y2: y2, r2: r2,\n\t                addColorStop: colorStop\n\t            };\n\t            out._radialGradientParsed = {\n\t                create: [x1, y1, r1, x2, y2, r2],\n\t                colorStop: colorStop\n\t            };\n\t        } else if (pt.fillLinearGradient) {\n\t            out.fillLinearGradient = pt.fillLinearGradient;\n\t        } else {\n\t            if (pt.fillPattern) {\n\t                out.canvasPattern = pt.canvasPattern ? pt.canvasPattern : _Utils.gmxAPIutils.getPatternIcon(item, pt, indexes);\n\t            }\n\t\n\t            if (type === 'iconPath') {\n\t                out.type = type;\n\t                out.iconPath = pt.iconPath;\n\t            }\n\t\n\t            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\n\t                type = 'polygon';\n\t            }\n\t            if (pt.iconSize) {\n\t                var iconSize = 'sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize;\n\t                out.sx = out.sy = iconSize;\n\t                // iconSize += pt.weight ? pt.weight : 0;\n\t                out.iconSize = iconSize;\n\t                if ('iconScale' in pt) {\n\t                    out.iconSize *= pt.iconScale;\n\t                }\n\t                out.maxSize = iconSize;\n\t            }\n\t            out.stroke = true;\n\t            if ('colorFunction' in pt || 'opacityFunction' in pt) {\n\t                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\n\t                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\n\t            }\n\t            out.strokeStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            out.lineWidth = 'weight' in pt ? pt.weight : 1;\n\t        }\n\t\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if ('iconAnchor' in pt) {\n\t            out.iconAnchor = pt.iconAnchor;\n\t        }\n\t        if ('iconCenter' in pt) {\n\t            out.iconCenter = pt.iconCenter;\n\t        }\n\t\n\t        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\n\t            out.type = type;\n\t            var fop = pt.fillOpacity,\n\t                fc = pt.fillColor,\n\t                fcDec = typeof fc === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\n\t\n\t            if ('fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, 1);\n\t            }\n\t            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\n\t                color = 'fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255;\n\t                opacity = 'fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1;\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, fop);\n\t            }\n\t        }\n\t\n\t        if ('dashArray' in pt) {\n\t            out.dashArray = pt.dashArray;\n\t        }\n\t        if ('dashOffset' in pt) {\n\t            out.dashOffset = pt.dashOffset;\n\t        }\n\t\n\t        if (this.gmx.labelsLayer) {\n\t            arr = _Utils.gmxAPIutils.styleKeys.label.client;\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i];\n\t                if (it in pt) {\n\t                    if (it === 'labelField') {\n\t                        if (!indexes[pt[it]]) {\n\t                            continue;\n\t                        }\n\t                    } else if (it === 'labelTemplate') {\n\t                        var properties = _Utils.gmxAPIutils.getPropertiesHash(prop, indexes);\n\t                        out.labelText = _Utils.gmxAPIutils.parseTemplate(pt[it], properties);\n\t                    }\n\t                    out[it] = pt[it];\n\t                }\n\t            }\n\t            if ('labelAnchor' in pt) {\n\t                out.labelAnchor = pt.labelAnchor;\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t};\n\tStyleManager.MAX_STYLE_SIZE = 256;\n\t//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\n\tStyleManager.DEFAULT_STYLE = { outline: { color: 255, thickness: 1 }, marker: { size: 8 } };\n\tStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\n\tStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10]; // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\n\t\n\tStyleManager.parsePattern = function (pattern) {\n\t    var common = true,\n\t        parsers = L.gmx.Parsers;\n\t    if ('step' in pattern && typeof pattern.step === 'string') {\n\t        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\n\t        common = false;\n\t    }\n\t    if ('width' in pattern && typeof pattern.width === 'string') {\n\t        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\n\t        common = false;\n\t    }\n\t    if ('colors' in pattern) {\n\t        var arr = [];\n\t        for (var i = 0, len = pattern.colors.length; i < len; i++) {\n\t            var rt = pattern.colors[i];\n\t            if (typeof rt === 'string') {\n\t                arr.push(parsers.parseExpression(rt));\n\t                common = false;\n\t            } else {\n\t                arr.push(null);\n\t            }\n\t        }\n\t        pattern.patternColorsFunction = arr;\n\t    }\n\t    return common;\n\t};\n\t\n\tStyleManager.getStyleKeys = function (style) {\n\t    var out = {};\n\t    for (var key in _Utils.gmxAPIutils.styleKeys) {\n\t        var keys = _Utils.gmxAPIutils.styleKeys[key];\n\t        for (var i = 0, len = keys.client.length; i < len; i++) {\n\t            var key1 = keys.client[i];\n\t            if (key1 in style) {\n\t                if (style[key1] !== undefined) {\n\t                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\n\t                }\n\t                if (key1 === 'fillPattern') {\n\t                    delete out[key1].patternColorsFunction;\n\t                } else if (key1 === 'fillLinearGradient') {\n\t                    delete out[key1].addColorStopFunctions;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if ('iconAnchor' in style) {\n\t        out.iconAnchor = style.iconAnchor;\n\t    }\n\t    if ('labelAnchor' in style) {\n\t        out.labelAnchor = style.labelAnchor;\n\t    }\n\t    return out;\n\t};\n\t\n\tStyleManager.checkDiff = function (st, st1) {\n\t    for (var key in st) {\n\t        if (st[key] !== st1[key]) {\n\t            return key;\n\t        }\n\t    }\n\t    return null;\n\t};\n\t\n\tStyleManager.parseRadialGradient = function (rg) {\n\t    //\tx1,y1,r1 — координаты центра и радиус первой окружности;\n\t    //\tx2,y2,r2 — координаты центра и радиус второй окружности.\n\t    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\n\t    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\n\t    //\t\tcolor — код цвета или формула.\n\t    //\t\topacity — прозрачность\n\t    //\t\tcanvasStyleColor — результрующий цвет в формате canvas\n\t    var common = true,\n\t        parsers = L.gmx.Parsers,\n\t        i = 0,\n\t        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (!rg[it]) {\n\t            rg[it] = 0;\n\t        }\n\t        if (typeof rg[it] === 'string') {\n\t            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\n\t            common = false;\n\t        }\n\t    }\n\t\n\t    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\n\t    rg.addColorStopFunctions = [];\n\t    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\n\t        arr = rg.addColorStop[i];\n\t        var resFunc = [typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null];\n\t        rg.addColorStopFunctions.push(resFunc);\n\t        if (resFunc[1] === null && resFunc[2] === null) {\n\t            arr[3] = _Utils.gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\n\t        } else {\n\t            common = false;\n\t        }\n\t    }\n\t    if ('r2Function' in rg) {\n\t        common = false;\n\t    }\n\t    return common ? Math.max(rg.r1, rg.r2) : null;\n\t};\n\t\n\tStyleManager.parseLinearGradient = function (lg) {\n\t    var common = true;\n\t    //\tx1,y1 — координаты начальной точки\n\t    //\tx2,y2 — координаты конечной точки\n\t    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\n\t    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\n\t    //\t\tcolor — код цвета или формула.\n\t    //\t\topacity — прозрачность\n\t    var i = 0,\n\t        parsers = L.gmx.Parsers,\n\t        arr = ['x1', 'y1', 'x2', 'y2'],\n\t        def = [0, 0, 0, 256],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (it in lg) {\n\t            if (typeof lg[it] === 'string') {\n\t                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\n\t                common = false;\n\t            }\n\t        } else {\n\t            lg[it] = def[i];\n\t        }\n\t    }\n\t\n\t    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\n\t    lg.addColorStopFunctions = [];\n\t    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\n\t        arr = lg.addColorStop[i];\n\t        lg.addColorStopFunctions.push([typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null]);\n\t    }\n\t    return common;\n\t};\n\texports.StyleManager = StyleManager;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ScreenVectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t// Single tile on screen with vector data\n\tfunction ScreenVectorTile(layer, tilePoint, zoom) {\n\t    this.layer = layer;\n\t    this.tilePoint = tilePoint;\n\t    this.zoom = zoom;\n\t    this.gmx = layer._gmx;\n\t    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\n\t    var utils = _Utils.gmxAPIutils;\n\t    this.worldWidthMerc = utils.worldWidthMerc;\n\t    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\n\t    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\n\t    this.tpx = 256 * gmxTilePoint.x;\n\t    this.tpy = 256 * (1 + gmxTilePoint.y);\n\t    this.gmxTilePoint = gmxTilePoint;\n\t\n\t    this.showRaster = zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx || zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx;\n\t    this.rasters = {}; //combined and processed canvases for each vector item in tile\n\t    this.rasterRequests = {}; // all cached raster requests\n\t    this.itemsView = []; // items on screen tile + todo: without not visible\n\t    this._uniqueID = 0; // draw attempt id\n\t    this.gmx.badTiles = this.gmx.badTiles || {};\n\t}\n\t\n\tScreenVectorTile.prototype = {\n\t\n\t    //return promise, which resolves with object {gtp, image}\n\t    _loadTileRecursive: function _loadTileRecursive(gtp, urlFunction) {\n\t        var gmx = this.gmx,\n\t            _this = this,\n\t            requestPromise = null,\n\t            currentUrl,\n\t            def = new L.gmx.Deferred(function () {\n\t            if (requestPromise) {\n\t                //don't store cancelled requests in request cache\n\t                delete _this.rasterRequests[currentUrl];\n\t                requestPromise.cancel();\n\t            }\n\t        });\n\t\n\t        var tryLoad = function tryLoad(gtp, crossOrigin) {\n\t            var rUrl = urlFunction(gtp);\n\t\n\t            var tryHigherLevelTile = function tryHigherLevelTile() {\n\t                if (gtp.z > 1) {\n\t                    tryLoad({\n\t                        x: Math.floor(gtp.x / 2),\n\t                        y: Math.floor(gtp.y / 2),\n\t                        z: gtp.z - 1\n\t                    }, ''); // 'anonymous' 'use-credentials'\n\t                } else {\n\t                    def.reject();\n\t                }\n\t            };\n\t\n\t            if (gmx.badTiles[rUrl] || gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z) {\n\t                tryHigherLevelTile();\n\t                return;\n\t            }\n\t            var request = _this.rasterRequests[rUrl];\n\t            if (!request) {\n\t                if (gmx.rasterProcessingHook) {\n\t                    crossOrigin = 'anonymous';\n\t                }\n\t                request = L.gmx.imageLoader.push(rUrl, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    zoom: _this.zoom,\n\t                    cache: true,\n\t                    crossOrigin: crossOrigin || ''\n\t                });\n\t                _this.rasterRequests[rUrl] = request;\n\t            } else {\n\t                request.options.tileRastersId = _this._uniqueID;\n\t            }\n\t            currentUrl = rUrl;\n\t            requestPromise = request.def;\n\t\n\t            requestPromise.then(function (imageObj) {\n\t                def.resolve({ gtp: gtp, image: imageObj });\n\t            }, function () {\n\t                gmx.badTiles[rUrl] = true;\n\t                tryHigherLevelTile();\n\t            });\n\t        };\n\t\n\t        tryLoad(gtp);\n\t        return def;\n\t    },\n\t\n\t    _rasterHook: function _rasterHook(attr) {\n\t        var source = attr.sourceTilePoint || attr.destinationTilePoint,\n\t            info = {\n\t            geoItem: attr.geoItem,\n\t            destination: {\n\t                z: attr.destinationTilePoint.z,\n\t                x: attr.destinationTilePoint.x,\n\t                y: attr.destinationTilePoint.y\n\t            },\n\t            source: {\n\t                z: source.z,\n\t                x: source.x,\n\t                y: source.y\n\t            }\n\t        };\n\t        if (attr.url) {\n\t            info.quicklook = attr.url;\n\t        }\n\t        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(attr.res, attr.image, attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256, attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256, info);\n\t    },\n\t\n\t    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\n\t    _defaultRasterHook: function _defaultRasterHook(res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\n\t        var ptx = res.getContext('2d');\n\t        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n\t    },\n\t\n\t    // get pixels parameters for shifted object\n\t    _getShiftPixels: function _getShiftPixels(it) {\n\t        var w = it.dx + (it.dx < 0 ? 256 : 0),\n\t            h = it.dy + (it.dy < 0 ? 256 : 0),\n\t            sx = 0,\n\t            sw = 256 - w,\n\t            dx = w,\n\t            dw = sw;\n\t        if (it.tx > it.x) {\n\t            sx = sw;sw = w;dx = 0;dw = sw;\n\t        }\n\t        if (sx === 256 || sw < 1) {\n\t            return null;\n\t        }\n\t\n\t        var sy = h,\n\t            sh = 256 - h,\n\t            dy = 0,\n\t            dh = sh;\n\t        if (it.ty > it.y) {\n\t            sy = 0;dy = sh;sh = h;dh = sh;\n\t        }\n\t        if (sy === 256 || sh < 1) {\n\t            return null;\n\t        }\n\t\n\t        return {\n\t            sx: sx, sy: sy, sw: sw, sh: sh,\n\t            dx: dx, dy: dy, dw: dw, dh: dh\n\t        };\n\t    },\n\t\n\t    // get tiles parameters for shifted object\n\t    _getShiftTilesArray: function _getShiftTilesArray(bounds, shiftX, shiftY) {\n\t        var mInPixel = this.gmx.mInPixel,\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            px = shiftX * mInPixel,\n\t            py = shiftY * mInPixel,\n\t            deltaX = Math.floor(0.5 + px % 256),\n\t\n\t        // shift on tile in pixel\n\t        deltaY = Math.floor(0.5 + py % 256),\n\t            tileSize = 256 / mInPixel,\n\t            tminX = gmxTilePoint.x - shiftX / tileSize,\n\t\n\t        // by screen tile\n\t        tminY = gmxTilePoint.y - shiftY / tileSize,\n\t            rminX = Math.floor(tminX),\n\t            rmaxX = rminX + (tminX === rminX ? 0 : 1),\n\t            rminY = Math.floor(tminY),\n\t            rmaxY = rminY + (tminY === rminY ? 0 : 1),\n\t            minX = Math.floor((bounds.min.x - shiftX) / tileSize),\n\t\n\t        // by geometry bounds\n\t        maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\n\t            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\n\t            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\n\t\n\t        if (rminX < minX) {\n\t            rminX = minX;\n\t        }\n\t        if (rmaxX > maxX) {\n\t            rmaxX = maxX;\n\t        }\n\t        if (rminY < minY) {\n\t            rminY = minY;\n\t        }\n\t        if (rmaxY > maxY) {\n\t            rmaxY = maxY;\n\t        }\n\t\n\t        var arr = [];\n\t        for (var j = rminY; j <= rmaxY; j++) {\n\t            for (var i = rminX; i <= rmaxX; i++) {\n\t                arr.push({\n\t                    z: gmxTilePoint.z,\n\t                    x: i,\n\t                    y: j,\n\t                    dx: deltaX,\n\t                    dy: deltaY,\n\t                    tx: tminX,\n\t                    ty: tminY\n\t                });\n\t            }\n\t        }\n\t        return arr;\n\t    },\n\t\n\t    // Loads missing rasters for single item and combines them in canvas.\n\t    // Stores resulting canvas in this.rasters\n\t    _getItemRasters: function _getItemRasters(geo) {\n\t        var properties = geo.properties,\n\t            idr = properties[0],\n\t            _this = this,\n\t            gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            rasters = this.rasters,\n\t            mainRasterLoader = null,\n\t            recursiveLoaders,\n\t            shiftX = Number(gmx.shiftXfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\n\t            shiftY = Number(gmx.shiftYfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\n\t            isShift = shiftX || shiftY,\n\t            urlBG = _Utils.gmxAPIutils.getPropItem('urlBG', properties, indexes),\n\t            url = '',\n\t            itemImageProcessingHook = null,\n\t            isTiles = false,\n\t            item = gmx.dataManager.getItem(idr),\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            resCanvas = null,\n\t            imageItem = null;\n\t\n\t        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || _Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\n\t            isTiles = true; // Raster Layer\n\t        } else if (gmx.quicklookBGfunc) {\n\t            url = gmx.quicklookBGfunc(item); // Quicklook\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        } else if (urlBG) {\n\t            url = urlBG; // Image urlBG from properties\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        }\n\t        if (isTiles) {\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                recursiveLoaders.forEach(function (it) {\n\t                    it.cancel();\n\t                });\n\t                recursiveLoaders = null;\n\t            });\n\t        } else {\n\t            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey; //  for browser cache from another tabs\n\t            var request = this.rasterRequests[url];\n\t            if (!request) {\n\t                request = L.gmx.imageLoader.push(url, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    crossOrigin: gmx.crossOrigin || 'anonymous'\n\t                });\n\t                this.rasterRequests[url] = request;\n\t            } else {\n\t                request.options.tileRastersId = this._uniqueID;\n\t            }\n\t\n\t            // in fact, we want to return request.def, but need to do additional action during cancellation.\n\t            // so, we consctruct new promise and add pipe it with request.def\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                //don't cache cancelled requests\n\t                delete _this.rasterRequests[url];\n\t                request.def.cancel();\n\t            });\n\t            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\n\t        }\n\t        var itemRasterPromise = new L.gmx.Deferred(function () {\n\t            if (mainRasterLoader) {\n\t                mainRasterLoader.cancel();\n\t                mainRasterLoader = null;\n\t            }\n\t        });\n\t\n\t        if (isTiles) {\n\t            var dataOption = geo.dataOption || {},\n\t                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\n\t                cnt = tileToLoadPoints.length,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (cnt < 1) {\n\t                    mainRasterLoader.resolve();\n\t                }\n\t            },\n\t                skipRasterFunc = function skipRasterFunc() {\n\t                cnt--;\n\t                chkReadyRasters();\n\t            },\n\t                urlFunction = function urlFunction(gtp) {\n\t                return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\n\t            },\n\t                onLoadFunction = function onLoadFunction(gtp, p, img) {\n\t                item.skipRasters = false;\n\t                var isImage = true;\n\t\n\t                if (itemImageProcessingHook) {\n\t                    img = itemImageProcessingHook(img, {\n\t                        gmx: gmx,\n\t                        geoItem: geo,\n\t                        item: item,\n\t                        gmxTilePoint: gtp\n\t                    });\n\t                    isImage = false;\n\t                }\n\t\n\t                var info = {\n\t                    geoItem: geo,\n\t                    image: img,\n\t                    destinationTilePoint: gmxTilePoint,\n\t                    sourceTilePoint: gtp,\n\t                    sx: 0, sy: 0, sw: 256, sh: 256,\n\t                    dx: 0, dy: 0, dw: 256, dh: 256\n\t                };\n\t\n\t                if (isShift) {\n\t                    var pos = _this._getShiftPixels(p);\n\t                    if (pos === null) {\n\t                        skipRasterFunc();\n\t                        return;\n\t                    }\n\t                    L.extend(info, pos);\n\t                    isImage = false;\n\t                }\n\t\n\t                if (gtp.z !== gmxTilePoint.z) {\n\t                    var posInfo = _Utils.gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\n\t                    if (posInfo.size < 1 / 256) {\n\t                        // меньше 1px\n\t                        chkReadyRasters();\n\t                        return;\n\t                    }\n\t                    isImage = false;\n\t                    info.sx = Math.floor(posInfo.x);\n\t                    info.sy = Math.floor(posInfo.y);\n\t                    info.sw = info.sh = posInfo.size;\n\t                    if (isShift) {\n\t                        var sw = Math.floor(info.dw / posInfo.zDelta);\n\t                        info.sx = (info.dx === 0 ? info.sw : 256) - sw;\n\t                        info.sw = sw;\n\t\n\t                        var sh = Math.floor(info.dh / posInfo.zDelta);\n\t                        info.sy = (info.dy === 0 ? info.sh : 256) - sh;\n\t                        info.sh = sh;\n\t                    }\n\t                }\n\t                if (isImage && !gmx.rasterProcessingHook) {\n\t                    cnt--;\n\t                    resCanvas = img;\n\t                    chkReadyRasters();\n\t                } else {\n\t                    if (!resCanvas) {\n\t                        resCanvas = document.createElement('canvas');\n\t                        resCanvas.width = resCanvas.height = 256;\n\t                    }\n\t                    info.res = resCanvas;\n\t                    var hookResult = _this._rasterHook(info),\n\t                        then = function then() {\n\t                        cnt--;\n\t                        p.resImage = resCanvas;\n\t                        chkReadyRasters();\n\t                    };\n\t\n\t                    if (hookResult) {\n\t                        if (hookResult instanceof L.gmx.Deferred) {\n\t                            hookResult.then(then);\n\t                        }\n\t                    } else if (hookResult === null) {\n\t                        item.skipRasters = true;\n\t                        skipRasterFunc();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                }\n\t            };\n\t            recursiveLoaders = tileToLoadPoints.map(function (it) {\n\t                var loader = _this._loadTileRecursive(it, urlFunction);\n\t                loader.then(function (loadResult) {\n\t                    onLoadFunction(loadResult.gtp, it, loadResult.image);\n\t                }, skipRasterFunc);\n\t                return loader;\n\t            });\n\t\n\t            mainRasterLoader.then(function () {\n\t                rasters[idr] = resCanvas;\n\t                itemRasterPromise.resolve();\n\t            });\n\t        } else {\n\t            // for quicklook\n\t            item.skipRasters = false;\n\t            var imageLoaded = function imageLoaded(img) {\n\t                var imgAttr = {\n\t                    gmx: gmx,\n\t                    geoItem: geo,\n\t                    item: item,\n\t                    gmxTilePoint: gmxTilePoint\n\t                };\n\t                if (!resCanvas) {\n\t                    resCanvas = document.createElement('canvas');\n\t                    resCanvas.width = resCanvas.height = 256;\n\t                }\n\t                var prepareItem = function prepareItem(imageElement) {\n\t                    var promise = _this._rasterHook({\n\t                        geoItem: geo,\n\t                        res: resCanvas,\n\t                        image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\n\t                        destinationTilePoint: gmxTilePoint,\n\t                        url: url\n\t                    }),\n\t                        then = function then() {\n\t                        rasters[idr] = resCanvas;\n\t                        itemRasterPromise.resolve();\n\t                    };\n\t                    if (promise) {\n\t                        if (promise instanceof L.gmx.Deferred) {\n\t                            promise.then(then);\n\t                        }\n\t                    } else if (promise === null) {\n\t                        item.skipRasters = true;\n\t                        itemRasterPromise.resolve();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                };\n\t                prepareItem(img);\n\t                delete _this.rasterRequests[url];\n\t            };\n\t            if (imageItem) {\n\t                imageLoaded(imageItem);\n\t            } else {\n\t                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\n\t            }\n\t        }\n\t        itemRasterPromise.always(function () {\n\t            mainRasterLoader = null;\n\t            if (recursiveLoaders) {\n\t                recursiveLoaders = null;\n\t            }\n\t        });\n\t        return itemRasterPromise;\n\t    },\n\t\n\t    _getVisibleItems: function _getVisibleItems(geoItems) {\n\t        if (geoItems.length < 2) {\n\t            this.itemsView = geoItems;\n\t            return geoItems;\n\t        }\n\t        if (!_Utils.gmxAPIutils._tileCanvas) {\n\t            _Utils.gmxAPIutils._tileCanvas = document.createElement('canvas');\n\t            _Utils.gmxAPIutils._tileCanvas.width = _Utils.gmxAPIutils._tileCanvas.height = 256;\n\t        }\n\t        var i,\n\t            len,\n\t            gmx = this.gmx,\n\t            dm = gmx.dataManager,\n\t            canvas = _Utils.gmxAPIutils._tileCanvas,\n\t            ctx = canvas.getContext('2d'),\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.imageSmoothingEnabled = false;\n\t        for (i = 0, len = geoItems.length; i < len; i++) {\n\t            ctx.fillStyle = _Utils.gmxAPIutils.dec2rgba(i + 1, 1);\n\t            var geoItem = geoItems[i];\n\t            L.gmxUtil.drawGeoItem(geoItem, dm.getItem(geoItem.properties[0]), dattr, { fillStyle: ctx.fillStyle });\n\t        }\n\t        var items = {},\n\t            data = ctx.getImageData(0, 0, 256, 256).data;\n\t\n\t        for (i = 0, len = data.length; i < len; i += 4) {\n\t            if (data[i + 3] === 255) {\n\t                var color = data[i + 2];\n\t                if (data[i + 1]) {\n\t                    color += data[i + 1] << 8;\n\t                }\n\t                if (data[i]) {\n\t                    color += data[i] << 16;\n\t                }\n\t                if (color) {\n\t                    items[color] = true;\n\t                }\n\t            }\n\t        }\n\t        var out = [];\n\t        for (var num in items) {\n\t            var it = geoItems[Number(num) - 1];\n\t            if (it) {\n\t                out.push(it);\n\t            }\n\t        }\n\t        this.itemsView = out;\n\t        return out;\n\t    },\n\t\n\t    _getNeedRasterItems: function _getNeedRasterItems(geoItems) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            tbounds = this.tbounds,\n\t            out = [];\n\t        for (var i = 0, len = geoItems.length; i < len; i++) {\n\t            var geo = geoItems[i],\n\t                properties = geo.properties,\n\t                idr = properties[0],\n\t                dataOption = geo.dataOption || {},\n\t                skipRasters = false;\n\t\n\t            if (gmx.quicklookBGfunc && !_Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\n\t                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) {\n\t                    continue;\n\t                }\n\t                var platform = _Utils.gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\n\t                if ((!platform || platform === 'imageMercator') && !_Utils.gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)) {\n\t                    continue;\n\t                }\n\t            }\n\t\n\t            if (gmx.styleHook) {\n\t                geo.styleExtend = gmx.styleHook(gmx.dataManager.getItem(idr), gmx.lastHover && idr === gmx.lastHover.id);\n\t                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\n\t            }\n\t            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                out.push(geo);\n\t            }\n\t        }\n\t        return this._getVisibleItems(out);\n\t    },\n\t\n\t    _getTileRasters: function _getTileRasters(geoItems) {\n\t        //load all missing rasters for items we are going to render\n\t        var itemPromises = [],\n\t            def = new L.gmx.Deferred(function () {\n\t            itemPromises.forEach(function (promise) {\n\t                promise.cancel();\n\t            });\n\t            itemPromises = null;\n\t        }),\n\t            itemRasters = this._getNeedRasterItems(geoItems),\n\t            needLoadRasters = itemRasters.length;\n\t\n\t        if (needLoadRasters) {\n\t            var _this = this,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (needLoadRasters < 1) {\n\t                    def.resolve();\n\t                }\n\t            };\n\t            itemRasters.forEach(function (geo) {\n\t                var itemRasterPromise = _this._getItemRasters(geo);\n\t                itemRasterPromise.then(function () {\n\t                    needLoadRasters--;\n\t                    chkReadyRasters();\n\t                });\n\t                itemPromises.push(itemRasterPromise);\n\t            });\n\t        } else {\n\t            def.resolve();\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _chkItems: function _chkItems(data) {\n\t        var layer = this.layer;\n\t        if (!layer._map) {\n\t            return null;\n\t        }\n\t        var items = data && data.added && data.added.length ? data.added : null;\n\t\n\t        if (!items) {\n\t            var tLink = layer._tiles[this.zKey];\n\t            if (tLink && tLink.el) {\n\t                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\n\t            }\n\t            return null;\n\t        }\n\t        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\n\t    },\n\t\n\t    _cancelRastersPromise: function _cancelRastersPromise() {\n\t        if (this.rastersPromise) {\n\t            this.rastersPromise.cancel();\n\t            this.rastersPromise = null;\n\t        }\n\t    },\n\t\n\t    drawTile: function drawTile(data) {\n\t        var drawPromise = this.currentDrawPromise,\n\t            _this = this;\n\t\n\t        this._uniqueID++; // count draw attempt\n\t\n\t        if (drawPromise) {\n\t            this._cancelRastersPromise();\n\t            if (this._preRenderPromise) {\n\t                this._preRenderPromise.cancel(); // cancel preRenderHooks chain if exists\n\t            }\n\t            if (this._renderPromise) {\n\t                this._renderPromise.cancel(); // cancel renderHooks chain if exists\n\t            }\n\t            drawPromise.reject();\n\t        }\n\t        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\n\t        drawPromise.always(function () {\n\t            _this._drawDone();\n\t            _this.currentDrawPromise = null;\n\t            _this.rastersPromise = null;\n\t            _this._preRenderPromise = null;\n\t            _this._renderPromise = null;\n\t        });\n\t\n\t        this.currentDrawPromise = drawPromise;\n\t\n\t        var geoItems = this._chkItems(data);\n\t        if (!geoItems) {\n\t            drawPromise.resolve();\n\t            return drawPromise;\n\t        }\n\t        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\n\t            tile = tileLink.el,\n\t            ctx = tile.getContext('2d'),\n\t            gmx = this.gmx,\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            rasters: this.rasters,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        tile.zKey = tileLink.el._zKey = this.zKey;\n\t\n\t        var doDraw = function doDraw() {\n\t            ctx.clearRect(0, 0, 256, 256);\n\t            var hookInfo = {\n\t                tpx: _this.tpx,\n\t                tpy: _this.tpy,\n\t                x: _this.tilePoint.x,\n\t                y: _this.tilePoint.y,\n\t                z: _this.zoom\n\t            },\n\t                bgImage = null;\n\t\n\t            _this._preRenderPromise = new L.gmx.Deferred();\n\t            _this._preRenderPromise.resolve(bgImage);\n\t\n\t            gmx.preRenderHooks.forEach(function (f) {\n\t                _this._preRenderPromise = _this._preRenderPromise.then(function (hookBgImage) {\n\t\n\t                    //in-place modifications are possible\n\t                    bgImage = hookBgImage || bgImage;\n\t\n\t                    if (!bgImage) {\n\t                        bgImage = document.createElement('canvas');\n\t                        bgImage.width = bgImage.height = 256;\n\t                    }\n\t                    return f(bgImage, hookInfo);\n\t                });\n\t            });\n\t            _this._preRenderPromise.then(function (hookBgImage) {\n\t                bgImage = hookBgImage || bgImage;\n\t                if (bgImage) {\n\t                    dattr.bgImage = bgImage;\n\t                }\n\t                //ctx.save();\n\t                for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                    var geoItem = geoItems[i],\n\t                        id = geoItem.id,\n\t                        item = gmx.dataManager.getItem(id);\n\t                    if (item) {\n\t                        // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\n\t                        var style = gmx.styleManager.getObjStyle(item),\n\t                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\n\t\n\t                        if (gmx.multiFilters) {\n\t                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                                var it = item.multiFilters[j];\n\t                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\n\t                            }\n\t                        } else {\n\t                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\n\t                        }\n\t                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\n\t                            gmx._needPopups[id] = true;\n\t                        }\n\t                    }\n\t                }\n\t                //ctx.restore();\n\t                _this.rasters = {}; // clear rasters\n\t                if (_this.layer._map && !tile.parentNode) {\n\t                    _this.layer.appendTileToContainer(tile);\n\t                }\n\t                //async chain\n\t                _this._renderPromise = new L.gmx.Deferred();\n\t                _this._renderPromise.resolve(tile);\n\t                gmx.renderHooks.forEach(function (f) {\n\t                    _this._renderPromise = _this._renderPromise.then(function (hookTile) {\n\t                        tile = hookTile || tile;\n\t                        return f(tile, hookInfo);\n\t                    });\n\t                });\n\t                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\n\t            }, drawPromise.reject);\n\t        };\n\t\n\t        if (this.showRaster) {\n\t            this.rastersPromise = this._getTileRasters(geoItems);\n\t            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\n\t        } else {\n\t            doDraw();\n\t        }\n\t\n\t        return drawPromise;\n\t    },\n\t\n\t    destructor: function destructor() {\n\t        this._cancelRastersPromise();\n\t        this._clearCache();\n\t\n\t        this.currentDrawPromise && this.currentDrawPromise.reject();\n\t    },\n\t\n\t    _drawDone: function _drawDone() {\n\t        for (var url in this.rasterRequests) {\n\t            var req = this.rasterRequests[url];\n\t            if (this._uniqueID !== req.options.tileRastersId) {\n\t                req.remove();\n\t                delete this.rasterRequests[url];\n\t            }\n\t        }\n\t        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\n\t    },\n\t\n\t    _clearCache: function _clearCache() {\n\t        for (var url in this.rasterRequests) {\n\t            this.rasterRequests[url].remove();\n\t        }\n\t        this.rasterRequests = {};\n\t    }\n\t};\n\texports.ScreenVectorTile = ScreenVectorTile;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * ObjectsReorder  - Reorder objects in Gemixer layer\r\n\t */\n\t(function () {\n\t\n\t    var MAX = 1000000,\n\t        ObjectsReorder = function ObjectsReorder(layer) {\n\t        this.all = {};\n\t        this.userSetSortFunc = false; // user sort func flag\n\t        this.sortFunc = null;\n\t        this.count = 0;\n\t        this.disabled = false;\n\t        this.layer = layer;\n\t        layer.on('add', this.onAdd, this);\n\t        layer.on('remove', this.onRemove, this);\n\t    };\n\t    ObjectsReorder.prototype = {\n\t        addToReorder: function addToReorder(id, bottomFlag) {\n\t            ++this.count;\n\t            this.all[id] = bottomFlag ? -this.count : this.count;\n\t        },\n\t        clickFunc: function clickFunc(ev) {\n\t            if (!this.disabled) {\n\t                var id = ev.gmx.id;\n\t                this.addToReorder(id, ev.originalEvent.ctrlKey);\n\t                this.layer.redrawItem(id);\n\t            }\n\t        },\n\t        sortItems: function sortItems(a, b) {\n\t            // layer context\n\t            var reorder = this._objectsReorder;\n\t            if (reorder.count > 0) {\n\t                var ap = reorder.all[a.id],\n\t                    bp = reorder.all[b.id];\n\t\n\t                if (ap || bp) {\n\t                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\n\t                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\n\t                    return ap - bp;\n\t                }\n\t            }\n\t            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\n\t        },\n\t        resetSortFunc: function resetSortFunc() {\n\t            var layer = this.layer,\n\t                gmx = layer._gmx,\n\t                zIndexField = gmx.zIndexField;\n\t            gmx.sortItems = this.sortItems;\n\t            this.sortFunc = zIndexField && !this.userSetSortFunc ? function (a, b) {\n\t                // layer context\n\t                var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\n\t                return res ? res : a.id - b.id;\n\t            } : function (a, b) {\n\t                return a.id - b.id;\n\t            };\n\t        },\n\t        initialize: function initialize() {\n\t            var gmx = this.layer._gmx;\n\t            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\n\t                this.resetSortFunc();\n\t            }\n\t        },\n\t        onAdd: function onAdd() {\n\t            this.initialize();\n\t            this.layer.on('click', this.clickFunc, this);\n\t        },\n\t        onRemove: function onRemove() {\n\t            this.layer.off('click', this.clickFunc, this);\n\t        }\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t        _objectsReorder: null,\n\t\n\t        _objectsReorderInit: function _objectsReorderInit() {\n\t            if (!this._objectsReorder) {\n\t                this._objectsReorder = new ObjectsReorder(this);\n\t            }\n\t        },\n\t\n\t        getReorderArrays: function getReorderArrays() {\n\t            var out = { top: [], bottom: [] };\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder,\n\t                    arr = Object.keys(reorder.all).sort(function (a, b) {\n\t                    return reorder.all[a] - reorder.all[b];\n\t                });\n\t\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var id = arr[i];\n\t                    if (reorder.all[id] > 0) {\n\t                        out.top.push(id);\n\t                    } else {\n\t                        out.bottom.push(id);\n\t                    }\n\t                }\n\t            }\n\t            return out;\n\t        },\n\t\n\t        bringToTopItem: function bringToTopItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        bringToBottomItem: function bringToBottomItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id, true);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        clearReorderArrays: function clearReorderArrays() {\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder;\n\t                reorder.all = {};\n\t                reorder.count = 0;\n\t                this.repaint();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        setReorderArrays: function setReorderArrays(top, bottom) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.all = {};\n\t            reorder.count = 0;\n\t            bottom.forEach(function (id) {\n\t                reorder.addToReorder(id, true);\n\t            });\n\t            top.forEach(function (id) {\n\t                reorder.addToReorder(id);\n\t            });\n\t            this.repaint();\n\t            return this;\n\t        },\n\t\n\t        getSortedItems: function getSortedItems(arr) {\n\t            this._objectsReorderInit();\n\t            return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\n\t        },\n\t\n\t        setSortFunc: function setSortFunc(func) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.sortFunc = func;\n\t            reorder.userSetSortFunc = func ? true : false;\n\t            this._gmx.sortItems = reorder.sortItems;\n\t            this.repaint();\n\t            return this;\n\t        },\n\t        disableFlip: function disableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = true;\n\t            return this;\n\t        },\n\t        enableFlip: function enableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = false;\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.VectorLayer.include({\n\t    bindPopup: function bindPopup(content, options) {\n\t        var popupOptions = L.extend({ maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID }, options);\n\t\n\t        if (this._popup) {\n\t            this.unbindPopup();\n\t        }\n\t        if (content instanceof L.Popup) {\n\t            this._popup = content;\n\t        } else {\n\t            if (!this._popup || options) {\n\t                this._popup = new L.Popup(popupOptions);\n\t            }\n\t            this._popup.setContent(content);\n\t        }\n\t        this._popup._initContent = content;\n\t        this._popup._state = '';\n\t\n\t        if (!this._popupHandlersAdded) {\n\t            this.on('click', this._openClickPopup, this).on('mousemove', this._movePopup, this).on('mouseover', this._overPopup, this).on('mouseout', this._outPopup, this).on('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupHandlersAdded = true;\n\t        }\n\t        if (popupOptions && popupOptions.popupopen) {\n\t            this._popupopen = popupOptions.popupopen;\n\t        }\n\t\n\t        this._popup.updateLayout = this._popup._updateLayout;\n\t\n\t        return this;\n\t    },\n\t\n\t    unbindPopup: function unbindPopup() {\n\t        if (this._popup) {\n\t            this._popup = null;\n\t            this.off('click', this._openClickPopup, this).off('mousemove', this._movePopup, this).off('mouseover', this._overPopup, this).off('mouseout', this._outPopup, this).off('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupopen = null;\n\t            this._popupHandlersAdded = false;\n\t        }\n\t        this._gmx.balloonEnable = false;\n\t        return this;\n\t    },\n\t\n\t    _chkNeedOpenPopup: function _chkNeedOpenPopup() {\n\t        for (var id in this._gmx._needPopups) {\n\t            if (this._gmx._needPopups[id]) {\n\t                this.addPopup(id);\n\t                delete this._gmx._needPopups[id];\n\t            }\n\t        }\n\t    },\n\t\n\t    disablePopup: function disablePopup() {\n\t        this._popupDisabled = true;\n\t        return this;\n\t    },\n\t\n\t    enablePopup: function enablePopup() {\n\t        this._popupDisabled = false;\n\t        return this;\n\t    },\n\t\n\t    openPopup: function openPopup(latlng, options) {\n\t\n\t        if (this._popup) {\n\t            // open the popup from one of the path's points if not specified\n\t            latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];\n\t\n\t            options = options || {};\n\t            options.latlng = latlng;\n\t            this._openPopup(options);\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    closePopup: function closePopup() {\n\t        if (this._popup) {\n\t            this._popup._close();\n\t            this.fire('popupclose', { popup: this._popup });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _movePopup: function _movePopup(options) {\n\t        if (this._popup._state === 'mouseover') {\n\t            var id = this._popup.options._gmxID || -1;\n\t            if (id !== options.gmx.id) {\n\t                this._setPopupContent(options);\n\t            }\n\t            this._popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _overPopup: function _overPopup(options) {\n\t        var _popup = this._popup;\n\t        if (!_popup._map) {\n\t            this._openPopup(options);\n\t        } else {\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: this._setPopupContent(options, _popup)\n\t            });\n\t        }\n\t        if (_popup._state === 'mouseover') {\n\t            _popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _outPopup: function _outPopup(ev) {\n\t        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\n\t            this.closePopup();\n\t        }\n\t    },\n\t\n\t    _callBalloonHook: function _callBalloonHook(props, div) {\n\t\n\t        var spans = div.getElementsByTagName('span'),\n\t            hooksCount = {},\n\t            key,\n\t            i,\n\t            len;\n\t        for (key in this._balloonHook) {\n\t            // collect hook counts\n\t            var hookID = this._balloonHook[key].hookID;\n\t            hooksCount[key] = 0;\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                if (spans[i].id === hookID) {\n\t                    hooksCount[key]++;\n\t                }\n\t            }\n\t        }\n\t\n\t        for (key in this._balloonHook) {\n\t            var hook = this._balloonHook[key],\n\t                fid = hook.hookID,\n\t                notFound = true;\n\t\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                var node = spans[i];\n\t                if (node.id === fid) {\n\t                    notFound = false;\n\t                    node.id += '_' + i;\n\t                    hook.callback(props, div, node, hooksCount);\n\t                }\n\t            }\n\t            if (notFound) {\n\t                hook.callback(props, div, null, hooksCount);\n\t            }\n\t        }\n\t    },\n\t\n\t    _setPopupContent: function _setPopupContent(options, _popup) {\n\t        if (!_popup) {\n\t            _popup = this._popup;\n\t        }\n\t        var gmx = options.gmx || {},\n\t            balloonData = gmx.balloonData || {},\n\t            properties = L.extend({}, gmx.properties),\n\t            target = gmx.target || {},\n\t            geometry = target.geometry || {},\n\t            offset = target.offset,\n\t            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\n\t            type = options.type,\n\t            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\n\t            outItem = {\n\t            id: gmx.id,\n\t            type: type,\n\t            nodePoint: gmx.nodePoint,\n\t            latlng: options.latlng,\n\t            properties: properties,\n\t            templateBalloon: templateBalloon\n\t        };\n\t\n\t        if (geometry.type === 'POINT') {\n\t            var coord = geometry.coordinates;\n\t            outItem.latlng = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t        }\n\t        if (offset) {\n\t            var protoOffset = L.Popup.prototype.options.offset;\n\t            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\n\t        }\n\t\n\t        if (this._popupopen) {\n\t            this._popupopen({\n\t                popup: _popup,\n\t                latlng: outItem.latlng,\n\t                layerPoint: options.layerPoint,\n\t                contentNode: _popup._contentNode,\n\t                containerPoint: options.containerPoint,\n\t                originalEvent: options.originalEvent,\n\t                gmx: outItem\n\t            });\n\t        } else if (!(templateBalloon instanceof L.Popup)) {\n\t            if (!(templateBalloon instanceof HTMLElement)) {\n\t                var geometries,\n\t                    summary = '',\n\t                    unitOptions = this._map ? this._map.options : {};\n\t\n\t                if (!skipSummary) {\n\t                    geometries = target.geometry ? [target.geometry] : gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || [];\n\t                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                if (this._balloonHook) {\n\t                    if (!templateBalloon) {\n\t                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\n\t                    }\n\t                    for (var key in this._balloonHook) {\n\t                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\n\t                    }\n\t                }\n\t                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: this._gmx.tileAttributeTypes,\n\t                    unitOptions: unitOptions,\n\t                    summary: summary,\n\t                    geometries: geometries\n\t                });\n\t            }\n\t\n\t            var contentDiv = L.DomUtil.create('div', '');\n\t            contentDiv.innerHTML = templateBalloon;\n\t            _popup.setContent(contentDiv);\n\t            if (this._balloonHook) {\n\t                this._callBalloonHook(gmx.properties, _popup.getContent());\n\t            }\n\t            //outItem.templateBalloon = templateBalloon;\n\t        }\n\t        _popup.options._gmxID = gmx.id;\n\t        return outItem;\n\t    },\n\t\n\t    _openClickPopup: function _openClickPopup(options) {\n\t        var originalEvent = options.originalEvent || {},\n\t            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                gmx = options.gmx,\n\t                balloonData = gmx.balloonData,\n\t                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\n\t                item = gmx.target;\n\t\n\t            if (flag && item.options.isGeneralized && !item.geometry) {\n\t                var layerProp = gmx.layer.getGmxProperties();\n\t                gmxAPIutils.getLayerItemFromServer({\n\t                    options: options,\n\t                    layerID: layerProp.name,\n\t                    value: item.id,\n\t                    field: layerProp.identityField\n\t                }).then(function (json, params) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        var pArr = json.Result.values[0];\n\t                        params.options.gmx.target.fromServerProps = pArr;\n\t                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\n\t                        this._openPopup(params.options);\n\t                    }\n\t                }.bind(this));\n\t            } else {\n\t                this._openPopup(options);\n\t            }\n\t        }\n\t    },\n\t\n\t    _openPopup: function _openPopup(options, notSkip) {\n\t        var map = this._map,\n\t            originalEvent = options.originalEvent || {},\n\t            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                _popup = this._popup,\n\t                gmx = options.gmx || {},\n\t                balloonData = gmx.balloonData || {};\n\t\n\t            if (type === 'click') {\n\t                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) {\n\t                    return;\n\t                }\n\t\n\t                if (!('_gmxPopups' in map)) {\n\t                    map._gmxPopups = [];\n\t                }\n\t                if (!('maxPopupCount' in map.options)) {\n\t                    map.options.maxPopupCount = 1;\n\t                }\n\t                if (!this._gmx._gmxPopupsInit) {\n\t                    this._gmx._gmxPopupsInit = true;\n\t                    map.on({\n\t                        layerremove: function layerremove(ev) {\n\t                            if (ev.layer instanceof L.Popup) {\n\t                                this._clearPopup(ev.layer);\n\t                            } else if (ev.layer === this) {\n\t                                if (map._gmxPopups) {\n\t                                    var layerId = this._gmx.layerID;\n\t                                    map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                                        if (c._map) {\n\t                                            if (c.options.layerId === layerId) {\n\t                                                c._map.removeLayer(c);\n\t                                            } else {\n\t                                                p.push(c);\n\t                                            }\n\t                                        }\n\t                                        return p;\n\t                                    }, []);\n\t                                }\n\t                                this.closePopup();\n\t                            }\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                this._clearPopup(gmx.id);\n\t                var opt = this._popup ? this._popup.options : { maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID };\n\t                _popup = new L.Popup(L.extend({}, opt, { closeOnClick: map.options.maxPopupCount === 1, autoPan: true }));\n\t            } else if (type === 'mouseover') {\n\t                if (balloonData.DisableBalloonOnMouseMove) {\n\t                    _popup._state = '';\n\t                    return;\n\t                }\n\t                _popup.options.autoPan = false;\n\t            } else {\n\t                return;\n\t            }\n\t            _popup.options.objectId = gmx.id;\n\t            _popup._state = type;\n\t            var outItem = this._setPopupContent(options, _popup);\n\t            _popup.setLatLng(outItem.latlng);\n\t\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: outItem\n\t            });\n\t            if (type === 'click') {\n\t                if (map._gmxPopups.length >= map.options.maxPopupCount) {\n\t                    map.removeLayer(map._gmxPopups.shift());\n\t                }\n\t                map._gmxPopups.push(_popup);\n\t            }\n\t            _popup.addTo(map); // this._map.openPopup(_popup);\n\t\n\t            if (_popup._closeButton) {\n\t                var closeStyle = _popup._closeButton.style;\n\t                if (type === 'mouseover' && closeStyle !== 'hidden') {\n\t                    closeStyle.visibility = 'hidden';\n\t                    _popup._container.style.marginBottom = '7px';\n\t                    _popup._container.style.pointerEvents = 'none';\n\t                } else if (type === 'click' && closeStyle !== 'inherit') {\n\t                    closeStyle.visibility = 'inherit';\n\t                    _popup._container.style.marginBottom = '';\n\t                    _popup._container.style.pointerEvents = '';\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _clearPopup: function _clearPopup(item /* <L.Popup> or objectId */) {\n\t        var map = this._map;\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID,\n\t                flagPopup = item instanceof L.Popup;\n\t            map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                if (c._map) {\n\t                    if (flagPopup && c === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else if (c.options.layerId === layerId && c.options.objectId === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else {\n\t                        p.push(c);\n\t                    }\n\t                }\n\t                return p;\n\t            }, []);\n\t        }\n\t    },\n\t\n\t    getPopups: function getPopups(flag) {\n\t        var map = this._map,\n\t            out = [];\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID;\n\t            map._gmxPopups.reduce(function (p, c) {\n\t                if (c.options.layerId === layerId) {\n\t                    p.push(flag ? c : c.options.objectId);\n\t                }\n\t                return p;\n\t            }, out);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    addPopup: function addPopup(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        if (!item || !this._map) {\n\t            gmx._needPopups[id] = false;\n\t        } else {\n\t            var center = item.bounds.getCenter(),\n\t                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\n\t            this._openPopup({\n\t                type: 'click',\n\t                latlng: latlng,\n\t                gmx: this.getHoverOption(item)\n\t            }, true);\n\t            delete gmx._needPopups[id];\n\t        }\n\t        return this;\n\t    },\n\t\n\t    addPopupHook: function addPopupHook(key, callback) {\n\t        if (!this._balloonHook) {\n\t            this._balloonHook = {};\n\t        }\n\t        if (!this._balloonHook[key]) {\n\t            var hookID = '_' + L.stamp({});\n\t            this._balloonHook[key] = {\n\t                key: key,\n\t                hookID: hookID,\n\t                resStr: '<span id=\"' + hookID + '\"></span>',\n\t                callback: callback\n\t            };\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removePopupHook: function removePopupHook(key) {\n\t        if (this._balloonHook) {\n\t            delete this._balloonHook[key];\n\t        }\n\t        return this;\n\t    }\n\t});\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx.VectorLayer.include({\n\t    _gmxFirstObjectsByPoint: function _gmxFirstObjectsByPoint(geoItems, mercPoint, bounds) {\n\t        // Получить верхний объект по координатам mouseClick\n\t        var gmx = this._gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            j,\n\t            len;\n\t\n\t        for (var i = geoItems.length - 1; i >= 0; i--) {\n\t            var geoItem = geoItems[i].properties,\n\t                idr = geoItem[0],\n\t                dataOption = geoItems[i].dataOption || {},\n\t                item = gmx.dataManager.getItem(idr),\n\t                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t                iconScale = currentStyle.iconScale || 1,\n\t                iconCenter = currentStyle.iconCenter,\n\t                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\n\t                parsedStyle = gmx.styleManager.getObjStyle(item),\n\t                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\n\t                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\n\t                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\n\t                offset = [iconScale * sx / 2, iconScale * sy / 2],\n\t                point = mercPoint,\n\t                geom = geoItem[geoItem.length - 1],\n\t                type = geom.type;\n\t\n\t            if (type === 'POINT' && parsedStyle.type === 'circle') {\n\t                offset[0] *= 2;\n\t                offset[1] *= 2;\n\t            }\n\t            var radius = offset[0],\n\t                objBounds = _Utils.gmxAPIutils.bounds().extendBounds(dataOption.bounds).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t            if (iconAnchor) {\n\t                offset = [iconAnchor[0] - offset[0], iconAnchor[1] - offset[1]];\n\t                point = [mercPoint[0] + offset[0] / mInPixel, mercPoint[1] - offset[1] / mInPixel];\n\t            }\n\t            if (!objBounds.contains(point)) {\n\t                continue;\n\t            }\n\t\n\t            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\n\t                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\n\t                chktype = type,\n\t                hiddenLines = dataOption.hiddenLines || [],\n\t                boundsArr = dataOption.boundsArr,\n\t                coords = geom.coordinates,\n\t                nodePoint = null,\n\t                ph = {\n\t                point: mercPoint,\n\t                bounds: bounds,\n\t                coords: coords,\n\t                boundsArr: boundsArr\n\t            };\n\t\n\t            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\n\t                if (marker) {\n\t                    chktype = 'POINT';\n\t                } else if (!fill) {\n\t                    if (type === 'POLYGON') {\n\t                        chktype = 'MULTILINESTRING';\n\t                        hiddenLines = hiddenLines[0];\n\t                    } else {\n\t                        chktype = 'LIKEMULTILINESTRING';\n\t                    }\n\t                    ph.hidden = hiddenLines;\n\t                }\n\t            }\n\t\n\t            if (chktype === 'LINESTRING') {\n\t                if (!_Utils.gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\n\t                    nodePoint = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'LIKEMULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                var flag = false;\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    ph.coords = coords[j];\n\t                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\n\t                    ph.boundsArr = boundsArr[j];\n\t                    if (_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                        flag = true;\n\t                        break;\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'MULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                ph.hidden = hiddenLines;\n\t                if (!_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                    var pBounds = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t                    for (j = 0, len = coords.length; j < len; j++) {\n\t                        nodePoint = pBounds.isNodeIntersect(coords[j]);\n\t                        if (nodePoint !== null) {\n\t                            nodePoint.ring = j;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\n\t                var chkPoint = mercPoint;\n\t                flag = false;\n\t                if (chktype === 'POLYGON') {\n\t                    coords = [geom.coordinates];\n\t                    boundsArr = [dataOption.boundsArr];\n\t                }\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    var arr = coords[j],\n\t                        bbox = boundsArr[j];\n\t                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\n\t                        var b = bbox[j1];\n\t                        if (b.intersects(bounds)) {\n\t                            if (_Utils.gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\n\t                                flag = j1 === 0 ? true : false;\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'POINT') {\n\t                if (parsedStyle.type === 'circle') {\n\t                    var x = (coords[0] - point[0]) * mInPixel,\n\t                        y = (coords[1] - point[1]) * mInPixel;\n\t                    if (x * x + y * y > radius * radius) {\n\t                        continue;\n\t                    }\n\t                }\n\t            }\n\t            if (!this.isPointInClipPolygons(mercPoint)) {\n\t                continue;\n\t            }\n\t\n\t            return {\n\t                id: idr,\n\t                properties: item.properties,\n\t                geometry: geom,\n\t                bounds: item.bounds,\n\t                nodePoint: nodePoint,\n\t                offset: iconAnchor ? offset : null,\n\t                parsedStyle: parsedStyle\n\t            };\n\t        }\n\t        return null;\n\t    },\n\t\n\t    gmxEventCheck: function gmxEventCheck(ev, skipOver) {\n\t        if (!this._map) {\n\t            return 0;\n\t        }\n\t        var layer = this,\n\t            gmx = layer._gmx,\n\t            type = ev.type,\n\t            lastHover = gmx.lastHover,\n\t            chkHover = function chkHover(evType) {\n\t            if (lastHover && type === 'mousemove') {\n\t                if (evType && layer.hasEventListeners(evType)) {\n\t                    ev.gmx = lastHover;\n\t                    layer.fire(evType, ev);\n\t                }\n\t                if (lastHover.hoverDiff) {\n\t                    layer.redrawItem(lastHover.id);\n\t                }\n\t            }\n\t        };\n\t\n\t        var zoom = this._map.getZoom();\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            skipOver = true;\n\t        }\n\t        if (skipOver) {\n\t            if (lastHover) {\n\t                lastHover.prevId = null;\n\t            }\n\t            chkHover('mouseout');\n\t            gmx.lastHover = null;\n\t        } else if (this.hasEventListeners('mouseover') || this.hasEventListeners('mouseout') || this.hasEventListeners(type) || type === 'mousemove' && gmx.properties.fromType !== 'Raster') {\n\t\n\t            var lng = ev.latlng.lng % 360,\n\t                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : lng > 180 ? -360 : 0)),\n\t                point = L.Projection.Mercator.project(latlng)._subtract({ x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0 }),\n\t                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\n\t                mercatorPoint = [point.x, point.y];\n\t\n\t            //создаём observer только для того, чтобы сделать выборку данных вокруг курсора\n\t            var observerOptions = {\n\t                type: 'resend',\n\t                bbox: _Utils.gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\n\t                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                active: false //делаем его неактивным, так как потом будем явно выбирать данные\n\t            };\n\t            if (this.options.isGeneralized) {\n\t                observerOptions.targetZoom = zoom;\n\t            }\n\t\n\t            gmx.dataManager.addObserver(observerOptions, 'hover');\n\t\n\t            var geoItems = gmx.dataManager.getItems('hover');\n\t\n\t            gmx.dataManager.removeObserver('hover');\n\t\n\t            if (geoItems && geoItems.length) {\n\t                if (geoItems.length > 1 && gmx.sortItems) {\n\t                    geoItems = this.getSortedItems(geoItems);\n\t                }\n\t\n\t                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\n\t                if (target) {\n\t                    var idr = target.id,\n\t                        item = gmx.dataManager.getItem(idr),\n\t                        prevId = lastHover ? lastHover.id : null,\n\t                        changed = !lastHover || lastHover.id !== idr;\n\t                    if (type === 'mousemove' && lastHover) {\n\t                        if (!changed) {\n\t                            ev.gmx = lastHover;\n\t                            this.fire(type, ev);\n\t                            return idr;\n\t                        }\n\t                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\n\t                        gmx.lastHover = null;\n\t                    }\n\t\n\t                    ev.gmx = L.extend(this.getHoverOption(item), {\n\t                        targets: geoItems,\n\t                        nodePoint: target.nodePoint,\n\t                        prevId: prevId,\n\t                        hoverDiff: item.hoverDiff\n\t                    });\n\t                    if (this.hasEventListeners(type)) {\n\t                        this.fire(type, ev);\n\t                    }\n\t                    if (type === 'mousemove' && changed) {\n\t                        lastHover = gmx.lastHover = ev.gmx;\n\t                        chkHover('mouseover');\n\t                        gmx.lastMouseover = gmx.lastHover;\n\t                    }\n\t                    this._map.doubleClickZoom.disable();\n\t                    return idr;\n\t                }\n\t            }\n\t        }\n\t        if (this._map) {\n\t            this._map.doubleClickZoom.enable();\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    getHoverOption: function getHoverOption(item) {\n\t        return {\n\t            layer: this,\n\t            target: item,\n\t            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\n\t            properties: this.getItemProperties(item.properties),\n\t            currentFilter: item.currentFilter || 0,\n\t            id: item.id\n\t        };\n\t    }\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t(function () {\n\t    var delay = 20000,\n\t        layers = {},\n\t        dataManagersLinks = {},\n\t        script = '/Layer/CheckVersion.ashx',\n\t        intervalID = null,\n\t        timeoutID = null,\n\t        lastLayersStr = '';\n\t\n\t    var isExistsTiles = function isExistsTiles(prop) {\n\t        var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\n\t        return tilesKey in prop;\n\t    };\n\t    var getParams = function getParams(prop, dm, layerDateInterval) {\n\t        var pt = {\n\t            Name: prop.name,\n\t            Version: isExistsTiles(prop) ? prop.LayerVersion : -1\n\t        };\n\t        if (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\n\t            var maxDateInterval = dm.getMaxDateInterval(),\n\t                beginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\n\t                endDate = maxDateInterval.endDate || layerDateInterval.endDate;\n\t            if (beginDate) {\n\t                pt.dateBegin = Math.floor(beginDate.getTime() / 1000);\n\t            }\n\t            if (endDate) {\n\t                pt.dateEnd = Math.floor(endDate.getTime() / 1000);\n\t            }\n\t        }\n\t        return pt;\n\t    };\n\t    var getRequestParams = function getRequestParams(layer) {\n\t        var hosts = {},\n\t            prop,\n\t            hostName,\n\t            dm,\n\t            layerDateInterval;\n\t        if (layer) {\n\t            if (layer instanceof L.gmx.DataManager) {\n\t                dm = layer;\n\t                prop = dm.options;\n\t            } else {\n\t                prop = layer._gmx.properties;\n\t                dm = layer._gmx.dataManager;\n\t                layerDateInterval = layer._gmx;\n\t            }\n\t            hostName = prop.hostName || layer._gmx.hostName;\n\t            hosts[hostName] = [getParams(prop, dm, layerDateInterval)];\n\t        } else {\n\t            var skipItems = {};\n\t            for (var id in layers) {\n\t                var obj = layers[id],\n\t                    isDataManager = obj instanceof L.gmx.DataManager;\n\t                if (obj.options.chkUpdate || isDataManager) {\n\t                    dm = isDataManager ? obj : obj._gmx.dataManager;\n\t                    prop = isDataManager ? obj.options : obj._gmx.properties;\n\t                    layerDateInterval = isDataManager ? obj : obj._gmx;\n\t                    hostName = prop.hostName || obj._gmx.hostName;\n\t                    var pt = getParams(prop, dm, layerDateInterval),\n\t                        key = pt.Name + pt.Version;\n\t                    if (!skipItems[key]) {\n\t                        if (hosts[hostName]) {\n\t                            hosts[hostName].push(pt);\n\t                        } else {\n\t                            hosts[hostName] = [pt];\n\t                        }\n\t                    }\n\t                    skipItems[key] = true;\n\t                }\n\t            }\n\t        }\n\t        return hosts;\n\t    };\n\t\n\t    var chkVersion = function chkVersion(layer, callback) {\n\t        var processResponse = function processResponse(res) {\n\t            if (res && res.Status === 'ok' && res.Result) {\n\t                for (var i = 0, len = res.Result.length; i < len; i++) {\n\t                    var item = res.Result[i],\n\t                        id = item.properties.name;\n\t\n\t                    if (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) {\n\t                        layer.updateVersion(item);\n\t                    }\n\t                    for (var key in layers) {\n\t                        var curLayer = layers[key];\n\t                        if (layer && layer === curLayer) {\n\t                            continue;\n\t                        }\n\t                        if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\n\t                            // слои\n\t                            curLayer.updateVersion(item);\n\t                        } else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\n\t                            // источники данных\n\t                            curLayer.updateVersion(item.properties);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            lastLayersStr = '';\n\t            if (callback) {\n\t                callback(res);\n\t            }\n\t        };\n\t\n\t        if (document.body && !_Utils.gmxAPIutils.isPageHidden()) {\n\t            var hosts = getRequestParams(layer),\n\t                chkHost = function chkHost(hostName) {\n\t                var url = 'http://' + hostName + script,\n\t                    layersStr = JSON.stringify(hosts[hostName]);\n\t\n\t                if (lastLayersStr !== layersStr) {\n\t                    lastLayersStr = layersStr;\n\t                    if ('FormData' in window) {\n\t                        _Utils.gmxAPIutils.request({\n\t                            url: url,\n\t                            async: true,\n\t                            headers: {\n\t                                'Content-type': 'application/x-www-form-urlencoded'\n\t                            },\n\t                            type: 'POST',\n\t                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\n\t                            withCredentials: true,\n\t                            callback: function callback(response) {\n\t                                processResponse(JSON.parse(response));\n\t                            },\n\t                            onError: function onError(response) {\n\t                                console.log('Error: LayerVersion ', response);\n\t                            }\n\t                        });\n\t                    } else {\n\t                        _Utils.gmxAPIutils.sendCrossDomainPostRequest(url, {\n\t                            WrapStyle: 'message',\n\t                            layers: layersStr\n\t                        }, processResponse);\n\t                    }\n\t                    var timeStamp = Date.now();\n\t                    for (var key in layers) {\n\t                        var it = layers[key];\n\t                        var options = it._gmx || it.options;\n\t                        if (options.hostName === hostName) {\n\t                            options._stampVersionRequest = timeStamp;\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t            for (var hostName in hosts) {\n\t                chkHost(hostName);\n\t            }\n\t        }\n\t    };\n\t\n\t    var layersVersion = {\n\t\n\t        addDataManager: function addDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t            dataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\n\t            layers[id] = dataManager;\n\t        },\n\t\n\t        removeDataManager: function removeDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                dataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\n\t                delete layers[id];\n\t            }\n\t        },\n\t\n\t        remove: function remove(layer) {\n\t            delete layers[layer._leaflet_id];\n\t            var _gmx = layer._gmx,\n\t                pOptions = layer.options.parentOptions;\n\t            if (pOptions) {\n\t                var pId = pOptions.name;\n\t                if (dataManagersLinks[pId]) {\n\t                    delete dataManagersLinks[pId][_gmx.properties.name];\n\t                    if (!Object.keys(dataManagersLinks[pId]).length) {\n\t                        layersVersion.removeDataManager(_gmx.dataManager);\n\t                        delete dataManagersLinks[pId];\n\t                    }\n\t                }\n\t            } else {\n\t                _gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\n\t            }\n\t        },\n\t\n\t        add: function add(layer) {\n\t            var id = layer._leaflet_id;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t\n\t            var _gmx = layer._gmx,\n\t                prop = _gmx.properties;\n\t            if ('LayerVersion' in prop) {\n\t                layers[id] = layer;\n\t                _gmx._chkVersion = function () {\n\t                    chkVersion(layer);\n\t                };\n\t                _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\n\t                var pOptions = layer.options.parentOptions;\n\t                if (pOptions) {\n\t                    var pId = pOptions.name;\n\t                    layersVersion.addDataManager(_gmx.dataManager);\n\t                    if (!dataManagersLinks[pId]) {\n\t                        dataManagersLinks[pId] = {};\n\t                    }\n\t                    dataManagersLinks[pId][prop.name] = layer;\n\t                }\n\t\n\t                layersVersion.start();\n\t                if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\n\t                    layersVersion.now();\n\t                }\n\t            }\n\t        },\n\t\n\t        chkVersion: chkVersion,\n\t\n\t        now: function now() {\n\t            if (timeoutID) {\n\t                clearTimeout(timeoutID);\n\t            }\n\t            timeoutID = setTimeout(chkVersion, 0);\n\t        },\n\t\n\t        stop: function stop() {\n\t            if (intervalID) {\n\t                clearInterval(intervalID);\n\t            }\n\t            intervalID = null;\n\t        },\n\t\n\t        start: function start(msec) {\n\t            if (msec) {\n\t                delay = msec;\n\t            }\n\t            layersVersion.stop();\n\t            intervalID = setInterval(chkVersion, delay);\n\t        }\n\t    };\n\t\n\t    if (!L.gmx) {\n\t        L.gmx = {};\n\t    }\n\t    L.gmx.layersVersion = layersVersion;\n\t\n\t    L.gmx.VectorLayer.include({\n\t        updateVersion: function updateVersion(layerDescription) {\n\t            if (layerDescription) {\n\t                var gmx = this._gmx;\n\t                if (layerDescription.geometry) {\n\t                    gmx.geometry = layerDescription.geometry;\n\t                }\n\t                if (layerDescription.properties) {\n\t                    L.extend(gmx.properties, layerDescription.properties);\n\t                    gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\n\t                    gmx.rawProperties = gmx.properties;\n\t                    this.fire('versionchange');\n\t                    if (!gmx.dataSource) {\n\t                        gmx.dataManager.updateVersion(gmx.rawProperties);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//Raster layer is just vector layer with the single object and special background tiles\n\tL.gmx.RasterLayer = L.gmx.VectorLayer.extend({\n\t    options: {\n\t        isGeneralized: false,\n\t        zIndexOffset: 0\n\t        //clickable: false\n\t    },\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var props = ph.properties,\n\t            styles = props.styles[0] || { MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21 },\n\t            vectorProperties = {\n\t            type: 'Vector',\n\t            fromType: props.type,\n\t            identityField: 'ogc_fid',\n\t            GeometryType: 'POLYGON',\n\t            IsRasterCatalog: true,\n\t            Copyright: props.Copyright || '',\n\t            RCMinZoomForRasters: styles.MinZoom,\n\t            visible: props.visible,\n\t            styles: [{\n\t                DisableBalloonOnClick: true,\n\t                MinZoom: styles.MinZoom,\n\t                MaxZoom: styles.MaxZoom,\n\t                RenderStyle: { outline: { thickness: 0 }, fill: { opacity: 100 } },\n\t                HoverStyle: null\n\t            }]\n\t        },\n\t            gmx = this._gmx,\n\t            worldSize = gmxAPIutils.tileSizes[1];\n\t\n\t        if (props.MaxZoom) {\n\t            gmx.maxNativeZoom = props.MaxZoom;\n\t        }\n\t        if (!ph.geometry) {\n\t            ph.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        L.gmx.VectorLayer.prototype.initFromDescription.call(this, { geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties });\n\t\n\t        gmx.rasterBGfunc = function (x, y, z) {\n\t            return 'http://' + gmx.hostName + '/' + 'TileSender.ashx?ModeKey=tile' + '&key=' + encodeURIComponent(gmx.sessionKey) + '&LayerName=' + gmx.layerID + '&z=' + z + '&x=' + x + '&y=' + y;\n\t        };\n\t\n\t        var vectorDataProvider = { load: function load(x, y, z, v, s, d, callback) {\n\t                var objects = [[777, ph.geometry]],\n\t                    itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\n\t                    bounds = itemBounds.bounds;\n\t\n\t                if (bounds.max.x > worldSize) {\n\t                    // for old layers geometry\n\t                    var ww2 = 2 * worldSize,\n\t                        id = 777,\n\t                        coords = ph.geometry.coordinates,\n\t                        bboxArr = itemBounds.boundsArr;\n\t\n\t                    objects = [];\n\t                    if (ph.geometry.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                        bboxArr = [bboxArr];\n\t                    }\n\t\n\t                    for (var i = 0, len = coords.length; i < len; i++) {\n\t                        var it = coords[i],\n\t                            bbox = bboxArr[i][0],\n\t                            arr = it;\n\t                        objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        if (bbox.max.x > worldSize) {\n\t                            arr = [];\n\t                            for (var j = 0, len1 = it.length; j < len1; j++) {\n\t                                var it1 = it[j];\n\t                                for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\n\t                                    var it2 = it1[j1];\n\t                                    arr1.push([it2[0] - ww2, it2[1]]);\n\t                                }\n\t                                arr.push(arr1);\n\t                            }\n\t                            objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        }\n\t                    }\n\t                }\n\t                callback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\n\t            } };\n\t        gmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, { x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2 });\n\t        gmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\n\t\n\t        return this;\n\t    },\n\t\n\t    setZoomBounds: function setZoomBounds(minZoom, maxZoom) {\n\t        var styles = this.getStyles().slice(0);\n\t        styles[0] = L.extend({}, styles[0]);\n\t        styles[0].MinZoom = minZoom;\n\t        styles[0].MaxZoom = maxZoom;\n\t        this.setStyles(styles);\n\t    }\n\t});\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.LabelsLayer = L.Class.extend({\n\t\n\t    options: {\n\t        pane: 'overlayPane'\n\t    },\n\t\n\t    initialize: function initialize(map, options) {\n\t        L.setOptions(this, options);\n\t        this._observers = {};\n\t        this._styleManagers = {};\n\t        this._labels = {};\n\t        var _this = this;\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds();\n\t\n\t        var chkData = function chkData(data, layer) {\n\t            if (!data.added && !data.removed) {\n\t                return;\n\t            }\n\t\n\t            var opt = layer.options,\n\t                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\n\t                layerId = '_' + layer._leaflet_id,\n\t                gmx = layer._gmx,\n\t                labels = {};\n\t\n\t            for (var i = 0, len = added.length; i < len; i++) {\n\t                var item = added[i].item,\n\t                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\n\t                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\n\t\n\t                if (gmx.styleHook) {\n\t                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\n\t                    if (styleExtend) {\n\t                        currentStyle = L.extend({}, currentStyle, styleExtend);\n\t                    } else {\n\t                        continue;\n\t                    }\n\t                }\n\t                if (item.multiFilters) {\n\t                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                        var st = item.multiFilters[j].parsedStyle;\n\t                        if ('labelField' in st || 'labelText' in st) {\n\t                            currentStyle = st;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var style = gmx.styleManager.getObjStyle(item) || {},\n\t                    labelText = currentStyle.labelText || style.labelText,\n\t                    labelField = currentStyle.labelField || style.labelField,\n\t                    fieldType = gmx.tileAttributeTypes[labelField],\n\t                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\n\t\n\t                if (style.labelTemplate) {\n\t                    var reg = /\\[([^\\]]*)\\]/g,\n\t                        match;\n\t                    txt = style.labelTemplate;\n\t\n\t                    while (match = reg.exec(style.labelTemplate)) {\n\t                        if (match.length === 2) {\n\t                            labelField = match[1];\n\t                            fieldType = gmx.tileAttributeTypes[labelField];\n\t                            var val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\n\t                            txt = txt.replace(match[0], val);\n\t                        }\n\t                    }\n\t                }\n\t                if (txt || txt === 0) {\n\t                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\n\t                        id = '_' + item.id,\n\t                        changed = true,\n\t                        width = 0,\n\t                        arrTxtWidth,\n\t                        options = item.options,\n\t                        labelStyle = {\n\t                        font: fontSize + 'px \"Arial\"',\n\t                        labelHaloColor: 'labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : 'labelHaloColor' in style ? style.labelHaloColor : 0xffffff,\n\t                        labelColor: currentStyle.labelColor || style.labelColor,\n\t                        labelAlign: currentStyle.labelAlign || style.labelAlign,\n\t                        labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\n\t                        labelFontSize: fontSize\n\t                    };\n\t                    if (options) {\n\t                        if (!('center' in options)) {\n\t                            var center = _Utils.gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\n\t                            if (!center) {\n\t                                continue;\n\t                            }\n\t                            options.center = center;\n\t                        }\n\t                        if (options.label) {\n\t                            width = options.label.width;\n\t                            arrTxtWidth = options.label.arrTxtWidth;\n\t                            var pstyle = options.label.style;\n\t                            changed = options.label.txt !== txt || pstyle.labelHaloColor !== labelStyle.labelHaloColor || pstyle.labelColor !== labelStyle.labelColor || pstyle.labelAlign !== labelStyle.labelAlign || pstyle.labelAnchor !== labelStyle.labelAnchor || pstyle.labelFontSize !== labelStyle.labelFontSize;\n\t                        }\n\t                    }\n\t                    if (changed) {\n\t                        width = 0;\n\t                        arrTxtWidth = _Utils.gmxAPIutils.getLabelWidth(txt, labelStyle);\n\t                        if (arrTxtWidth) {\n\t                            arrTxtWidth.forEach(function (it) {\n\t                                width = Math.max(width, it[1]);\n\t                            });\n\t                        }\n\t\n\t                        if (!width) {\n\t                            delete labels[id];\n\t                            continue;\n\t                        }\n\t                        width += 4;\n\t                        item.options.labelStyle = null;\n\t                    }\n\t                    options.label = {\n\t                        isPoint: isPoint,\n\t                        width: width,\n\t                        sx: style.sx || 0,\n\t                        txt: txt,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        style: labelStyle\n\t                    };\n\t                    labels[id] = item;\n\t                }\n\t            }\n\t            _this._labels[layerId] = labels;\n\t        };\n\t\n\t        var addObserver = function addObserver(layer) {\n\t            var gmx = layer._gmx,\n\t                filters = ['styleFilter', 'userFilter'],\n\t                options = {\n\t                type: 'resend',\n\t                bbox: _this.bbox,\n\t                filters: filters,\n\t                callback: function callback(data) {\n\t                    chkData(data, layer);\n\t                    _this.redraw();\n\t                }\n\t            };\n\t            if (gmx.beginDate && gmx.endDate) {\n\t                options.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t            return gmx.dataManager.addObserver(options, '_Labels');\n\t        };\n\t        this.add = function (layer) {\n\t            var id = layer._leaflet_id,\n\t                gmx = layer._gmx;\n\t\n\t            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\n\t                gmx.styleManager.deferred.then(function () {\n\t                    var observer = addObserver(layer),\n\t                        _zoom = _this._map._zoom;\n\t                    if (layer.options.isGeneralized) {\n\t                        observer.targetZoom = _zoom; //need update to current zoom\n\t                    }\n\t                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\n\t                        observer.deactivate();\n\t                    }\n\t                    _this._observers[id] = observer;\n\t                    _this._styleManagers[id] = gmx.styleManager;\n\t\n\t                    _this._labels['_' + id] = {};\n\t                    _this._updateBbox();\n\t                });\n\t            }\n\t        };\n\t        this.remove = function (layer) {\n\t            var id = layer._leaflet_id;\n\t            if (_this._observers[id]) {\n\t                var gmx = layer._gmx,\n\t                    dataManager = gmx.dataManager;\n\t                dataManager.removeObserver(_this._observers[id].id);\n\t                delete _this._observers[id];\n\t                delete _this._styleManagers[id];\n\t                delete _this._labels['_' + id];\n\t                _this.redraw();\n\t            }\n\t        };\n\t        this._layeradd = function (ev) {\n\t            _this.add(ev.layer);\n\t        };\n\t        this._layerremove = function (ev) {\n\t            _this.remove(ev.layer);\n\t        };\n\t    },\n\t\n\t    redraw: function redraw() {\n\t        if (!this._frame && !this._map._animating) {\n\t            this._frame = L.Util.requestAnimFrame(this._redraw, this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _addToPane: function _addToPane() {\n\t        var pane = this._map.getPanes()[this.options.pane];\n\t        if (pane) {\n\t            pane.insertBefore(this._canvas, pane.firstChild);\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        this._map = map;\n\t\n\t        if (!this._canvas) {\n\t            this._initCanvas();\n\t        }\n\t        // this._addToPane();\n\t\n\t        map.on('moveend', this._reset, this);\n\t        map.on({\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        });\n\t        if (map.options.zoomAnimation && L.Browser.any3d) {\n\t            map.on('zoomanim', this._animateZoom, this);\n\t        }\n\t\n\t        this._reset();\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._canvas.parentNode) {\n\t            this._canvas.parentNode.removeChild(this._canvas);\n\t        }\n\t\n\t        map.off('moveend', this._reset, this);\n\t        map.off('layeradd', this._layeradd);\n\t        map.off('layerremove', this._layerremove);\n\t\n\t        if (map.options.zoomAnimation) {\n\t            map.off('zoomanim', this._animateZoom, this);\n\t        }\n\t    },\n\t\n\t    addTo: function addTo(map) {\n\t        map.addLayer(this);\n\t        return this;\n\t    },\n\t\n\t    _initCanvas: function _initCanvas() {\n\t        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\n\t            size = this._map.getSize();\n\t        canvas.width = size.x;canvas.height = size.y;\n\t        canvas.style.pointerEvents = 'none';\n\t        this._canvas = canvas;\n\t\n\t        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n\t        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        var _map = this._map,\n\t            screenBounds = _map.getBounds(),\n\t            southWest = screenBounds.getSouthWest(),\n\t            northEast = screenBounds.getNorthEast(),\n\t            m1 = L.Projection.Mercator.project(southWest),\n\t            m2 = L.Projection.Mercator.project(northEast),\n\t            _zoom = _map.getZoom();\n\t\n\t        this.mInPixel = _Utils.gmxAPIutils.getPixelScale(_zoom);\n\t        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (observer.targetZoom) {\n\t                observer.targetZoom = _zoom;\n\t            }\n\t            observer.setBounds({\n\t                min: { x: southWest.lng, y: southWest.lat },\n\t                max: { x: northEast.lng, y: northEast.lat }\n\t            });\n\t        }\n\t    },\n\t\n\t    _reset: function _reset() {\n\t        this._updateBbox();\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (!observer.isActive() && this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())) {\n\t                observer.activate();\n\t            }\n\t            observer.fire('update');\n\t        }\n\t    },\n\t\n\t    _redraw: function _redraw() {\n\t        var out = [],\n\t            _map = this._map,\n\t            mapSize = _map.getSize(),\n\t            _canvas = this._canvas,\n\t            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\n\t            topLeft = _map.containerPointToLayerPoint(offset);\n\t\n\t        _canvas.width = mapSize.x;_canvas.height = mapSize.y;\n\t        L.DomUtil.setPosition(_canvas, topLeft);\n\t\n\t        var w2 = 2 * this.mInPixel * _Utils.gmxAPIutils.worldWidthMerc,\n\t            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\n\t            ctx = _canvas.getContext('2d'),\n\t            i,\n\t            len,\n\t            it;\n\t\n\t        for (var layerId in this._labels) {\n\t            var labels = this._labels[layerId];\n\t            for (var id in labels) {\n\t                it = labels[id];\n\t                var options = it.options,\n\t                    label = options.label,\n\t                    style = label.style,\n\t                    labelAlign = style.labelAlign || 'center',\n\t                    arrTxtWidth = label.arrTxtWidth,\n\t                    count = arrTxtWidth.length || 1,\n\t                    width = label.width,\n\t                    width2 = width / 2,\n\t                    size = style.labelFontSize || 12,\n\t                    size2 = size / 2,\n\t                    center = options.center,\n\t                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\n\t                    isFiltered = false;\n\t\n\t                if (label.isPoint) {\n\t                    var delta = label.sx;\n\t                    if (labelAlign === 'left') {\n\t                        pos[0] += width2 + delta;\n\t                    } else if (labelAlign === 'right') {\n\t                        pos[0] -= width + delta;\n\t                    }\n\t                }\n\t                pos[0] -= width2 + this._ctxShift[0];\n\t                pos[1] = -size2 - pos[1] + this._ctxShift[1];\n\t                size2 *= count;\n\t                if (style.labelAnchor) {\n\t                    pos[0] += style.labelAnchor[0];\n\t                    pos[1] += style.labelAnchor[1];\n\t                }\n\t\n\t                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\n\t                    var coord = [Math.floor(tx), Math.floor(pos[1])],\n\t                        bbox = _Utils.gmxAPIutils.bounds([[coord[0] - width2, coord[1] - size2], [coord[0] + width2, coord[1] + size2]]);\n\t                    for (i = 0, len = out.length; i < len; i++) {\n\t                        if (bbox.intersects(out[i].bbox)) {\n\t                            isFiltered = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (isFiltered) {\n\t                        continue;\n\t                    }\n\t\n\t                    if (!options.labelStyle) {\n\t                        options.labelStyle = {\n\t                            font: size + 'px \"Arial\"',\n\t                            fillStyle: _Utils.gmxAPIutils.dec2color(style.labelColor || 0, 1),\n\t                            shadowBlur: 4\n\t                        };\n\t                        if (style.labelHaloColor !== -1) {\n\t                            options.labelStyle.strokeStyle = options.labelStyle.shadowColor = _Utils.gmxAPIutils.dec2color(style.labelHaloColor, 1);\n\t                        }\n\t                    }\n\t                    out.push({\n\t                        arr: it.properties,\n\t                        bbox: bbox,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        width2: labelAlign === 'center' ? width2 : 0,\n\t                        txt: label.txt,\n\t                        style: options.labelStyle,\n\t                        size: size,\n\t                        coord: coord\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        if (out.length) {\n\t            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\n\t            for (i = 0, len = out.length; i < len; i++) {\n\t                it = out[i];\n\t                it.arrTxtWidth.forEach(function (pt, nm) {\n\t                    var coord = [it.coord[0] + it.width2 - pt[1] / 2, it.coord[1] + nm * it.size];\n\t                    _Utils.gmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\n\t                });\n\t            }\n\t            if (!_canvas.parentNode) {\n\t                this._addToPane();\n\t            }\n\t        } else if (_canvas.parentNode) {\n\t            _canvas.parentNode.removeChild(_canvas);\n\t        }\n\t\n\t        this._frame = null;\n\t    },\n\t\n\t    _animateZoom: function _animateZoom(e) {\n\t        var scale = this._map.getZoomScale(e.zoom),\n\t            pixelBoundsMin = this._map.getPixelBounds().min;\n\t\n\t        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\n\t        if (pixelBoundsMin.y < 0) {\n\t            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\n\t        }\n\t\n\t        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\n\t    }\n\t}); /*\r\n\t     (c) 2014, Sergey Alekseev\r\n\t     Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n\t    */\n\t\n\t\n\tL.labelsLayer = function (map, options) {\n\t    return new L.LabelsLayer(map, options);\n\t};\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if Labels has already been initialized.\n\t    if (!this._labelsLayer) {\n\t        this._labelsLayer = new L.LabelsLayer(this);\n\t        this._labelsLayer.addTo(this);\n\t    }\n\t});\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var isBoundsIntersects = function isBoundsIntersects(bounds, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].intersects(bounds)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    var isObserverIntersects = function isObserverIntersects(observer, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (observer.intersects(bbox[j1])) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var _isPointInClipPolygons = function _isPointInClipPolygons(chkPoint, clipPolygons) {\n\t        if (!clipPolygons || Object.keys(clipPolygons).length === 0) {\n\t            return true;\n\t        }\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].contains(chkPoint)) {\n\t                            var coords = it.geometry.coordinates,\n\t                                isIn = false;\n\t                            if (type === 'Polygon') {\n\t                                coords = [coords];\n\t                            }\n\t                            for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\n\t                                if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\n\t                                    isIn = true;\n\t                                    break;\n\t                                }\n\t                            }\n\t                            if (isIn) {\n\t                                return true;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var getClipPolygonItem = function getClipPolygonItem(geo) {\n\t        var geometry = gmxAPIutils.convertGeometry(geo),\n\t            bboxArr = gmxAPIutils.geoItemBounds(geometry);\n\t        bboxArr.geometry = geometry;\n\t        return bboxArr;\n\t    };\n\t\n\t    var clipTileByPolygon = function clipTileByPolygon(dattr) {\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = canvas.height = 256;\n\t        var ctx = canvas.getContext('2d'),\n\t            clipPolygons = dattr.clipPolygons;\n\t\n\t        dattr.ctx = ctx;\n\t        ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\n\t\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var geo = arr[i].geometry,\n\t                    coords = geo.coordinates;\n\t                if (geo.type === 'Polygon') {\n\t                    coords = [coords];\n\t                }\n\t                for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\n\t                    var coords1 = coords[i1];\n\t                    ctx.beginPath();\n\t                    for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\n\t                        dattr.coords = coords1[j1];\n\t                        var pixels = gmxAPIutils.getRingPixels(dattr);\n\t                        dattr.coords = pixels.coords;\n\t                        gmxAPIutils.polygonToCanvasFill(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    ctx.fill();\n\t                }\n\t            }\n\t        }\n\t        ctx = dattr.tile.getContext('2d');\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.drawImage(canvas, 0, 0);\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t\n\t        isPointInClipPolygons: function isPointInClipPolygons(point) {\n\t            // point [x, y] in Mercator\n\t            return _isPointInClipPolygons(point, this._gmx._clipPolygons);\n\t        },\n\t\n\t        addClipPolygon: function addClipPolygon(polygon) {\n\t            // (L.Polygon) or (L.GeoJSON with Polygons)\n\t            var item = [],\n\t                i,\n\t                len;\n\t\n\t            if ('coordinates' in polygon && 'type' in polygon) {\n\t                item.push(getClipPolygonItem(polygon));\n\t            } else if (polygon instanceof L.Polygon) {\n\t                item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\n\t            } else if (polygon instanceof L.GeoJSON) {\n\t                var layers = polygon.getLayers();\n\t                for (i = 0, len = layers.length; i < len; i++) {\n\t                    var layer = layers[i];\n\t                    if (layer instanceof L.Polygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    } else if (layer instanceof L.MultiPolygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    }\n\t                }\n\t            }\n\t            if (item.length) {\n\t                var gmx = this._gmx,\n\t                    dataManager = gmx.dataManager,\n\t                    _this = this,\n\t                    id = L.stamp(polygon);\n\t\n\t                if (!this._gmx._clipPolygons) {\n\t                    this._gmx._clipPolygons = {};\n\t                }\n\t                this._gmx._clipPolygons[id] = item;\n\t                dataManager.setTileFilteringHook(function (tile) {\n\t                    return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipFilter', function (item, tile, observer) {\n\t                    return isObserverIntersects(observer, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipPointsFilter', function (item) {\n\t                    if (item.type === 'POINT') {\n\t                        var propArr = item.properties,\n\t                            geom = propArr[propArr.length - 1];\n\t                        return _isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\n\t                    }\n\t                    return true;\n\t                });\n\t                if (Object.keys(this._gmx._clipPolygons).length === 1) {\n\t                    gmx.renderHooks.unshift(function (tile, hookInfo) {\n\t                        if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\n\t                            clipTileByPolygon({\n\t                                tile: tile,\n\t                                tpx: hookInfo.tpx,\n\t                                tpy: hookInfo.tpy,\n\t                                gmx: { mInPixel: gmx.mInPixel },\n\t                                clipPolygons: _this._gmx._clipPolygons\n\t                            });\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        removeClipPolygon: function removeClipPolygon(polygon) {\n\t            var id = L.stamp(polygon);\n\t            if (this._gmx._clipPolygons) {\n\t                delete this._gmx._clipPolygons[id];\n\t                if (Object.keys(this._gmx._clipPolygons).length === 0) {\n\t                    this._gmx.dataManager.removeTileFilteringHook();\n\t                    this._gmx.dataManager.removeFilter('clipFilter');\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.gmxImageTransform = function (img, hash) {\n\t    var gmx = hash.gmx,\n\t        gmxTilePoint = hash.gmxTilePoint,\n\t        mInPixel = gmx.mInPixel,\n\t        geoItem = hash.geoItem,\n\t        properties = geoItem.properties,\n\t        dataOption = geoItem.dataOption || {},\n\t\n\t\n\t    // geom = properties[properties.length - 1],\n\t    // coord = geom.coordinates[0],\n\t    indexes = gmx.tileAttributeIndexes,\n\t        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\n\t        points = {};\n\t\n\t    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\n\t    if (quicklookPlatform === 'LANDSAT8') {\n\t        points.x1 = dataOption.bounds.min.x;points.y1 = dataOption.bounds.max.y;\n\t        points.x2 = dataOption.bounds.max.x;points.y2 = dataOption.bounds.max.y;\n\t        points.x3 = dataOption.bounds.max.x;points.y3 = dataOption.bounds.min.y;\n\t        points.x4 = dataOption.bounds.min.x;points.y4 = dataOption.bounds.min.y;\n\t    } else {\n\t        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\n\t    }\n\t\n\t    var x1 = mInPixel * points.x1,\n\t        y1 = mInPixel * points.y1,\n\t        x2 = mInPixel * points.x2,\n\t        y2 = mInPixel * points.y2,\n\t        x3 = mInPixel * points.x3,\n\t        y3 = mInPixel * points.y3,\n\t        x4 = mInPixel * points.x4,\n\t        y4 = mInPixel * points.y4,\n\t        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\n\t        ww = Math.round(boundsP.max.x - boundsP.min.x),\n\t        hh = Math.round(boundsP.max.y - boundsP.min.y),\n\t        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\n\t        itbounds = geoItem.item.bounds,\n\t        wMerc = gmxAPIutils.worldWidthMerc,\n\t        tpx = gmxTilePoint.x;\n\t\n\t    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\n\t        // For points intersects 180 deg\n\t        tpx += Math.round(wMerc * mInPixel / 128);\n\t    }\n\t    var dx = boundsP.min.x - 256 * tpx;\n\t\n\t    x1 -= boundsP.min.x;y1 = boundsP.max.y - y1;\n\t    x2 -= boundsP.min.x;y2 = boundsP.max.y - y2;\n\t    x3 -= boundsP.min.x;y3 = boundsP.max.y - y3;\n\t    x4 -= boundsP.min.x;y4 = boundsP.max.y - y4;\n\t\n\t    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\n\t\n\t    if (!gmx.ProjectiveImage) {\n\t        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\n\t    }\n\t    var pt = gmx.ProjectiveImage.getCanvas({\n\t        imageObj: img,\n\t        points: shiftPoints,\n\t        wView: ww,\n\t        hView: hh,\n\t        deltaX: dx,\n\t        deltaY: dy\n\t    });\n\t    return pt.canvas;\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var ProjectiveImageWebGL = L.Class.extend({\n\t        options: {\n\t            antialias: true,\n\t            depth: false,\n\t            preserveDrawingBuffer: true,\n\t            shaderVS: 'attribute vec2 aVertCoord;\\\r\n\t            uniform mat4 uTransformMatrix;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            void main(void) {\\\r\n\t                vTextureCoord = aVertCoord;\\\r\n\t                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n\t            }\\\r\n\t        ',\n\t            shaderFS: 'precision mediump float;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            uniform sampler2D uSampler;\\\r\n\t            void main(void) {\\\r\n\t                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n\t            }\\\r\n\t        '\n\t        },\n\t\n\t        setOptions: function setOptions(options) {\n\t            L.setOptions(this, options);\n\t        },\n\t\n\t        initialize: function initialize(options) {\n\t            this.setOptions(options);\n\t\n\t            var canvas = document.createElement('canvas'),\n\t                glOpts = {\n\t                antialias: this.options.antialias,\n\t                depth: this.options.depth,\n\t                preserveDrawingBuffer: this.options.preserveDrawingBuffer\n\t            },\n\t                gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\n\t            if (!gl) {\n\t                return;\n\t            }\n\t            var glResources = this._setupGlContext(gl);\n\t            if (!glResources) {\n\t                return;\n\t            }\n\t\n\t            canvas.width = canvas.height = 256;\n\t            glResources.canvas = canvas;\n\t\n\t            this.glResources = glResources;\n\t            this.canvas = canvas;\n\t            this.gl = gl;\n\t        },\n\t\n\t        _getShader: function _getShader(type, source, gl) {\n\t            var shader = gl.createShader(type);\n\t\n\t            gl.shaderSource(shader, source);\n\t            gl.compileShader(shader);\n\t\n\t            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t                gl.deleteShader(shader);\n\t                return null;\n\t            }\n\t            return shader;\n\t        },\n\t\n\t        _setupGlContext: function _setupGlContext(gl) {\n\t            // Store return values here\n\t            var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\n\t                fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\n\t\n\t            if (vertexShader && fragmentShader) {\n\t                // Compile the program\n\t                var shaderProgram = gl.createProgram();\n\t                gl.attachShader(shaderProgram, vertexShader);\n\t                gl.attachShader(shaderProgram, fragmentShader);\n\t                gl.linkProgram(shaderProgram);\n\t\n\t                if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n\t                    // Find and set up the uniforms and attributes\n\t                    gl.useProgram(shaderProgram);\n\t                    this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n\t                    var vertexBuffer = gl.createBuffer(),\n\t\n\t                    // Create a buffer to hold the vertices\n\t                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\n\t                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\t                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n\t\n\t                    // draw the triangles\n\t                    gl.enableVertexAttribArray(vertAttrib);\n\t                    gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\n\t                    return {\n\t                        transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\n\t                        samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\n\t                        screenTexture: gl.createTexture() // Create a texture to use for the screen image\n\t                    };\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        _bindTexture: function _bindTexture(gl, image, texture) {\n\t            gl.bindTexture(gl.TEXTURE_2D, texture);\n\t            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\n\t            // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t            // Prevents s-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t            // Prevents t-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t            gl.bindTexture(gl.TEXTURE_2D, null);\n\t        },\n\t\n\t        getCanvas: function getCanvas(attr) {\n\t            var p = attr.points,\n\t                deltaX = attr.deltaX,\n\t                deltaY = attr.deltaY,\n\t                dstPoints = new Float32Array([(p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128, (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128, (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128, (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128]);\n\t\n\t            var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\n\t                gl = this.gl,\n\t                glResources = this.glResources;\n\t\n\t            this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\n\t\n\t            gl.viewport(0, 0, 256, 256);\n\t            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // set background to full transparency\n\t\n\t            gl.uniformMatrix4fv(glResources.transMatUniform, false, [v[0], v[3], 0, v[6], v[1], v[4], 0, v[7], 0, 0, 1, 0, v[2], v[5], 0, 1]);\n\t\n\t            gl.activeTexture(gl.TEXTURE0);\n\t            gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\n\t            gl.uniform1i(glResources.samplerUniform, 0);\n\t\n\t            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t            return this;\n\t        }\n\t    });\n\t\n\t    function adj(m) {\n\t        // Compute the adjugate of m\n\t        return [m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4], m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5], m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]];\n\t    }\n\t\n\t    function multmm(a, b) {\n\t        // multiply two matrices\n\t        var c = Array(9);\n\t        for (var i = 0; i !== 3; ++i) {\n\t            for (var j = 0; j !== 3; ++j) {\n\t                var cij = 0;\n\t                for (var k = 0; k !== 3; ++k) {\n\t                    cij += a[3 * i + k] * b[3 * k + j];\n\t                }\n\t                c[3 * i + j] = cij;\n\t            }\n\t        }\n\t        return c;\n\t    }\n\t\n\t    function multmv(m, v) {\n\t        // multiply matrix and vector\n\t        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n\t    }\n\t\n\t    function basisToPoints(p) {\n\t        var m = [p[0], p[2], p[4], p[1], p[3], p[5], 1, 1, 1];\n\t        var v = multmv(adj(m), [p[6], p[7], 1]);\n\t        return multmm(m, [v[0], 0, 0, 0, v[1], 0, 0, 0, v[2]]);\n\t    }\n\t\n\t    ProjectiveImageWebGL.Utils = {\n\t        general2DProjection: function general2DProjection(from, to) {\n\t            var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\n\t            if (arr[8]) {\n\t                for (var i = 0; i !== 9; ++i) {\n\t                    arr[i] = arr[i] / arr[8];\n\t                }\n\t            }\n\t            return arr;\n\t        },\n\t\n\t        getWebGlResources: function getWebGlResources(options) {\n\t            var obj = new ProjectiveImageWebGL(options);\n\t            return obj.gl ? obj : null;\n\t        }\n\t    };\n\t    L.gmx.projectiveImageWebGL = function (options) {\n\t        var res = new ProjectiveImageWebGL(options);\n\t        return res.gl ? res : null;\n\t    };\n\t})();\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\t// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\n\t\tvar ProjectiveImage = function ProjectiveImage() {\n\t\t\tvar cnt = 0,\n\t\t\t    limit = 4,\n\t\t\t    patchSize = 64,\n\t\t\t    transform = null;\n\t\n\t\t\tvar allocate = function allocate(w, h) {\n\t\t\t\tvar values = [];\n\t\t\t\tfor (var i = 0; i < h; ++i) {\n\t\t\t\t\tvalues[i] = [];\n\t\t\t\t\tfor (var j = 0; j < w; ++j) {\n\t\t\t\t\t\tvalues[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t};\n\t\n\t\t\tvar Matrix = function Matrix(w, h, values) {\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.values = values || allocate(h);\n\t\t\t};\n\t\n\t\t\tvar cloneValues = function cloneValues(values) {\n\t\t\t\tvar clone = [];\n\t\t\t\tfor (var i = 0; i < values.length; ++i) {\n\t\t\t\t\tclone[i] = [].concat(values[i]);\n\t\t\t\t}\n\t\t\t\treturn clone;\n\t\t\t};\n\t\n\t\t\tMatrix.prototype = {\n\t\t\t\tadd: function add(operand) {\n\t\t\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix add size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (var x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] + operand.values[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t},\n\t\t\t\ttransformProjectiveVector: function transformProjectiveVector(operand) {\n\t\t\t\t\tvar out = [],\n\t\t\t\t\t    x,\n\t\t\t\t\t    y;\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tout[y] = 0;\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar zn = out[out.length - 1];\n\t\t\t\t\tif (zn) {\n\t\t\t\t\t\tvar iz = 1 / out[out.length - 1];\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tout[y] *= iz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn out;\n\t\t\t\t},\n\t\t\t\tmultiply: function multiply(operand) {\n\t\t\t\t\tvar values, x, y;\n\t\t\t\t\tif (+operand !== operand) {\n\t\t\t\t\t\t// Matrix mult\n\t\t\t\t\t\tif (operand.h !== this.w) {\n\t\t\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\n\t\t\t\t\t\t\t\tvar accum = 0;\n\t\t\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\n\t\t\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalues[y][x] = accum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(operand.w, this.h, values);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Scalar mult\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trowEchelon: function rowEchelon() {\n\t\t\t\t\tif (this.w <= this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = cloneValues(this.values);\n\t\n\t\t\t\t\t// Do Gauss-Jordan algorithm.\n\t\t\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\n\t\t\t\t\t\t// Look up pivot value.\n\t\t\t\t\t\tvar pivot = temp[yp][yp];\n\t\t\t\t\t\twhile (pivot === 0) {\n\t\t\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\n\t\t\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\n\t\t\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\n\t\t\t\t\t\t\t\t\t// Swap rows.\n\t\t\t\t\t\t\t\t\tvar tmpRow = temp[ys];\n\t\t\t\t\t\t\t\t\ttemp[ys] = temp[yp];\n\t\t\t\t\t\t\t\t\ttemp[yp] = tmpRow;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ys === this.h) {\n\t\t\t\t\t\t\t\t// No suitable pivot found. Abort.\n\t\t\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpivot = temp[yp][yp];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Normalize this row.\n\t\t\t\t\t\tvar scale = 1 / pivot;\n\t\t\t\t\t\tfor (var x = yp; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[yp][x] *= scale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Subtract this row from all other rows (scaled).\n\t\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tif (y === yp) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar factor = temp[y][yp];\n\t\t\t\t\t\t\ttemp[y][yp] = 0;\n\t\t\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\n\t\t\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t},\n\t\t\t\tinvert: function invert() {\n\t\t\t\t\tvar x, y;\n\t\n\t\t\t\t\tif (this.w !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix invert size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = allocate(this.w * 2, this.h);\n\t\n\t\t\t\t\t// Initialize augmented matrix\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[y][x] = this.values[y][x];\n\t\t\t\t\t\t\ttemp[y][x + this.w] = x === y ? 1 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\n\t\t\t\t\ttemp = temp.rowEchelon();\n\t\n\t\t\t\t\t// Extract right block matrix.\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (y = 0; y < this.w; ++y) {\n\t\t\t\t\t\t// @todo check if \"x < this.w;\" is mistake\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tvar getProjectiveTransform = function getProjectiveTransform(points) {\n\t\t\t\tvar eqMatrix = new Matrix(9, 8, [[1, 1, 1, 0, 0, 0, -points[2][0], -points[2][0], -points[2][0]], [0, 1, 1, 0, 0, 0, 0, -points[3][0], -points[3][0]], [1, 0, 1, 0, 0, 0, -points[1][0], 0, -points[1][0]], [0, 0, 1, 0, 0, 0, 0, 0, -points[0][0]], [0, 0, 0, -1, -1, -1, points[2][1], points[2][1], points[2][1]], [0, 0, 0, 0, -1, -1, 0, points[3][1], points[3][1]], [0, 0, 0, -1, 0, -1, points[1][1], 0, points[1][1]], [0, 0, 0, 0, 0, -1, 0, 0, points[0][1]]]);\n\t\n\t\t\t\tvar kernel = eqMatrix.rowEchelon().values;\n\t\t\t\tvar transform = new Matrix(3, 3, [[-kernel[0][8], -kernel[1][8], -kernel[2][8]], [-kernel[3][8], -kernel[4][8], -kernel[5][8]], [-kernel[6][8], -kernel[7][8], 1]]);\n\t\t\t\treturn transform;\n\t\t\t};\n\t\n\t\t\tvar divide = function divide(u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\n\t\t\t\tif (limit) {\n\t\t\t\t\t// Measure patch non-affinity.\n\t\t\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\n\t\t\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\n\t\t\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\n\t\t\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\n\t\n\t\t\t\t\t// Measure patch area.\n\t\t\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\n\t\t\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\n\t\t\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\n\t\n\t\t\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\n\t\t\t\t\t// The non-affinity measure is used as a correction factor.\n\t\t\t\t\tif (u1 === 0 && u4 === 1 || (.25 + r * 5) * area > patchSize * patchSize) {\n\t\t\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\n\t\t\t\t\t\tvar umid = (u1 + u4) / 2;\n\t\t\t\t\t\tvar vmid = (v1 + v4) / 2;\n\t\t\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\n\t\t\t\t\t\tvar pt = transform.transformProjectiveVector([umid, v1, 1]);\n\t\t\t\t\t\tvar pb = transform.transformProjectiveVector([umid, v4, 1]);\n\t\t\t\t\t\tvar pl = transform.transformProjectiveVector([u1, vmid, 1]);\n\t\t\t\t\t\tvar pr = transform.transformProjectiveVector([u4, vmid, 1]);\n\t\n\t\t\t\t\t\t// Subdivide.\n\t\t\t\t\t\tlimit--;\n\t\t\t\t\t\tdivide.call(this, u1, v1, umid, vmid, p1, pt, pl, pmid, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, v1, u4, vmid, pt, p2, pmid, pr, limit, attr);\n\t\t\t\t\t\tdivide.call(this, u1, vmid, umid, v4, pl, pmid, p3, pb, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, vmid, u4, v4, pmid, pr, pb, p4, limit, attr);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar ctx = attr.ctx;\n\t\n\t\t\t\t// Get patch edge vectors.\n\t\t\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\n\t\t\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\n\t\t\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\n\t\t\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\n\t\n\t\t\t\t// Find the corner that encloses the most area\n\t\t\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\n\t\t\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\n\t\t\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\n\t\t\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\n\t\t\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\n\t\t\t\tvar dx = 0,\n\t\t\t\t    dy = 0,\n\t\t\t\t    padx = 0,\n\t\t\t\t    pady = 0;\n\t\n\t\t\t\t// Align the transform along this corner.\n\t\t\t\t// Calculate 1.05 pixel padding on vector basis.\n\t\t\t\tif (amax === a1) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t} else if (amax === a2) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], d24[0], d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t} else if (amax === a4) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t\tdy = -1;\n\t\t\t\t} else if (amax === a3) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdy = -1;\n\t\t\t\t}\n\t\n\t\t\t\t// Calculate image padding to match.\n\t\t\t\tvar du = u4 - u1;\n\t\t\t\tvar dv = v4 - v1;\n\t\t\t\tpadx++;\n\t\t\t\tpady++;\n\t\n\t\t\t\tvar iw = attr.imageObj.width,\n\t\t\t\t    ih = attr.imageObj.height,\n\t\t\t\t    sx = Math.floor(u1 * iw),\n\t\t\t\t    sy = Math.floor(v1 * ih),\n\t\t\t\t    sw = Math.floor(Math.min(padx * du, 1) * iw),\n\t\t\t\t    sh = Math.floor(Math.min(pady * dv, 1) * ih);\n\t\n\t\t\t\tcnt++;\n\t\t\t\tctx.drawImage(attr.imageObj, sx, sy, sw, sh, dx, dy, padx, pady);\n\t\t\t};\n\t\n\t\t\tthis.getCanvas = function (attr) {\n\t\t\t\tcnt = 0;\n\t\t\t\ttransform = getProjectiveTransform(attr.points);\n\t\t\t\t// Begin subdivision process.\n\t\n\t\t\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\n\t\t\t\t    ptr = transform.transformProjectiveVector([1, 0, 1]),\n\t\t\t\t    pbl = transform.transformProjectiveVector([0, 1, 1]),\n\t\t\t\t    pbr = transform.transformProjectiveVector([1, 1, 1]);\n\t\n\t\t\t\tvar canvas = document.createElement('canvas');\n\t\t\t\tcanvas.width = canvas.height = 256;\n\t\t\t\tattr.canvas = canvas;\n\t\t\t\tattr.ctx = canvas.getContext('2d');\n\t\n\t\t\t\tvar boundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\n\t\t\t\t    maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\n\t\n\t\t\t\tlimit = 'limit' in attr ? attr.limit : maxSize < 200 ? 1 : 4;\n\t\t\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log('Error: ProjectiveImage event:', e);\n\t\t\t\t\tcanvas = null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tptl: ptl,\n\t\t\t\t\tptr: ptr,\n\t\t\t\t\tpbl: pbl,\n\t\t\t\t\tpbr: pbr,\n\t\t\t\t\tcnt: cnt\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tL.gmx.projectiveImage = function () {\n\t\t\treturn new ProjectiveImage();\n\t\t};\n\t})();\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\n\t\n\tL.RotatedMarker = L.Marker.extend({\n\t    options: {\n\t        angle: 0\n\t    },\n\t\n\t    statics: {\n\t        TRANSFORM_ORIGIN: L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\n\t    },\n\t\n\t    _initIcon: function _initIcon() {\n\t        L.Marker.prototype._initIcon.call(this);\n\t\n\t        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\n\t    },\n\t\n\t    _getTransformOrigin: function _getTransformOrigin() {\n\t        var iconAnchor = this.options.icon.options.iconAnchor;\n\t\n\t        if (!iconAnchor) {\n\t            return '50% 50%';\n\t        }\n\t\n\t        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\n\t    },\n\t\n\t    _setPos: function _setPos(pos) {\n\t        L.Marker.prototype._setPos.call(this, pos);\n\t\n\t        if (L.DomUtil.TRANSFORM) {\n\t            // use the CSS transform rule if available\n\t            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\n\t        } else if (L.Browser.ie) {\n\t            // fallback for IE6, IE7, IE8\n\t            var rad = this.options.angle * (Math.PI / 180),\n\t                costheta = Math.cos(rad),\n\t                sintheta = Math.sin(rad);\n\t            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + costheta + ', M12=' + -sintheta + ', M21=' + sintheta + ', M22=' + costheta + ')';\n\t        }\n\t    },\n\t\n\t    setAngle: function setAngle(ang) {\n\t        this.options.angle = ang;\n\t    }\n\t});\n\t\n\tL.rotatedMarker = function (pos, options) {\n\t    return new L.RotatedMarker(pos, options);\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.ExternalLayer = L.Class.extend({\n\t    createExternalLayer: function createExternalLayer() {\n\t        // extend: must return <ILayer> or null = this.externalLayer\n\t        return null;\n\t    },\n\t\n\t    isExternalVisible: function isExternalVisible() /*zoom*/{\n\t        // extend: return true view this.externalLayer, return false view this.parentLayer\n\t        return true;\n\t    },\n\t\n\t    updateData: function updateData() /*data*/{// extend: for data update in this.externalLayer\n\t    },\n\t\n\t    setDateInterval: function setDateInterval() {\n\t        if (this._observer) {\n\t            var gmx = this.parentLayer._gmx;\n\t            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\n\t        }\n\t    },\n\t\n\t    options: {\n\t        useDataManager: true,\n\t        observerOptions: {\n\t            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\n\t        }\n\t    },\n\t\n\t    initialize: function initialize(options, layer) {\n\t        L.setOptions(this, options);\n\t        this.parentLayer = layer;\n\t        layer.on('add', this._addEvent, this).on('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this.options.useDataManager) {\n\t            this._addObserver(this.options.observerOptions);\n\t        }\n\t\n\t        this.externalLayer = this.createExternalLayer();\n\t\n\t        if (layer._map) {\n\t            this._addEvent({ target: { _map: layer._map } });\n\t            this._updateBbox();\n\t        }\n\t    },\n\t\n\t    _addObserver: function _addObserver(opt) {\n\t        this._items = {};\n\t        this._observer = this.parentLayer.addObserver(L.extend({\n\t            bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\n\t            callback: L.bind(this.updateData, this)\n\t        }, opt)).deactivate();\n\t    },\n\t\n\t    unbindLayer: function unbindLayer() {\n\t        this.parentLayer.off('add', this._addEvent, this).off('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this._observer) {\n\t            delete this.parentLayer.repaintObservers[this._observer.id];\n\t        }\n\t        var map = this._map || this.parentLayer._map;\n\t        this._onRemove(!map);\n\t        this._removeMapHandlers();\n\t    },\n\t\n\t    _addMapHandlers: function _addMapHandlers(map) {\n\t        this._map = map;\n\t        this._map.on({\n\t            moveend: this._updateBbox,\n\t            zoomend: this._chkZoom,\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        }, this);\n\t    },\n\t\n\t    _removeMapHandlers: function _removeMapHandlers() {\n\t        if (this._map) {\n\t            this._map.off({\n\t                moveend: this._updateBbox,\n\t                zoomend: this._chkZoom,\n\t                layeradd: this._layeradd,\n\t                layerremove: this._layerremove\n\t            }, this);\n\t        }\n\t        this._map = null;\n\t    },\n\t\n\t    _addEvent: function _addEvent(ev) {\n\t        this._addMapHandlers(ev.target._map);\n\t        this._updateBbox();\n\t        this._chkZoom();\n\t    },\n\t\n\t    _isParentLayer: function _isParentLayer(ev) {\n\t        var layer = ev.layer;\n\t        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\n\t    },\n\t\n\t    _layeradd: function _layeradd(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._chkZoom();\n\t        }\n\t    },\n\t\n\t    _layerremove: function _layerremove(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._onRemove(true);\n\t            this._removeMapHandlers();\n\t        }\n\t    },\n\t\n\t    _onRemove: function _onRemove(fromMapFlag) {\n\t        // remove external layer from parent layer\n\t        if (this._observer) {\n\t            this._observer.deactivate();\n\t        }\n\t        var map = this._map;\n\t        if (map) {\n\t            if (map.hasLayer(this.externalLayer)) {\n\t                this._chkZoom();\n\t                map.removeLayer(this.externalLayer);\n\t            }\n\t            if (!fromMapFlag) {\n\t                this.parentLayer.onAdd(map);\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkZoom: function _chkZoom() {\n\t        if (!this._map) {\n\t            return;\n\t        }\n\t\n\t        var layer = this.parentLayer,\n\t            observer = this._observer,\n\t            map = this._map,\n\t            isExtLayerOnMap = map.hasLayer(this.externalLayer);\n\t\n\t        layer.setCurrentZoom(map);\n\t        if (!this.isExternalVisible(map.getZoom())) {\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            if (!layer._map) {\n\t                if (isExtLayerOnMap) {\n\t                    map.removeLayer(this.externalLayer);\n\t                }\n\t                layer.onAdd(map);\n\t            }\n\t            layer.enablePopup();\n\t        } else if (layer._map) {\n\t            layer.onRemove(map);\n\t            if (!isExtLayerOnMap) {\n\t                map.addLayer(this.externalLayer);\n\t            }\n\t            this.setDateInterval();\n\t            if (observer) {\n\t                layer.getIcons(function () {\n\t                    observer.activate();\n\t                }.bind(this));\n\t            }\n\t            layer.disablePopup();\n\t        }\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        if (!this._map || !this._observer) {\n\t            return;\n\t        }\n\t\n\t        var screenBounds = this._map.getBounds(),\n\t            p1 = screenBounds.getNorthWest(),\n\t            p2 = screenBounds.getSouthEast(),\n\t            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\n\t        this._observer.setBounds(bbox);\n\t    }\n\t});\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var BindWMS = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minZoom: 1,\n\t            maxZoom: 6,\n\t            useDataManager: false,\n\t            format: 'png',\n\t            transparent: true\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var poptions = this.parentLayer.options,\n\t                opt = {\n\t                map: poptions.mapID,\n\t                layers: poptions.layerID,\n\t                format: this.options.format,\n\t                transparent: this.options.transparent\n\t            },\n\t                rawProperties = this.parentLayer.getGmxProperties();\n\t\n\t            if (rawProperties && rawProperties.Temporal) {\n\t                this._extendOptionsByDateInterval(opt);\n\t            }\n\t            if (this.options.apikey) {\n\t                opt.apikey = this.options.apikey;\n\t            }\n\t            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\n\t        },\n\t\n\t        _extendOptionsByDateInterval: function _extendOptionsByDateInterval(options) {\n\t            var dateInterval = this.parentLayer.getDateInterval(),\n\t                beginDate = dateInterval.beginDate,\n\t                endDate = dateInterval.endDate;\n\t            L.extend(options, {\n\t                StartDate: beginDate && beginDate.toLocaleDateString(),\n\t                EndDate: endDate && endDate.toLocaleDateString()\n\t            });\n\t        },\n\t\n\t        setDateInterval: function setDateInterval() {\n\t            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\n\t            this.externalLayer.redraw();\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindWMS: function bindWMS(options) {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t            }\n\t            this._layerWMS = new BindWMS(options, this);\n\t            this.isExternalVisible = this._layerWMS.isExternalVisible;\n\t            return this;\n\t        },\n\t\n\t        unbindWMS: function unbindWMS() {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t                this._layerWMS = null;\n\t                this.isExternalVisible = null;\n\t                this.enablePopup();\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var GmxHeatMap = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minHeatMapZoom: 1,\n\t            maxHeatMapZoom: 6,\n\t            intensityField: '',\n\t            intensityScale: 1,\n\t            observerOptions: {\n\t                type: 'resend'\n\t            }\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            return L.heatLayer([], L.extend({\n\t                // minOpacity: 0.05,\n\t                // maxZoom: 18,\n\t                // radius: 25,\n\t                // blur: 15,\n\t                // max: 1.0\n\t            }, this.options));\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            if (data.added) {\n\t                var latlngs = [],\n\t                    indexes = this.parentLayer.getTileAttributeIndexes(),\n\t                    altIndex = null,\n\t                    intensityField = this.options.intensityField || '',\n\t                    intensityScale = this.options.intensityScale || 1;\n\t\n\t                if (intensityField && intensityField in indexes) {\n\t                    altIndex = indexes[intensityField];\n\t                }\n\t                for (var i = 0, len = data.added.length; i < len; i++) {\n\t                    var it = data.added[i].properties,\n\t                        alt = altIndex !== null ? it[altIndex] : 1,\n\t                        geo = it[it.length - 1],\n\t                        coord = geo.coordinates,\n\t                        point = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t\n\t                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\n\t                }\n\t                this.externalLayer.setLatLngs(latlngs);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindHeatMap: function bindHeatMap(options) {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                }\n\t                this._heatmap = new GmxHeatMap(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindHeatMap: function unbindHeatMap() {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                    this._heatmap = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var _DEFAULTS = {\n\t        radiusFunc: function radiusFunc(count) {\n\t            var r = Math.floor(count / 15);\n\t            if (r > 40) {\n\t                r = 40;\n\t            } else if (r < 20) {\n\t                r = 20;\n\t            }\n\t            return r;\n\t        },\n\t        text: {\n\t            stroke: 'black',\n\t            'stroke-width': 1,\n\t            'text-anchor': 'middle',\n\t            fill: 'white'\n\t        }\n\t    };\n\t    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            observerOptions: {\n\t                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\n\t            },\n\t            spiderfyOnMaxZoom: true,\n\t            minZoom: 1,\n\t            maxZoom: 6\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var mOptions = L.extend({\n\t                showCoverageOnHover: false,\n\t                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\n\t            }, this.options);\n\t\n\t            if ('clusterIconOptions' in this.options) {\n\t                var opt = this.options.clusterIconOptions;\n\t                if ('radialGradient' in opt) {\n\t                    var radialGradient = opt.radialGradient,\n\t                        text = opt.text || _DEFAULTS.text;\n\t                    mOptions.iconCreateFunction = function (cluster) {\n\t                        var childCount = cluster.getChildCount();\n\t\n\t                        text.count = childCount;\n\t                        return L.gmxUtil.getSVGIcon({\n\t                            type: 'circle',\n\t                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\n\t                            text: text,\n\t                            fillRadialGradient: radialGradient\n\t                        });\n\t                    };\n\t                }\n\t            }\n\t\n\t            if (this.options.clusterclick) {\n\t                mOptions.clusterclick = this.options.clusterclick;\n\t                if (mOptions.clusterclick === true) {\n\t                    mOptions.zoomToBoundsOnClick = false;\n\t                }\n\t            }\n\t\n\t            this._popup = new L.Popup({ maxWidth: 10000, className: 'gmxPopup' });\n\t            var markers = new L.MarkerClusterGroup(mOptions);\n\t\n\t            // текущий развёрнутый кластер\n\t            var currentSpiderfiedCluster = null;\n\t\n\t            markers.on('click', function (ev) {\n\t                var propsArr = ev.layer.options.properties,\n\t                    properties = this.parentLayer.getItemProperties(propsArr),\n\t                    geometry = [propsArr[propsArr.length - 1]],\n\t                    id = propsArr[0];\n\t\n\t                if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\n\t                    currentSpiderfiedCluster.unspiderfy();\n\t                    markers.once('unspiderfied', function () {\n\t                        this._openPopup(propsArr, ev.latlng);\n\t                    }, this);\n\t                } else {\n\t                    this._openPopup(propsArr, ev.latlng);\n\t                }\n\t\n\t                this.parentLayer.fire('click', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'click',\n\t                    gmx: {\n\t                        id: id,\n\t                        layer: this.parentLayer,\n\t                        properties: properties,\n\t                        target: {\n\t                            id: id,\n\t                            properties: propsArr,\n\t                            geometry: geometry\n\t                        }\n\t                    }\n\t                }));\n\t            }, this).on('animationend', function () {\n\t                if (this._popup && this._popup._map) {\n\t                    this._popup._map.removeLayer(this._popup);\n\t                }\n\t            }, this).on('clusterclick', function (ev) {\n\t                this.parentLayer.fire('clusterclick', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'clusterclick'\n\t                }));\n\t            }, this).on('spiderfied', function (ev) {\n\t                currentSpiderfiedCluster = ev.cluster;\n\t            }, this).on('unspiderfied', function () {\n\t                currentSpiderfiedCluster = null;\n\t            }, this);\n\t\n\t            if (mOptions.clusterclick) {\n\t                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\n\t                    a.layer.spiderfy();\n\t                });\n\t            }\n\t\n\t            return markers;\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            var arr = [],\n\t                i,\n\t                len,\n\t                vectorTileItem,\n\t                id,\n\t                marker;\n\t            if (data.removed) {\n\t                for (i = 0, len = data.removed.length; i < len; i++) {\n\t                    vectorTileItem = data.removed[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    if (marker) {\n\t                        arr.push(marker);\n\t                    }\n\t                    delete this._items[id];\n\t                }\n\t                this.externalLayer.removeLayers(arr);\n\t                arr = [];\n\t            }\n\t            if (data.added) {\n\t                for (i = 0, len = data.added.length; i < len; i++) {\n\t                    vectorTileItem = data.added[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    var item = vectorTileItem.properties;\n\t                    if (marker && item.processing) {\n\t                        this.externalLayer.removeLayer(marker);\n\t                        marker = null;\n\t                    }\n\t                    if (!marker) {\n\t                        if (!vectorTileItem.item.parsedStyleKeys) {\n\t                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\n\t                        }\n\t                        var geo = item[item.length - 1],\n\t                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\n\t                            p = geo.coordinates,\n\t                            latlng = L.Projection.Mercator.unproject({ x: p[0], y: p[1] }),\n\t                            opt = {\n\t                            properties: vectorTileItem.properties,\n\t                            mPoint: p\n\t                        };\n\t\n\t                        if (this.options.notClusteredIcon) {\n\t                            var icon = this.options.notClusteredIcon;\n\t                            if (icon instanceof L.Icon) {\n\t                                opt.icon = icon;\n\t                            } else {\n\t                                opt.icon = L.icon(icon);\n\t                            }\n\t                        } else if (parsedStyle) {\n\t                            if (parsedStyle.iconUrl) {\n\t                                var iconAnchor = parsedStyle.iconAnchor;\n\t                                if (!iconAnchor) {\n\t                                    var style = this.parentLayer.getItemStyle(id);\n\t                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\n\t                                }\n\t                                opt.icon = L.icon({\n\t                                    iconAnchor: iconAnchor,\n\t                                    iconUrl: parsedStyle.iconUrl\n\t                                });\n\t                            } else {\n\t                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\n\t                            }\n\t                        }\n\t                        if (parsedStyle.rotate) {\n\t                            marker = L.rotatedMarker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        } else {\n\t                            marker = L.marker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        }\n\t                        this._items[id] = marker;\n\t                    }\n\t                    arr.push(marker);\n\t                }\n\t                this.externalLayer.addLayers(arr);\n\t            }\n\t        },\n\t\n\t        _openPopup: function _openPopup(propsArr, latlng) {\n\t            var gmx = this.parentLayer._gmx,\n\t                id = propsArr[0],\n\t                balloonData = gmx.styleManager.getItemBalloon(id),\n\t                properties = this.parentLayer.getItemProperties(propsArr),\n\t                geometry = [propsArr[propsArr.length - 1]];\n\t\n\t            if (balloonData && !balloonData.DisableBalloonOnClick) {\n\t                var style = this.parentLayer.getItemStyle(id);\n\t                if (style && style.iconAnchor) {\n\t                    var protoOffset = L.Popup.prototype.options.offset;\n\t                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2, protoOffset[1] - style.iconAnchor[1] + style.sy / 2];\n\t                }\n\t                this._popup.setLatLng(latlng).setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: gmx.tileAttributeTypes,\n\t                    unitOptions: this._map.options || {},\n\t                    geometries: geometry\n\t                })).openOn(this._map);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindClusters: function bindClusters(options) {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                }\n\t                this._clusters = new GmxMarkerCluster(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindClusters: function unbindClusters() {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                    this._clusters = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx = L.gmx || {};\n\t\n\t\n\tvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\n\tvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\n\t\n\t//Build in layer classes\n\tL.gmx._layerClasses = {\n\t    'Raster': L.gmx.RasterLayer,\n\t    'Vector': L.gmx.VectorLayer,\n\t    'VectorView': L.gmx.DummyLayer\n\t};\n\t\n\tL.gmx._loadingLayerClasses = {};\n\t\n\tL.gmx.addLayerClass = function (type, layerClass) {\n\t    L.gmx._layerClasses[type] = layerClass;\n\t};\n\t\n\tL.gmx._layerClassLoaders = [];\n\t\n\tL.gmx.addLayerClassLoader = function (layerClassLoader) {\n\t    L.gmx._layerClassLoaders.push(layerClassLoader);\n\t\n\t    //delete all loading promises to ensure that new loader will be invoked\n\t    L.gmx._loadingLayerClasses = {};\n\t};\n\t\n\tL.gmx._loadLayerClass = function (type) {\n\t    if (!L.gmx._loadingLayerClasses[type]) {\n\t        var promise = new L.gmx.Deferred();\n\t        promise.resolve();\n\t\n\t        L.gmx._layerClassLoaders.forEach(function (loader) {\n\t            promise = promise.then(function (layerClass) {\n\t                if (layerClass) {\n\t                    L.gmx._layerClasses[type] = layerClass;\n\t                    return layerClass;\n\t                }\n\t\n\t                return loader(type);\n\t            }, function () {\n\t                //just skip loader errors\n\t            });\n\t        });\n\t\n\t        promise = promise.then(function (layerClass) {\n\t            if (layerClass) {\n\t                L.gmx._layerClasses[type] = layerClass;\n\t                return layerClass;\n\t            }\n\t        }, function () {\n\t            //just skip loader errors\n\t        });\n\t\n\t        L.gmx._loadingLayerClasses[type] = promise;\n\t    }\n\t\n\t    return L.gmx._loadingLayerClasses[type];\n\t};\n\t\n\tL.gmx.loadLayer = function (mapID, layerID, options) {\n\t\n\t    var promise = new L.gmx.Deferred(),\n\t        layerParams = {\n\t        mapID: mapID,\n\t        layerID: layerID\n\t    };\n\t\n\t    options = options || {};\n\t\n\t    for (var p in options) {\n\t        layerParams[p] = options[p];\n\t    }\n\t\n\t    var hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t    layerParams.hostName = hostName;\n\t\n\t    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(function () {\n\t        var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\n\t\n\t        if (!layerInfo) {\n\t            promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\n\t            return;\n\t        }\n\t\n\t        //to know from what host the layer was loaded\n\t        layerInfo.properties.hostName = hostName;\n\t\n\t        var type = layerInfo.properties.ContentID || layerInfo.properties.type;\n\t\n\t        var doCreateLayer = function doCreateLayer() {\n\t            var layer = L.gmx.createLayer(layerInfo, layerParams);\n\t            if (layer) {\n\t                promise.resolve(layer);\n\t            } else {\n\t                promise.reject('Unknown type of layer ' + layerID);\n\t            }\n\t        };\n\t\n\t        if (type in L.gmx._layerClasses) {\n\t            doCreateLayer();\n\t        } else {\n\t            L.gmx._loadLayerClass(type).then(doCreateLayer);\n\t        }\n\t    }, function (response) {\n\t        promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\n\t    });\n\t\n\t    return promise;\n\t};\n\t\n\tL.gmx.loadLayers = function (layers, globalOptions) {\n\t    var defs = layers.map(function (layerInfo) {\n\t        var options = L.extend({}, globalOptions, layerInfo.options);\n\t        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\n\t    });\n\t\n\t    return L.gmx.Deferred.all.apply(null, defs);\n\t};\n\t\n\tL.gmx.loadMap = function (mapID, options) {\n\t    options = L.extend({}, options);\n\t    options.hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t\n\t    var def = new L.gmx.Deferred();\n\t\n\t    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function (mapInfo) {\n\t        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\n\t\n\t        loadedMap.layersCreated.then(function () {\n\t            if (options.leafletMap || options.setZIndex) {\n\t                var curZIndex = 0,\n\t                    layer,\n\t                    rawProperties;\n\t\n\t                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\n\t                    layer = loadedMap.layers[l];\n\t                    rawProperties = layer.getGmxProperties();\n\t                    if (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\n\t                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\n\t                    }\n\t                    if (options.setZIndex && layer.setZIndex) {\n\t                        layer.setZIndex(++curZIndex);\n\t                    }\n\t\n\t                    if (options.leafletMap && rawProperties.visible) {\n\t                        layer.addTo(options.leafletMap);\n\t                    }\n\t                }\n\t            }\n\t            def.resolve(loadedMap);\n\t        });\n\t    }, function (response) {\n\t        var errorMessage = response && response.ErrorInfo && response.ErrorInfo.ErrorMessage || 'Server error';\n\t        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\n\t    });\n\t    return def;\n\t};\n\t\n\tL.gmx.DummyLayer = function (props) {\n\t    this.onAdd = this.onRemove = function () {};\n\t    this.getGmxProperties = function () {\n\t        return props;\n\t    };\n\t};\n\t\n\tL.gmx.createLayer = function (layerInfo, options) {\n\t    if (!layerInfo) {\n\t        layerInfo = {};\n\t    }\n\t    if (!layerInfo.properties) {\n\t        layerInfo.properties = { type: 'Vector' };\n\t    }\n\t\n\t    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\n\t        layer;\n\t\n\t    if (type in L.gmx._layerClasses) {\n\t        try {\n\t            layer = new L.gmx._layerClasses[type](options);\n\t            layer = layer.initFromDescription(layerInfo);\n\t        } catch (e) {\n\t            layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t        }\n\t    } else {\n\t        layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t    }\n\t\n\t    return layer;\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/** GeoMixer virtual layer for standard tile raster layers (L.TileLayer)\r\n\t*/\n\t(function () {\n\t\n\t    'use strict';\n\t\n\t    //this function is copied from L.Utils and modified to allow missing data attributes\n\t\n\t    var template = function template(str, data) {\n\t        return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n\t            var value = data[key];\n\t            if (value === undefined) {\n\t                value = '';\n\t            } else if (typeof value === 'function') {\n\t                value = value(data);\n\t            }\n\t            return value;\n\t        });\n\t    };\n\t\n\t    var GmxVirtualTileLayer = function GmxVirtualTileLayer() {};\n\t\n\t    GmxVirtualTileLayer.prototype.initFromDescription = function (layerDescription) {\n\t        var props = layerDescription.properties,\n\t            meta = props.MetaProperties,\n\t            urlTemplate = meta['url-template'] && meta['url-template'].Value,\n\t            isMercator = !!meta['merc-projection'],\n\t            options = {};\n\t\n\t        if (!urlTemplate) {\n\t            return new L.gmx.DummyLayer(props);\n\t        }\n\t\n\t        if (props.Copyright) {\n\t            options.attribution = props.Copyright;\n\t        }\n\t\n\t        if (meta.minZoom) {\n\t            options.minZoom = meta.minZoom.Value;\n\t        }\n\t\n\t        if (meta.maxZoom) {\n\t            options.maxZoom = meta.maxZoom.Value;\n\t        }\n\t\n\t        var layer = (isMercator ? L.tileLayer.Mercator : L.tileLayer)(urlTemplate, options);\n\t\n\t        layer.getGmxProperties = function () {\n\t            return props;\n\t        };\n\t\n\t        return layer;\n\t    };\n\t\n\t    L.gmx.addLayerClass('TMS', GmxVirtualTileLayer);\n\t\n\t    //depricated - use \"TMS\" instead\n\t    L.gmx.addLayerClass('TiledRaster', GmxVirtualTileLayer);\n\t\n\t    var GmxVirtualWMSLayer = function GmxVirtualWMSLayer() {};\n\t\n\t    GmxVirtualWMSLayer.prototype.initFromDescription = function (layerDescription) {\n\t        var WMS_OPTIONS = ['layers', 'styles', 'format', 'transparent', 'version', 'minZoom', 'maxZoom', 'tileSize', 'f', 'bboxSR', 'imageSR', 'size'];\n\t        var WMS_OPTIONS_PROCESSORS = { tileSize: parseInt };\n\t        var props = layerDescription.properties,\n\t            meta = props.MetaProperties,\n\t            baseURL = meta['base-url'] && meta['base-url'].Value,\n\t            options = {};\n\t\n\t        if (!baseURL) {\n\t            return new L.gmx.DummyLayer(props);\n\t        }\n\t\n\t        if (props.Copyright) {\n\t            options.attribution = props.Copyright;\n\t        }\n\t\n\t        for (var p in meta) {\n\t            if (WMS_OPTIONS.indexOf(p) !== -1) {\n\t                options[p] = WMS_OPTIONS_PROCESSORS[p] ? WMS_OPTIONS_PROCESSORS[p](meta[p].Value) : meta[p].Value;\n\t            }\n\t        }\n\t\n\t        var layer = L.tileLayer.wms(baseURL, options);\n\t\n\t        layer.getGmxProperties = function () {\n\t            return props;\n\t        };\n\t\n\t        var balloonTemplate = meta['balloonTemplate'] && meta['balloonTemplate'].Value;\n\t        if (meta['clickable'] && balloonTemplate) {\n\t            layer.options.clickable = true;\n\t\n\t            layer.onRemove = function (map) {\n\t                lastOpenedPopup && map.removeLayer(lastOpenedPopup);\n\t                L.TileLayer.WMS.prototype.onRemove.apply(this, arguments);\n\t            };\n\t\n\t            var lastOpenedPopup;\n\t            layer.gmxEventCheck = function (event) {\n\t                if (event.type === 'click') {\n\t                    var p = this._map.project(event.latlng),\n\t                        tileSize = layer.options.tileSize,\n\t                        I = p.x % tileSize,\n\t                        J = p.y % tileSize,\n\t                        tilePoint = p.divideBy(tileSize).floor(),\n\t                        url = this.getTileUrl(tilePoint);\n\t\n\t                    url = url.replace('=GetMap', '=GetFeatureInfo');\n\t                    url += '&X=' + I + '&Y=' + J + '&INFO_FORMAT=application/geojson&QUERY_LAYERS=' + options.layers;\n\t\n\t                    fetch(url).then(function (geoJSON) {\n\t                        // $.getJSON(url).then(function(geoJSON) {\n\t                        if (geoJSON.features[0]) {\n\t                            var html = template(balloonTemplate, geoJSON.features[0].properties);\n\t                            lastOpenedPopup = L.popup().setLatLng(event.latlng).setContent(html).openOn(this._map);\n\t                        }\n\t                    }.bind(this));\n\t                }\n\t\n\t                return 1;\n\t            };\n\t        }\n\t\n\t        return layer;\n\t    };\n\t\n\t    L.gmx.addLayerClass('WMS', GmxVirtualWMSLayer);\n\t})();\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/geomixer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 40e73fdd0b5a98990589","L.gmx = L.gmx || {};\r\n\r\n// import './commonjs.js';\r\nimport './Parsers.js';\r\nimport './Deferred.js';\r\nimport './ImageLoader.js';\r\nimport './Utils.js';\r\nimport './DrawCanvas.js';\r\nimport './SessionManager.js';\r\nimport {gmxMapManager} from './MapManager.js';\tL.gmx.gmxMapManager = gmxMapManager;\r\nimport './GeomixerMap.js';\r\nimport './EventsManager.js';\r\nimport './Locale.js';\r\nimport './lang_ru.js';\r\nimport './lang_en.js';\r\n\r\nimport './DataManager/VectorTileLoader.js';\r\nimport './DataManager/VectorTile.js';\r\nimport {Observer} from './DataManager/Observer.js';\tL.gmx.observer = function(options) { return new Observer(options); };\r\nimport './DataManager/TilesTree.js';\r\nimport {DataManager} from './DataManager/DataManager.js';\tL.gmx.DataManager = DataManager;\r\n\r\nimport './Layer/VectorLayer.js';\r\nimport './Layer/ScreenVectorTile.js';\r\nimport './Layer/ObjectsReorder.js';\r\nimport './Layer/StyleManager.js';\r\nimport './Layer/VectorLayer.Popup.js';\r\nimport './Layer/VectorLayer.Hover.js';\r\nimport './Layer/LayersVersion.js';\r\nimport './Layer/RasterLayer.js';\r\nimport './Layer/LabelsLayer.js';\r\nimport './Layer/ClipPolygon.js';\r\nimport './Layer/ImageTransform.js';\r\nimport './Layer/ProjectiveImageWebGL.js';\r\nimport './Layer/ProjectiveImage.js';\r\n\r\nimport './Layer/external/RotatedMarker.js';\r\nimport './Layer/external/ExternalLayer.js';\r\nimport './Layer/external/BindWMS.js';\r\nimport './Layer/external/HeatMap.js';\r\nimport './Layer/external/MarkerCluster.js';\r\n\r\nimport './LayerFactory.js';\r\nimport './Layer/external/GmxVirtualTileLayer.js';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/includes.js","/*\r\n   Single-pass recursive descent PEG parser library:\r\n      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n   Inspired by Chris Double's parser combinator library in JavaScript:\r\n      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t+ Добавлены функции: Math.floor\r\n*/\r\n(function() {\r\n    var regexExpression = /\\[(.+?)\\]/g,\r\n        regexMath = /(floor\\()/g;\r\n\tvar Parsers = {\t\t\t\t\t\t// Парсеры\r\n        functionFromExpression: function(s) {\r\n/*eslint-disable no-new-func*/\r\n            return new Function(\r\n/*eslint-enable */\r\n                'props',\r\n                'indexes',\r\n                'return ' +\r\n                    s\r\n                     .replace(regexExpression, 'props[indexes[\"$1\"]]')\r\n                     .replace(regexMath, 'Math.$1')\r\n                    + ';'\r\n            );\r\n        }\r\n    };\r\n\r\n\tvar makePair = function(t1, t2) {\r\n\t\treturn {head: t1, tail: t2};\r\n\t};\r\n\r\n// C-style linked list via recursive typedef.\r\n//   Used purely functionally to get shareable sublists.\r\n//typedef LinkedList = Pair<Dynamic, LinkedList>;\r\n\tvar LinkedList = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser state contains position in string and some accumulated data.\r\n//typedef ParserState = Pair<Int, LinkedList>;\r\n\tvar ParserState = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser accepts string and state, returns another state.\r\n//typedef Parser = String->ParserState->ParserState;\r\n\r\n\t// A parser state that indicates failure.\r\n\tvar fail = new ParserState(-1, null);\r\n\r\n\t// Check for failure.\r\n\tvar failed = function(state) {\r\n\t\treturn (state.head === -1);\r\n\t};\r\n\r\n\t// Advance a parser state by n characters.\r\n\tvar advance = function(state, n) {\r\n\t\treturn new ParserState(state.head + n, state.tail);\r\n\t};\r\n\r\n\t// Match a specified string.\r\n\tvar token = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len) === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a string without regard to case.\r\n\tvar caseInsensitiveToken = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\ttok = tok.toLowerCase();\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len).toLowerCase() === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a single character in a specified range.\r\n\tvar range = function(startChar, endChar) {\r\n\t\tvar startCode = startChar.charCodeAt(0);\r\n\t\tvar endCode = endChar.charCodeAt(0);\r\n\t\treturn function(s, state) {\r\n\t\t\tvar code = s.charCodeAt(state.head);\r\n\t\t\treturn ((code >= startCode) && (code <= endCode)) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match any character outside a certain set.\r\n\t//   This combinator is intended only for single character parsers.\r\n\tvar anythingExcept = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\treturn ((s.length > state.head) && failed(parser(s, state))) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, then thing2, ..., then thingN.\r\n\tvar sequence = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tstate = parsers[i](s, state);\r\n\t\t\t\tif (failed(state)) {\r\n\t\t\t\t\treturn fail;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn state;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, or thing2, ..., or thingN.\r\n\tvar choice = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tvar newState = parsers[i](s, state);\r\n\t\t\t\tif (!failed(newState)) {\r\n\t\t\t\t\treturn newState;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match immediately, without regard to what's in the string.\r\n\tvar nothing = function(s, state) {\r\n\t\treturn state;\r\n\t};\r\n\r\n\t// Match this thing or nothing.\r\n\tvar maybe = function(parser) {\r\n\t\treturn choice([parser, nothing]);\r\n\t};\r\n\r\n\t// Match minCount or more repetitions of this thing.\r\n\tvar repeat = function(minCount, parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar count = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar newState = parser(s, state);\r\n\t\t\t\tif (failed(newState)) {\r\n\t\t\t\t\treturn (count >= minCount) ? state : fail;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount += 1;\r\n\t\t\t\t\tstate = newState;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// return fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a list of minCount or more instances of thing1, separated by thing2.\r\n\tvar separatedList = function(minCount, parser, separator) {\r\n\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\r\n\t\treturn (minCount > 0) ? parser1 : choice([parser1, nothing]);\r\n\t};\r\n\r\n\tvar whitespace = repeat(0, choice([\r\n\t\ttoken(' '),\r\n\t\ttoken('\\t'),\r\n\t\ttoken('\\n')\r\n\t]));\r\n\r\n\t// Same as separatedList, but can have whitespace between items and separators.\r\n\tvar whitespaceSeparatedList = function(minCount, parser, separator) {\r\n\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\r\n\t};\r\n\r\n\t// Same as sequence, but can have whitespace between items.\r\n\tvar whitespaceSeparatedSequence = function(parsers) {\r\n\t\tvar newParsers = [];\r\n\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\tif (newParsers.length > 0) { newParsers.push(whitespace); }\r\n\t\t\tnewParsers.push(parsers[i]);\r\n\t\t}\r\n\t\treturn sequence(newParsers);\r\n\t};\r\n\r\n\t// This combinator captures the string that the parser matched\r\n\t//   and adds it to the current parser state, consing a new state.\r\n\tvar capture = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar newState = parser(s, state);\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// This combinator passes the accumulated parser state to a given\r\n\t//  function for processing. The result goes into the new state.\r\n\tvar action = function(parser, func) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar oldState = state;\r\n\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// Define a syntactic subset of SQL WHERE clauses.\r\n\tvar fieldName = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('а', 'я'),\r\n\t\trange('А', 'Я'),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_')\r\n\t])));\r\n\r\n\tvar fieldNameWithSpaces = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('а', 'я'),\r\n\t\trange('А', 'Я'),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_'),\r\n\t\ttoken(' ')\r\n\t])));\r\n\r\n\tvar quotedFieldName = choice([\r\n\t\tfieldName,\r\n\t\tsequence([token('\"'), fieldNameWithSpaces, token('\"')]),\r\n\t\tsequence([token('`'), fieldNameWithSpaces, token('`')])\r\n\t]);\r\n\r\n\tvar stringLiteral = sequence([\r\n\t\ttoken('\\''),\r\n\t\tcapture(repeat(0, anythingExcept(token('\\'')))),\r\n\t\ttoken('\\'')\r\n\t]);\r\n\r\n\tvar digits = repeat(1, range('0', '9'));\r\n\r\n\tvar numberLiteral = capture(sequence([\r\n\t\tmaybe(token('-')),\r\n\t\tdigits,\r\n\t\tmaybe(sequence([token('.'), digits]))\r\n\t]));\r\n\r\n\tvar literal = choice([numberLiteral, stringLiteral]);\r\n\r\n\tvar applyParser = function(s, parser) {\r\n\t\treturn parser(s, new ParserState(0, null));\r\n\t};\r\n\r\n\t// Order is important here: longer ops should be tried first.\r\n\tvar opTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcapture(choice([\r\n\t\t\t\ttoken('=='),\r\n\t\t\t\ttoken('!='),\r\n\t\t\t\ttoken('<>'),\r\n\t\t\t\ttoken('<='),\r\n\t\t\t\ttoken('>='),\r\n\t\t\t\ttoken('='),\r\n\t\t\t\ttoken('<'),\r\n\t\t\t\ttoken('>'),\r\n\t\t\t\tcaseInsensitiveToken('LIKE')\r\n\t\t\t])),\r\n            choice([literal, quotedFieldName])\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname, operation, value\r\n\t\t\t// (in reverse order).\r\n\r\n\t\t\tvar fieldName = state.tail.tail.head;\r\n\t\t\tvar op = state.tail.head;\r\n\t\t\tvar referenceValue = state.head;\r\n\r\n\t\t\tvar matchPattern = null;\r\n\t\t\tif (op.toUpperCase() === 'LIKE') {\r\n\t\t\t\tmatchPattern = function(fieldValue) {\r\n\t\t\t\t\tvar matchFrom = null;\r\n\t\t\t\t\tmatchFrom = function(referenceIdx, fieldIdx) {\r\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\r\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\r\n\t\t\t\t\t\tif (referenceChar === '') {\r\n\t\t\t\t\t\t\treturn (fieldChar === '');\r\n\t\t\t\t\t\t} else if (referenceChar === '%') {\r\n\t\t\t\t\t\t\treturn matchFrom(referenceIdx + 1, fieldIdx) || ((fieldChar !== '') && matchFrom(referenceIdx, fieldIdx + 1));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn (referenceChar === fieldChar) && matchFrom(referenceIdx + 1, fieldIdx + 1);\r\n                        }\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn matchFrom(0, 0);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\r\n                    rValue = referenceValue;\r\n                if (referenceValue in indexes) { rValue = props[indexes[rValue]]; }\r\n                if (types[fieldName] === 'date' && typeof rValue === 'string') { rValue = L.gmxUtil.getUnixTimeFromStr(rValue); }\r\n                if (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\r\n                    fieldValue = fieldValue ? 'True' : 'False';\r\n                }\r\n\t\t\t\tif (fieldValue === null) { return false; }\r\n\t\t\t\tif (matchPattern !== null) { return matchPattern(fieldValue);\r\n/*eslint-disable eqeqeq */\r\n                } else if ((op === '=') || (op === '==')) { return (fieldValue == rValue);\r\n\t\t\t\t} else if ((op === '!=') || (op === '<>')) { return (fieldValue != rValue);\r\n/*eslint-enable */\r\n                } else {\r\n                    var f1, f2;\r\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\r\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\r\n\t\t\t\t\t\tf2 = parseFloat(rValue);\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tf1 = fieldValue;\r\n\t\t\t\t\t\tf2 = rValue;\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar inTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcaseInsensitiveToken('IN'),\r\n\t\t\ttoken('('),\r\n\t\t\twhitespaceSeparatedList(0, literal, token(',')),\r\n\t\t\ttoken(')')\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname and multiple values\r\n\t\t\t//   (in reverse order).\r\n\r\n\t\t\tvar node = state;\r\n\t\t\twhile (node.tail != null) {\r\n\t\t\t\tnode = node.tail;\r\n\t\t\t}\r\n            var fieldName = node.head;\r\n\r\n\t\t\treturn function(props, indexes) {\r\n\t\t\t\tvar value = props[indexes[fieldName]];\r\n\t\t\t\tif (value == null) { return false; }\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node.tail !== null) {\r\n\t\t\t\t\tif (node.head === value) { return true; }\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Forward declarations to allow mutually recursive grammar definitions.\r\n\tvar term = function(s, state) { return term(s, state); };\r\n\tvar expression = function(s, state) { return expression(s, state); };\r\n\r\n\tvar notTerm = action(\r\n\t\twhitespaceSeparatedSequence([caseInsensitiveToken('NOT'), term]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains only processed inner term.\r\n\t\t\tvar innerTerm = state.head;\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\treturn !innerTerm(props, indexes, types);\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tterm = choice([\r\n\t\tnotTerm,\r\n\t\topTerm,\r\n\t\tinTerm,\r\n\t\twhitespaceSeparatedSequence([token('('), expression, token(')')])\r\n\t]);\r\n\r\n\t// AND and OR expressions must have at least 2 terms,\r\n\t//   to disambiguate them from a single term.\r\n\r\n\tvar andExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('AND')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = true;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar orExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('OR')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = false;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Order is important here: term should be tried last,\r\n\t//   because andExpression and orExpression start with it.\r\n\texpression = choice([\r\n\t\tandExpression,\r\n\t\torExpression,\r\n\t\tterm\r\n\t]);\r\n\r\n\tvar whereClause = sequence([whitespace, expression, whitespace]);\r\n\r\n\tParsers.parseSQL = function(str) {\r\n\t\tvar result = applyParser(str, whereClause);\r\n\t\treturn result.head === str.length ?\r\n\t\t\tresult.tail.head :\r\n            (applyParser(str, whitespace).head === str.length) ?\r\n\t\t\t\tfunction(/*props*/) { return true; } :\r\n\t\t\t\tnull;\r\n\t};\r\n\r\n\tvar additiveExpression = function(s, state) { return additiveExpression(s, state); };\r\n\tvar multiplicativeExpression = function(s, state) { return multiplicativeExpression(s, state); };\r\n\tadditiveExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeExpression,\r\n\t\t\tcapture(choice([token('+'), token('-')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types)\r\n\t\t\t{\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 0.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm += pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '-') { term = -term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar multiplicativeTerm = choice([\r\n\t\taction(\r\n\t\t\tnumberLiteral,\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(/*props, indexes, types*/) {\r\n\t\t\t\t\treturn parseFloat(state.head);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('floor('), additiveExpression, token(')')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\tvar res = state.head(props, indexes, types);\r\n\t\t\t\t\treturn Math.floor(res);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('['), fieldName, token(']')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes) {\r\n\t\t\t\t\treturn parseFloat(props[indexes[state.head]]);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\ttoken('('),\r\n\t\t\tadditiveExpression,\r\n\t\t\ttoken(')')\r\n\t\t])\r\n\t]);\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\tmultiplicativeExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeTerm,\r\n\t\t\tcapture(choice([token('*'), token('/')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 1.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '/') { term = 1.0 / term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\r\n\tvar arithmeticExpression = sequence([whitespace, additiveExpression, whitespace]);\r\n\tParsers.parseExpression = function(s) {\r\n\t\tvar result = applyParser(s, arithmeticExpression);\r\n        return result.head === s.length ? result.tail.head : null;\r\n        // return result.head === s.length ? Parsers.functionFromExpression(s) : null;\r\n\t};\r\n\r\n\tvar svgPath = action(\r\n\t\trepeat(0, choice([\r\n\t\t\tnumberLiteral,\r\n\t\t\ttoken(','),\r\n\t\t\ttoken('M'),\r\n\t\t\ttoken('C'),\r\n\t\t\trepeat(1, choice([\r\n\t\t\t\ttoken(' '),\r\n\t\t\t\ttoken('\\t'),\r\n\t\t\t\ttoken('\\r'),\r\n\t\t\t\ttoken('\\n')\r\n\t\t\t]))\r\n\t\t])),\r\n\t\tfunction(state) {\r\n\t\t\tvar coords = [];\r\n\t\t\twhile (state !== null) {\r\n\t\t\t\tcoords.push(parseFloat(state.head));\r\n\t\t\t\tstate = state.tail;\r\n\t\t\t}\r\n\t\t\tcoords.reverse();\r\n\t\t\treturn coords;\r\n\t\t}\r\n\t);\r\n\r\n\tParsers.parseSVGPath = function(s) {\r\n\t\tvar result = applyParser(s, svgPath);\r\n\t\tif (result.head === s.length) {\r\n\t\t\treturn result.tail.head;\r\n\t\t} else {\r\n\t\t\treturn [];\r\n        }\r\n\t};\r\n\r\n\t//extend L.gmx namespace\r\n    L.gmx = L.gmx || {};\r\n\tL.gmx.Parsers = Parsers;\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Parsers.js","//all the methods can be called without instance itself\r\n//For example:\r\n//\r\n// var def = new Deferred();\r\n// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\r\nvar Deferred = function(cancelFunc) {\r\n    var resolveCallbacks = [],\r\n        rejectCallbacks = [],\r\n        isFulfilled = false,\r\n        isResolved = false,\r\n        fulfilledData,\r\n        onceAdded = false,\r\n        isCancelled = false;\r\n\r\n    var fulfill = this._fulfill = function(resolved /*, data*/) {\r\n        if (isFulfilled) {\r\n            return;\r\n        }\r\n        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\r\n        fulfilledData = [].slice.call(arguments, 1);\r\n        isFulfilled = true;\r\n        isResolved = resolved;\r\n\r\n        callbacks.forEach(function(callback) { callback.apply(null, fulfilledData); });\r\n        resolveCallbacks = rejectCallbacks = [];\r\n    };\r\n\r\n    this.resolve = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    this.reject = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    var cancel = this.cancel = function() {\r\n        if (!isCancelled && !isFulfilled) {\r\n            isCancelled = true;\r\n            cancelFunc && cancelFunc();\r\n        }\r\n    };\r\n\r\n    var then = this.then = function(resolveCallback, rejectCallback) {\r\n        if (isCancelled) {\r\n            return null;\r\n        }\r\n\r\n        var userFuncDef = null;\r\n        var def = new Deferred(function() {\r\n            cancel();\r\n            userFuncDef && userFuncDef.cancel();\r\n        });\r\n\r\n        var fulfillFunc = function(func, resolved) {\r\n            return function(/*data*/) {\r\n                if (!func) {\r\n                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\r\n                } else {\r\n                    var res = func.apply(null, arguments);\r\n                    if (res instanceof Deferred) {\r\n                        userFuncDef = res;\r\n                        res.then(def.resolve, def.reject);\r\n                    } else {\r\n                        def.resolve(res);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        if (isFulfilled) {\r\n            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\r\n        } else {\r\n            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\r\n            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\r\n        }\r\n        return def;\r\n    };\r\n\r\n    this.once = function(onceResolveCallback) {\r\n        if (!onceAdded) {\r\n            onceAdded = true;\r\n            then(onceResolveCallback);\r\n        }\r\n    };\r\n\r\n    this.always = function(callback) {\r\n        then(callback, callback);\r\n    };\r\n\r\n    this.getFulfilledData = function() {\r\n        return fulfilledData;\r\n    };\r\n};\r\n\r\nDeferred.all = function() {\r\n    var defArray = [].slice.apply(arguments);\r\n    var resdef = new Deferred();\r\n    var left = defArray.length;\r\n    var results = new Array(defArray.length);\r\n\r\n    if (left) {\r\n        defArray.forEach(function(def, i) {\r\n            def.then(function(res) {\r\n                results[i] = res;\r\n                left--;\r\n                if (left === 0) {\r\n                    resdef.resolve.apply(resdef, results);\r\n                }\r\n            }, function() {\r\n                resdef.reject();\r\n            });\r\n        });\r\n    } else {\r\n        resdef.resolve();\r\n    }\r\n\r\n    return resdef;\r\n};\r\n\r\nL.gmx = L.gmx || {};\r\nL.gmx.Deferred = Deferred;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Deferred.js","(function() {\r\n\r\nvar ImageRequest = function(id, url, options) {\r\n    this._id = id;\r\n    this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\r\n    this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\r\n    this.url = url;\r\n    this.options = options || {};\r\n};\r\n\r\nvar GmxImageLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    statics: {\r\n        MAX_COUNT: 20 // max number of parallel requests\r\n    },\r\n\r\n    initialize: function() {\r\n        this.curCount = 0;        // number of currently processing requests (number of items in \"inProgress\")\r\n        this.requests = [];       // not yet processed image requests\r\n        this.inProgress = {};     // hash of in progress image loadings\r\n        this.requestsCache = {};  // for requests cache by uniqueID\r\n        this.uniqueID = 0;\r\n    },\r\n\r\n    _resolveRequest: function(request, image, canceled) {\r\n        var def = request.def;\r\n        if (image) {\r\n            if (!canceled && request.options.cache) {\r\n                var url = request.url,\r\n                    cacheItem = this.requestsCache[url],\r\n                    cacheKey = request._id;\r\n                if (!cacheItem) { cacheItem = this.requestsCache[url] = {image: image, requests:{}}; }\r\n                if (!cacheItem.requests[cacheKey]) { cacheItem.requests[cacheKey] = request; }\r\n            }\r\n            def.resolve(image);\r\n        } else if (!canceled) {\r\n            def.reject();\r\n        }\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _imageLoaded: function(url, image, canceled) {\r\n        if (url in this.inProgress) {\r\n            var resolveRequest = function(it) {\r\n                this._resolveRequest(it, image, canceled);\r\n            };\r\n            this.inProgress[url].requests.forEach(resolveRequest.bind(this));\r\n            --this.curCount;\r\n            delete this.inProgress[url];\r\n        }\r\n        L.gmxUtil.loaderStatus(url, true);\r\n        this.fire('imageloaded', {url: url});\r\n        this._nextLoad();\r\n    },\r\n\r\n    _nextLoad: function() {  // загрузка следующего\r\n        if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\r\n            return;\r\n        }\r\n\r\n        var request = this.requests.shift(),\r\n            url = request.url;\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            var requests = [request];\r\n            this.inProgress[url] = {requests: requests};\r\n            ++this.curCount;\r\n\r\n            for (var k = this.requests.length - 1; k >= 0; k--) {\r\n                if (this.requests[k].url === url) {\r\n                    requests.push(this.requests[k]);\r\n                    this.requests.splice(k, 1);\r\n                }\r\n            }\r\n\r\n            var image = this._loadImage(request);\r\n            if (!image.width) {\r\n                L.gmxUtil.loaderStatus(url);\r\n            }\r\n\r\n            //theoretically image loading can be synchronous operation\r\n            if (this.inProgress[url]) {\r\n                this.inProgress[url].image = image;\r\n            }\r\n        }\r\n    },\r\n\r\n    _loadImage: function(request) {\r\n        var imageObj = new Image(),\r\n            url = request.url,\r\n            _this = this;\r\n\r\n        if (request.options.crossOrigin) {\r\n            imageObj.crossOrigin = request.options.crossOrigin;\r\n        }\r\n\r\n        imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\r\n        imageObj.onerror = function() {\r\n            _this._imageLoaded(url);\r\n        };\r\n        imageObj.src = url;\r\n\r\n        this.fire('imageloadstart', {url: url});\r\n\r\n        return imageObj;\r\n    },\r\n\r\n    _cancelRequest: function(request) {\r\n        var id = request._id,\r\n            url = request.url,\r\n            i = 0, len;\r\n        if (url in this.inProgress) {\r\n            var loadingImg = this.inProgress[url],\r\n                requests = loadingImg.requests;\r\n\r\n            len = requests.length;\r\n            if (len === 1 && requests[0]._id === id) {\r\n                loadingImg.image.onload = L.Util.falseFn;\r\n                loadingImg.image.onerror = L.Util.falseFn;\r\n                loadingImg.image.src = L.Util.emptyImageUrl;\r\n                this._imageLoaded(url, null, true);\r\n            } else {\r\n                for (i = 0; i < len; i++) {\r\n                    if (requests[i]._id === id) {\r\n                        requests.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = this.requests.length; i < len; i++) {\r\n                if (this.requests[i]._id === id) {\r\n                    this.requests.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _removeRequestFromCache: function(request) {    // remove request from cache\r\n        this._cancelRequest(request);\r\n        this._clearCacheItem(request.url, request._id);\r\n    },\r\n\r\n    _clearCacheItem: function(url, cacheKey) {    // remove cache item\r\n        if (this.requestsCache[url]) {\r\n            var cacheItem = this.requestsCache[url];\r\n            delete cacheItem.requests[cacheKey];\r\n            if (Object.keys(cacheItem.requests).length === 0) {\r\n                delete this.requestsCache[url];\r\n            }\r\n        }\r\n    },\r\n    _add: function(atBegin, url, options) {\r\n        var id = 'id' + (++this.uniqueID),\r\n            request = new ImageRequest(id, url, options);\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            atBegin ? this.requests.unshift(request) : this.requests.push(request);\r\n            this._nextLoad();\r\n        }\r\n\r\n        this.fire('request', {request: request});\r\n\r\n        return request;\r\n    },\r\n\r\n    push: function(url, options) {  // добавить запрос в конец очереди\r\n        return this._add(false, url, options);\r\n    },\r\n\r\n    unshift: function(url, options) {   // добавить запрос в начало очереди\r\n        return this._add(true, url, options);\r\n    }\r\n});\r\n\r\nL.gmx.imageLoader = new GmxImageLoader();\r\n\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ImageLoader.js","/**\r\n* @name L.gmxUtil\r\n* @namespace\r\n*/\r\nvar gmxAPIutils = {\r\n    lastMapId: 0,\r\n\r\n    newId: function()\r\n    {\r\n        gmxAPIutils.lastMapId += 1;\r\n        return '_' + gmxAPIutils.lastMapId;\r\n    },\r\n\r\n    uniqueGlobalName: function(thing)\r\n    {\r\n        var id = gmxAPIutils.newId();\r\n        window[id] = thing;\r\n        return id;\r\n    },\r\n\r\n    isPageHidden: function()\t{\t\t// Видимость окна браузера\r\n        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\r\n    },\r\n\r\n    normalizeHostname: function(hostName) {\r\n        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\r\n\r\n        hostName = parsedHost.host + parsedHost.directory;\r\n\r\n        if (hostName[hostName.length - 1] === '/') {\r\n            hostName = hostName.substring(0, hostName.length - 1);\r\n        }\r\n\r\n        return hostName;\r\n    },\r\n\r\n\tgetLayerItemFromServer: function(options) {\r\n        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\r\n            req = {\r\n                WrapStyle: 'func',\r\n                geometry: true,\r\n                layer: options.layerID,\r\n                query: query\r\n            };\r\n        if (options.border) { req.border = options.border; }\r\n        return gmxAPIutils.requestJSONP(\r\n            options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx',\r\n            req,\r\n            options\r\n        );\r\n    },\r\n\r\n\tgetCadastreFeatures: function(options) {\r\n\t\t// example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\r\n        if (options.latlng) {\r\n\t\t\tvar latlng = options.latlng,\r\n\t\t\t\treq = {\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\ttext: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\r\n\t\t\t\t\ttolerance: options.tolerance || 0\r\n\t\t\t\t};\r\n\t\t\treturn gmxAPIutils.requestJSONP(\r\n\t\t\t\toptions.url || 'http://pkk5.rosreestr.ru/api/features/',\r\n\t\t\t\treq,\r\n\t\t\t\toptions\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n    },\r\n\r\n\tgetFormData: function(json) {\r\n\t\tvar arr = [];\r\n\t\tfor (var key in json) {\r\n\t\t\tvar val = json[key];\r\n\t\t\tarr.push(key + '=' + (typeof val === 'object' ? JSON.stringify(val) : val));\r\n\t\t}\r\n\t\treturn arr.join('&');\r\n    },\r\n\r\n    /** Sends JSONP requests\r\n     * @memberof L.gmxUtil\r\n     * @param {String} url - request URL\r\n     * @param {Object} params - request params\r\n     * @param {Object} [options] - additional request options\r\n     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n     * @return {Deferred} Promise with server JSON response or with error status\r\n    */\r\n\trequestJSONP: function(url, params, options) {\r\n        options = options || {};\r\n        var def = new L.gmx.Deferred();\r\n\r\n        var script = document.createElement('script');\r\n        script.setAttribute('charset', 'UTF-8');\r\n        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\r\n        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\r\n\r\n        if (callbackParamName) {\r\n            var callbackName = gmxAPIutils.uniqueGlobalName(function(obj) {\r\n                delete window[callbackName];\r\n                def.resolve(obj, options);\r\n            });\r\n\r\n            urlParams[callbackParamName] = callbackName;\r\n        }\r\n\r\n        var paramsStringItems = [];\r\n\r\n        for (var p in urlParams) {\r\n            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\r\n        }\r\n\r\n        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\r\n\r\n        script.onerror = function(e) {\r\n            def.reject(e);\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        script.onload = function() {\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        L.gmxUtil.loaderStatus(src, null, 'vector');\r\n        script.setAttribute('src', src);\r\n\r\n        document.getElementsByTagName('head').item(0).appendChild(script);\r\n        return def;\r\n    },\r\n    getXmlHttp: function() {\r\n        var xmlhttp;\r\n        if (typeof XMLHttpRequest !== 'undefined') {\r\n            xmlhttp = new XMLHttpRequest();\r\n        } else {\r\n          try {\r\n            xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\r\n          } catch (e) {\r\n            try {\r\n              xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\r\n            } catch (E) {\r\n              xmlhttp = false;\r\n            }\r\n          }\r\n        }\r\n        return xmlhttp;\r\n    },\r\n    request: function(ph) { // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\r\n        var xhr = gmxAPIutils.getXmlHttp();\r\n        if (xhr) {\r\n            xhr.open((ph.type ? ph.type : 'GET'), ph.url, ph.async || false);\r\n            if (ph.headers) {\r\n                for (var key in ph.headers) {\r\n                    xhr.setRequestHeader(key, ph.headers[key]);\r\n                }\r\n            }\r\n            var reqId = L.gmxUtil.loaderStatus();\r\n            if (ph.async) {\r\n                if (ph.withCredentials) {\r\n                    xhr.withCredentials = true;\r\n                }\r\n                xhr.onreadystatechange = function() {\r\n                    if (xhr.readyState === 4) {\r\n                        L.gmxUtil.loaderStatus(reqId, true);\r\n                        if (xhr.status === 200) {\r\n                            ph.callback(xhr.responseText);\r\n                            xhr = null;\r\n                        } else if (ph.onError) {\r\n                            ph.onError(xhr);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\t\t\tvar params = null;\r\n\t\t\tif (ph.params) {\r\n\t\t\t\tparams = ph.params;\r\n\t\t\t\tvar syncParams = L.gmx.gmxMapManager.getSyncParams(true);\r\n\t\t\t\tif (syncParams) {\r\n\t\t\t\t\tparams += '&' + syncParams;\r\n\t\t\t\t}\r\n\t\t\t}\r\n            xhr.send(params);\r\n            if (!ph.async && xhr.status === 200) {\r\n                ph.callback(xhr.responseText);\r\n                L.gmxUtil.loaderStatus(reqId, true);\r\n                return xhr.status;\r\n            }\r\n            return true;\r\n        }\r\n        if (ph.onError) {\r\n            ph.onError({Error: 'bad XMLHttpRequest!'});\r\n        }\r\n        return false;\r\n    },\r\n\r\n    tileSizes: [], // Размеры тайла по zoom\r\n    getTileNumFromLeaflet: function (tilePoint, zoom) {\r\n        if ('z' in tilePoint) {\r\n            zoom = tilePoint.z;\r\n        }\r\n        var pz = Math.pow(2, zoom),\r\n            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\r\n            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\r\n        return {\r\n            z: zoom,\r\n            x: tx % pz - pz / 2,\r\n            y: pz / 2 - 1 - ty % pz\r\n        };\r\n    },\r\n\r\n\tgetTilePosZoomDelta: function(tilePoint, zoomFrom, zoomTo) {\t\t// получить смещение тайла на меньшем zoom\r\n        var dz = Math.pow(2, zoomFrom - zoomTo),\r\n            size = 256 / dz,\r\n            dx = tilePoint.x % dz,\r\n            dy = tilePoint.y % dz;\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tzDelta: dz,\r\n\t\t\tx: size * (dx < 0 ? dz + dx : dx),\r\n\t\t\ty: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\r\n\t\t};\r\n    },\r\n\r\n    geoItemBounds: function(geo) {  // get item bounds array by geometry\r\n        if (!geo) {\r\n            return {\r\n                bounds: null,\r\n                boundsArr: []\r\n            };\r\n        }\r\n        var type = geo.type,\r\n            coords = geo.coordinates,\r\n            b = null,\r\n            i = 0,\r\n            len = 0,\r\n            bounds = null,\r\n            boundsArr = [];\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr1 = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr1.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                }\r\n                boundsArr.push(arr1);\r\n            }\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                boundsArr.push(b);\r\n                if (i === 0) { bounds.extendBounds(b); }\r\n            }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds([coords[i]]);\r\n                bounds.extendBounds(b);\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n            //boundsArr.push(bounds);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                bounds.extendBounds(b);\r\n                //boundsArr.push(b);\r\n            }\r\n        }\r\n        return {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n    },\r\n\r\n    getUnFlattenGeo: function(geo) {  // get unFlatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            coords = geo.coordinates,\r\n            coordsOut = coords;\r\n\r\n        if (isLikePolygon) {\r\n            coordsOut = [];\r\n            var isPolygon = type === 'POLYGON' || type === 'Polygon';\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                var ring = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\r\n                }\r\n                coordsOut.push(ring);\r\n            }\r\n            if (isPolygon) { coordsOut = coordsOut[0]; }\r\n        }\r\n        return {type: type, coordinates: coordsOut};\r\n    },\r\n\r\n    unFlattenRing: function(arr) {\r\n        if (typeof arr[0] !== 'number') {\r\n            return arr;\r\n        }\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            res = new Array(len / 2);\r\n\r\n        for (var i = 0; i < len; i += 2) {\r\n            res[cnt++] = [arr[i], arr[i + 1]];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    geoFlatten: function(geo) {  // get flatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates;\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    flattenRing: function(arr) {\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\r\n            res = new CurArray(2 * len);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            res[cnt++] = arr[i][0];\r\n            res[cnt++] = arr[i][1];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /** Check rectangle type by coordinates\r\n     * @memberof L.gmxUtil\r\n     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n     * @return {Boolean}\r\n    */\r\n    isRectangle: function(coords) {\r\n        return (coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4)\r\n            && ((coords[0][0][0] === coords[0][1][0]) || (coords[0][0][1] === coords[0][1][1]))\r\n            && ((coords[0][1][0] === coords[0][2][0]) || (coords[0][1][1] === coords[0][2][1]))\r\n            && ((coords[0][2][0] === coords[0][3][0]) || (coords[0][2][1] === coords[0][3][1]))\r\n            && ((coords[0][3][0] === coords[0][0][0]) || (coords[0][3][1] === coords[0][0][1]))\r\n        );\r\n    },\r\n\r\n    /** Get bounds from geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n     * @return {Object} bounds\r\n    */\r\n    getGeometryBounds: function(geo) {\r\n        var pt = gmxAPIutils.geoItemBounds(geo);\r\n        return pt.bounds;\r\n    },\r\n\r\n    getMarkerPolygon: function(bounds, dx, dy) {\r\n        var x = (bounds.min.x + bounds.max.x) / 2,\r\n            y = (bounds.min.y + bounds.max.y) / 2;\r\n        return [\r\n            [x - dx, y - dy],\r\n            [x - dx, y + dy],\r\n            [x + dx, y + dy],\r\n            [x + dx, y - dy],\r\n            [x - dx, y - dy]\r\n        ];\r\n    },\r\n\r\n    getQuicklookPointsFromProperties: function(pArr, gmx) {\r\n        var indexes = gmx.tileAttributeIndexes;\r\n        var points = {\r\n                x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\r\n                y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\r\n                x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\r\n                y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\r\n                x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\r\n                y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\r\n                x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\r\n                y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\r\n            },\r\n            bounds = gmxAPIutils.bounds([\r\n                [points.x1, points.y1],\r\n                [points.x2, points.y2],\r\n                [points.x3, points.y3],\r\n                [points.x4, points.y4]\r\n            ]);\r\n\r\n        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\r\n            return null;\r\n        }\r\n\r\n        if (!gmx.quicklookPlatform) {\r\n            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\r\n            points.x1 = merc.x; points.y1 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\r\n            points.x2 = merc.x; points.y2 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\r\n            points.x3 = merc.x; points.y3 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\r\n            points.x4 = merc.x; points.y4 = merc.y;\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /** Get hash properties from array properties\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} properties in Array format\r\n     * @param {Object} keys indexes\r\n     * @return {Object} properties in Hash format\r\n    */\r\n    getPropertiesHash: function(arr, indexes) {\r\n        var properties = {};\r\n        for (var key in indexes) {\r\n            properties[key] = arr[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    getPropItem: function(key, arr, indexes) {\r\n        return key in indexes ? arr[indexes[key]] : '';\r\n    },\r\n\r\n    dec2rgba: function(i, a)\t{\t\t\t\t// convert decimal to rgb\r\n        var r = (i >> 16) & 255,\r\n            g = (i >> 8) & 255,\r\n            b = i & 255;\r\n\t\treturn 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\r\n\t},\r\n\r\n    dec2hex: function(i) {\t\t\t\t\t// convert decimal to hex\r\n        return (i + 0x1000000).toString(16).substr(-6);\r\n    },\r\n\r\n    dec2color: function(i, a)   {   // convert decimal to canvas color\r\n        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\r\n    },\r\n\r\n    oneDay: 60 * 60 * 24,\t\t\t// один день\r\n\r\n    isTileKeysIntersects: function(tk1, tk2) { // пересечение по номерам двух тайлов\r\n        if (tk1.z < tk2.z) {\r\n            var t = tk1; tk1 = tk2; tk2 = t;\r\n        }\r\n\r\n        var dz = tk1.z - tk2.z;\r\n        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\r\n\t},\r\n\r\n    rotatePoints: function(arr, angle, iconScale, center) {\t\t\t// rotate - массива точек\r\n        var out = [];\r\n        angle *= Math.PI / 180.0;\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n        if (!iconScale) { iconScale = 1; }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            var x = iconScale * arr[i].x - center.x;\r\n            var y = iconScale * arr[i].y - center.y;\r\n            out.push({\r\n                'x': cos * x - sin * y + center.x,\r\n                'y': sin * x + cos * y + center.y\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n    getPatternIcon: function(item, style, indexes) { // получить bitmap стиля pattern\r\n        if (!style.fillPattern) { return null; }\r\n\r\n        var notFunc = true,\r\n            pattern = style.fillPattern,\r\n            prop = item ? item.properties : null,\r\n            step = pattern.step > 0 ? pattern.step : 0,\r\n            patternDefaults = {\r\n                minWidth: 1,\r\n                maxWidth: 1000,\r\n                minStep: 0,\r\n                maxStep: 1000\r\n            };\r\n        if (pattern.patternStepFunction && prop !== null) {\r\n            step = pattern.patternStepFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (step > patternDefaults.maxStep) {\r\n            step = patternDefaults.maxStep;\r\n        }\r\n        else if (step < patternDefaults.minStep) {\r\n            step = patternDefaults.minStep;\r\n        }\r\n\r\n        var size = pattern.width > 0 ? pattern.width : 8;\r\n        if (pattern.patternWidthFunction && prop !== null) {\r\n            size = pattern.patternWidthFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (size > patternDefaults.maxWidth) {\r\n            size = patternDefaults.maxWidth;\r\n        } else if (size < patternDefaults.minWidth) {\r\n            size = patternDefaults.minWidth;\r\n        }\r\n\r\n        var op = style.fillOpacity;\r\n        if (style.opacityFunction && prop !== null) {\r\n            op = style.opacityFunction(prop, indexes) / 100;\r\n            notFunc = false;\r\n        }\r\n\r\n        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\r\n            arr = (pattern.colors != null ? pattern.colors : rgb),\r\n            count = arr.length,\r\n            resColors = [],\r\n            i = 0;\r\n\r\n        for (i = 0; i < count; i++) {\r\n            var col = arr[i];\r\n            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\r\n                col = (prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3]);\r\n                notFunc = false;\r\n            }\r\n            resColors.push(col);\r\n        }\r\n        if (count === 0) { resColors = [0]; op = 0; count = 1; }   // pattern without colors\r\n\r\n        var delta = size + step,\r\n            allSize = delta * count,\r\n            center = 0,\r\n            //radius,\r\n            rad = 0,\r\n            hh = allSize,\t\t\t\t// высота битмапа\r\n            ww = allSize,\t\t\t\t// ширина битмапа\r\n            type = pattern.style || 'horizontal',\r\n            flagRotate = false;\r\n\r\n        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\r\n            flagRotate = true;\r\n        } else if (type === 'circle') {\r\n            ww = hh = 2 * delta;\r\n            center = Math.floor(ww / 2);\t// центр круга\r\n            //radius = Math.floor(size / 2);\t// радиус\r\n            rad = 2 * Math.PI / count;\t\t// угол в рад.\r\n        } else if (type === 'vertical') {\r\n            hh = 1;\r\n        } else if (type === 'horizontal') {\r\n            ww = 1;\r\n        }\r\n        if (ww * hh > patternDefaults.maxWidth) {\r\n            console.log({'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big'});\r\n            return null;\r\n        }\r\n\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.clearRect(0, 0, canvas.width, canvas.height);\r\n        if (type === 'diagonal2' || type === 'vertical') {\r\n            ptx.translate(ww, 0);\r\n            ptx.rotate(Math.PI / 2);\r\n        }\r\n\r\n        for (i = 0; i < count; i++) {\r\n            ptx.beginPath();\r\n            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\r\n            ptx.fillStyle = fillStyle;\r\n\r\n            if (flagRotate) {\r\n                var x1 = i * delta; var xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n\r\n                x1 += allSize; xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n                if (type === 'cross' || type === 'cross1') {\r\n                    x1 = i * delta; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n\r\n                    x1 += allSize; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n                }\r\n            } else if (type === 'circle') {\r\n                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\r\n                ptx.lineTo(center, center);\r\n            } else {\r\n                ptx.fillRect(0, i * delta, ww, size);\r\n            }\r\n            ptx.closePath();\r\n            ptx.fill();\r\n        }\r\n        var canvas1 = document.createElement('canvas');\r\n        canvas1.width = ww;\r\n        canvas1.height = hh;\r\n        var ptx1 = canvas1.getContext('2d');\r\n        ptx1.drawImage(canvas, 0, 0, ww, hh);\r\n        return {'notFunc': notFunc, 'canvas': canvas1};\r\n    },\r\n\r\n    getSVGIcon: function (options) {\r\n        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\r\n            type = options.type,\r\n            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\r\n            stroke = options.strokeStyle || '#0000ff',\r\n            strokeWidth = options.lineWidth || 2,\r\n            iconOptions = {\r\n                className: 'gmx-svg-icon'\r\n            };\r\n\r\n        if (options.className) {\r\n            iconOptions.className = options.className;\r\n        }\r\n        var size = options.iconSize;\r\n        iconOptions.iconSize = [size, size];\r\n        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\r\n\r\n        if (type === 'circle') {\r\n            if (options.fillRadialGradient) {\r\n                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\r\n                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop\r\n                    || [     // [%, color, opacity]\r\n                        [0, '#ffff00', 0.8],\r\n                        [1, '#ff0000', 0.8]\r\n                    ];\r\n\r\n                for (var i = 0, len = stopColor.length; i < len; i++) {\r\n                    var it = stopColor[i];\r\n                    svg += '<stop offset=\"' + (100 * it[0]) + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\r\n                }\r\n                svg += '</radialGradient></defs>';\r\n                fill = 'url(#myRadialGradient4)';\r\n                stroke = strokeWidth = null;\r\n            }\r\n            size /= 2;\r\n            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:\"' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:\"' + strokeWidth + ';'; }\r\n            svg += ';\" />';\r\n        } else if (type === 'square') {\r\n            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:' + 2 * strokeWidth + ';'; }\r\n            svg += '\" />';\r\n        }\r\n        if (options.text) {\r\n            var text = options.text;\r\n            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\r\n            for (var key in text) {\r\n                if (key !== 'count') { svg += ' ' + key + '=\"' + text[key] + '\"'; }\r\n            }\r\n            svg += '>' + text.count + '</text>';\r\n        }\r\n        svg += '</g></svg>';\r\n        iconOptions.html = svg;\r\n\r\n        return new L.DivIcon(iconOptions);\r\n    },\r\n\r\n    toPixels: function(p, tpx, tpy, mInPixel) { // get pixel point\r\n        var px1 = p[0] * mInPixel; \tpx1 = (0.5 + px1) << 0;\r\n        var py1 = p[1] * mInPixel;\tpy1 = (0.5 + py1) << 0;\r\n        return [px1 - tpx, tpy - py1].concat(p.slice(2));\r\n    },\r\n\r\n    getPixelPoint: function(attr, coords) {\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n            style = attr.style || {},\r\n            iconScale = currentStyle.iconScale || 1,\r\n            iconCenter = currentStyle.iconCenter || false,\r\n            sx = currentStyle.sx || style.sx || 4,\r\n            sy = currentStyle.sy || style.sy || 4,\r\n            weight = currentStyle.weight || style.weight || 0,\r\n            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy;\r\n\r\n        if (!iconCenter && iconAnchor) {\r\n            px1 -= iconAnchor[0];\r\n            py1 -= iconAnchor[1];\r\n        }\r\n        sx *= iconScale;\r\n        sy *= iconScale;\r\n        sx += weight;\r\n        sy += weight;\r\n\r\n        var py1 = py - coords[1] * mInPixel,\r\n\t\t\tpx1 = coords[0] * mInPixel - px;\r\n\r\n\t\tif (px1 - sx > 256) {\r\n\t\t\tpx1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t} else if (px1 < -sx) {\r\n\t\t\tpx1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t}\r\n\r\n        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0\r\n\t\t\t? null :\r\n            {\r\n                sx: sx,\r\n                sy: sy,\r\n                px1: (0.5 + px1) << 0,\r\n                py1: (0.5 + py1) << 0\r\n            }\r\n        ;\r\n    },\r\n    getImageData: function(img) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return null; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.drawImage(img, 0, 0);\r\n        return ptx.getImageData(0, 0, ww, hh).data;\r\n    },\r\n    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\r\n    isIE: function(v) {\r\n        return v === gmxAPIutils.getIEversion();\r\n    },\r\n    gtIE: function(v) {\r\n        return v < gmxAPIutils.getIEversion();\r\n    },\r\n\r\n    getIEversion: function() {\r\n        var ua = navigator.userAgent || '',\r\n            msie = ua.indexOf('MSIE ');\r\n        if (msie > 0) {\r\n            // IE 10 or older => return version number\r\n            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n        }\r\n\r\n        var trident = ua.indexOf('Trident/');\r\n        if (trident > 0) {\r\n            // IE 11 => return version number\r\n            var rv = ua.indexOf('rv:');\r\n            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n        }\r\n\r\n        var edge = ua.indexOf('Edge/');\r\n        if (edge > 0) {\r\n            // Edge (IE 12+) => return version number\r\n            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n        }\r\n\r\n        // other browser\r\n        return -1;\r\n    },\r\n\r\n    replaceColor: function(img, color, fromData) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return img; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var flag = false,\r\n            imageData,\r\n            ptx = canvas.getContext('2d');\r\n\r\n        if (typeof color === 'string') {\r\n            color = parseInt('0x' + color.replace(/#/, ''));\r\n        }\r\n        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\r\n            var r = (color >> 16) & 255,\r\n                g = (color >> 8) & 255,\r\n                b = color & 255;\r\n\r\n            if (fromData) {\r\n                imageData = ptx.createImageData(ww, hh);\r\n            } else {\r\n                ptx.drawImage(img, 0, 0);\r\n                imageData = ptx.getImageData(0, 0, ww, hh);\r\n                fromData = imageData.data;\r\n            }\r\n            var toData = imageData.data;\r\n            for (var i = 0, len = fromData.length; i < len; i += 4) {\r\n                if ((fromData[i] === 0xff || fromData[i] === 238)\r\n                    && fromData[i + 1] === 0\r\n                    && fromData[i + 2] === 0xff\r\n                    ) {\r\n                    toData[i] = r;\r\n                    toData[i + 1] = g;\r\n                    toData[i + 2] = b;\r\n                    toData[i + 3] = fromData[i + 3];\r\n                    flag = true;\r\n                }\r\n            }\r\n        }\r\n        if (flag) {\r\n            ptx.putImageData(imageData, 0, 0);\r\n        } else {\r\n            ptx.drawImage(img, 0, 0);\r\n        }\r\n        return canvas;\r\n    },\r\n\r\n    drawIconPath: function(path, attr) { // draw iconPath in canvas\r\n        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) { return; }\r\n        var trFlag = false,\r\n            ctx = attr.ctx,\r\n            rad = attr.radian;\r\n\r\n        if (attr.px || attr.py) { ctx.translate(attr.px || 0, attr.py || 0); trFlag = true; }\r\n        if (!rad && attr.rotateRes) { rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes); }\r\n        if (rad) { ctx.rotate(rad); trFlag = true; }\r\n        ctx.moveTo(path[0], path[1]);\r\n        for (var i = 2, len = path.length; i < len; i += 2) {\r\n            ctx.lineTo(path[i], path[i + 1]);\r\n        }\r\n        if (trFlag) { ctx.setTransform(1, 0, 0, 1, 0, 0); }\r\n    },\r\n\r\n    pointToCanvas: function(attr) { // Точку в canvas\r\n        var gmx = attr.gmx,\r\n            pointAttr = attr.pointAttr,\r\n            style = attr.style || {},\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconScale = currentStyle.iconScale || 1,\r\n            image = currentStyle.image,\r\n            sx = pointAttr.sx,\r\n            sy = pointAttr.sy,\r\n            px1 = pointAttr.px1,\r\n            py1 = pointAttr.py1,\r\n            px1sx = px1,\r\n            py1sy = py1,\r\n            ctx = attr.ctx;\r\n\r\n        if (currentStyle.type === 'image') {\r\n            sx = style.sx;\r\n            sy = style.sy;\r\n            image = style.image;\r\n        }\r\n        if (currentStyle.iconCenter) {\r\n            px1sx -= sx / 2;\r\n            py1sy -= sy / 2;\r\n        } else if (style.type === 'circle') {\r\n            px1 += sx / 2;\r\n            py1 += sy / 2;\r\n        }\r\n        if (currentStyle.iconPath) {\r\n            attr.px = px1;\r\n            attr.py = py1;\r\n            attr.rotateRes = currentStyle.rotate || 0;\r\n        }\r\n        if (image) {\r\n            if ('iconColor' in currentStyle) {\r\n                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\r\n            }\r\n            style.rotateRes = currentStyle.rotate || 0;\r\n            if ('opacity' in style) { ctx.globalAlpha = currentStyle.opacity || style.opacity; }\r\n            if (gmx.transformFlag) {\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\r\n                ctx.drawImage(image, px1, -py1, sx, sy);\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\r\n            } else {\r\n\t\t\t\tif (iconScale !== 1) {\r\n\t\t\t\t\tsx *= iconScale;\r\n\t\t\t\t\tsy *= iconScale;\r\n\t\t\t\t\tpx1 = pointAttr.px1;\r\n\t\t\t\t\tpy1 = pointAttr.py1;\r\n\t\t\t\t\tpx1sx = px1;\r\n\t\t\t\t\tpy1sy = py1;\r\n\t\t\t\t\tif (currentStyle.iconCenter) {\r\n\t\t\t\t\t\tpx1sx -= sx / 2;\r\n\t\t\t\t\t\tpy1sy -= sy / 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (style.rotateRes) {\r\n\t\t\t\t\tctx.translate(px1, py1);\r\n\t\t\t\t\tctx.rotate(gmxAPIutils.degRad(style.rotateRes));\r\n\t\t\t\t\tctx.translate(-px1, -py1);\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t}\r\n            }\r\n            if ('opacity' in style) { ctx.globalAlpha = 1; }\r\n        } else if (style.fillColor || currentStyle.fillRadialGradient) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\r\n                var circle = style.iconSize / 2;\r\n                if (currentStyle.fillRadialGradient) {\r\n                    var rgr = currentStyle.fillRadialGradient;\r\n                    circle = rgr.r2 * iconScale;\r\n                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\r\n                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\r\n                        var arr = rgr.addColorStop[i];\r\n                        radgrad.addColorStop(arr[0], arr[1]);\r\n                    }\r\n                    ctx.fillStyle = radgrad;\r\n                }\r\n                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.fillRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.fill();\r\n        }\r\n        if (currentStyle.strokeStyle) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle') {\r\n                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.strokeRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n    },\r\n    lineToCanvasAsIcon: function(pixels, attr) {  // add line(as icon) to canvas\r\n        var len = pixels.length,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconPath = currentStyle.iconPath;\r\n\r\n        if (len > 0) {\r\n            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n                ctx.setLineDash([]);\r\n            }\r\n            ctx.beginPath();\r\n            for (var i = 0, p; i < len; i++) {\r\n                p = pixels[i];\r\n                gmxAPIutils.drawIconPath(iconPath, {ctx: ctx, px: p.x, py: p.y, radian: p.radian});\r\n            }\r\n            if (currentStyle.strokeStyle) {\r\n                ctx.stroke();\r\n            }\r\n            if (currentStyle.fillStyle) {\r\n                ctx.fill();\r\n            }\r\n        }\r\n    },\r\n    lineToCanvas: function(attr) {  // Lines in canvas\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            pixels = currentStyle.iconPath ? [] : null;\r\n\r\n        var lastX = null, lastY = null;\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\r\n                x = p[0],\r\n                y = p[1];\r\n            if (lastX !== x || lastY !== y) {\r\n                if (pixels) { pixels.push({x: x, y: y, radian: p[2]}); }\r\n                if (i === 0) {\r\n                    ctx.moveTo(x, y);\r\n                } else {\r\n                    ctx.lineTo(x, y);\r\n                }\r\n                lastX = x; lastY = y;\r\n            }\r\n        }\r\n        ctx.stroke();\r\n        return pixels;\r\n    },\r\n\r\n    getCoordsPixels: function(attr) {\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || [],\r\n            pixels = [],\r\n            hidden = [],\r\n            hiddenFlag = false,\r\n            hash = {\r\n                gmx: gmx,\r\n                tpx: attr.tpx,\r\n                tpy: attr.tpy,\r\n                coords: null,\r\n                hiddenLines: null\r\n            };\r\n        for (var j = 0, len = coords.length; j < len; j++) {\r\n            var coords1 = coords[j],\r\n                hiddenLines1 = hiddenLines[j] || [],\r\n                pixels1 = [], hidden1 = [];\r\n            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\r\n                hash.coords = coords1[j1];\r\n                hash.hiddenLines = hiddenLines1[j1] || [];\r\n                var res = gmxAPIutils.getRingPixels(hash);\r\n                pixels1.push(res.coords);\r\n                hidden1.push(res.hidden);\r\n                if (res.hidden) {\r\n                    hiddenFlag = true;\r\n                }\r\n            }\r\n            pixels.push(pixels1);\r\n            hidden.push(hidden1);\r\n        }\r\n        return {coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom};\r\n    },\r\n\r\n    getRingPixels: function(attr) {\r\n        if (attr.coords.length === 0) { return null; }\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            lastX = null, lastY = null,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            pixels = [], hidden = [];\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var lineIsOnEdge = false;\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x1 = c[0] * mInPixel, y1 = c[1] * mInPixel,\r\n                x2 = Math.round(x1 - px), y2 = Math.round(py - y1);\r\n\r\n            if (lastX !== x2 || lastY !== y2) {\r\n                lastX = x2; lastY = y2;\r\n                if (lineIsOnEdge) {\r\n                    hidden.push(cnt);\r\n                }\r\n                pixels[cnt++] = x1;\r\n                pixels[cnt++] = y1;\r\n            }\r\n        }\r\n        return {coords: pixels, hidden: hidden.length ? hidden : null};\r\n    },\r\n\r\n    polygonToCanvas: function(attr) {       // Polygons in canvas\r\n        if (attr.coords.length === 0) { return null; }\r\n        var hiddenLines = attr.hiddenLines || null,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            lastX = null, lastY = null;\r\n\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x = Math.round(c[0] - px),\r\n                y = Math.round(py - c[1]),\r\n                lineIsOnEdge = false;\r\n\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n\r\n            if (lastX !== x || lastY !== y) {\r\n                ctx[(lineIsOnEdge ? 'moveTo' : 'lineTo')](x, y);\r\n                lastX = x; lastY = y;\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt === 1) { ctx.lineTo(lastX + 1, lastY); }\r\n        ctx.stroke();\r\n    },\r\n\r\n    polygonToCanvasFill: function(attr) {     // Polygon fill\r\n        if (attr.coords.length < 3) { return; }\r\n        var coords = attr.coords,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            vectorSize = 1,\r\n            ctx = attr.ctx;\r\n\r\n        ctx.lineWidth = 0;\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\r\n        } else {\r\n            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\r\n        }\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\r\n        }\r\n    },\r\n\r\n    isPatternNode: function(it) {\r\n        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\r\n    },\r\n    labelCanvasContext: null,    // 2dContext canvas for Label size\r\n    getLabelWidth: function(txt, style) {   // Get label size Label\r\n        if (style) {\r\n            if (!gmxAPIutils.labelCanvasContext) {\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = canvas.height = 512;\r\n                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\r\n            }\r\n            var ptx = gmxAPIutils.labelCanvasContext;\r\n            ptx.clearRect(0, 0, 512, 512);\r\n\r\n            if (ptx.font !== style.font) { ptx.font = style.font; }\r\n            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\r\n            if (ptx.fillStyle !== style.fillStyle) { ptx.fillStyle = style.fillStyle; }\r\n\t\t\tvar arr = txt.split('\\n');\r\n            return arr.map(function(it) {\r\n\t\t\t\tptx.fillText(it, 0, 0);\r\n\t\t\t\treturn [it, ptx.measureText(it).width];\r\n\t\t\t});\r\n        }\r\n        return 0;\r\n    },\r\n    setLabel: function(ctx, txt, coord, style) {\r\n        var x = coord[0],\r\n            y = coord[1];\r\n\r\n        if (ctx.shadowColor !== style.strokeStyle) { ctx.shadowColor = style.strokeStyle; }\r\n        if (ctx.shadowBlur !== style.shadowBlur) { ctx.shadowBlur = style.shadowBlur; }\r\n        if (ctx.font !== style.font) { ctx.font = style.font; }\r\n        if (ctx.strokeStyle !== style.strokeStyle) { ctx.strokeStyle = style.strokeStyle; }\r\n        if (ctx.fillStyle !== style.fillStyle) { ctx.fillStyle = style.fillStyle; }\r\n        ctx.strokeText(txt, x, y);\r\n        ctx.fillText(txt, x, y);\r\n    },\r\n    worldWidthMerc: 20037508,\r\n    rMajor: 6378137.000,\r\n    degRad: function(ang) {\r\n        return ang * (Math.PI / 180.0);\r\n    },\r\n\r\n    distVincenty: function(lon1, lat1, lon2, lat2) {\r\n        var p1 = {\r\n            lon: gmxAPIutils.degRad(lon1),\r\n            lat: gmxAPIutils.degRad(lat1)\r\n        },\r\n            p2 = {\r\n            lon: gmxAPIutils.degRad(lon2),\r\n            lat: gmxAPIutils.degRad(lat2)\r\n        },\r\n            a = gmxAPIutils.rMajor,\r\n            b = 6356752.3142,\r\n            f = 1 / 298.257223563;  // WGS-84 ellipsiod\r\n\r\n        var L1 = p2.lon - p1.lon,\r\n            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\r\n            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\r\n            sinU1 = Math.sin(U1), cosU1 = Math.cos(U1),\r\n            sinU2 = Math.sin(U2), cosU2 = Math.cos(U2),\r\n            lambda = L1,\r\n            lambdaP = 2 * Math.PI,\r\n            iterLimit = 20;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda),\r\n                    sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +\r\n                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n                if (sinSigma === 0) { return 0; }\r\n                var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\r\n                    sigma = Math.atan2(sinSigma, cosSigma),\r\n                    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\r\n                    cosSqAlpha = 1 - sinAlpha * sinAlpha,\r\n                    cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n                if (isNaN(cos2SigmaM)) { cos2SigmaM = 0; }\r\n                var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n                lambdaP = lambda;\r\n                lambda = L1 + (1 - C) * f * sinAlpha *\r\n                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0) { return NaN; }\r\n\r\n        var uSq = cosSqAlpha * ((a * a) / (b * b) - 1),\r\n        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\r\n            A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\r\n            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\r\n            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -\r\n                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\r\n            s = b * A * (sigma - deltaSigma);\r\n\r\n        //s = s.toFixed(3);\r\n        return s;\r\n    },\r\n\r\n    _vfi: function(fi, a, b) {\r\n        return [\r\n            -Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a),\r\n            Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a),\r\n            -Math.sin(fi) * Math.cos(b)\r\n        ];\r\n    },\r\n\r\n    getCircleLatLngs: function(latlng, r) {   // Get latlngs for circle\r\n        var x = 0, y = 0;\r\n        if (latlng instanceof L.LatLng) {\r\n            x = latlng.lng;\r\n            y = latlng.lat;\r\n        } else if (L.Util.isArray(latlng)) {\r\n            x = latlng[1];\r\n            y = latlng[0];\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        var rad = Math.PI / 180,\r\n            a = x * rad,  //долгота центра окружности в радианах\r\n            b = y * rad,  //широта центра окружности в радианах\r\n            R = gmxAPIutils.rMajor,\r\n            d = R * Math.sin(r / R),\r\n            Rd = R * Math.cos(r / R),\r\n            VR = [\r\n                Rd * Math.cos(b) * Math.cos(a),\r\n                Rd * Math.cos(b) * Math.sin(a),\r\n                Rd * Math.sin(b)\r\n            ],\r\n            latlngs = [];\r\n\r\n        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\r\n            var v = gmxAPIutils._vfi(fi, a, b),\r\n                circle = [];\r\n            for (var i = 0; i < 3; i++) { circle[i] = VR[i] + d * v[i]; }\r\n\r\n            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\r\n            if (circle[1] < 0) { t2 = -t2; }\r\n\r\n            if (t2 < x - 180) {\r\n                t2 += 360;\r\n            } else if (t2 > x + 180) {\r\n                t2 -= 360;\r\n            }\r\n            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\r\n        }\r\n        return latlngs;\r\n    },\r\n\r\n    /** Get point coordinates from string\r\n     * @memberof L.gmxUtil\r\n     * @param {String} text - point coordinates in following formats:\r\n         <br/><i>55.74312, 37.61558</i>\r\n         <br/><i>55°44'35\" N, 37°36'56\" E</i>\r\n         <br/><i>4187347, 7472103</i>\r\n         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n     * @return {Array} [lat, lng] or null\r\n    */\r\n    parseCoordinates: function(text) {\r\n        var crs = null,\r\n            regex = /\\(EPSG:(\\d+)\\)/g,\r\n            t = regex.exec(text);\r\n\r\n        if (t) {\r\n            crs = t[1];\r\n            text = text.replace(regex, '');\r\n        }\r\n\r\n        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\r\n            return null;\r\n        }\r\n\r\n        //there should be a separator in the string (exclude strings like \"11E11\")\r\n        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\r\n            return null;\r\n        }\r\n\r\n        if (text.indexOf(' ') !== -1) {\r\n            text = text.replace(/,/g, '.');\r\n        }\r\n        var results = [];\r\n        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\r\n        t = regex.exec(text);\r\n        while (t) {\r\n            results.push(t[1]);\r\n            t = regex.exec(text);\r\n        }\r\n        if (results.length < 2) {\r\n            return null;\r\n        }\r\n        var ii = Math.floor(results.length / 2),\r\n            y = 0,\r\n            mul = 1,\r\n            i;\r\n        for (i = 0; i < ii; i++) {\r\n            y += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n        var x = 0;\r\n        mul = 1;\r\n        for (i = ii; i < results.length; i++) {\r\n            x += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n\r\n        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\r\n            t = x;\r\n            x = y;\r\n            y = t;\r\n        }\r\n\r\n        var pos;\r\n        if (crs === '3857') {\r\n            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\r\n            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n\r\n        if (text.indexOf('W') !== -1) {\r\n            x = -x;\r\n        }\r\n\r\n        if (text.indexOf('S') !== -1) {\r\n            y = -y;\r\n        }\r\n        return [y, x];\r\n    },\r\n\r\n\tpad2: function(t) {\r\n\t\treturn (t >= 0 && t < 10) ? ('0' + t) : ('' + t);\r\n\t},\r\n\r\n\ttrunc: function(x) {\r\n\t\treturn ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\r\n\t},\r\n\r\n\tformatDegrees: function(angle, format) {\r\n\t\tangle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\r\n\t\tvar a1 = Math.floor(angle),\r\n\t\t\ta2 = Math.floor(60 * (angle - a1)),\r\n\t\t\ta3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\r\n\t\t\tst = gmxAPIutils.pad2(a1) + '°';\r\n\r\n\t\tif (format ===  undefined ) { format = 2; }\r\n\t\tif (format > 0) {\r\n\t\t\tst += gmxAPIutils.pad2(a2) + '\\'';\r\n\t\t}\r\n\t\tif (format > 1) {\r\n\t\t\tst += gmxAPIutils.pad2(a3) + '\"';\r\n\t\t}\r\n\t\treturn st;\r\n\t},\r\n\r\n    /** Get point coordinates in string format with degrees\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format with degrees\r\n    */\r\n\tlatLonFormatCoordinates: function(x, y) {\r\n        x %= 360;\r\n        if (x > 180) { x -= 360; }\r\n        else if (x < -180) { x += 360; }\r\n\t\treturn  gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\r\n\tformatCoordinates: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates(x, y);\r\n\t},\r\n\r\n    /** Get point coordinates in string format\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format\r\n    */\r\n\tlatLonFormatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\tformatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates2(x, y);\r\n\t},\r\n\r\n    getPixelScale: function(zoom) {\r\n        return 256 / gmxAPIutils.tileSizes[zoom];\r\n    },\r\n\r\n    forEachPoint: function(coords, callback) {\r\n        if (!coords || coords.length === 0) { return []; }\r\n        var i, len, ret = [];\r\n        if (!coords[0].length) {\r\n            if (coords.length === 2) {\r\n                return callback(coords);\r\n            } else {\r\n                for (i = 0, len = coords.length / 2; i < len; i++) {\r\n                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                if (typeof coords[i] !== 'string') {\r\n                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    },\r\n/*\r\n\tgetQuicklookPoints: function(coord) { // получить 4 точки привязки снимка\r\n\t\tvar d1 = Number.MAX_VALUE;\r\n\t\tvar d2 = Number.MAX_VALUE;\r\n\t\tvar d3 = Number.MAX_VALUE;\r\n\t\tvar d4 = Number.MAX_VALUE;\r\n\t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t\tthis.forEachPoint(coord, function(p) {\r\n\t\t\tvar x = p[0];\r\n\t\t\tvar y = p[1];\r\n\t\t\tif ((x - y) < d1) {\r\n\t\t\t\td1 = x - y;\r\n\t\t\t\tx1 = p[0];\r\n\t\t\t\ty1 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x - y) < d2) {\r\n\t\t\t\td2 = -x - y;\r\n\t\t\t\tx2 = p[0];\r\n\t\t\t\ty2 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x + y) < d3) {\r\n\t\t\t\td3 = -x + y;\r\n\t\t\t\tx3 = p[0];\r\n\t\t\t\ty3 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((x + y) < d4) {\r\n\t\t\t\td4 = x + y;\r\n\t\t\t\tx4 = p[0];\r\n\t\t\t\ty4 = p[1];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t},\r\n*/\r\n    getItemCenter: function(item, geoItems) {\r\n        var bounds = item.bounds,\r\n            min = bounds.min, max = bounds.max,\r\n            type = item.type,\r\n            isPoint = type === 'POINT' || type === 'MULTIPOINT',\r\n            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n\r\n        if (type === 'MULTIPOLYGON') {\r\n\t\t\treturn center;\r\n\t\t} else if (type === 'POLYGON') {\r\n            for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                var it = geoItems[i],\r\n                    geom = it.geo,\r\n                    coords = geom.coordinates,\r\n                    dataOption = it.dataOption,\r\n                    bbox = dataOption.bounds;\r\n\r\n                if (bbox.contains(center)) {\r\n                    if (geom.type === 'POLYGON') { coords = [coords]; }\r\n                    for (var j = 0, len1 = coords.length; j < len1; j++) {\r\n                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\r\n                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\r\n                            if (pt) {\r\n                                return pt.max.center;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (type === 'POINT' || type === 'MULTIPOINT') {\r\n            return center;\r\n        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\r\n            return center;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    getHSegmentsInPolygon: function(y, poly) {\r\n        var s = [], i, len, out,\r\n            vectorSize = 1,\r\n            p1 = poly[0];\r\n\r\n        if (typeof poly[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [poly[0], poly[1]];\r\n        }\r\n        var isGt1 = y > p1[1];\r\n        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\r\n                isGt2 = y > p2[1];\r\n            if (isGt1 !== isGt2) {\r\n                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\r\n            }\r\n            p1 = p2;\r\n            isGt1 = isGt2;\r\n        }\r\n        len = s.length;\r\n        if (len) {\r\n            s = s.sort();\r\n            var max = 0,\r\n                index = -1;\r\n            for (i = 1; i < len; i += 2) {\r\n                var j = i - 1,\r\n                    d = Math.abs(s[i] - s[j]);\r\n                if (d > max) {\r\n                    max = d;\r\n                    index = j;\r\n                }\r\n            }\r\n            out = {\r\n                y: y,\r\n                segArr: s,\r\n                max: {\r\n                    width: max,\r\n                    center: [(s[index] + s[index + 1]) / 2, y]\r\n                }\r\n            };\r\n        }\r\n        return out;\r\n    },\r\n\r\n    isPointInPolygonArr: function(chkPoint, coords) { // Проверка точки на принадлежность полигону в виде массива\r\n        var isIn = false,\r\n            x = chkPoint[0],\r\n            y = chkPoint[1],\r\n            vectorSize = 1,\r\n            p1 = coords[0];\r\n\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [coords[0], coords[1]];\r\n        }\r\n\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                xmin = Math.min(p1[0], p2[0]),\r\n                xmax = Math.max(p1[0], p2[0]),\r\n                ymax = Math.max(p1[1], p2[1]);\r\n            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\r\n                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\r\n                if (p1[1] === p2[1] || y <= xinters) { isIn = !isIn; }\r\n            }\r\n            p1 = p2;\r\n        }\r\n        return isIn;\r\n    },\r\n\r\n    /** Is point in polygon with holes\r\n     * @memberof L.gmxUtil\r\n     * @param {chkPoint} chkPoint - point in [x, y] format\r\n     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n     * @return {Boolean} true if polygon contain chkPoint\r\n    */\r\n    isPointInPolygonWithHoles: function(chkPoint, coords) {\r\n        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) { return false; }\r\n        for (var j = 1, len = coords.length; j < len; j++) {\r\n            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) { return false; }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /** Is polygon clockwise\r\n     * @memberof L.gmxUtil\r\n     * @param {ring} ring - ring from geoJSON coordinates data format\r\n     * @return {Boolean} true if ring is clockwise\r\n    */\r\n    isClockwise: function(ring) {\r\n        var area = 0;\r\n        for (var i = 0, j, len = ring.length; i < len; i++) {\r\n            j = (i + 1) % len;\r\n            area += ring[i][0] * ring[j][1];\r\n            area -= ring[j][0] * ring[i][1];\r\n        }\r\n        return (area < 0);\r\n    },\r\n\r\n    isPointInPolyLine: function(chkPoint, lineHeight, coords, hiddenLines) {\r\n        // Проверка точки(с учетом размеров) на принадлежность линии\r\n        var dx = chkPoint[0], dy = chkPoint[1],\r\n            nullPoint = {x: dx, y: dy},\r\n            minx = dx - lineHeight, maxx = dx + lineHeight,\r\n            miny = dy - lineHeight, maxy = dy + lineHeight,\r\n            cntHide = 0;\r\n\r\n        lineHeight *= lineHeight;\r\n        for (var i = 1, len = coords.length; i < len; i++) {\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                cntHide++;\r\n            } else {\r\n                var p1 = coords[i - 1], p2 = coords[i],\r\n                    x1 = p1[0], y1 = p1[1],\r\n                    x2 = p2[0], y2 = p2[1];\r\n\r\n                if (!(Math.max(x1, x2) < minx\r\n                    || Math.min(x1, x2) > maxx\r\n                    || Math.max(y1, y2) < miny\r\n                    || Math.min(y1, y2) > maxy)) {\r\n                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, {x: x1, y: y1}, {x: x2, y: y2}, true);\r\n                    if (sqDist < lineHeight) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    isPointInLines: function (attr) {\r\n        var arr = attr.coords,\r\n            point = attr.point,\r\n            delta = attr.delta,\r\n            boundsArr = attr.boundsArr,\r\n            hidden = attr.hidden;\r\n        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\r\n            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\r\n            if (flag\r\n                && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)\r\n            ) {\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /** Get length\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} latlngs array\r\n     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n     * @return {Number} length\r\n    */\r\n    getLength: function(latlngs, isMerc) {\r\n        var length = 0;\r\n        if (latlngs && latlngs.length) {\r\n            var lng = false,\r\n                lat = false;\r\n\r\n            isMerc = isMerc === undefined || isMerc;\r\n            latlngs.forEach(function(latlng) {\r\n                if (L.Util.isArray(latlng)) {\r\n                    if (L.Util.isArray(latlng[0])) {\r\n                        length += gmxAPIutils.getLength(latlng, isMerc);\r\n                        return length;\r\n                    } else if (isMerc) {   // From Mercator array\r\n                        latlng = L.Projection.Mercator.unproject({x: latlng[0], y: latlng[1]});\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\r\n                }\r\n                lng = latlng.lng;\r\n                lat = latlng.lat;\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get prettify length\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area\r\n     * @param {String} type: ('km', 'm', 'nm')\r\n     * @return {String} prettify length\r\n    */\r\n    prettifyDistance: function(length, type) {\r\n        var km = ' ' + L.gmxLocale.getText('units.km');\r\n        if (type === 'nm') {\r\n            return (Math.round(0.539956803 * length) / 1000) + ' ' + L.gmxLocale.getText('units.nm');\r\n        } else if (type === 'km') {\r\n            return (Math.round(length) / 1000) + km;\r\n        } else if (length < 2000 || type === 'm') {\r\n            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\r\n        } else if (length < 200000) {\r\n            return (Math.round(length / 10) / 100) + km;\r\n        }\r\n        return Math.round(length / 1000) + km;\r\n    },\r\n\r\n    /** Get geoJSON length\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} length\r\n    */\r\n    geoJSONGetLength: function(geoJSON) {\r\n        var out = 0,\r\n            i, j, len, len1, coords;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'LineString') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingLength(coords[i]);\r\n            }\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                for (j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    out += gmxAPIutils.getRingLength(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getRingLength: function(coords) {\r\n        var length = 0;\r\n        if (coords && coords.length) {\r\n            var lng = false, lat = false;\r\n            coords.forEach(function(lnglat) {\r\n                if (L.Util.isArray(lnglat)) {\r\n                    if (lnglat.length > 2) {\r\n                        length += gmxAPIutils.getRingLength(lnglat);\r\n                        return length;\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\r\n                }\r\n                lng = lnglat[0];\r\n                lat = lnglat[1];\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get geoJSON area\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoJSONGetArea: function(geoJSON) {\r\n        var out = 0;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            var coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingArea(coords[i][0]);\r\n                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\r\n                    out -= gmxAPIutils.getRingArea(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    geoJSONGetLatLng: function(geoJSON) {\r\n        if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'Point') {\r\n            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\r\n        } else {\r\n            throw new Error('cannot get ' + geoJSON.type + ' latLng');\r\n        }\r\n    },\r\n\r\n    getRingArea: function(coords) {\r\n        var area = 0;\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = coords[i], p2 = coords[ipp];\r\n            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\r\n        }\r\n        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n        return out;\r\n    },\r\n\r\n    /** Get area\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} L.latLng array\r\n     * @return {Number} area in square meters\r\n    */\r\n    getArea: function(arr) {\r\n        var area = 0;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = arr[i], p2 = arr[ipp];\r\n            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\r\n        }\r\n        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n    },\r\n\r\n    /** Get prettified size of area\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area in square meters\r\n     * @param {String} type: ('km2', 'ha', 'm2')\r\n     * @return {String} prettified area\r\n    */\r\n    prettifyArea: function(area, type) {\r\n        var km2 = ' ' + L.gmxLocale.getText('units.km2');\r\n\r\n        if (type === 'km2') {\r\n            return ('' + (Math.round(area / 100) / 10000)) + km2;\r\n        } else if (type === 'ha') {\r\n            return ('' + (Math.round(area / 100) / 100)) + ' ' + L.gmxLocale.getText('units.ha');\r\n        } else if (area < 100000 || type === 'm2') {\r\n            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\r\n        } else if (area < 3000000) {\r\n            return ('' + (Math.round(area / 1000) / 1000)).replace('.', ',') + km2;\r\n        } else if (area < 30000000) {\r\n            return ('' + (Math.round(area / 10000) / 100)).replace('.', ',') + km2;\r\n        } else if (area < 300000000) {\r\n            return ('' + (Math.round(area / 100000) / 10)).replace('.', ',') + km2;\r\n        }\r\n        return (Math.round(area / 1000000)) + km2;\r\n    },\r\n\r\n    geoLength: function(geom) {\r\n        var ret = 0,\r\n            type = geom.type;\r\n        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoLength({type: 'LINESTRING', coordinates: geom.coordinates[i]});\r\n            }\r\n            return ret;\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            ret = gmxAPIutils.getLength(geom.coordinates);\r\n        }\r\n        return ret;\r\n    },\r\n\r\n    /** Converts Geomixer geometry to geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - Geomixer geometry\r\n     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n     * @return {Object} geoJSON geometry\r\n    */\r\n    geometryToGeoJSON: function (geom, mercFlag) {\r\n        if (!geom) {\r\n            return null;\r\n        }\r\n\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    convertGeometry: function (geom, fromMerc) {\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (fromMerc) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        } else {\r\n            coords = gmxAPIutils.coordsToMercator(type, coords);\r\n        }\r\n        return {\r\n            type: geom.type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    /** Converts GeoJSON object into GeoMixer format\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - GeoJSON object\r\n     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n     * @return {Object} Geometry in GeoMixer format\r\n    */\r\n    geoJSONtoGeometry: function (geoJSON, mercFlag) {\r\n        if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        }\r\n\r\n        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON'\r\n                : geoJSON.type === 'Polygon' ? 'POLYGON'\r\n                : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING'\r\n                : geoJSON.type === 'LineString' ? 'LINESTRING'\r\n                : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT'\r\n                : geoJSON.type === 'Point' ? 'POINT'\r\n                : geoJSON.type,\r\n            coords = geoJSON.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    _coordsConvert: function(type, coords, toMerc) {\r\n        var i, len, p,\r\n            resCoords = [];\r\n        if (type === 'Point') {\r\n            if (toMerc) {\r\n                p = L.Projection.Mercator.project({lat: coords[1], lng: coords[0]});\r\n                resCoords = [p.x, p.y];\r\n            } else {\r\n                p = L.Projection.Mercator.unproject({y: coords[1], x: coords[0]});\r\n                resCoords = [p.lng, p.lat];\r\n            }\r\n        } else if (type === 'LineString' || type === 'MultiPoint') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'Polygon' || type === 'MultiLineString') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'MultiPolygon') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\r\n            }\r\n        }\r\n        return resCoords;\r\n    },\r\n\r\n    coordsFromMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, false);\r\n    },\r\n\r\n    coordsToMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, true);\r\n    },\r\n\r\n    transformGeometry: function(geom, callback) {\r\n        return !geom ? geom : {\r\n            type: geom.type,\r\n            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function(p) {\r\n                return callback(p);\r\n            })\r\n        };\r\n    },\r\n\r\n    /** Get area for geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry\r\n     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoArea: function(geom, isMerc) {\r\n        var i, len, ret = 0,\r\n            type = geom.type || '';\r\n        isMerc = isMerc === undefined || isMerc;\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            for (i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoArea({type: 'POLYGON', coordinates: geom.coordinates[i]}, isMerc);\r\n            }\r\n            return ret;\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\r\n            for (i = 1, len = geom.coordinates.length; i < len; i++) {\r\n                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\r\n            }\r\n            return ret;\r\n        } else if (geom.length) {\r\n            var latlngs = [],\r\n                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\r\n\r\n            for (i = 0, len = geom.length; i < len; i += vectorSize) {\r\n                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\r\n                latlngs.push(\r\n                    isMerc ?\r\n                    L.Projection.Mercator.unproject({y: p[1], x: p[0]}) :\r\n                    {lat: p[1], lng: p[0]}\r\n                );\r\n            }\r\n            return gmxAPIutils.getArea(latlngs);\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    /** Get summary for geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON geometry\r\n     * @param {Object} unitOptions {\r\n     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n     *               }\r\n     * @return {String} Summary string for geometry\r\n    */\r\n    getGeoJSONSummary: function(geom, unitOptions) {\r\n        var type = geom.type,\r\n            units = unitOptions || {},\r\n            out = 0,\r\n            i, len, coords;\r\n        if (type === 'Point') {\r\n            coords = geom.coordinates;\r\n            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\r\n        } else if (type === 'Polygon') {\r\n            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\r\n        } else if (type === 'MultiPolygon') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoArea({type: 'Polygon', coordinates: coords[i]}, false);\r\n            }\r\n            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\r\n        } else if (type === 'LineString') {\r\n            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\r\n        } else if (type === 'MultiLineString') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoJSONGetLength({type: 'LineString', coordinates: coords[i]});\r\n            }\r\n            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for point\r\n     * @memberof L.gmxUtil\r\n     * @param {latlng} point\r\n     * @param {num} format number:\r\n     *         0: 62°52'30.68\" N, 22°48'27.42\" E\r\n     *         1: 62.875188 N, 22.807617 E\r\n     *         2: 2538932, 9031643 (EPSG:3395)\r\n     *         3: 2538932, 9069712 (EPSG:3857)\r\n     * @return {String} Summary string for LatLng point\r\n    */\r\n    getCoordinatesString: function(latlng, num) {\r\n        var x = latlng.lng,\r\n            y = latlng.lat,\r\n            formats = [\r\n                '',\r\n                '',\r\n                ' (EPSG:3395)',\r\n                ' (EPSG:3857)'\r\n            ],\r\n            len = formats.length,\r\n            merc,\r\n            out = '';\r\n        num = num || 0;\r\n        if (x > 180) { x -= 360; }\r\n        if (x < -180) { x += 360; }\r\n        if (num % len === 0) {\r\n            out = gmxAPIutils.formatCoordinates2(x, y);\r\n        } else if (num % len === 1) {\r\n            out = gmxAPIutils.formatCoordinates(x, y);\r\n        } else if (num % len === 2) {\r\n            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\r\n        } else {\r\n            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for geometries array\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} geometries array in Geomixer format\r\n     * @param {Object} units Options for length and area\r\n     * @return {String} Summary string for geometries array\r\n    */\r\n    getGeometriesSummary: function(arr, unitOptions) {\r\n        var out = '',\r\n            type = '',\r\n            res = 0;\r\n        if (!unitOptions) { unitOptions = {}; }\r\n        if (arr) {\r\n            arr.forEach(function(geom) {\r\n                if (geom) {\r\n                    type = geom.type.toUpperCase();\r\n                    if (type.indexOf('POINT') !== -1) {\r\n                        var latlng = L.Projection.Mercator.unproject({y: geom.coordinates[1], x: geom.coordinates[0]});\r\n                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: '\r\n                            + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\r\n                    } else if (type.indexOf('LINESTRING') !== -1) {\r\n                        res += gmxAPIutils.geoLength(geom);\r\n                    } else if (type.indexOf('POLYGON') !== -1) {\r\n                        res += gmxAPIutils.geoArea(geom);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (!out) {\r\n            if (type.indexOf('LINESTRING') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: '\r\n                    + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\r\n            } else if (type.indexOf('POLYGON') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: '\r\n                    + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getGeometrySummary: function(geom, unitOptions) {\r\n        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\r\n    },\r\n\r\n    chkOnEdge: function(p1, p2, ext) { // отрезок на границе\r\n        if ((p1[0] < ext.min.x && p2[0] < ext.min.x) || (p1[0] > ext.max.x && p2[0] > ext.max.x)) { return true; }\r\n        if ((p1[1] < ext.min.y && p2[1] < ext.min.y) || (p1[1] > ext.max.y && p2[1] > ext.max.y)) { return true; }\r\n        return false;\r\n    },\r\n\r\n    getHidden: function(coords, tb) {  // массив точек на границах тайлов\r\n        var hiddenLines = [],\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            prev = null;\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\r\n                hiddenLines.push(i);\r\n            }\r\n            prev = p;\r\n        }\r\n        return hiddenLines;\r\n    },\r\n\r\n    getNormalizeBounds: function (screenBounds, mercDeltaY) { // get bounds array from -180 180 lng\r\n        var northWest = screenBounds.getNorthWest(),\r\n            southEast = screenBounds.getSouthEast(),\r\n            minX = northWest.lng,\r\n            maxX = southEast.lng,\r\n            w = (maxX - minX) / 2,\r\n            minX1 = null,\r\n            maxX1 = null,\r\n            out = [];\r\n\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = {x: minX, y: southEast.lat},\r\n            m2 = {x: maxX, y: northWest.lat};\r\n\r\n        if (mercDeltaY !== undefined) {\r\n            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\r\n            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\r\n            m1.y -= mercDeltaY;\r\n            m2.y -= mercDeltaY;\r\n        }\r\n        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\r\n\r\n        if (minX1) {\r\n            var m11 = {x: minX1, y: southEast.lat},\r\n                m12 = {x: maxX1, y: northWest.lat};\r\n            if (mercDeltaY !== undefined) {\r\n                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\r\n                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\r\n                m11.y -= mercDeltaY;\r\n                m12.y -= mercDeltaY;\r\n            }\r\n            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\r\n        }\r\n        return out;\r\n    },\r\n\r\n    toPrecision: function(x, prec) {\r\n        var zn = Math.pow(10, prec ? prec : 4);\r\n        return Math.round(zn * x) / zn;\r\n    },\r\n\r\n    getTileBounds: function(x, y, z) {  //x, y, z - GeoMixer tile coordinates\r\n        var tileSize = gmxAPIutils.tileSizes[z],\r\n            minx = x * tileSize,\r\n            miny = y * tileSize;\r\n        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\r\n    },\r\n\r\n    parseTemplate: function(str, properties) {\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = key in properties ? properties[key] : '';\r\n\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getDefaultBalloonTemplate: function(properties, tileAttributeTypes) {\r\n        var str = '';\r\n        for (var key in properties) {\r\n            if (!tileAttributeTypes || (key in tileAttributeTypes)) {\r\n\t\t\t\tstr += '<b>' + key + ':</b> [' +  key + ']<br />';\r\n\t\t\t}\r\n        }\r\n        str += '<br />[SUMMARY]<br />';\r\n        return str;\r\n    },\r\n\r\n    parseBalloonTemplate: function(str, options) {\r\n        var properties = options.properties;\r\n\r\n        if (!str) {\r\n            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\r\n        }\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            var tileAttributeTypes = options.tileAttributeTypes,\r\n                unitOptions = options.unitOptions,\r\n                geometries = options.geometries;\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = '';\r\n\r\n                if (key in properties) {\r\n                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\r\n                } else if (key === 'SUMMARY') {\r\n                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    styleKeys: {\r\n        marker: {\r\n            server: ['image',   'angle',     'scale',     'minScale',     'maxScale',     'size',         'circle',     'center',     'color'],\r\n            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\r\n        },\r\n        outline: {\r\n            server: ['color',  'opacity',   'thickness', 'dashes'],\r\n            client: ['color',  'opacity',   'weight',    'dashArray']\r\n        },\r\n        fill: {\r\n            server: ['color',     'opacity',   'image',       'pattern',     'radialGradient',     'linearGradient'],\r\n            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\r\n        },\r\n        label: {\r\n            server: ['text',      'field',      'template',      'color',      'haloColor',      'size',          'spacing',      'align'],\r\n            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\r\n        }\r\n    },\r\n    styleFuncKeys: {\r\n        iconSize: 'iconSizeFunction',\r\n        iconAngle: 'rotateFunction',\r\n        iconScale: 'scaleFunction',\r\n        iconColor: 'iconColorFunction',\r\n        opacity: 'opacityFunction',\r\n        fillOpacity: 'fillOpacityFunction',\r\n        color: 'colorFunction',\r\n        fillColor: 'fillColorFunction'\r\n    },\r\n    styleFuncError: {\r\n        iconSize: function() { return 8; },\r\n        iconAngle: function() { return 0; },\r\n        iconScale: function() { return 1; },\r\n        iconColor: function() { return 0xFF; },\r\n        opacity: function() { return 1; },\r\n        fillOpacity: function() { return 0.5; },\r\n        color: function() { return 0xFF; },\r\n        fillColor: function() { return 0xFF; }\r\n    },\r\n    defaultStyles: {\r\n       MinZoom: 1,\r\n       MaxZoom: 21,\r\n       Filter: '',\r\n       Balloon: '',\r\n       DisableBalloonOnMouseMove: true,\r\n       DisableBalloonOnClick: false,\r\n       RenderStyle: {\r\n            point: {    // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\r\n                color: 0xFF,\r\n                weight: 1,\r\n                iconSize: 8\r\n            },\r\n            linestring: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            },\r\n            polygon: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    getDefaultStyle: function(type) {\r\n        var from = gmxAPIutils.defaultStyles,\r\n            out = L.extend({}, from);\r\n        out.RenderStyle = from.RenderStyle[type];\r\n        return out;\r\n    },\r\n\r\n    toServerStyle: function(style) {   // Style leaflet->Scanex\r\n        var out = {};\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (var i = 0, len = keys.client.length; i < len; i++) {\r\n                var key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    if (!out[key]) { out[key] = {}; }\r\n                    var zn = style[key1];\r\n                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\r\n                        zn *= 100;\r\n                    }\r\n                    out[key][keys.server[i]] = zn;\r\n                }\r\n            }\r\n        }\r\n        if ('iconAnchor' in style) {\r\n            if (!out.marker) { out.marker = {}; }\r\n            out.marker.dx = -style.iconAnchor[0];\r\n            out.marker.dy = -style.iconAnchor[1];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    fromServerStyle: function(style) {   // Style Scanex->leaflet\r\n        var st, i, len, key1,\r\n            out = {\r\n                type: ''    // 'polygon', 'line', 'circle', 'square', 'image'\r\n            };\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (i = 0, len = keys.client.length; i < len; i++) {\r\n                key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    out[key1] = style[key1];\r\n                }\r\n            }\r\n            st = style[key];\r\n            if (st && typeof (st) === 'object') {\r\n                for (i = 0, len = keys.server.length; i < len; i++) {\r\n                    key1 = keys.server[i];\r\n                    if (key1 in st) {\r\n                        var newKey = keys.client[i],\r\n                            zn = st[key1];\r\n                        if (typeof (zn) === 'string') {\r\n                            if (gmxAPIutils.styleFuncKeys[newKey]) {\r\n                                if (zn.match(/[^\\d\\.]/) === null) {\r\n                                    zn = Number(zn);\r\n                                } else {\r\n                                    var func = L.gmx.Parsers.parseExpression(zn);\r\n                                    if (func === null) {\r\n                                        zn = gmxAPIutils.styleFuncError[newKey]();\r\n                                    } else {\r\n                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else if (key1 === 'opacity') {\r\n                            zn /= 100;\r\n                        }\r\n                        out[newKey] = zn;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (style.marker) {\r\n            st = style.marker;\r\n            if ('dx' in st || 'dy' in st) {\r\n                var dx = st.dx || 0,\r\n                    dy = st.dy || 0;\r\n                out.iconAnchor = [-dx, -dy];    // For leaflet type iconAnchor\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getUnixTimeFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\treturn Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\r\n    },\r\n\r\n    getDateFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\tvar dt = new Date(arr[0], arr[1] - 1, arr[2]);\r\n        return dt;\r\n    },\r\n\r\n    getUTCdate: function(utime) {\r\n        var dt = new Date(utime * 1000);\r\n\r\n        return [\r\n            dt.getUTCFullYear(),\r\n            gmxAPIutils.pad2(dt.getUTCMonth() + 1),\r\n            gmxAPIutils.pad2(dt.getUTCDate())\r\n        ].join('.');\r\n    },\r\n\r\n    getUTCtime: function(utime) {\r\n        var h = Math.floor(utime / 3600),\r\n            m = Math.floor((utime - h * 3600) / 60),\r\n            s = Math.floor(utime - h * 3600 - m * 60);\r\n\r\n        return [\r\n            //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\r\n            gmxAPIutils.pad2(h),\r\n            gmxAPIutils.pad2(m),\r\n            gmxAPIutils.pad2(s)\r\n        ].join(':');\r\n    },\r\n\r\n    getUTCdateTime: function(utime) {\r\n        var time = utime % (3600 * 24);\r\n\r\n        if (time) {\r\n            return [\r\n                gmxAPIutils.getUTCdate(utime),\r\n                gmxAPIutils.getUTCtime(utime % (3600 * 24))\r\n            ].join(' ');\r\n        } else {\r\n            return gmxAPIutils.getUTCdate(utime);\r\n        }\r\n    },\r\n\r\n    attrToString: function(type, value) {\r\n        if (type === 'date') {\r\n            return value ? L.gmxUtil.getUTCdate(value) : value;\r\n        } else if (type === 'time') {\r\n            return value ? L.gmxUtil.getUTCtime(value) : value;\r\n        } else if (type === 'datetime') {\r\n            return value ? L.gmxUtil.getUTCdateTime(value) : value;\r\n        } else {\r\n            return value;\r\n        }\r\n    },\r\n\r\n    getTileAttributes: function(prop) {\r\n        var tileAttributeIndexes = {},\r\n            tileAttributeTypes = {};\r\n        if (prop.attributes) {\r\n            var attrs = prop.attributes,\r\n                attrTypes = prop.attrTypes || null;\r\n            if (prop.identityField) { tileAttributeIndexes[prop.identityField] = 0; }\r\n            for (var a = 0; a < attrs.length; a++) {\r\n                var key = attrs[a];\r\n                tileAttributeIndexes[key] = a + 1;\r\n                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\r\n            }\r\n        }\r\n        return {\r\n            tileAttributeTypes: tileAttributeTypes,\r\n            tileAttributeIndexes: tileAttributeIndexes\r\n        };\r\n    }\r\n};\r\n\r\ngmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0);\t\t\t\t// 111319.5;\r\ngmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI;\t// 6335440.712613423;\r\n\r\n(function() {\r\n    //pre-calculate tile sizes\r\n    for (var z = 0; z < 30; z++) {\r\n        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\r\n    }\r\n})();\r\n\r\ngmxAPIutils.Bounds = function(arr) {\r\n    this.min = {\r\n        x: Number.MAX_VALUE,\r\n        y: Number.MAX_VALUE\r\n    };\r\n    this.max = {\r\n        x: -Number.MAX_VALUE,\r\n        y: -Number.MAX_VALUE\r\n    };\r\n    this.extendArray(arr);\r\n};\r\ngmxAPIutils.Bounds.prototype = {\r\n    extend: function(x, y) {\r\n        if (x < this.min.x) { this.min.x = x; }\r\n        if (x > this.max.x) { this.max.x = x; }\r\n        if (y < this.min.y) { this.min.y = y; }\r\n        if (y > this.max.y) { this.max.y = y; }\r\n        return this;\r\n    },\r\n    extendBounds: function(bounds) {\r\n        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\r\n    },\r\n    extendArray: function(arr) {\r\n        if (!arr || !arr.length) { return this; }\r\n        var i, len;\r\n        if (typeof arr[0] === 'number') {\r\n            for (i = 0, len = arr.length; i < len; i += 2) {\r\n                this.extend(arr[i], arr[i + 1]);\r\n            }\r\n        } else {\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                this.extend(arr[i][0], arr[i][1]);\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    addBuffer: function(dxmin, dymin, dxmax, dymax) {\r\n        this.min.x -= dxmin;\r\n        this.min.y -= dymin || dxmin;\r\n        this.max.x += dxmax || dxmin;\r\n        this.max.y += dymax || dymin || dxmin;\r\n        return this;\r\n    },\r\n    contains: function (point) { // ([x, y]) -> Boolean\r\n        var min = this.min, max = this.max,\r\n            x = point[0], y = point[1];\r\n        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\r\n    },\r\n    getCenter: function () {\r\n        var min = this.min, max = this.max;\r\n        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n    },\r\n    addOffset: function (offset) {\r\n        this.min.x += offset[0]; this.max.x += offset[0];\r\n        this.min.y += offset[1]; this.max.y += offset[1];\r\n        return this;\r\n    },\r\n    intersects: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\r\n    },\r\n    intersectsWithDelta: function (bounds, dx, dy) { // (Bounds, dx, dy) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            x = dx || 0,\r\n            y = dy || 0,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\r\n    },\r\n    isEqual: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\r\n    },\r\n    isNodeIntersect: function (coords) {\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            if (this.contains(coords[i])) {\r\n                return {\r\n                    num: i,\r\n                    point: coords[i]\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n    clipPolygon: function (coords) { // (coords) -> clip coords\r\n        var min = this.min,\r\n            max = this.max,\r\n            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\r\n            cp1, cp2, s, e,\r\n            inside = function (p) {\r\n                return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\r\n            },\r\n            intersection = function () {\r\n                var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\r\n                    dp = [s[0] - e[0], s[1] - e[1]],\r\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n                    n2 = s[0] * e[1] - s[1] * e[0],\r\n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n                return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\r\n            };\r\n\r\n        var outputList = coords;\r\n        cp1 = clip[3];\r\n        for (var j = 0; j < 4; j++) {\r\n            cp2 = clip[j];\r\n            var inputList = outputList,\r\n                len = inputList.length;\r\n            outputList = [];\r\n            s = inputList[len - 1]; //last on the input list\r\n            for (var i = 0; i < len; i++) {\r\n                e = inputList[i];\r\n                if (inside(e)) {\r\n                    if (!inside(s)) { outputList.push(intersection()); }\r\n                    outputList.push(e);\r\n                } else if (inside(s)) {\r\n                    outputList.push(intersection());\r\n                }\r\n                s = e;\r\n            }\r\n            cp1 = cp2;\r\n        }\r\n        return outputList;\r\n    },\r\n    clipPolyLine: function (coords, angleFlag, delta) { // (coords) -> clip coords\r\n        delta = delta || 0;\r\n        var min = this.min,\r\n            max = this.max,\r\n            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\r\n            bitCode = function (p) {\r\n                var code = 0;\r\n\r\n                if (p[0] < bbox[0]) code |= 1; // left\r\n                else if (p[0] > bbox[2]) code |= 2; // right\r\n\r\n                if (p[1] < bbox[1]) code |= 4; // bottom\r\n                else if (p[1] > bbox[3]) code |= 8; // top\r\n\r\n                return code;\r\n            },\r\n            getAngle = function (a, b) {\r\n                return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\r\n            },\r\n            intersect = function (a, b, edge) {\r\n                return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\r\n                       edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\r\n                       edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\r\n                       edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\r\n                       null;\r\n            },\r\n            result = [],\r\n            len = coords.length,\r\n            codeA = bitCode(coords[0], bbox),\r\n            part = [],\r\n            i, a, b, c, codeB, lastCode;\r\n\r\n        for (i = 1; i < len; i++) {\r\n            a = coords[i - 1];\r\n            b = coords[i];\r\n            if (a[0] === b[0] && a[1] === b[1]) { continue; }\r\n            codeB = lastCode = bitCode(b, bbox);\r\n\r\n            while (true) {\r\n\r\n                if (!(codeA | codeB)) { // accept\r\n                    if (angleFlag) {\r\n                        a[2] = getAngle(a, b);\r\n                        c = coords[i + 1];\r\n                        b[2] = c ? getAngle(b, c) : a[2];\r\n                    }\r\n                    part.push(a);\r\n\r\n                    if (codeB !== lastCode) { // segment went outside\r\n                        part.push(b);\r\n\r\n                        if (i < len - 1) { // start a new line\r\n                            result.push(part);\r\n                            part = [];\r\n                        }\r\n                    } else if (i === len - 1) {\r\n                        part.push(b);\r\n                    }\r\n                    break;\r\n\r\n                } else if (codeA & codeB) { // trivial reject\r\n                    break;\r\n\r\n                } else if (codeA) { // a outside, intersect with clip edge\r\n                    a = intersect(a, b, codeA, bbox);\r\n                    codeA = bitCode(a, bbox);\r\n\r\n                } else { // b outside\r\n                    b = intersect(a, b, codeB, bbox);\r\n                    codeB = bitCode(b, bbox);\r\n                }\r\n            }\r\n\r\n            codeA = lastCode;\r\n        }\r\n\r\n        if (part.length) result.push(part);\r\n\r\n        return result;\r\n    }\r\n};\r\n\r\ngmxAPIutils.bounds = function(arr) {\r\n    return new gmxAPIutils.Bounds(arr);\r\n};\r\n\r\n//скопирована из API для обеспечения независимости от него\r\ngmxAPIutils.parseUri = function (str) {\r\n    var\to   = gmxAPIutils.parseUri.options,\r\n        m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\r\n        uri = {},\r\n        i   = 14;\r\n\r\n    while (i--) {\r\n        uri[o.key[i]] = m[i] || '';\r\n    }\r\n\r\n    uri[o.q.name] = {};\r\n    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n        if ($1) { uri[o.q.name][$1] = $2; }\r\n    });\r\n\r\n    uri.hostOnly = uri.host;\r\n    uri.host = uri.authority; // HACK\r\n\r\n    return uri;\r\n};\r\n\r\ngmxAPIutils.parseUri.options = {\r\n    strictMode: false,\r\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\r\n    q:   {\r\n        name:   'queryKey',\r\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n    },\r\n    parser: {\r\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n        loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n    }\r\n};\r\n\r\nif (!L.gmxUtil) { L.gmxUtil = {}; }\r\n\r\n//public interface\r\nL.extend(L.gmxUtil, {\r\n    newId: gmxAPIutils.newId,\r\n    loaderStatus: function () {},\r\n    isIE9: gmxAPIutils.isIE(9),\r\n    isIE10: gmxAPIutils.isIE(10),\r\n    isIE11: gmxAPIutils.isIE(11),\r\n    gtIE11: gmxAPIutils.gtIE(11),\r\n    getFormData: gmxAPIutils.getFormData,\r\n    requestJSONP: gmxAPIutils.requestJSONP,\r\n    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\r\n    request: gmxAPIutils.request,\r\n    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\r\n    fromServerStyle: gmxAPIutils.fromServerStyle,\r\n    toServerStyle: gmxAPIutils.toServerStyle,\r\n    getDefaultStyle: gmxAPIutils.getDefaultStyle,\r\n    bounds: gmxAPIutils.bounds,\r\n    getGeometryBounds: gmxAPIutils.getGeometryBounds,\r\n    tileSizes: gmxAPIutils.tileSizes,\r\n    getDateFromStr: gmxAPIutils.getDateFromStr,\r\n    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\r\n    getUTCdate: gmxAPIutils.getUTCdate,\r\n    getUTCtime: gmxAPIutils.getUTCtime,\r\n    getUTCdateTime: gmxAPIutils.getUTCdateTime,\r\n    attrToString: gmxAPIutils.attrToString,\r\n    getTileAttributes: gmxAPIutils.getTileAttributes,\r\n    formatCoordinates: function (latlng, type) {\r\n        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\r\n    },\r\n    formatDegrees: gmxAPIutils.formatDegrees,\r\n    pad2: gmxAPIutils.pad2,\r\n    dec2hex: gmxAPIutils.dec2hex,\r\n\tdec2rgba: gmxAPIutils.dec2rgba,\r\n    trunc: gmxAPIutils.trunc,\r\n    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\r\n    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\r\n    getLength: gmxAPIutils.getLength,\r\n    geoLength: gmxAPIutils.geoLength,\r\n    prettifyDistance: gmxAPIutils.prettifyDistance,\r\n    getArea: gmxAPIutils.getArea,\r\n    prettifyArea: gmxAPIutils.prettifyArea,\r\n    geoArea: gmxAPIutils.geoArea,\r\n    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\r\n    getSVGIcon: gmxAPIutils.getSVGIcon,\r\n    getCoordinatesString: gmxAPIutils.getCoordinatesString,\r\n    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\r\n    getGeometrySummary: gmxAPIutils.getGeometrySummary,\r\n    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\r\n    getPropertiesHash: gmxAPIutils.getPropertiesHash,\r\n    distVincenty: gmxAPIutils.distVincenty,\r\n    parseCoordinates: gmxAPIutils.parseCoordinates,\r\n    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\r\n    convertGeometry: gmxAPIutils.convertGeometry,\r\n    transformGeometry: gmxAPIutils.transformGeometry,\r\n    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\r\n    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\r\n    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\r\n    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\r\n    parseUri: gmxAPIutils.parseUri,\r\n    isRectangle: gmxAPIutils.isRectangle,\r\n    isClockwise: gmxAPIutils.isClockwise,\r\n    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\r\n    getPatternIcon: gmxAPIutils.getPatternIcon,\r\n    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\r\n    normalizeHostname: gmxAPIutils.normalizeHostname,\r\n    getTileBounds: gmxAPIutils.getTileBounds,\r\n    parseTemplate: gmxAPIutils.parseTemplate\r\n});\r\n\r\n(function() {\r\n    var requests = {};\r\n    var lastRequestId = 0;\r\n\r\n    var processMessage = function(e) {\r\n\r\n        if (!(e.origin in requests)) {\r\n            return;\r\n        }\r\n\r\n        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\r\n        try {\r\n            var dataObj = JSON.parse(dataStr);\r\n        } catch (ev) {\r\n            console.log({Status:'error', ErrorInfo: {ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr}});\r\n        }\r\n        var request = requests[e.origin][dataObj.CallbackName];\r\n        if (!request) {\r\n            return;    // message от других запросов\r\n        }\r\n\r\n        delete requests[e.origin][dataObj.CallbackName];\r\n        delete dataObj.CallbackName;\r\n\r\n        if (request.iframe.parentNode) {\r\n            request.iframe.parentNode.removeChild(request.iframe);\r\n        }\r\n        if ('callback' in request) { request.callback(dataObj); }\r\n    };\r\n\r\n    L.DomEvent.on(window, 'message', processMessage);\r\n\r\n    function createPostIframe2(id, callback, url) {\r\n        var uniqueId = 'gmxAPIutils_id' + (lastRequestId++),\r\n            iframe = L.DomUtil.create('iframe');\r\n\r\n        iframe.style.display = 'none';\r\n        iframe.setAttribute('id', id);\r\n        iframe.setAttribute('name', id);    /*eslint-disable no-script-url */\r\n        iframe.src = 'javascript:true';     /*eslint-enable */\r\n        iframe.callbackName = uniqueId;\r\n\r\n        var parsedURL = gmxAPIutils.parseUri(url);\r\n        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\r\n\r\n        requests[origin] = requests[origin] || {};\r\n        requests[origin][uniqueId] = {callback: callback, iframe: iframe};\r\n\r\n        return iframe;\r\n    }\r\n\r\n\t//расширяем namespace\r\n    gmxAPIutils.createPostIframe2 = createPostIframe2;\r\n\r\n})();\r\n\r\n// кроссдоменный POST запрос\r\n(function()\r\n{\r\n\t/** Посылает кроссдоменный POST запрос\r\n\t* @namespace L.gmxUtil\r\n    * @ignore\r\n\t* @function\r\n\t*\r\n\t* @param url {string} - URL запроса\r\n\t* @param params {object} - хэш параметров-запросов\r\n\t* @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные\r\n\t* @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл.\r\n\t*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.\r\n\t*/\r\n\tfunction sendCrossDomainPostRequest(url, params, callback, baseForm) {\r\n        var form,\r\n            id = '$$iframe_' + gmxAPIutils.newId();\r\n\r\n        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\r\n            originalFormAction;\r\n\r\n        if (baseForm) {\r\n            form = baseForm;\r\n            originalFormAction = form.getAttribute('action');\r\n            form.setAttribute('action', url);\r\n            form.target = id;\r\n        } else if (L.Browser.ielt9) {\r\n            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\r\n            form = document.createElement(str);\r\n        } else {\r\n            form = document.createElement('form');\r\n            form.style.display = 'none';\r\n            form.setAttribute('enctype', 'multipart/form-data');\r\n            form.target = id;\r\n            form.setAttribute('method', 'POST');\r\n            form.setAttribute('action', url);\r\n            form.id = id;\r\n        }\r\n\r\n        var hiddenParamsDiv = document.createElement('div');\r\n        hiddenParamsDiv.style.display = 'none';\r\n\r\n        if (params.WrapStyle === 'window') {\r\n            params.WrapStyle = 'message';\r\n        }\r\n\r\n        if (params.WrapStyle === 'message') {\r\n            params.CallbackName = iframe.callbackName;\r\n        }\r\n\r\n        for (var paramName in params) {\r\n            var input = document.createElement('input');\r\n            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\r\n            input.setAttribute('type', 'hidden');\r\n            input.setAttribute('name', paramName);\r\n            input.setAttribute('value', value);\r\n            hiddenParamsDiv.appendChild(input);\r\n        }\r\n\r\n        form.appendChild(hiddenParamsDiv);\r\n\r\n        if (!baseForm) {\r\n            document.body.appendChild(form);\r\n        }\r\n        document.body.appendChild(iframe);\r\n\r\n        form.submit();\r\n\r\n        if (baseForm) {\r\n            form.removeChild(hiddenParamsDiv);\r\n            if (originalFormAction !== null) {\r\n                form.setAttribute('action', originalFormAction);\r\n            } else {\r\n                form.removeAttribute('action');\r\n            }\r\n        } else {\r\n            form.parentNode.removeChild(form);\r\n        }\r\n    }\r\n    //расширяем namespace\r\n    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\r\n})();\r\nexport {gmxAPIutils};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Utils.js","import {gmxAPIutils as utils} from './Utils.js';\r\n\r\nvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\r\n    styleCanvasKeysLen = styleCanvasKeys.length;\r\n\r\nvar setCanvasStyle = function(prop, indexes, ctx, style) {\r\n    for (var i = 0; i < styleCanvasKeysLen; i++) {\r\n        var key = styleCanvasKeys[i],\r\n            valKey = style[key];\r\n        if (valKey !== ctx[key]) {\r\n            ctx[key] = valKey;\r\n        }\r\n    }\r\n    if (style.dashArray) {\r\n        var dashes = style.dashArray,\r\n            dashOffset = style.dashOffset || 0;\r\n        if ('setLineDash' in ctx) {\r\n            ctx.setLineDash(dashes);\r\n            if (ctx.lineDashOffset !== dashOffset) {\r\n                ctx.lineDashOffset = dashOffset;\r\n            }\r\n        }\r\n    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n        ctx.setLineDash([]);\r\n    }\r\n    if (ctx.lineCap !== 'round') { ctx.lineCap = 'round'; }\r\n    if (ctx.lineJoin !== 'round') { ctx.lineJoin = 'round'; }\r\n\r\n    if (style.canvasPattern) {\r\n        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\r\n    } else if (style.fillLinearGradient) {\r\n        var rgr = style.fillLinearGradient,\r\n            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\r\n            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\r\n            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\r\n            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\r\n            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\r\n        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\r\n            var arr1 = rgr.addColorStop[j],\r\n                arrFunc = rgr.addColorStopFunctions[j],\r\n                p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0]),\r\n                p2 = (arr1.length < 3 ? 100 : (arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2])),\r\n                p1 = utils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\r\n            lineargrad.addColorStop(p0, p1);\r\n        }\r\n        ctx.fillStyle = style.fillStyle = lineargrad;\r\n    }\r\n};\r\n\r\n/*\r\ngeoItem\r\n     properties: объект (в формате векторного тайла)\r\n     dataOption: дополнительные свойства объекта\r\nitem\r\n     skipRasters: скрыть растр\r\n     currentStyle: текущий canvas стиль объекта\r\n     parsedStyleKeys: стиль прошедший парсинг\r\noptions\r\n     ctx: canvas context\r\n     tbounds: tile bounds\r\n     tpx: X смещение тайла\r\n     tpy: Y смещение тайла\r\n     gmx: ссылка на layer._gmx\r\n        gmx.currentZoom\r\n        gmx.lastHover\r\n        gmx.tileAttributeIndexes\r\n     bgImage: растр для background\r\n     rasters: растры по объектам для background\r\ncurrentStyle\r\n    текущий стиль\r\nstyle\r\n    стиль в новом формате\r\n    style.image - для type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n*/\r\nL.gmxUtil.drawGeoItem = function(geoItem, item, options, currentStyle, style) {\r\n    var propsArr = geoItem.properties,\r\n        idr = propsArr[0],\r\n        i, len, j, len1,\r\n        gmx = options.gmx,\r\n        ctx = options.ctx,\r\n        geom = propsArr[propsArr.length - 1],\r\n        coords = null,\r\n        dataOption = geoItem.dataOption,\r\n        rasters = options.rasters || {},\r\n        tbounds = options.tbounds;\r\n\r\n    item.currentStyle = L.extend({}, currentStyle);\r\n    if (style) {\r\n        if (gmx.styleHook) {\r\n            if (!geoItem.styleExtend) {\r\n                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\r\n            }\r\n            if (geoItem.styleExtend) {\r\n                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\r\n    } else {\r\n        style = {};\r\n    }\r\n\r\n    var geoType = geom.type,\r\n        dattr = {\r\n            gmx: gmx,\r\n            item: item,\r\n            style: style,\r\n            styleExtend: geoItem.styleExtend || {},\r\n            ctx: ctx,\r\n            tpx: options.tpx,\r\n            tpy: options.tpy\r\n        };\r\n    if (geoType === 'POINT') {\r\n        dattr.pointAttr = utils.getPixelPoint(dattr, geom.coordinates);\r\n        if (!dattr.pointAttr) { return false; }   // point not in canvas tile\r\n    }\r\n    if (geoType === 'POINT' || geoType === 'MULTIPOINT') { // Отрисовка геометрии точек\r\n        coords = geom.coordinates;\r\n        if ('iconColor' in style && style.image) {\r\n            if (style.lastImage !== style.image) {\r\n                style.lastImage = style.image;\r\n                style.lastImageData = utils.getImageData(style.image);\r\n            }\r\n            dattr.imageData = style.lastImageData;\r\n        }\r\n\r\n        if (geoType === 'MULTIPOINT') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                dattr.coords = coords[i];\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            dattr.coords = coords;\r\n            utils.pointToCanvas(dattr);\r\n        }\r\n    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\r\n        if (style.image) { // set MULTIPOLYGON as marker\r\n            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\r\n            dattr.pointAttr = utils.getPixelPoint(dattr, dattr.coords);\r\n            if (dattr.pointAttr) {\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            coords = geom.coordinates;\r\n            if (geoType === 'POLYGON') { coords = [coords]; }\r\n\r\n            var hiddenLines = dataOption.hiddenLines || [],\r\n                pixelsMap = dataOption.pixels,\r\n                flagPixels = true;\r\n\r\n            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\r\n                pixelsMap = dataOption.pixels = utils.getCoordsPixels({\r\n                    gmx: gmx,\r\n                    coords: coords,\r\n                    tpx: options.tpx,\r\n                    tpy: options.tpy,\r\n                    hiddenLines: hiddenLines\r\n                });\r\n            }\r\n\r\n            var coordsToCanvas = function(func, flagFill) {\r\n                coords = pixelsMap.coords;\r\n                hiddenLines = pixelsMap.hidden || [];\r\n                dattr.flagPixels = flagPixels;\r\n                for (i = 0, len = coords.length; i < len; i++) {\r\n                    var coords1 = coords[i];\r\n                    var hiddenLines1 = hiddenLines[i] || [];\r\n                    ctx.beginPath();\r\n                    for (j = 0, len1 = coords1.length; j < len1; j++) {\r\n                        dattr.coords = coords1[j];\r\n                        dattr.hiddenLines = hiddenLines1[j] || [];\r\n                        func(dattr);\r\n                    }\r\n                    ctx.closePath();\r\n                    if (flagFill) { ctx.fill(); }\r\n                }\r\n            };\r\n            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\r\n                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\r\n            if (strokeStyle && lineWidth) {\r\n                coordsToCanvas(utils.polygonToCanvas);\r\n            }\r\n            if (options.bgImage) {\r\n                dattr.bgImage = options.bgImage;\r\n            } else if (rasters[idr]) {\r\n                dattr.bgImage = rasters[idr];\r\n            }\r\n            if (dattr.styleExtend.skipRasters || item.skipRasters) {\r\n                delete dattr.bgImage;\r\n            }\r\n            if (style.imagePattern) {\r\n                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\r\n            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                if (utils.isPatternNode(dattr.bgImage)) {\r\n                    if ('rasterOpacity' in gmx) { ctx.globalAlpha = gmx.rasterOpacity; }\r\n                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\r\n                    style.bgImage = true;\r\n                }\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n                ctx.globalAlpha = 1;\r\n            }\r\n            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\r\n                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n            }\r\n        }\r\n    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\r\n        coords = geom.coordinates;\r\n        if (geoType === 'LINESTRING') { coords = [coords]; }\r\n        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\r\n        for (i = 0, len = coords.length; i < len; i++) {\r\n            var arr = tbounds.clipPolyLine(coords[i], true, size);\r\n            for (j = 0, len1 = arr.length; j < len1; j++) {\r\n                dattr.coords = arr[j];\r\n                var pixels = utils.lineToCanvas(dattr);\r\n                if (pixels) {\r\n                    ctx.save();\r\n                    utils.lineToCanvasAsIcon(pixels, dattr);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DrawCanvas.js","/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n*/\r\nvar gmxSessionManager = {\r\n    APIKEY_PARAM: 'key',\r\n    SCRIPT_REGEXP: [\r\n\t\t/\\bleaflet-geomixer(-\\w*)?\\.js\\b/,\r\n\t\t/\\bgeomixer(-\\w*)?\\.js\\b/\r\n\t],\r\n    _scriptSearched: false,\r\n    _scriptAPIKey: null,\r\n    _searchScriptAPIKey: function() {\r\n        var _this = this;\r\n        if (this._scriptSearched) {\r\n            return this._scriptAPIKey;\r\n        }\r\n\r\n        var scripts = document.getElementsByTagName('script');\r\n        for (var i = 0; i < scripts.length; i++) {\r\n            var src = scripts[i].getAttribute('src'),\r\n\t\t\t\tarr = this.SCRIPT_REGEXP;\r\n\t\t\tfor (var j = 0, len = arr.length; j < len; j++) {\r\n\t\t\t\tif (arr[j].exec(src)) {\r\n\t\t\t\t\tvar query = src.split('?')[1];\r\n\r\n\t\t\t\t\tif (query) {\r\n\t\t\t\t\t\tvar params = query.split('&');\r\n\t\t\t\t\t\tfor (var p = 0; p < params.length; p++) {\r\n\t\t\t\t\t\t\tvar parsedParam = params[p].split('=');\r\n\t\t\t\t\t\t\tif (parsedParam[0] === _this.APIKEY_PARAM) {\r\n\t\t\t\t\t\t\t\t_this._scriptAPIKey = parsedParam[1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n            }\r\n\t\t\tif (_this._scriptAPIKey) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n        }\r\n        this._scriptSearched = true;\r\n        return this._scriptAPIKey;\r\n    },\r\n\r\n    //we will search apiKey in script tags iff apiKey parameter is undefined.\r\n    //if it is defined as falsy (null, '', etc), we won't send any requests to server\r\n    requestSessionKey: function(serverHost, apiKey) {\r\n        var keys = this._sessionKeys;\r\n\r\n        if (!(serverHost in keys)) {\r\n            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\r\n            keys[serverHost] = new L.gmx.Deferred();\r\n            if (apiKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/ApiKey.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        Key: apiKey\r\n                    }\r\n                ).then(function(response) {\r\n                    if (response && response.Status === 'ok') {\r\n                        keys[serverHost].resolve(response.Result.Key);\r\n                    } else {\r\n                        keys[serverHost].reject();\r\n                    }\r\n                }, keys[serverHost].reject);\r\n            } else {\r\n                keys[serverHost].resolve('');\r\n            }\r\n        }\r\n        return keys[serverHost];\r\n    },\r\n\r\n    //get already received session key\r\n    getSessionKey: function(serverHost) {\r\n        var keyPromise = this._sessionKeys[serverHost];\r\n\r\n        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\r\n    },\r\n    _sessionKeys: {} //deferred for each host\r\n};\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxSessionManager = gmxSessionManager;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/SessionManager.js","/** Asynchronously request information about map given server host and map name\r\n*/\r\nimport {gmxAPIutils} from './Utils.js';\r\nvar gmxMapManager = {\r\n    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\r\n    getMap: function(serverHost, apiKey, mapName, skipTiles) {\r\n        var maps = this._maps;\r\n        if (!maps[serverHost] || !maps[serverHost][mapName]) {\r\n            var def = new L.gmx.Deferred();\r\n            maps[serverHost] = maps[serverHost] || {};\r\n            maps[serverHost][mapName] = {promise: def};\r\n\r\n            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function(sessionKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/TileSender.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        skipTiles: skipTiles || 'None', // All, NotVisible, None\r\n                        key: sessionKey,\r\n                        MapName: mapName,\r\n                        ModeKey: 'map'\r\n                    }\r\n                ).then(function(json) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        json.Result.properties.hostName = serverHost;\r\n                        def.resolve(json.Result);\r\n                    } else {\r\n                        def.reject(json);\r\n                    }\r\n                }, def.reject);\r\n            }, def.reject);\r\n        }\r\n        return maps[serverHost][mapName].promise;\r\n    },\r\n\r\n\tsyncParams: {},\r\n    // установка дополнительных параметров для серверных запросов\r\n    setSyncParams: function(hash) {\r\n\t\tthis.syncParams = hash;\r\n    },\r\n    getSyncParams: function(stringFlag) {\r\n\t\tvar res = this.syncParams;\r\n\t\tif (stringFlag) {\r\n\t\t\tvar arr = [];\r\n\t\t\tfor (var key in res) {\r\n\t\t\t\tarr.push(key + '=' + res[key]);\r\n\t\t\t}\r\n\t\t\tres = arr.join('&');\r\n\t\t}\r\n\t\treturn res;\r\n    },\r\n\r\n    //we will (lazy) create index by layer name to speed up multiple function calls\r\n    findLayerInfo: function(serverHost, mapID, layerID) {\r\n        var hostMaps = this._maps[serverHost],\r\n            mapInfo = hostMaps && hostMaps[mapID];\r\n\r\n        if (!mapInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (mapInfo.layers) {\r\n            return mapInfo.layers[layerID];\r\n        }\r\n\r\n        var serverData = mapInfo.promise.getFulfilledData();\r\n\r\n        if (!serverData) {\r\n            return null;\r\n        }\r\n\r\n        mapInfo.layers = {};\r\n\r\n        //create index by layer name\r\n        gmxMapManager.iterateLayers(serverData[0], function(layerInfo) {\r\n            mapInfo.layers[layerInfo.properties.name] = layerInfo;\r\n        });\r\n\r\n        return mapInfo.layers[layerID];\r\n    },\r\n    iterateLayers: function(treeInfo, callback) {\r\n        var iterate = function(arr) {\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var layer = arr[i];\r\n\r\n                if (layer.type === 'group') {\r\n                    iterate(layer.content.children);\r\n                } else if (layer.type === 'layer') {\r\n                    callback(layer.content);\r\n                }\r\n            }\r\n        };\r\n\r\n        treeInfo && iterate(treeInfo.children);\r\n    },\r\n    iterateNode: function(treeInfo, callback) {\r\n        var iterate = function(node) {\r\n\t\t\tvar arr = node.children;\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var layer = arr[i];\r\n\r\n\t\t\t\tcallback(layer);\r\n                if (layer.type === 'group') {\r\n                    iterate(layer.content);\r\n                // } else if (layer.type === 'layer') {\r\n                }\r\n            }\r\n        };\r\n\r\n        treeInfo && iterate(treeInfo);\r\n    },\r\n    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\r\n};\r\nexport {gmxMapManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/MapManager.js","//Helper class, that represents layers of single Geomixer's map\r\n//Creates layers from given map description\r\nimport {DataManager} from './DataManager/DataManager.js';\r\nvar gmxMap = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    initialize: function(mapInfo, commonLayerOptions) {\r\n\t\tthis.layers = [];\r\n\t\tthis.layersByTitle = {};\r\n\t\tthis.layersByID = {};\r\n\t\tthis.dataManagers = {};\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.properties = L.extend({}, mapInfo.properties);\r\n\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\r\n\t\tthis.rawTree = mapInfo;\r\n\r\n\t\tthis.layersCreated = new L.gmx.Deferred();\r\n\r\n\t\tvar missingLayerTypes = {},\r\n\t\t\tdataSources = {};\r\n\r\n\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function(layerInfo) {\r\n\t\t\tvar props = layerInfo.properties,\r\n\t\t\t\tmeta = props.MetaProperties || {},\r\n\t\t\t\toptions = {\r\n\t\t\t\t\tmapID: mapInfo.properties.name,\r\n\t\t\t\t\tlayerID: props.name\r\n\t\t\t\t};\r\n\r\n\t\t\tprops.hostName = mapInfo.properties.hostName;\r\n\r\n\t\t\tvar type = props.ContentID || props.type,\r\n\t\t\t\tlayerOptions = L.extend(options, commonLayerOptions);\r\n\r\n\t\t\tif (props.dataSource || 'parentLayer' in meta) {      \t// Set dataSource layer\r\n\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\r\n\t\t\t\tif ('parentLayer' in meta) {      \t// todo удалить после изменений вов вьювере\r\n\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\r\n\t\t\t\t}\r\n\t\t\t\tdataSources[options.layerID] = {\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t};\r\n\t\t\t} else if (type in L.gmx._layerClasses) {\r\n\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\r\n\t\t\t} else {\r\n\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\r\n\t\t\t\tmissingLayerTypes[type].push({\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t//load missing layer types\r\n\t\tvar loaders = [];\r\n\t\tfor (var type in missingLayerTypes) {\r\n\t\t\tloaders.push(L.gmx._loadLayerClass(type).then(/*eslint-disable no-loop-func */function (type) {/*eslint-enable */\r\n\t\t\t\tvar it = missingLayerTypes[type];\r\n\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\r\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\r\n\t\t\t\t}\r\n\t\t\t}.bind(null, type)));\r\n\t\t}\r\n\t\tvar hosts = {}, host, id, it;\r\n\t\tfor (id in dataSources) {\r\n\t\t\tit = dataSources[id];\r\n\t\t\tvar opt = it.options,\r\n\t\t\t\tpId = opt.parentLayer,\r\n\t\t\t\tpLayer = this.layersByID[pId];\r\n\t\t\tif (pLayer) {\r\n\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\r\n\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);\r\n\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\r\n\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\r\n\t\t\t} else {\r\n\t\t\t\thost = opt.hostName;\r\n\t\t\t\tif (!hosts[host]) { hosts[host] = {}; }\r\n\t\t\t\tif (!hosts[host][pId]) { hosts[host][pId] = []; }\r\n\t\t\t\thosts[host][pId].push(id);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (host in hosts) {\r\n\t\t\tvar arr = [],\r\n\t\t\t\tprefix = 'http://' + host;\r\n\t\t\tfor (id in hosts[host]) {\r\n\t\t\t\tarr.push({Layer: id});\r\n\t\t\t}\r\n\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx',\r\n\t\t\t\t{\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\tLayers: JSON.stringify(arr)\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tids: hosts[host]\r\n\t\t\t\t}\r\n\t\t\t).then(function(json, opt) {\r\n\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\r\n\t\t\t\t\tjson.Result.forEach(function(it) {\r\n\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\r\n\t\t\t\t\t\t\tprops = it.properties,\r\n\t\t\t\t\t\t\tpId = props.name;\r\n\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\tvar pt = dataSources[id];\r\n\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\r\n\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\r\n\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\r\n\t\t\t\t\tif (opt && opt.ids) {\r\n\t\t\t\t\t\tfor (var pId in opt.ids) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\r\n\t},\r\n\r\n\taddDataManager: function(it) {\r\n\t\tvar pid = it.properties.name;\r\n\t\tif (!this.dataManagers[pid]) {\r\n\t\t\tthis.dataManagers[pid] = new DataManager(it.properties);\r\n\t\t}\r\n\t\treturn this.dataManagers[pid];\r\n\t},\r\n\tgetDataManager: function(id) {\r\n\t\treturn this.dataManagers[id];\r\n\t},\r\n\r\n\taddLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tthis.layers.push(layer);\r\n\t\tthis.layersByTitle[props.title] = layer;\r\n\t\tthis.layersByID[props.name] = layer;\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tfor (var i = 0; i < this.layers.length; i++) {\r\n\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\r\n\t\t\t\tthis.layers.splice(i, 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdelete this.layersByTitle[props.title];\r\n\t\tdelete this.layersByID[props.name];\r\n\t\tthis.fire('layerremove', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddLayersToMap: function(leafletMap) {\r\n\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\r\n\t\t\tvar layer = this.layers[l];\r\n\t\t\tif (layer.getGmxProperties().visible) {\r\n\t\t\t\tleafletMap.addLayer(layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxMap = gmxMap;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/GeomixerMap.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {VectorTile} from './VectorTile.js';\r\nimport {gmxVectorTileLoader} from './VectorTileLoader.js';\r\n\r\nvar ObserverTileLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    initialize: function(dataManager) {\r\n        this._dataManager = dataManager;\r\n        this._observerData = {};\r\n        this._tileData = {};\r\n    },\r\n\r\n    addObserver: function(observer) {\r\n        this._observerData[observer.id] = {\r\n            observer: observer,\r\n            tiles: {},\r\n            leftToLoad: 0,\r\n            loadingState: false //are we loading any tiles for this observer?\r\n        };\r\n\r\n        observer.on('update', this._updateObserver.bind(this, observer));\r\n\r\n        this._updateObserver(observer);\r\n\r\n        return this;\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        var obsTiles = this._observerData[id].tiles;\r\n\r\n        for (var tileId in obsTiles) {\r\n            delete this._tileData[tileId].observers[id];\r\n        }\r\n\r\n        delete this._observerData[id];\r\n\r\n        return this;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\r\n        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\r\n\r\n        var tileObservers = {};\r\n\r\n        for (var key in this._observerData) {\r\n            var obsInfo = this._observerData[key];\r\n\r\n            if (obsInfo.observer.intersectsWithTile(tile)) {\r\n                obsInfo.tiles[tile.vectorTileKey] = true;\r\n                obsInfo.leftToLoad += leftToLoadDelta;\r\n                tileObservers[key] = true;\r\n            }\r\n        }\r\n\r\n        this._tileData[tile.vectorTileKey] = {\r\n            observers: tileObservers,\r\n            tile: tile\r\n        };\r\n\r\n        return this;\r\n    },\r\n\r\n    removeTile: function(tileId) {\r\n        var tileData = this._tileData[tileId],\r\n            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\r\n\r\n        for (var id in tileData.observers) {\r\n            var observerData = this._observerData[id];\r\n            observerData.leftToLoad -= leftToLoadDelta;\r\n            delete observerData.tiles[tileId];\r\n        }\r\n\r\n        delete this._tileData[tileId];\r\n\r\n        return this;\r\n    },\r\n\r\n    startLoadTiles: function(observer) {\r\n\r\n        //force active tile list update\r\n        this._dataManager._getActiveTileKeys();\r\n\r\n        var obsData = this._observerData[observer.id];\r\n        if (obsData.leftToLoad === 0) {\r\n            this.fire('observertileload', {observer: observer});\r\n            return this;\r\n        }\r\n\r\n        if (!obsData.loadingState) {\r\n            obsData.loadingState = true;\r\n            observer.fire('startLoadingTiles');\r\n        }\r\n\r\n        for (var tileId in obsData.tiles) {\r\n            this._tileData[tileId].tile.load();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getTileObservers: function(tileId) {\r\n        return this._tileData[tileId].observers;\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerData[observer.id].loadingState;\r\n    },\r\n\r\n    _updateObserver: function(observer) {\r\n        var obsData = this._observerData[observer.id],\r\n            newObserverTiles = {},\r\n            leftToLoad = 0,\r\n            key;\r\n\r\n        for (key in this._tileData) {\r\n            var tile = this._tileData[key].tile;\r\n            if (observer.intersectsWithTile(tile)) {\r\n                newObserverTiles[key] = true;\r\n                if (tile.state !== 'loaded') {\r\n                    leftToLoad++;\r\n                }\r\n                this._tileData[key].observers[observer.id] = true;\r\n            }\r\n        }\r\n\r\n        for (key in obsData.tiles) {\r\n            if (!(key in newObserverTiles)) {\r\n                delete this._tileData[key].observers[observer.id];\r\n            }\r\n        }\r\n\r\n        obsData.tiles = newObserverTiles;\r\n        obsData.leftToLoad = leftToLoad;\r\n    },\r\n\r\n    _tileLoadedCallback: function(tile) {\r\n        this.fire('tileload', {tile: tile});\r\n\r\n        if (!(tile.vectorTileKey in this._tileData)) {\r\n            return;\r\n        }\r\n\r\n        var tileObservers = this._tileData[tile.vectorTileKey].observers;\r\n        for (var id in tileObservers) {\r\n            var obsData = this._observerData[id];\r\n            obsData.leftToLoad--;\r\n\r\n            if (obsData.leftToLoad === 0) {\r\n                if (obsData.loadingState) {\r\n                    obsData.loadingState = false;\r\n                    obsData.observer.fire('stopLoadingTiles');\r\n                }\r\n                this.fire('observertileload', {observer: obsData.observer});\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar DataManager = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    options: {\r\n        name: null,                         // layer ID\r\n        identityField: '',                  // attribute name for identity items\r\n        attributes: [],                     // attributes names\r\n        attrTypes: [],                      // attributes types\r\n        tiles: null,                        // tiles array for nontemporal data\r\n        tilesVers: null,                    // tiles version array for nontemporal data\r\n        LayerVersion: -1,                   // layer version\r\n        GeoProcessing: null,                // processing data\r\n        Temporal: false,                    // only for temporal data\r\n        TemporalColumnName: '',             // temporal attribute name\r\n        ZeroDate: '01.01.2008',             // 0 date string\r\n        TemporalPeriods: [],                // temporal periods\r\n        TemporalTiles: [],                  // temporal tiles array\r\n        TemporalVers: [],                   // temporal version array\r\n        hostName: 'maps.kosmosnimki.ru',    // default hostName\r\n        sessionKey: '',                     // session key\r\n        isGeneralized: false,               // flag for use generalized tiles\r\n        isFlatten: false                    // flag for flatten geometry\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        this._clearProcessing();\r\n        if (options.GeoProcessing) {\r\n            this.processingTile = this.addData([]);\r\n            this._chkProcessing(options.GeoProcessing);\r\n        }\r\n        L.setOptions(this, options);\r\n        this.optionsLink = options;\r\n\r\n        this._isTemporalLayer = this.options.Temporal;\r\n\r\n        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\r\n        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\r\n        var hostName = this.options.hostName,\r\n            sessionKey = this.options.sessionKey;\r\n        if (!sessionKey) {\r\n            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\r\n        }\r\n        this.tileSenderPrefix = 'http://' + hostName + '/' +\r\n            'TileSender.ashx?WrapStyle=None' +\r\n            '&key=' + encodeURIComponent(sessionKey);\r\n\r\n        this._needCheckActiveTiles = true;\r\n    },\r\n\r\n    _vectorTileDataProviderLoad: function(x, y, z, v, s, d, callback) {\r\n        var _this = this;\r\n        gmxVectorTileLoader.load(\r\n            _this.tileSenderPrefix,\r\n            {x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name}\r\n        ).then(callback, function() {\r\n            console.log('Error loading vector tile');\r\n            callback([]);\r\n            _this.fire('chkLayerUpdate', {dataProvider: _this}); //TODO: do we really need event here?\r\n        });\r\n    },\r\n\r\n    initialize: function(options, clearVersion) {\r\n        this._tilesTree = null;\r\n        this._activeTileKeys = {};\r\n        this._endDate = null;\r\n        this._beginDate = null;\r\n\r\n        this._tiles = {};\r\n        this._filters = {};\r\n        this._freeSubscrID = 0;\r\n        this._items = {};\r\n        this._observers = {};\r\n\r\n        this._needCheckDateInterval = false;\r\n        this._needCheckActiveTiles = true;\r\n\r\n        var _this = this;\r\n        this._vectorTileDataProvider = {\r\n            load: this._vectorTileDataProviderLoad.bind(this)\r\n        };\r\n\r\n        this._observerTileLoader = new ObserverTileLoader(this);\r\n        this._observerTileLoader.on('tileload', function(event) {\r\n            var tile = event.tile;\r\n            _this._updateItemsFromTile(tile);\r\n\r\n            if (_this._tilesTree) {\r\n                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\r\n                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\r\n            }\r\n        });\r\n\r\n        this._observerTileLoader.on('observertileload', function(event) {\r\n            var observer = event.observer;\r\n            if (observer.isActive()) {\r\n                observer.needRefresh = false;\r\n                observer.updateData(_this.getItems(observer.id));\r\n            }\r\n        });\r\n        this.setOptions(options);\r\n        if (clearVersion) {\r\n\t\t\tthis.options.LayerVersion = -1;\r\n\t\t}\r\n        if (this._isTemporalLayer) {\r\n            this.addFilter('TemporalFilter', function(item, tile, observer) {\r\n                var unixTimeStamp = item.options.unixTimeStamp,\r\n                    dates = observer.dateInterval;\r\n                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\r\n            });\r\n        }\r\n    },\r\n\r\n    _getActiveTileKeys: function() {\r\n\r\n        this._chkMaxDateInterval();\r\n        if (!this._needCheckActiveTiles) {\r\n            return this._activeTileKeys;\r\n        }\r\n\r\n        this._needCheckActiveTiles = false;\r\n\r\n        if (this._isTemporalLayer) {\r\n            var newTileKeys = {};\r\n            if (this._beginDate && this._endDate) {\r\n                if (!this._tilesTree) {\r\n                    this.initTilesTree();\r\n                }\r\n\r\n                /*var commonBounds = L.gmxUtil.bounds();\r\n                for (var obs in this._observers) {\r\n                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n                }*/\r\n\r\n                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\r\n            }\r\n            this._updateActiveTilesList(newTileKeys);\r\n        } else {\r\n            this.initTilesList();\r\n        }\r\n\r\n        return this._activeTileKeys;\r\n    },\r\n\r\n    _getObserversByFilterName: function(filterName) {\r\n        var oKeys = {};\r\n        for (var id in this._observers) {\r\n            if (this._observers[id].hasFilter(filterName)) {\r\n                oKeys[id] = true;\r\n            }\r\n        }\r\n        return oKeys;\r\n    },\r\n\r\n    addFilter: function(filterName, filterFunc) {\r\n        this._filters[filterName] = filterFunc;\r\n        this._triggerObservers(this._getObserversByFilterName(filterName));\r\n    },\r\n\r\n    removeFilter: function(filterName) {\r\n        if (this._filters[filterName]) {\r\n            var oKeys = this._getObserversByFilterName(filterName);\r\n            delete this._filters[filterName];\r\n            this._triggerObservers(oKeys);\r\n        }\r\n    },\r\n\r\n    getItems: function(oId) {\r\n        var resItems = [],\r\n            observer = this._observers[oId];\r\n\r\n        if (!observer) {\r\n            return [];\r\n        }\r\n\r\n        //add internal filters\r\n        var filters = observer.filters.concat('processingFilter');\r\n        this._isTemporalLayer && filters.push('TemporalFilter');\r\n\r\n        filters = filters.filter(function(filter) {\r\n            return filter in this._filters;\r\n        }.bind(this));\r\n\r\n        var _this = this,\r\n            putData = function(tile) {\r\n                var data = tile.data;\r\n                for (var i = 0, len = data.length; i < len; i++) {\r\n                    var dataOption = tile.dataOptions[i];\r\n                    if (!observer.intersects(dataOption.bounds)) { continue; }\r\n\r\n                    var it = data[i],\r\n                        id = it[0],\r\n                        item = _this.getItem(id);\r\n\r\n                    var geom = it[it.length - 1],\r\n                        isFiltered = false;\r\n\r\n                    for (var f = 0; f < filters.length; f++) {\r\n                        var filterFunc = _this._filters[filters[f]];\r\n                        if (!filterFunc(item, tile, observer, geom, dataOption)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!isFiltered) {\r\n                        resItems.push({\r\n                            id: id,\r\n                            properties: it,\r\n                            item: item,\r\n                            dataOption: dataOption,\r\n                            tileKey: tile.vectorTileKey\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n        var activeTileKeys =  this._getActiveTileKeys();\r\n        for (var tkey in activeTileKeys) {\r\n            var tile = _this._tiles[tkey].tile;\r\n            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\r\n                putData(tile);\r\n            }\r\n        }\r\n\r\n        return resItems;\r\n    },\r\n\r\n    _updateItemsFromTile: function(tile) {\r\n        var vectorTileKey = tile.vectorTileKey,\r\n            data = tile.data || [],\r\n            len = data.length,\r\n            geomIndex = data[0] && (data[0].length - 1);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            var it = data[i],\r\n                geom = it[geomIndex],\r\n                id = it[0],\r\n                item = this._items[id];\r\n            if (item) {\r\n                if (!item.processing) {\r\n                    item.properties = it;\r\n                    if (item.type.indexOf('MULTI') === -1) {\r\n                        item.type = 'MULTI' + item.type;\r\n                    }\r\n                } else {\r\n                    tile.data[i] = item.properties;\r\n                }\r\n                delete item.bounds;\r\n                item.currentFilter = null;\r\n            } else {\r\n                item = {\r\n                    id: id,\r\n                    type: geom.type,\r\n                    properties: it,\r\n                    options: {\r\n                        fromTiles: {}\r\n                    }\r\n                };\r\n                this._items[id] = item;\r\n            }\r\n            item.options.fromTiles[vectorTileKey] = i;\r\n            if (tile.isGeneralized) {\r\n                item.options.isGeneralized = true;\r\n            }\r\n\r\n            if (this.options.TemporalColumnName) {\r\n                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\r\n                item.options.unixTimeStamp = zn * 1000;\r\n            }\r\n        }\r\n        return len;\r\n    },\r\n\r\n    getMaxDateInterval: function() {\r\n        this._chkMaxDateInterval();\r\n\t\treturn {\r\n\t\t\tbeginDate: this._beginDate,\r\n\t\t\tendDate: this._endDate\r\n\t\t};\r\n    },\r\n\r\n    _chkMaxDateInterval: function() {\r\n        if (this._isTemporalLayer && this._needCheckDateInterval) {\r\n            this._needCheckDateInterval = false;\r\n            var observers = this._observers,\r\n                newBeginDate = null,\r\n                newEndDate = null;\r\n            for (var oId in observers) {\r\n                var observer = observers[oId],\r\n                    dateInterval = observer.dateInterval;\r\n\r\n                if (!dateInterval) {\r\n                    continue;\r\n                }\r\n\r\n                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\r\n                    newBeginDate = dateInterval.beginDate;\r\n                }\r\n\r\n                if (!newEndDate || dateInterval.endDate > newEndDate) {\r\n                    newEndDate = dateInterval.endDate;\r\n                }\r\n            }\r\n            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\r\n                this._beginDate = newBeginDate;\r\n                this._endDate = newEndDate;\r\n                this._needCheckActiveTiles = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    addObserver: function(options, id) {\r\n        id = id || 's' + (++this._freeSubscrID);\r\n        var _this = this,\r\n            observer = L.gmx.observer(options);\r\n\r\n        observer.id = id;\r\n        observer.needRefresh = true;\r\n        this._observerTileLoader.addObserver(observer);\r\n\r\n        observer\r\n            .on('update', function(ev) {\r\n                observer.needRefresh = true;\r\n                if (ev.temporalFilter) {\r\n                    _this._needCheckDateInterval = true;\r\n                }\r\n\r\n                _this._waitCheckObservers();\r\n            })\r\n            .on('activate', function() {\r\n                _this.fire('observeractivate');\r\n                _this.checkObserver(observer);\r\n            });\r\n\r\n        _this._needCheckDateInterval = true;\r\n        this._observers[id] = observer;\r\n        this._waitCheckObservers();\r\n\r\n        if (observer.isActive()) {\r\n            this.fire('observeractivate');\r\n        }\r\n\r\n        return observer;\r\n    },\r\n\r\n    getActiveObserversCount: function() {\r\n        var count = 0;\r\n        for (var k in this._observers) {\r\n            if (this._observers[k].isActive()) { count++; }\r\n        }\r\n        return count;\r\n    },\r\n\r\n    getObserver: function(id) {\r\n        return this._observers[id];\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        if (this._observers[id]) {\r\n            this._observerTileLoader.removeObserver(id);\r\n            var isActive = this._observers[id].isActive();\r\n\r\n            delete this._observers[id];\r\n\r\n            if (isActive) {\r\n                this.fire('observeractivate');\r\n            }\r\n        }\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerTileLoader.getObserverLoadingState(observer);\r\n    },\r\n\r\n    getItemsBounds: function() {\r\n        if (!this._itemsBounds) {\r\n            this._itemsBounds = gmxAPIutils.bounds();\r\n            for (var id in this._items) {\r\n                var item = this.getItem(id);\r\n                this._itemsBounds.extendBounds(item.bounds);\r\n            }\r\n        }\r\n        return this._itemsBounds;\r\n    },\r\n\r\n    //combine and return all parts of geometry\r\n    getItem: function(id) {\r\n        var item = this._items[id];\r\n        if (item && !item.bounds) {\r\n            var fromTiles = item.options.fromTiles,\r\n                arr = [];\r\n            for (var key in fromTiles) {    // get full object bounds\r\n                if (this._tiles[key]) {\r\n                    var num = fromTiles[key],\r\n                        tile = this._tiles[key].tile;\r\n                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\r\n                        arr.push(tile.dataOptions[num].bounds);\r\n                    } else {\r\n                        delete fromTiles[key];\r\n                    }\r\n                }\r\n            }\r\n            if (arr.length === 1) {\r\n                item.bounds = arr[0];\r\n            } else {\r\n                item.bounds = gmxAPIutils.bounds();\r\n                var w = gmxAPIutils.worldWidthMerc;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    var it = arr[i];\r\n                    if (item.bounds.max.x - it.min.x > w) {\r\n                        it = gmxAPIutils.bounds([\r\n                            [it.min.x + 2 * w, it.min.y],\r\n                            [it.max.x + 2 * w, it.max.y]\r\n                        ]);\r\n                    }\r\n                    item.bounds.extendBounds(it);\r\n                }\r\n            }\r\n        }\r\n        return item;\r\n    },\r\n\r\n    getItemMembers: function(id) {\r\n        var fromTiles = this._items[id].options.fromTiles,\r\n            members = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key]) {\r\n                var tile = this._tiles[key].tile;\r\n                if (tile.data) {\r\n                    var objIndex = fromTiles[key],\r\n                        props = tile.data[objIndex],\r\n                        dataOption = tile.dataOptions[objIndex],\r\n                        bbox = dataOption.bounds;\r\n\r\n                    members.push({\r\n                        geo: props[props.length - 1],\r\n                        width: bbox.max.x - bbox.min.x,\r\n                        dataOption: dataOption\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n        return members.sort(function(a, b) {\r\n            return b.width - a.width;\r\n        });\r\n    },\r\n\r\n    getItemGeometries: function(id) {\r\n        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\r\n            geomItems = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key] && this._tiles[key].tile.data) {\r\n                var tileData = this._tiles[key].tile.data,\r\n                    props = tileData[fromTiles[key]];\r\n\r\n                geomItems.push(gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\r\n            }\r\n        }\r\n        return geomItems;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        this._tiles[tile.vectorTileKey] = {tile: tile};\r\n        this._getActiveTileKeys()[tile.vectorTileKey] = true;\r\n        this._observerTileLoader.addTile(tile);\r\n        this.checkObservers();\r\n    },\r\n\r\n    checkObserver: function(observer) {\r\n        if (observer.needRefresh && observer.isActive()) {\r\n            this._observerTileLoader.startLoadTiles(observer);\r\n        }\r\n    },\r\n\r\n    checkObservers: function() {\r\n        var observers = this._observers;\r\n        for (var id in this._observers) {\r\n            this.checkObserver(observers[id]);\r\n        }\r\n    },\r\n\r\n    _waitCheckObservers: function() {\r\n        //TODO: refactor\r\n        if (this._checkObserversTimer) {\r\n            clearTimeout(this._checkObserversTimer);\r\n        }\r\n\r\n        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\r\n    },\r\n\r\n    _triggerObservers: function(oKeys) {\r\n        var keys = oKeys || this._observers;\r\n\r\n        for (var id in keys) {\r\n            if (this._observers[id]) {\r\n                this._observers[id].needRefresh = true;\r\n            }\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    _removeDataFromObservers: function(data) {\r\n        var keys = this._observers;\r\n        for (var id in keys) {\r\n            this._observers[id].removeData(data);\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    preloadTiles: function(dateBegin, dateEnd, bounds) {\r\n        var tileKeys = {};\r\n        if (this._isTemporalLayer) {\r\n            if (!this._tilesTree) {\r\n                this.initTilesTree();\r\n            }\r\n            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\r\n        } else {\r\n            this._needCheckActiveTiles = true;\r\n            tileKeys = this._getActiveTileKeys();\r\n        }\r\n\r\n        var loadingDefs = [];\r\n        for (var key in tileKeys) {\r\n            var tile = this._getVectorTile(key, true).tile;\r\n\r\n            if (tile.state !== 'notLoaded') {\r\n                continue;\r\n            }\r\n\r\n            if (bounds && !bounds.intersects(tile.bounds)) {\r\n                continue;\r\n            }\r\n\r\n            var loadDef = tile.load();\r\n            loadingDefs.push(loadDef);\r\n        }\r\n\r\n        return Deferred.all.apply(null, loadingDefs);\r\n    },\r\n\r\n    _updateActiveTilesList: function(newTilesList) {\r\n\r\n        if (this._tileFilteringHook) {\r\n            var filteredTilesList = {};\r\n            for (var tk in newTilesList) {\r\n                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\r\n                    filteredTilesList[tk] = true;\r\n                }\r\n            }\r\n            newTilesList = filteredTilesList;\r\n        }\r\n\r\n        var oldTilesList = this._activeTileKeys || {};\r\n\r\n        var observersToUpdate = {},\r\n            _this = this,\r\n            key;\r\n\r\n        if (this.processingTile) {\r\n            newTilesList[this.processingTile.vectorTileKey] = true;\r\n        }\r\n        if (this._rasterVectorTile) {\r\n\t\t\tkey = this._rasterVectorTile.vectorTileKey;\r\n            newTilesList[key] = true;\r\n\t\t\tthis._tiles[key] = {tile: this._rasterVectorTile};\r\n\t\t}\r\n\r\n        var checkSubscription = function(vKey) {\r\n            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\r\n            for (var sid in observerIds) {\r\n                observersToUpdate[sid] = true;\r\n            }\r\n        };\r\n\r\n        for (key in newTilesList) {\r\n            if (!oldTilesList[key]) {\r\n                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\r\n                checkSubscription(key);\r\n            }\r\n        }\r\n\r\n        for (key in oldTilesList) {\r\n            if (!newTilesList[key]) {\r\n                checkSubscription(key);\r\n                this._observerTileLoader.removeTile(key);\r\n            }\r\n        }\r\n\r\n        this._activeTileKeys = newTilesList;\r\n\r\n        this._triggerObservers(observersToUpdate);\r\n    },\r\n\r\n    _propertiesToArray: function(it) {\r\n        var prop = it.properties,\r\n            indexes = this.tileAttributeIndexes,\r\n            arr = [];\r\n\r\n        for (var key in indexes)\r\n            arr[indexes[key]] = prop[key];\r\n\r\n        arr[arr.length] = it.geometry;\r\n        arr[0] = it.id;\r\n        return arr;\r\n    },\r\n\r\n    _clearProcessing: function() {\r\n        if (this.processingTile) {\r\n            var _items = this._items,\r\n                tile = this.processingTile,\r\n                vKey = tile.vectorTileKey,\r\n                data = tile.data || [];\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i][0];\r\n                if (_items[id]) {\r\n                    var item = _items[id];\r\n                    item.processing = null;\r\n                    item.currentFilter = null;\r\n                    delete item.options.fromTiles[vKey];\r\n                    delete item.fromServerProps;\r\n                    delete item.geometry;\r\n               }\r\n            }\r\n            tile.clear();\r\n        }\r\n    },\r\n\r\n    _chkProcessing: function(processing) {\r\n        var _items = this._items,\r\n            needProcessingFilter = false,\r\n            skip = {},\r\n            id, i, len, it, data;\r\n\r\n        if (processing) {\r\n            if (processing.Deleted) {\r\n                for (i = 0, len = processing.Deleted.length; i < len; i++) {\r\n                    id = processing.Deleted[i];\r\n                    skip[id] = true;\r\n                    if (_items[id]) {\r\n                        _items[id].processing = true;\r\n                        _items[id].currentFilter = null;\r\n                    }\r\n                    if (len > 0) { needProcessingFilter = true; }\r\n                }\r\n            }\r\n\r\n            var out = {};\r\n            if (processing.Inserted) {\r\n                for (i = 0, len = processing.Inserted.length; i < len; i++) {\r\n                    it = processing.Inserted[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n            }\r\n\r\n            if (processing.Updated) {\r\n                for (i = 0, len = processing.Updated.length; i < len; i++) {\r\n                    it = processing.Updated[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n                if (!needProcessingFilter && len > 0) { needProcessingFilter = true; }\r\n            }\r\n\r\n            data = [];\r\n            for (id in out) {\r\n                if (this._items[id]) {\r\n                    this._items[id].properties = out[id];\r\n                    this._items[id].processing = true;\r\n                    this._items[id].currentFilter = null;\r\n                }\r\n                data.push(out[id]);\r\n            }\r\n\r\n            if (data.length > 0) {\r\n                this.processingTile = this.addData(data);\r\n            }\r\n        }\r\n        if (needProcessingFilter) {\r\n            this.addFilter('processingFilter', function(item, tile) {\r\n                return tile.z === 0 || !item.processing;\r\n            });\r\n        } else {\r\n            this.removeFilter('processingFilter');\r\n        }\r\n    },\r\n\r\n    enableGeneralization: function() {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function() {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    _resetTilesTree: function() {\r\n        this._tilesTree = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    updateVersion: function(options) {\r\n        if (options) {\r\n            this.setOptions(options);\r\n        }\r\n        this._resetTilesTree();\r\n\t\t// this.fire('versionchange');\r\n    },\r\n\r\n    _getDataKeys: function(data) {\r\n        var chkKeys = {};\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            chkKeys[data[i][0]] = true;\r\n        }\r\n        return chkKeys;\r\n    },\r\n\r\n    _getProcessingTile: function() {\r\n        if (!this.processingTile) {\r\n        var x = -0.5, y = -0.5, z = 0, v = 0, s = -1, d = -1, isFlatten = this.options.isFlatten;\r\n\r\n            this.processingTile = new VectorTile({load: function(x, y, z, v, s, d, callback) {\r\n                            callback([]);\r\n            }}, {x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten});\r\n\r\n            this.addTile(this.processingTile);\r\n        }\r\n        return this.processingTile;\r\n    },\r\n\r\n    addData: function(data) {\r\n        if (!data) {\r\n            data = [];\r\n        }\r\n        var vTile = this._getProcessingTile(),\r\n            chkKeys = this._getDataKeys(data),\r\n            dataBounds = vTile.addData(data, chkKeys);\r\n\r\n        if (this._itemsBounds) {\r\n            this._itemsBounds.extendBounds(dataBounds);\r\n        }\r\n        this._updateItemsFromTile(vTile);\r\n        this._triggerObservers();\r\n        return vTile;\r\n    },\r\n\r\n    removeData: function(data) {\r\n        this._itemsBounds = null;\r\n        var vTile = this.processingTile;\r\n        if (vTile) {\r\n            var chkKeys = {};\r\n\r\n            if (!data || !data.length) {\r\n                return vTile;\r\n            }\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i];\r\n                chkKeys[id] = true;\r\n                delete this._items[id];\r\n            }\r\n            this._removeDataFromObservers(chkKeys);\r\n            vTile.removeData(chkKeys, true);\r\n            this._updateItemsFromTile(vTile);\r\n\r\n            this._triggerObservers();\r\n        }\r\n\r\n        return vTile;\r\n    },\r\n\r\n    initTilesTree: function() {\r\n        this._tilesTree = L.gmx.tilesTree(this.options);\r\n        this.options.TemporalTiles = this.options.TemporalVers = null;\r\n\r\n        if ('TemporalTiles' in this.optionsLink) {\r\n            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\r\n        }\r\n        this.dateZero = this._tilesTree.dateZero;\r\n        if (this.processingTile) {\r\n            this._tiles[this.processingTile.vectorTileKey] = {\r\n                tile: this.processingTile\r\n            };\r\n        }\r\n    },\r\n\r\n    _getVectorTile: function(vKey, createFlag) {\r\n        if (!this._tiles[vKey] && createFlag) {\r\n            var info = VectorTile.parseTileKey(vKey);\r\n            info.dateZero = this.dateZero;\r\n            this._addVectorTile(info);\r\n        }\r\n        return this._tiles[vKey];\r\n    },\r\n\r\n    _addVectorTile: function(info) {\r\n        info.isFlatten = this.options.isFlatten;\r\n        var tile = new VectorTile(this._vectorTileDataProvider, info),\r\n            vKey = tile.vectorTileKey;\r\n\r\n        this._tiles[vKey] = {tile: tile};\r\n        return vKey;\r\n    },\r\n\r\n    _getGeneralizedTileKeys: function(vTilePoint) {\r\n        var dz = vTilePoint.z % 2 ? 1 : 2,\r\n            pz = Math.pow(2, dz),\r\n            z = vTilePoint.z - dz,\r\n            x = Math.floor(vTilePoint.x / pz),\r\n            y = Math.floor(vTilePoint.y / pz),\r\n            temp = {v: vTilePoint.v, s: -1, d: -1, isGeneralized: true},\r\n            keys = {};\r\n\r\n        while (z > 1) {\r\n            var gKey = [z, x, y].join('_');\r\n            keys[gKey] = L.extend({}, temp, {x: x, y: y, z: z});\r\n            z -= 2;\r\n            x = Math.floor(x / 4);\r\n            y = Math.floor(y / 4);\r\n        }\r\n        return keys;\r\n    },\r\n\r\n    initTilesList: function() {         // For non temporal layers we create all Vector tiles\r\n        var newActiveTileKeys = {};\r\n        if (this.options.tiles) {\r\n            var arr = this.options.tiles || [],\r\n                vers = this.options.tilesVers,\r\n                generalizedKeys = this.options.isGeneralized ? {} : null,\r\n                newTiles = {},\r\n                gKey, tKey, info, tHash;\r\n\r\n            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\r\n                info = {\r\n                    x: Number(arr[i]),\r\n                    y: Number(arr[i + 1]),\r\n                    z: Number(arr[i + 2]),\r\n                    v: Number(vers[cnt]),\r\n                    s: -1,\r\n                    d: -1\r\n                };\r\n\r\n                tHash = this._getVectorTile(VectorTile.createTileKey(info), true);\r\n                tKey = tHash.tile.vectorTileKey;\r\n                newTiles[tKey] = tHash;\r\n                newActiveTileKeys[tKey] = true;\r\n                if (generalizedKeys) {\r\n                    var gKeys = this._getGeneralizedTileKeys(info);\r\n                    for (gKey in gKeys) {\r\n                        var gPoint = gKeys[gKey];\r\n                        if (generalizedKeys[gKey]) {\r\n                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\r\n                        } else {\r\n                            generalizedKeys[gKey] = gPoint;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (generalizedKeys) {\r\n                for (gKey in generalizedKeys) {\r\n                    info = generalizedKeys[gKey];\r\n                    tKey = VectorTile.createTileKey(info);\r\n                    if (!newTiles[tKey]) {\r\n                        if (!this._tiles[tKey]) { this._addVectorTile(info); }\r\n                        newTiles[tKey] = this._tiles[tKey];\r\n                        newActiveTileKeys[tKey] = true;\r\n                    }\r\n                }\r\n            }\r\n            this._tiles = newTiles;\r\n            if (this.processingTile) {\r\n                this._tiles[this.processingTile.vectorTileKey] = {\r\n                    tile: this.processingTile\r\n                };\r\n            }\r\n        }\r\n        this._updateActiveTilesList(newActiveTileKeys);\r\n    },\r\n\r\n    //Tile filtering hook filters out active vector tiles.\r\n    //Can be used to prevent loading data from some spatial-temporal region\r\n    setTileFilteringHook: function(filteringHook) {\r\n        this._tileFilteringHook = filteringHook;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    removeTileFilteringHook: function() {\r\n        this._tileFilteringHook = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    }\r\n\r\n});\r\nexport {DataManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/DataManager.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n//Single vector tile, received from GeoMixer server\r\n//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\r\n//      - {Object[]} data - information about vector objects in tile\r\n//      - {Number[4]} [bbox] - optional bbox of objects in tile\r\n//  options:\r\n//      x, y, z, v, s, d: GeoMixer vector tile point\r\n//      dateZero: zero Date for temporal layers\r\n//      isGeneralized: flag for generalized tile\r\nvar VectorTile = function(dataProvider, options) {\r\n    this.dataProvider = dataProvider;\r\n    this.loadDef = new L.gmx.Deferred();\r\n    this.data = null;\r\n    this.dataOptions = null;\r\n\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.z = options.z;\r\n    this.v = options.v;\r\n    this.s = options.s || -1;\r\n    this.d = options.d || -1;\r\n    this.isGeneralized = options.isGeneralized;\r\n    this.isFlatten = options.isFlatten;\r\n    this.bounds = gmxAPIutils.getTileBounds(this.x, this.y, this.z);\r\n    this.gmxTilePoint = {x: this.x, y: this.y, z: this.z, s: this.s, d: this.d};\r\n    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\r\n\r\n    if (this.s >= 0 && options.dateZero) {\r\n        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * gmxAPIutils.oneDay * 1000);\r\n        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * gmxAPIutils.oneDay * 1000);\r\n    }\r\n\r\n    this.state = 'notLoaded'; //notLoaded, loading, loaded\r\n};\r\n\r\nVectorTile.prototype = {\r\n    addData: function(data, keys) {\r\n\r\n        if (keys) {\r\n            this.removeData(keys, true);\r\n        }\r\n\r\n        var len = data.length,\r\n            dataOptions = new Array(len),\r\n            dataBounds = gmxAPIutils.bounds();\r\n        for (var i = 0; i < len; i++) {\r\n            var dataOption = this._parseItem(data[i]);\r\n            dataOptions[i] = dataOption;\r\n            dataBounds.extendBounds(dataOption.bounds);\r\n        }\r\n\r\n        if (!this.data) {\r\n            this.data = data;\r\n            this.dataOptions = dataOptions;\r\n        } else {\r\n            this.data = this.data.concat(data);\r\n            this.dataOptions = this.dataOptions.concat(dataOptions);\r\n        }\r\n\r\n        this.state = 'loaded';\r\n\r\n        this.loadDef.resolve(this.data);\r\n        return dataBounds;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\r\n            if (keys[arr[i][0]]) {\r\n                arr.splice(i, 1);\r\n                if (this.dataOptions) { this.dataOptions.splice(i, 1); }\r\n            }\r\n        }\r\n    },\r\n\r\n    load: function() {\r\n        if (this.state === 'notLoaded') {\r\n            this.state = 'loading';\r\n            var _this = this;\r\n            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function(data, bbox) {\r\n                _this.bbox = bbox;\r\n                _this.addData(data);\r\n            });\r\n        }\r\n\r\n        return this.loadDef;\r\n    },\r\n\r\n    clear: function() {\r\n        this.state = 'notLoaded';\r\n        this.data = null;\r\n        this.dataOptions = null;\r\n\r\n        this.loadDef = new L.gmx.Deferred();\r\n    },\r\n\r\n    _parseItem: function(it) {\r\n        var len = it.length,\r\n            i;\r\n\r\n        // TODO: old properties null = ''\r\n        for (i = 0; i < len; i++) {\r\n            if (it[i] === null) { it[i] = ''; }\r\n        }\r\n\r\n        var geo = it[len - 1],\r\n            needFlatten = this.isFlatten,\r\n            type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates,\r\n            hiddenLines = [],\r\n            bounds = null,\r\n            boundsArr = [];\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            bounds = gmxAPIutils.bounds();\r\n            var edgeBounds = gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\r\n                hiddenFlag = false;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr = [],\r\n                    hiddenLines1 = [];\r\n\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\r\n                        coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                    }\r\n                    var b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                    // EdgeLines calc\r\n                    var edgeArr = gmxAPIutils.getHidden(coords[i][j], edgeBounds);\r\n                    hiddenLines1.push(edgeArr);\r\n                    if (edgeArr.length) {\r\n                        hiddenFlag = true;\r\n                    }\r\n                }\r\n                boundsArr.push(arr);\r\n                hiddenLines.push(hiddenLines1);\r\n            }\r\n            if (!hiddenFlag) { hiddenLines = null; }\r\n            if (isPolygon) { boundsArr = boundsArr[0]; }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds([coords[i]]));\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds(coords[i]));\r\n            }\r\n        }\r\n        var dataOption = {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n        if (hiddenLines) {\r\n            dataOption.hiddenLines = hiddenLines;\r\n        }\r\n        return dataOption;\r\n    }\r\n};\r\n//class methods\r\n\r\nVectorTile.makeTileKey = function(x, y, z, v, s, d) {\r\n    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\r\n};\r\n\r\nVectorTile.createTileKey = function(opt) {\r\n    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\r\n};\r\n\r\nVectorTile.parseTileKey = function(gmxTileKey) {\r\n    var p = gmxTileKey.split('_').map(function(it) { return Number(it); });\r\n    return {z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5]};\r\n};\r\n\r\nVectorTile.boundsFromTileKey = function(gmxTileKey) {\r\n    var p = VectorTile.parseTileKey(gmxTileKey);\r\n    return gmxAPIutils.getTileBounds(p.x, p.y, p.z);\r\n};\r\nexport {VectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTile.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar gmxVectorTileLoader = {\r\n    _loadedTiles: {},\r\n    _getKey: function(ti) {\r\n        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\r\n    },\r\n    load: function(tileSenderPrefix, tileInfo) {\r\n        var key = gmxVectorTileLoader._getKey(tileInfo);\r\n\r\n        if (!this._loadedTiles[key]) {\r\n            var def = new L.gmx.Deferred();\r\n            this._loadedTiles[key] = def;\r\n\r\n            var requestParams = {\r\n                ModeKey: 'tile',\r\n                r: 'j',\r\n                LayerName: tileInfo.layerID,\r\n                z: tileInfo.z,\r\n                x: tileInfo.x,\r\n                y: tileInfo.y,\r\n                v: tileInfo.v\r\n            };\r\n\r\n            if (tileInfo.d !== -1) {\r\n                requestParams.Level = tileInfo.d;\r\n                requestParams.Span = tileInfo.s;\r\n            }\r\n\r\n            gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, {callbackParamName: null}).then(null, function() {\r\n                def.reject();\r\n            });\r\n        }\r\n\r\n        return this._loadedTiles[key];\r\n    }\r\n};\r\n\r\nwindow.gmxAPI = window.gmxAPI || {};\r\nwindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function(data) {\r\n    var key = gmxVectorTileLoader._getKey({\r\n        layerID: data.LayerName,\r\n        x: data.x,\r\n        y: data.y,\r\n        z: data.z,\r\n        d: data.level,\r\n        s: data.span,\r\n        v: data.v\r\n    });\r\n\r\n    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\r\n};\r\nexport {gmxVectorTileLoader};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTileLoader.js","/*\r\n * gmxEventsManager - handlers manager\r\n */\r\nvar GmxEventsManager = L.Handler.extend({\r\n    options: {\r\n    },\r\n\r\n    initialize: function (map) {\r\n        this._map = map;\r\n        this._layers = {};\r\n        this._lastLayer = null;\r\n        this._lastId = null;\r\n        var _this = this;\r\n        this._drawstart = null;\r\n        this._lastCursor = '';\r\n\r\n        var isDrawing = function () {\r\n            if (_this._drawstart) {\r\n                return true;\r\n            } else if (_this._drawstart === null) {\r\n                if (map.gmxControlsManager) {\r\n                    var drawingControl = map.gmxControlsManager.get('drawing');\r\n                    if (drawingControl) {\r\n                        drawingControl.on('activechange', function (ev) {\r\n                            _this._drawstart = ev.activeIcon;\r\n                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\r\n                        });\r\n                    }\r\n                }\r\n                _this._drawstart = false;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        var getDomIndex = function (layer) {\r\n            var container = layer._container;\r\n            if (container) {\r\n                var arr = container.parentNode.childNodes;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    if (container === arr[i]) {\r\n                        return i;\r\n                    }\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n\r\n        var skipNodeName = {\r\n            IMG: true,\r\n            DIV: true,\r\n            path: true\r\n        };\r\n\r\n        var clearLastHover = function () {\r\n            if (_this._lastLayer) {\r\n                _this._lastLayer.gmxEventCheck({type: 'mousemove'}, true);\r\n                _this._lastLayer = null;\r\n            }\r\n        };\r\n\r\n        var eventCheck = function (ev) {\r\n            var type = ev.type,\r\n                map = _this._map,\r\n                skipNode = false;\r\n            if (ev.originalEvent) {\r\n                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\r\n                var target = ev.originalEvent.target;\r\n                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\r\n            }\r\n            if (map._animatingZoom ||\r\n                isDrawing() ||\r\n                skipNode ||\r\n                (type === 'click' &&  map._skipClick) ||        // from drawing\r\n                (type === 'mousemove' &&  map.gmxMouseDown)\r\n                ) {\r\n                clearLastHover();\r\n                map._skipClick = false;\r\n                return;\r\n            }\r\n            if (ev.layerPoint) {\r\n                map._gmxMouseLatLng = ev.latlng;\r\n                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\r\n            }\r\n\r\n            var arr = Object.keys(_this._layers).sort(function(a, b) {\r\n                var la = map._layers[a],\r\n                    lb = map._layers[b];\r\n                if (la && lb) {\r\n                    var oa = la.options, ob = lb.options,\r\n                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\r\n                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\r\n                        delta = zb - za;\r\n                    return delta ? delta : _this._layers[b] - _this._layers[a];\r\n                }\r\n                return 0;\r\n            });\r\n\r\n            var layer,\r\n                foundLayer = null,\r\n                cursor = '';\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                layer = map._layers[id];\r\n                if (layer && layer._map && !layer._animating && layer.options.clickable) {\r\n                    if (layer.gmxEventCheck(ev)) {\r\n                        if (layer.hasEventListeners('mouseover')) {\r\n                            cursor = 'pointer';\r\n                        }\r\n                        foundLayer = layer;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (_this._lastCursor !== cursor && !isDrawing()) {\r\n                map._container.style.cursor = cursor;\r\n            }\r\n            _this._lastCursor = cursor;\r\n\r\n            if (type !== 'zoomend') {\r\n                if (foundLayer) {\r\n                    if (_this._lastLayer !== foundLayer) {\r\n                        clearLastHover();\r\n                    }\r\n                    _this._lastLayer = foundLayer;\r\n                } else {\r\n                    clearLastHover();\r\n                }\r\n            }\r\n        };\r\n\r\n        map.on({\r\n            zoomend: function () {\r\n                if (map._gmxMouseLatLng) {\r\n                    setTimeout(function () {\r\n                        eventCheck({type: 'mousemove', latlng: map._gmxMouseLatLng});\r\n                    }, 0);\r\n                }\r\n            },\r\n            click: eventCheck,\r\n            dblclick: eventCheck,\r\n            mousedown: eventCheck,\r\n            mouseup: eventCheck,\r\n            mousemove: eventCheck,\r\n            contextmenu: eventCheck,\r\n            layeradd: function (ev) {\r\n                var layer = ev.layer;\r\n                if ('gmxEventCheck' in layer && layer.options.clickable) {\r\n                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\r\n                }\r\n            },\r\n            layerremove: function (ev) {\r\n                var id = ev.layer._leaflet_id;\r\n                delete _this._layers[id];\r\n                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\r\n                    _this._lastLayer = null;\r\n                    _this._lastId = 0;\r\n                }\r\n            }\r\n        }, this);\r\n    }\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n    // Check to see if handler has already been initialized.\r\n    if (!this._gmxEventsManager) {\r\n        this._gmxEventsManager = new GmxEventsManager(this);\r\n\t\tthis.isGmxDrawing = function () {\r\n\t\t\treturn this._gmxEventsManager._drawstart;\r\n\t\t};\r\n\r\n        this.on('remove', function () {\r\n            if (this._gmxEventsManager) {\r\n                this._gmxEventsManager.removeHooks();\r\n            }\r\n        });\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/EventsManager.js","(function() {\r\n    var DEFAULT_LANGUAGE = 'rus',\r\n        _setKeyText = function(lang, key, item, hash) {\r\n            if (!hash[lang]) { hash[lang] = {}; }\r\n            hash[lang][key] = item;\r\n        };\r\n    L.gmxLocale = {\r\n\r\n        setLanguage: function(lang) {\r\n            this._language = lang;\r\n        },\r\n\r\n        getLanguage: function() {\r\n            return window.language || this._language || DEFAULT_LANGUAGE;\r\n        }\r\n    };\r\n\r\n    L.gmxLocaleMixin = {\r\n        addText: function() {\r\n            var lang = arguments[0],\r\n                newHash = arguments[1];\r\n            if (arguments.length === 1) {\r\n                newHash = lang;\r\n                lang = null;\r\n            }\r\n            for (var k in newHash) {\r\n                if (lang === null) {\r\n                    for (var k1 in newHash[k]) {\r\n                        _setKeyText(k, k1, newHash[k][k1], this);\r\n                    }\r\n                } else {\r\n                    _setKeyText(lang, k, newHash[k], this);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n\r\n        getText: function(key) {\r\n            var lang = L.gmxLocale.getLanguage(),\r\n                locale = this[lang] || {};\r\n\r\n            var keyArr = key ? key.split(/\\./) : [];\r\n            for (var i = 0, len = keyArr.length; i < len; i++) {\r\n                if (!locale) { break; }\r\n                locale = locale[keyArr[i]];\r\n            }\r\n            return locale;\r\n        }\r\n    };\r\n    L.extend(L.gmxLocale, L.gmxLocaleMixin);\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Locale.js","L.extend(L.gmxLocale, {\r\n    rus: {\r\n        Coordinates : 'Координаты',\r\n        Length : 'Длина',\r\n        nodeLength : 'Длина от начала',\r\n        edgeLength : 'Длина сегмента',\r\n        Area : 'Площадь',\r\n        Perimeter : 'Периметр',\r\n        units: {\r\n            m: 'м',\r\n            nm: 'м.мили',\r\n            km: 'км',\r\n            m2: 'кв. м',\r\n            km2: 'кв. км',\r\n            ha: 'га',\r\n            m2html: 'м<sup>2',\r\n            km2html: 'км<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_ru.js","L.extend(L.gmxLocale, {\r\n    eng: {\r\n        Coordinates : 'Coordinates',\r\n        Length : 'Length',\r\n        nodeLength : 'From start point',\r\n        edgeLength : 'Segment length',\r\n        Area : 'Area',\r\n        Perimeter : 'Perimeter',\r\n        units: {\r\n            m: 'm',\r\n            nm: 'nmi',\r\n            km: 'km',\r\n            m2: 'sq. m',\r\n            km2: 'sq. km',\r\n            ha: 'ha',\r\n            m2html: 'm<sup>2',\r\n            km2html: 'km<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_en.js","//Single observer with vector data\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nvar Observer = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    /* options : {\r\n            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n                                        // `update` - send only changed data\r\n            callback: Func,             // will be called when layer's data for this observer is changed\r\n            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n            bbox: bbox,                 // bbox to observe on Mercator\r\n            filters: [String]           // filter keys array\r\n            active: [Boolean=true]      // is this observer active\r\n            targetZoom: [Number]        // for zoom generalized type default(null)\r\n        }\r\n    */\r\n    initialize: function(options) {\r\n        this.type = options.type || 'update';\r\n        this._callback = options.callback;\r\n        this._items = null;\r\n        this.bbox = options.bbox;      // set bbox by Mercator bounds\r\n        this.filters = options.filters || [];\r\n        this.targetZoom = options.targetZoom || null;\r\n        this.active = 'active' in options ? options.active : true;\r\n\r\n        if (options.bounds) {   // set bbox by LatLngBounds\r\n            this.setBounds(options.bounds);\r\n        }\r\n\r\n\t\tvar w = gmxAPIutils.worldWidthMerc,\r\n\t\t\tdx;\r\n        if (!this.bbox) {\r\n            this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n            this.world = true;\r\n        } else if (this.bbox.max.x > w) {\r\n\t\t\tdx = this.bbox.max.x - w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\r\n        } else if (this.bbox.min.x < -w) {\r\n\t\t\tdx = this.bbox.min.x + w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\r\n        }\r\n\r\n        if (options.dateInterval) {\r\n            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\r\n        }\r\n    },\r\n\r\n    hasFilter: function(filterName) {\r\n        for (var i = 0, len = this.filters.length; i < len; i++) {\r\n            if (this.filters[i] === filterName) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    activate: function() {\r\n        if (!this.active) {\r\n            this.active = true;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    deactivate: function() {\r\n        if (this.active) {\r\n            this.active = false;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    toggleActive: function(isActive) {\r\n        return isActive ? this.activate() : this.deactivate();\r\n    },\r\n\r\n    isActive: function() {\r\n        return this.active;\r\n    },\r\n\r\n    updateData: function(data) {\r\n        var len = data.length,\r\n            out = {count: len};\r\n\r\n        if (this.type === 'update') {\r\n            //calculate difference with previous data\r\n            if (!this._items) { this._items = {}; }\r\n            var prevItems = this._items,\r\n                newItems = {},\r\n                added = [],\r\n                removed = [],\r\n                key;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                var it = data[i];\r\n\r\n                key = it.id + '_' + it.tileKey;\r\n\r\n                newItems[key] = it;\r\n\r\n                if (!prevItems[key]) {\r\n                    added.push(it);\r\n                }\r\n            }\r\n\r\n            for (key in prevItems) {\r\n                if (!newItems[key]) {\r\n                    removed.push(prevItems[key]);\r\n                }\r\n            }\r\n\r\n            if (added.length) {\r\n                out.added = added;\r\n            }\r\n            if (removed.length) {\r\n                out.removed = removed;\r\n            }\r\n\r\n            this._items = newItems;\r\n\r\n        } else {\r\n            out.added = data;\r\n        }\r\n        this._callback(out);\r\n        out = null;\r\n        data = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        if (this.type !== 'update' || !this._items) {\r\n            return this;\r\n        }\r\n\r\n        var items = this._items,\r\n            removed = [];\r\n\r\n        for (var id in keys) {\r\n            if (items[id]) {\r\n                removed.push(items[id]);\r\n                delete items[id];\r\n            }\r\n        }\r\n\r\n        if (removed.length) {\r\n            this._callback({removed: removed});\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /*setFilter: function (func) {\r\n        this._filters.userFilter = func;\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        delete this._filters.userFilter;\r\n        this.fire('update');\r\n        return this;\r\n    },*/\r\n\r\n    setBounds: function(bounds) {\r\n        var w;\r\n        if (!bounds) {\r\n            if (!this.world) {\r\n                w = gmxAPIutils.worldWidthMerc;\r\n                this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n                this.bbox1 = null;\r\n                this.world = true;\r\n                this.fire('update');\r\n            }\r\n            return this;\r\n        }\r\n\r\n        var min = bounds.min,\r\n            max = bounds.max;\r\n        if (!min || !max) {\r\n            var latLngBounds = L.latLngBounds(bounds),\r\n                sw = latLngBounds.getSouthWest(),\r\n                ne = latLngBounds.getNorthEast();\r\n            min = {x: sw.lng, y: sw.lat};\r\n            max = {x: ne.lng, y: ne.lat};\r\n        }\r\n        var minX = min.x, maxX = max.x,\r\n            minY = min.y, maxY = max.y,\r\n            minX1 = null,\r\n            maxX1 = null;\r\n\r\n        this.world = false;\r\n        w = (maxX - minX) / 2;\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n            this.world = true;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\r\n\r\n        this.bbox = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        this.bbox1 = null;\r\n        if (minX1) {\r\n            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\r\n            this.bbox1 = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        }\r\n\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    intersects: function(bounds) {\r\n        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\r\n    },\r\n\r\n    intersectsWithTile: function(tile) {\r\n        if (this.targetZoom) {\r\n            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\r\n            if ((tile.isGeneralized && tile.z !== z) || tile.z > z) { return false; }\r\n        }\r\n        var di = this.dateInterval;\r\n        return this.intersects(tile.bounds) && (!tile.beginDate || (di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate));\r\n    },\r\n\r\n    _setDateInterval: function(beginDate, endDate) {\r\n        if (beginDate && endDate) {\r\n            // var beginValue = beginDate.valueOf(),\r\n                // endValue = endDate.valueOf();\r\n            this.dateInterval = {\r\n                beginDate: beginDate,\r\n                endDate: endDate\r\n            };\r\n        } else {\r\n            this.dateInterval = null;\r\n        }\r\n    },\r\n\r\n    setDateInterval: function(beginDate, endDate) {\r\n        var isValid = beginDate && endDate;\r\n\r\n        if (!this.dateInterval !== !isValid ||\r\n            isValid && (\r\n                this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() ||\r\n                this.dateInterval.endDate.valueOf() !== endDate.valueOf()\r\n            )\r\n        ) {\r\n            this._setDateInterval(beginDate, endDate);\r\n            this.fire('update', {temporalFilter: true});\r\n        }\r\n        return this;\r\n    }\r\n});\r\nexport {Observer};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/Observer.js","(function() {\r\n//tree for fast tiles selection inside temporal interval\r\n//  options:\r\n//      TemporalTiles: tilePoints array\r\n//      TemporalVers: tiles version array\r\n//      TemporalPeriods: periods\r\n//      ZeroDate: start Date\r\nvar TilesTree = function(options) {\r\n    var _rootNodes = [],\r\n        tiles = options.TemporalTiles || [],\r\n        vers = options.TemporalVers || [],\r\n        periods = options.TemporalPeriods || [],\r\n        maxPeriod = periods[periods.length - 1],\r\n        smin = Number.MAX_VALUE,\r\n        arr = options.ZeroDate.split('.'),\r\n        zn = new Date(\r\n            (arr.length > 2 ? arr[2] : 2008),\r\n            (arr.length > 1 ? arr[1] - 1 : 0),\r\n            (arr.length > 0 ? arr[0] : 1)\r\n        ),\r\n        dateZero = new Date(zn.getTime()  - zn.getTimezoneOffset() * 60000),\r\n        zeroUT = dateZero.getTime() / 1000;\r\n\r\n    this.dateZero = dateZero;\r\n\r\n    var addTile = function (node, tile, key) {\r\n        var d = node.d;\r\n        if (tile.d === periods[d]) {\r\n            node.count++;\r\n            node.tiles.push(key);\r\n            return;\r\n        }\r\n\r\n        var pd = periods[d - 1],\r\n            childrenCount = periods[d] / pd;\r\n\r\n        if (!('children' in node)) {\r\n            node.children = new Array(childrenCount);\r\n        }\r\n\r\n        var sChild = Math.floor(tile.s * tile.d / pd),\r\n            ds = sChild - node.s * childrenCount;\r\n\r\n        if (!node.children[ds]) {\r\n            var pdOneDay = pd * gmxAPIutils.oneDay,\r\n                t1 = sChild * pdOneDay + zeroUT;\r\n            node.children[ds] = {\r\n                d: d - 1,\r\n                s: sChild,\r\n                t1: t1,\r\n                t2: t1 + pdOneDay,\r\n                count: 0,\r\n                children: [],\r\n                tiles: []\r\n            };\r\n        }\r\n\r\n        addTile(node.children[ds], tile, key);\r\n    };\r\n\r\n    var dmax = periods.length - 1,\r\n        dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\r\n        i, len;\r\n\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var s = Number(arr[1]),\r\n            d = Number(arr[0]);\r\n\r\n        if (d === maxPeriod) {\r\n            smin = Math.min(smin, s);\r\n        }\r\n    }\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var t = {\r\n            x: Number(arr[2]),\r\n            y: Number(arr[3]),\r\n            z: Number(arr[4]),\r\n            v: Number(vers[i]),\r\n            s: Number(arr[1]),\r\n            d: Number(arr[0])\r\n        };\r\n        if (t.d < 0) {\r\n            continue;\r\n        }\r\n\r\n        var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\r\n            cs = ds + smin;\r\n\r\n        _rootNodes[ds] = _rootNodes[ds] || {\r\n            d: dmax,\r\n            s: cs,\r\n            t1: cs * dmaxOneDay + zeroUT,\r\n            t2: (cs + 1) * dmaxOneDay + zeroUT,\r\n            count: 0,\r\n            tiles: []\r\n        };\r\n        var key = VectorTile.createTileKey(t);\r\n\r\n        addTile(_rootNodes[ds], t, key);\r\n    }\r\n    tiles = vers = null;\r\n\r\n    //options: bounds (in mercator projection)\r\n    this.selectTiles = function(t1, t2, options) {\r\n\r\n        options = options || {};\r\n\r\n        var t1Val = t1.valueOf() / 1000,\r\n            t2Val = t2.valueOf() / 1000;\r\n\r\n        // We will restrict tile levels by the nearest two levels to target date interval length\r\n        // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\r\n        var minLevel = 0,\r\n            dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\r\n\r\n        for (var i = 0; i < periods.length; i++) {\r\n            if (periods[i] > dateIntervalLength) {\r\n                minLevel = Math.max(0, i - 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (periods[periods.length - 1] <= dateIntervalLength) {\r\n            minLevel = periods.length - 1;\r\n        }\r\n\r\n        var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\r\n\r\n        var getCountOfIntersected = function(tileBounds, bounds) {\r\n            var count = 0;\r\n            for (var t = 0; t < tileBounds.length; t++) {\r\n                if (tileBounds[t].intersects(bounds)) {\r\n                    count++;\r\n                }\r\n            }\r\n\r\n            return count;\r\n        };\r\n\r\n        // --------------------\r\n        var selectTilesForNode = function(node, t1, t2) {\r\n            if (t1 >= node.t2 || t2 <= node.t1) {\r\n                return {count: 0, tiles: [], nodes: []};\r\n            }\r\n\r\n            if (options.bounds && !node.tileBounds) {\r\n                node.tileBounds = node.tiles.map(function(it) {\r\n                    return VectorTile.boundsFromTileKey(it);\r\n                });\r\n            }\r\n\r\n            if (node.d === minLevel) {\r\n                var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: count,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n\r\n            var childrenCount = 0, //number of tiles if we use shorter intervals\r\n                childrenRes = [],\r\n\t\t\t\tlen = node.children ? node.children.length : 0,\r\n                ds;\r\n\r\n            for (ds = 0; ds < len; ds++) {\r\n                if (node.children[ds]) {\r\n                    childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\r\n                } else {\r\n                    childrenRes[ds] = {count: 0, tiles: [], nodes: []};\r\n                }\r\n                childrenCount += childrenRes[ds].count;\r\n            }\r\n\r\n            var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n\r\n            if (node.d > maxLevel || childrenCount < intersectCount) {\r\n                var resTilesArr = [],\r\n                    resNodesArr = [];\r\n                for (ds = 0; ds < childrenRes.length; ds++) {\r\n                    resNodesArr.push(childrenRes[ds].nodes);\r\n                    resTilesArr.push(childrenRes[ds].tiles);\r\n                }\r\n\r\n                return {\r\n                    tiles: [].concat.apply([], resTilesArr),\r\n                    count: childrenCount,\r\n                    nodes: [].concat.apply([], resNodesArr)\r\n                };\r\n            } else {\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: intersectCount,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n        };\r\n\r\n        var resTiles = [];\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            if (_rootNodes[ds]) {\r\n                var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\r\n                if (nodeSelection.tiles.length) {\r\n                    resTiles = resTiles.concat(nodeSelection.tiles);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resTilesHash = {};\r\n        for (var t = 0; t < resTiles.length; t++) {\r\n            resTilesHash[resTiles[t]] = true;\r\n        }\r\n\r\n        return {tiles: resTilesHash};\r\n    };\r\n\r\n    this.getNode = function(d, s) {\r\n        if (d < 0 || s < 0) {\r\n            return null;\r\n        }\r\n\r\n        var findNode = function(node, d, s) {\r\n            if (!node) { return null; }\r\n\r\n            if (periods[node.d] === d) {\r\n                return node.s === s ? node : null;\r\n            }\r\n\r\n            var childrenCount = periods[node.d] / periods[node.d - 1];\r\n            var sChild = Math.floor(s * d / periods[node.d - 1]);\r\n            var ds = sChild - node.s * childrenCount;\r\n\r\n            return node.children[ds] ? findNode(node.children[ds], d, s) : null;\r\n        };\r\n\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            var node = findNode(_rootNodes[ds], d, s);\r\n            if (node) {\r\n                return node;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n};\r\nL.gmx.tilesTree = function(options) {\r\n    return new TilesTree(options);\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/TilesTree.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {StyleManager} from './StyleManager.js';\r\nimport {ScreenVectorTile} from './ScreenVectorTile.js';\r\n\r\nL.gmx.VectorLayer = L.TileLayer.Canvas.extend(\r\n{\r\n    options: {\r\n        openPopups: [],\r\n        minZoom: 1,\r\n        zIndexOffset: 0,\r\n        isGeneralized: true,\r\n        isFlatten: false,\r\n        useWebGL: false,\r\n        clickable: true\r\n    },\r\n\r\n    initialize: function(options) {\r\n        options = L.setOptions(this, options);\r\n\r\n        this.initPromise = new L.gmx.Deferred();\r\n\r\n        this._drawQueue = [];\r\n        this._drawQueueHash = {};\r\n\r\n        this._drawInProgress = {};\r\n\r\n        this._anyDrawings = false; //are we drawing something?\r\n        this.repaintObservers = {};    // external observers like screen\r\n\r\n        var _this = this;\r\n\r\n        this._gmx = {\r\n            hostName: gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\r\n            mapName: options.mapID,\r\n            useWebGL: options.useWebGL,\r\n            layerID: options.layerID,\r\n            beginDate: options.beginDate,\r\n            endDate: options.endDate,\r\n            sortItems: options.sortItems || null,\r\n            styles: options.styles || [],\r\n            tileSubscriptions: {},\r\n            _tilesToLoad: 0,\r\n            shiftXlayer: 0,\r\n            shiftYlayer: 0,\r\n            renderHooks: [],\r\n            preRenderHooks: [],\r\n            _needPopups: {}\r\n        };\r\n        if (options.crossOrigin) {\r\n            this._gmx.crossOrigin = options.crossOrigin;\r\n        }\r\n\r\n        this.on('tileunload', function(e) {\r\n            _this._clearTileSubscription(e.tile.zKey);\r\n        });\r\n    },\r\n\r\n    // extended from L.TileLayer.Canvas\r\n    _removeTile: function (zKey) {\r\n        var tileLink = this._tiles[zKey];\r\n        if (tileLink) {\r\n            var tile = tileLink.el;\r\n            if (tile && tile.parentNode) {\r\n                tile.parentNode.removeChild(tile);\r\n            }\r\n\r\n            delete this._tiles[zKey];\r\n        }\r\n    },\r\n\r\n    onAdd: function(map) {\r\n        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\r\n            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\r\n        }\r\n        var gmx = this._gmx;\r\n\r\n        gmx.shiftY = 0;\r\n        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\r\n        gmx.currentZoom = map.getZoom();\r\n        gmx.styleManager.initStyles();\r\n\r\n        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\r\n\r\n        map.on('zoomstart', this._zoomStart, this);\r\n        map.on('zoomend', this._zoomEnd, this);\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.on('moveend', this._moveEnd, this);\r\n        }\r\n        if (this.options.clickable === false) {\r\n            this._container.style.pointerEvents = 'none';\r\n        }\r\n        if (gmx.balloonEnable && !this._popup) { this.bindPopup(''); }\r\n        this.on('stylechange', this._onStyleChange, this);\r\n        this.on('versionchange', this._onVersionChange, this);\r\n\r\n        // this._zIndexOffsetCheck();\r\n        L.gmx.layersVersion.add(this);\r\n        this.fire('add');\r\n    },\r\n\r\n    onRemove: function(map) {\r\n        if (this._container) {\r\n            this._container.parentNode.removeChild(this._container);\r\n        }\r\n\r\n        map.off({\r\n            'viewreset': this._reset,\r\n            'moveend': this._update\r\n        }, this);\r\n\r\n        if (this._animated) {\r\n            map.off({\r\n                'zoomanim': this._animateZoom,\r\n                'zoomend': this._endZoomAnim\r\n            }, this);\r\n        }\r\n\r\n        if (!this.options.updateWhenIdle) {\r\n            map.off('move', this._limitedUpdate, this);\r\n        }\r\n        this._container = null;\r\n        this._map = null;\r\n\r\n        this._clearAllSubscriptions();\r\n        map.off('zoomstart', this._zoomStart, this);\r\n        map.off('zoomend', this._zoomEnd, this);\r\n        this.off('stylechange', this._onStyleChange, this);\r\n\r\n        var gmx = this._gmx;\r\n\r\n        delete gmx.map;\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.off('moveend', this._moveEnd, this);\r\n        }\r\n        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\r\n            L.gmx.layersVersion.remove(this);\r\n        }\r\n        this.fire('remove');\r\n    },\r\n\r\n    _initContainer: function () {\r\n        L.TileLayer.Canvas.prototype._initContainer.call(this);\r\n        this._prpZoomData();\r\n        this.setZIndexOffset();\r\n    },\r\n\r\n    _updateZIndex: function () {\r\n        if (this._container) {\r\n            var options = this.options,\r\n                zIndex = options.zIndex || 0,\r\n                zIndexOffset = options.zIndexOffset || 0;\r\n\r\n            this._container.style.zIndex = zIndexOffset + zIndex;\r\n        }\r\n    },\r\n\r\n    _update: function () {\r\n        if (!this._map ||\r\n            this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\r\n            ) {\r\n            this._clearAllSubscriptions();\r\n            return;\r\n        }\r\n        this._gmx.styleManager.deferred.then(this.__update.bind(this));\r\n    },\r\n\r\n    _addTile: function (tilePoint) {\r\n        var myLayer = this,\r\n            zoom = this._map._zoom,\r\n            gmx = this._gmx;\r\n\r\n        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\r\n            this._tileLoaded();\r\n            return;\r\n        }\r\n\r\n        var zKey = this._tileCoordsToKey(tilePoint, zoom);\r\n        if (!gmx.tileSubscriptions[zKey]) {\r\n            gmx._tilesToLoad++;\r\n            var isDrawnFirstTime = false,\r\n                gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\r\n                done = function() {\r\n                    if (!isDrawnFirstTime) {\r\n                        gmx._tilesToLoad--;\r\n                        myLayer._tileLoaded();\r\n                        isDrawnFirstTime = true;\r\n                    }\r\n                },\r\n                attr = {\r\n                    type: 'resend',\r\n                    active: false,\r\n                    bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\r\n                    filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                    callback: function(data) {\r\n                        myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\r\n                    }\r\n                };\r\n            if (this.options.isGeneralized) {\r\n                attr.targetZoom = zoom;\r\n            }\r\n            if (gmx.layerType === 'VectorTemporal') {\r\n                attr.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n\r\n            var observer = gmx.dataManager.addObserver(attr, zKey);\r\n            observer.on('activate', function() {\r\n                //if observer is deactivated before drawing,\r\n                //we can consider corresponding tile as already drawn\r\n                if (!observer.isActive()) {\r\n                    done();\r\n                }\r\n            });\r\n\r\n            observer.on('startLoadingTiles', this._chkDrawingState, this);\r\n\r\n            gmx.tileSubscriptions[zKey] = {\r\n                z: zoom,\r\n                x: tilePoint.x,\r\n                y: tilePoint.y,\r\n                px: 256 * gmxTilePoint.x,\r\n                py: 256 * (1 + gmxTilePoint.y)\r\n            };\r\n            observer.activate();\r\n        }\r\n    },\r\n\r\n    _chkDrawingState: function() {\r\n        var gmx = this._gmx,\r\n            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\r\n\r\n        if (!isDrawing) {\r\n            for (var key in gmx.tileSubscriptions) {\r\n                var observer = gmx.dataManager.getObserver(key);\r\n                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\r\n                    isDrawing = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isDrawing && this._anyDrawings) {\r\n            this.fire('doneDraw');\r\n        } else  if (isDrawing && !this._anyDrawings) {\r\n            this.fire('startDraw');\r\n        }\r\n\r\n        this._anyDrawings = isDrawing;\r\n    },\r\n\r\n    _getLoadedTilesPercentage: function (container) {\r\n        if (!container) { return 0; }\r\n        var len = 0, count = 0;\r\n        var arr = ['img', 'canvas'];\r\n        for (var key in arr) {\r\n            var tiles = container.getElementsByTagName(arr[key]);\r\n            if (tiles && tiles.length > 0) {\r\n                len += tiles.length;\r\n                for (var i = 0, len1 = tiles.length; i < len1; i++) {\r\n                    if (tiles[i]._tileComplete) {\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (len < 1) { return 0; }\r\n        return count / len;\r\n    },\r\n\r\n    _tileLoaded: function () {\r\n        if (this._animated) {\r\n            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n        }\r\n        if (this._gmx._tilesToLoad === 0) {\r\n            this.fire('load');\r\n\r\n            if (this._animated) {\r\n                // clear scaled tiles after all new tiles are loaded (for performance)\r\n                this._setClearBgBuffer(0);\r\n            }\r\n        }\r\n    },\r\n\r\n    _tileOnLoad: function (tile) {\r\n        if (tile) { L.DomUtil.addClass(tile, 'leaflet-tile-loaded'); }\r\n        this._tileLoaded();\r\n    },\r\n\r\n    _tileOnError: function () {\r\n    },\r\n\r\n    tileDrawn: function (tile) {\r\n        this._tileOnLoad(tile);\r\n    },\r\n\r\n    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\r\n    // converts tile coordinates to key for the tile cache\r\n    _tileCoordsToKey: function (coords, zoom) {\r\n        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\r\n    },\r\n\r\n    _getTiledPixelBounds: function (center) {\r\n        var map = this._map,\r\n            gmx = this._gmx,\r\n            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\r\n            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\r\n            halfSize = map.getSize().divideBy(2);\r\n\r\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\r\n    },\r\n\r\n    _pxBoundsToTileRange: function (bounds) {\r\n        var tileSize = this.options.tileSize;\r\n        return new L.Bounds(\r\n            bounds.min.divideBy(tileSize)._floor(),\r\n            bounds.max.divideBy(tileSize)._round());\r\n    },\r\n\r\n    // original for L.gmx.VectorLayer\r\n\r\n    //public interface\r\n    initFromDescription: function(ph) {\r\n        var gmx = this._gmx;\r\n\r\n        gmx.properties = ph.properties;\r\n        gmx.geometry = ph.geometry;\r\n\r\n        if (gmx.properties._initDone) {    // need delete tiles key\r\n            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\r\n        }\r\n        gmx.properties._initDone = true;\r\n\r\n        if (!gmx.geometry) {\r\n            var worldSize = gmxAPIutils.tileSizes[1];\r\n            gmx.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n        // Original properties from the server.\r\n        // Descendant classes can override this property\r\n        // Not so good solution, but it works\r\n        gmx.rawProperties = ph.rawProperties || ph.properties;\r\n\r\n        this._updateProperties(ph.properties);\r\n\r\n        ph.properties.isGeneralized = this.options.isGeneralized;\r\n        ph.properties.isFlatten = this.options.isFlatten;\r\n\r\n        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tif (!ph.properties.styles) { ph.properties.styles = this.options.parentOptions.styles; }\r\n\t\t\tgmx.dataManager.on('versionchange', this._onVersionChange, this);\r\n\t\t}\r\n\r\n\t\tgmx.styleManager = new StyleManager(gmx);\r\n        this.options.minZoom = gmx.styleManager.minZoom;\r\n        this.options.maxZoom = gmx.styleManager.maxZoom;\r\n\r\n        gmx.dataManager.on('observeractivate', function() {\r\n            if (gmx.dataManager.getActiveObserversCount()) {\r\n                L.gmx.layersVersion.add(this);\r\n            } else {\r\n                L.gmx.layersVersion.remove(this);\r\n            }\r\n        }, this);\r\n\r\n        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\r\n            this.options.chkUpdate = true; //Check updates for vector layers by default\r\n        }\r\n        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\r\n            this._objectsReorderInit(this);\r\n        }\r\n\r\n        if (gmx.clusters) {\r\n            this.bindClusters(JSON.parse(gmx.clusters));\r\n        }\r\n        if (gmx.filter) {\r\n            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (func) {\r\n\t\t\t\tgmx.dataManager.addFilter('userFilter_' + gmx.layerID, function(item) {\r\n\t\t\t\t\treturn gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\r\n\t\t\t\t}.bind(this));\r\n            }\r\n        }\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\r\n        }\r\n\r\n        this.initPromise.resolve();\r\n        return this;\r\n    },\r\n\r\n    getDataManager: function () {\r\n\t\treturn this._gmx.dataManager;\r\n    },\r\n\r\n    enableGeneralization: function () {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.enableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function () {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.disableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    setRasterOpacity: function (opacity) {\r\n        var _this = this;\r\n        if (this._gmx.rasterOpacity !== opacity) {\r\n            this._gmx.rasterOpacity = opacity;\r\n            this.initPromise.then(function() {\r\n                _this.repaint();\r\n            });\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStyles: function () {\r\n        return this._gmx.styleManager.getStyles();\r\n    },\r\n\r\n    getIcons: function (callback) {\r\n        this._gmx.styleManager.getIcons(callback);\r\n        return this;\r\n    },\r\n\r\n    setStyles: function (styles) {\r\n        var _this = this;\r\n\r\n        this.initPromise.then(function() {\r\n            _this._gmx.styleManager.clearStyles();\r\n            if (styles) {\r\n                styles.forEach(function(it, i) {\r\n                    _this.setStyle(it, i, true);\r\n                });\r\n            } else {\r\n                _this.fire('stylechange');\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    getStyle: function (num) {\r\n        return this.getStyles()[num];\r\n    },\r\n\r\n    setStyle: function (style, num, createFlag) {\r\n        var _this = this,\r\n            gmx = this._gmx;\r\n        this.initPromise.then(function() {\r\n            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\r\n                _this.fire('stylechange', {num: num || 0});\r\n            });\r\n        });\r\n        return this;\r\n    },\r\n\r\n    setStyleHook: function (func) {\r\n        this._gmx.styleHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeStyleHook: function () {\r\n        this._gmx.styleHook = null;\r\n        return this;\r\n    },\r\n\r\n    setRasterHook: function (func) {\r\n        this._gmx.rasterProcessingHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeRasterHook: function () {\r\n        this._gmx.rasterProcessingHook = null;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    setFilter: function (func) {\r\n        var gmx = this._gmx;\r\n        gmx.dataManager.addFilter('userFilter', function(item) {\r\n            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\r\n        }.bind(this));\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        this._gmx.dataManager.removeFilter('userFilter');\r\n        return this;\r\n    },\r\n\r\n    setDateInterval: function (beginDate, endDate) {\r\n        var gmx = this._gmx;\r\n\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n\t\t\tbeginDate = gmx.dateBegin;\r\n\t\t\tendDate = gmx.dateEnd;\r\n\t\t}\r\n\r\n        //check that something changed\r\n        if (!gmx.beginDate !== !beginDate ||\r\n            !gmx.endDate !== !endDate ||\r\n            beginDate && (gmx.beginDate.valueOf() !== beginDate.valueOf()) ||\r\n            endDate && (gmx.endDate.valueOf() !== endDate.valueOf())\r\n        ) {\r\n            if (gmx.rawProperties.maxShownPeriod && beginDate) {\r\n                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\r\n                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\r\n            }\r\n\r\n            gmx.beginDate = beginDate;\r\n            gmx.endDate = endDate;\r\n\r\n            var observer = null,\r\n\t\t\t\tdataManager = gmx.dataManager;\r\n            for (var key in gmx.tileSubscriptions) {\r\n                observer = dataManager.getObserver(key);\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n            observer = dataManager.getObserver('_Labels');\r\n            if (observer) {\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n\t\t\tif (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\r\n\t\t\t\tgmx.properties.LayerVersion = -1;\r\n\t\t\t\tdataManager.setOptions({LayerVersion: -1});\r\n\t\t\t\tif (this._map) {\r\n\t\t\t\t\tL.gmx.layersVersion.now();\r\n\t\t\t\t}\r\n\t\t\t}\r\n            this.fire('dateIntervalChanged');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getDateInterval: function() {\r\n        return {\r\n            beginDate: this._gmx.beginDate,\r\n            endDate: this._gmx.endDate\r\n        };\r\n    },\r\n\r\n    addObserver: function (options) {\r\n        return this._gmx.dataManager.addObserver(options);\r\n    },\r\n\r\n    removeObserver: function(observer) {\r\n        return this._gmx.dataManager.removeObserver(observer.id);\r\n    },\r\n\r\n    setPositionOffset: function(dx, dy) {\r\n        var gmx = this._gmx;\r\n        gmx.shiftXlayer = dx;\r\n        gmx.shiftYlayer = dy;\r\n        this._update();\r\n        return this;\r\n    },\r\n\r\n    getPositionOffset: function() {\r\n        var gmx = this._gmx;\r\n        return {shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer};\r\n    },\r\n\r\n    setZIndexOffset: function (offset) {\r\n        if (arguments.length) {\r\n            this.options.zIndexOffset = offset;\r\n        }\r\n        this._updateZIndex();\r\n        return this;\r\n    },\r\n\r\n    repaint: function (zKeys) {\r\n        if (this._map) {\r\n            if (!zKeys) {\r\n                zKeys = {};\r\n                for (var key in this._gmx.tileSubscriptions) { zKeys[key] = true; }\r\n                L.extend(zKeys, this.repaintObservers);\r\n            }\r\n            this._gmx.dataManager._triggerObservers(zKeys);\r\n        }\r\n    },\r\n\r\n    redrawItem: function (id) {\r\n        if (this._map) {\r\n            var item = this._gmx.dataManager.getItem(id),\r\n                gmxTiles = this._getTilesByBounds(item.bounds);\r\n\r\n            this.repaint(gmxTiles);\r\n        }\r\n    },\r\n\r\n    gmxGetCanvasTile: function (tilePoint) {\r\n        var zKey = this._tileCoordsToKey(tilePoint);\r\n\r\n        if (zKey in this._tiles) {\r\n            return this._tiles[zKey];\r\n        }\r\n        // save tile in cache\r\n        var tile = this._getTile();\r\n        this._tiles[zKey] = {\r\n            el: tile,\r\n            coords: tilePoint,\r\n            current: true\r\n        };\r\n\r\n        // tile._zKey = zKey;\r\n        tile._zoom = this._map._zoom;\r\n        tile._tileComplete = true;\r\n        tile._tilePoint = tilePoint;\r\n        this.tileDrawn(tile);\r\n        return this._tiles[zKey];\r\n    },\r\n\r\n    appendTileToContainer: function (tile) {\r\n        this._tileContainer.appendChild(tile);\r\n        var tilePos = this._getTilePos(tile._tilePoint);\r\n        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\r\n    },\r\n\r\n    addData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.addData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.removeData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStylesByProperties: function(propArray, zoom) {\r\n        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\r\n    },\r\n\r\n    getItemStyle: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        return gmx.styleManager.getObjStyle(item);\r\n    },\r\n\r\n    getTileAttributeTypes: function() {\r\n        return this._gmx.tileAttributeTypes;\r\n    },\r\n\r\n    getTileAttributeIndexes: function() {\r\n        return this._gmx.tileAttributeIndexes;\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id),\r\n            styles = this.getStyles(),\r\n            out = '';\r\n\r\n        if (item && styles[item.currentFilter]) {\r\n            var propsArr = item.properties;\r\n            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\r\n                properties: this.getItemProperties(propsArr),\r\n                geometries: [propsArr[propsArr.length - 1]],\r\n                tileAttributeTypes: gmx.tileAttributeTypes,\r\n                unitOptions: this._map ? this._map.options : {}\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getItemProperties: function(propArray) {\r\n        var properties = {},\r\n            indexes = this._gmx.tileAttributeIndexes;\r\n        for (var key in indexes) {\r\n            properties[key] = propArray[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    addPreRenderHook: function(renderHook) {\r\n        this._gmx.preRenderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removePreRenderHook: function(hook) {\r\n        var arr = this._gmx.preRenderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    addRenderHook: function(renderHook) {\r\n        this._gmx.renderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removeRenderHook: function(hook) {\r\n        var arr = this._gmx.renderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    //get original properties from the server\r\n    getGmxProperties: function() {\r\n        return this._gmx.rawProperties;\r\n    },\r\n\r\n    //returns L.LatLngBounds\r\n    getBounds: function() {\r\n        var proj = L.Projection.Mercator,\r\n            gmxBounds = this._gmx.layerID ? gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\r\n\r\n        if (gmxBounds) {\r\n            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\r\n        } else {\r\n            return new L.LatLngBounds();\r\n        }\r\n    },\r\n\r\n    getGeometry: function() {\r\n        if (!this._gmx.latLngGeometry) {\r\n            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\r\n        }\r\n\r\n        return this._gmx.latLngGeometry;\r\n    },\r\n\r\n    // internal methods\r\n    _clearTileSubscription: function(zKey) {\r\n        var gmx = this._gmx;\r\n\r\n        if (zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            delete gmx.tileSubscriptions[zKey];\r\n            this._removeTile(zKey);\r\n\r\n            if (this._anyDrawings) {\r\n                this._chkDrawingState();\r\n            }\r\n        }\r\n\r\n        if (zKey in this._drawQueueHash) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n    },\r\n\r\n    _clearAllSubscriptions: function() {\r\n        while (this._drawQueue.length) {\r\n            this._drawQueue[0].def.cancel();\r\n        }\r\n\r\n        var gmx = this._gmx;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            gmx.dataManager.removeObserver(zKey);\r\n            delete gmx.tileSubscriptions[zKey];\r\n            delete this._tiles[zKey];\r\n        }\r\n\r\n        if (this._anyDrawings) {\r\n            this._chkDrawingState();\r\n        }\r\n\r\n        gmx._tilesToLoad = 0;\r\n    },\r\n\r\n    _zoomStart: function() {\r\n        this._gmx.zoomstart = true;\r\n    },\r\n\r\n    _zoomEnd: function() {\r\n        this._gmx.zoomstart = false;\r\n        this.setCurrentZoom(this._map);\r\n        // this._zIndexOffsetCheck();\r\n    },\r\n\r\n    _moveEnd: function() {\r\n        if ('dataManager' in this._gmx) {\r\n            this._gmx.dataManager.fire('moveend');\r\n        }\r\n    },\r\n\r\n    _onStyleChange: function() {\r\n        var gmx = this._gmx;\r\n        if (!gmx.balloonEnable && this._popup) {\r\n            this.unbindPopup();\r\n        } else if (gmx.balloonEnable && !this._popup) {\r\n            this.bindPopup('');\r\n        }\r\n        if (this._map) {\r\n            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\r\n                this.options.minZoom = gmx.styleManager.minZoom;\r\n                this.options.maxZoom = gmx.styleManager.maxZoom;\r\n                this._map._updateZoomLevels();\r\n            }\r\n            if (gmx.labelsLayer) {\r\n                this._map._labelsLayer.add(this);\r\n            } else if (!gmx.labelsLayer) {\r\n                this._map._labelsLayer.remove(this);\r\n            }\r\n            if (Object.keys(gmx.tileSubscriptions).length > 0) {\r\n                for (var key in gmx.tileSubscriptions) {    // recheck bbox on screen observers\r\n                    var observer = gmx.dataManager.getObserver(key),\r\n                        parsedKey = gmx.tileSubscriptions[key],\r\n                        gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\r\n                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\r\n                    if (!observer.bbox.isEqual(bbox)) {\r\n                        var proj = L.Projection.Mercator;\r\n                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\r\n                    }\r\n                }\r\n            } else {\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    _removeInProgressDrawing: function(zKey) {\r\n        delete this._drawInProgress[zKey];\r\n        this._chkDrawingState();\r\n    },\r\n\r\n    _drawTileAsync: function (tilePoint, zoom, data) {\r\n        var queue = this._drawQueue,\r\n            isEmpty = queue.length === 0,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            _this = this;\r\n\r\n        if (this._drawQueueHash[zKey]) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n\r\n        var drawNextTile = function() {\r\n            _this._chkDrawingState();\r\n\r\n            if (!queue.length) {\r\n                return;\r\n            }\r\n\r\n            var queueItem = queue.shift();\r\n            delete _this._drawQueueHash[queueItem.zKey];\r\n            if (_this._map && queueItem.z === _this._map._zoom) {\r\n                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\r\n\r\n                _this._drawInProgress[queueItem.zKey] = true;\r\n\r\n                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\r\n\r\n                queueItem.drawDef.then(\r\n                    queueItem.def.resolve.bind(queueItem.def, queueItem.data),\r\n                    queueItem.def.reject\r\n                );\r\n            } else {\r\n                queueItem.def.reject();\r\n            }\r\n            setTimeout(drawNextTile, 0);\r\n        };\r\n\r\n        var gtp = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\r\n        var queueItem = {gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data};\r\n        var def = queueItem.def = new L.gmx.Deferred(function() {\r\n            queueItem.drawDef && queueItem.drawDef.cancel();\r\n\r\n            _this._removeInProgressDrawing(zKey);\r\n\r\n            delete _this._drawQueueHash[zKey];\r\n            for (var i = queue.length - 1; i >= 0; i--) {\r\n                var elem = queue[i];\r\n                if (elem.zKey === zKey) {\r\n                    queue.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        queue.push(queueItem);\r\n\r\n        this._drawQueueHash[zKey] = def;\r\n\r\n        if (isEmpty) {\r\n            setTimeout(drawNextTile, 0);\r\n        }\r\n\r\n        return def;\r\n    },\r\n\r\n    _updateShiftY: function() {\r\n        var gmx = this._gmx,\r\n            map = this._map,\r\n            deltaY = 0;\r\n\r\n        if (map) {\r\n            var pos = map.getCenter();\r\n            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\r\n        }\r\n\r\n        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\r\n        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\r\n        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY);     // Сдвиг слоя\r\n\r\n        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\r\n    },\r\n\r\n    _prpZoomData: function() {\r\n        this.setCurrentZoom(this._map);\r\n        // this.repaint();\r\n    },\r\n\r\n    setCurrentZoom: function(map) {\r\n        var gmx = this._gmx;\r\n        gmx.currentZoom = map._zoom;\r\n        gmx.tileSize = gmxAPIutils.tileSizes[gmx.currentZoom];\r\n        gmx.mInPixel = 256 / gmx.tileSize;\r\n    },\r\n\r\n    // _zIndexOffsetCheck: function() {\r\n        // var gmx = this._gmx;\r\n        // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\r\n            // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\r\n            // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\r\n            // if (zIndexOffset !== this.options.zIndexOffset) {\r\n                // this.setZIndexOffset(zIndexOffset);\r\n            // }\r\n        // }\r\n    // },\r\n\r\n    _setClearBgBuffer: function (zd) {\r\n        if (this._clearBgBufferTimer) { clearTimeout(this._clearBgBufferTimer); }\r\n        var _this = this;\r\n        this._clearBgBufferTimer = setTimeout(function () {\r\n            if (_this._bgBuffer) {\r\n                _this._clearBgBuffer();\r\n            }\r\n        }, zd || 0);\r\n    },\r\n\r\n    _getNeedPopups: function () {\r\n        var out = {},\r\n            openPopups = this.options.openPopups;\r\n        for (var i = 0, len = openPopups.length; i < len; i++) {\r\n            out[openPopups[i]] = false;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    __update: function () {\r\n        var map = this._map;\r\n        if (!map) { return; }\r\n        var zoom = map.getZoom(),\r\n            center = map.getCenter();\r\n\r\n        if (this._gmx.applyShift) {\r\n            this._updateShiftY();\r\n        }\r\n        this._tileZoom = zoom;\r\n        if (this.options.openPopups.length) {\r\n            this._gmx._needPopups = this._getNeedPopups();\r\n            this.options.openPopups = [];\r\n        }\r\n\r\n        var pixelBounds = this._getTiledPixelBounds(center),\r\n            tileRange = this._pxBoundsToTileRange(pixelBounds),\r\n            limit = this._getWrapTileNum();\r\n\r\n        if (tileRange.min.y < 0) { tileRange.min.y = 0; }\r\n        if (tileRange.max.y >= limit.y) { tileRange.max.y = limit.y - 1; }\r\n\r\n        this._chkTileSubscriptions(zoom, tileRange);\r\n\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            this._setClearBgBuffer(500);\r\n            return;\r\n        }\r\n\r\n        // create a queue of coordinates to load tiles from\r\n        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\r\n            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\r\n                var coords = new L.Point(i, j);\r\n                coords.z = this._tileZoom;\r\n\r\n                if (!this._tiles[this._tileCoordsToKey(coords)]) {\r\n                    this._addTile(coords);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkTileSubscriptions: function (zoom, tileRange) {\r\n        //L.TileVector will remove all tiles from other zooms.\r\n        //But it will not remove subscriptions without tiles - we should do it ourself\r\n        var gmx = this._gmx,\r\n            min = tileRange.min,\r\n            max = tileRange.max;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.z !== zoom\r\n                || subscription.x < min.x\r\n                || subscription.x > max.x\r\n                || subscription.y < min.y\r\n                || subscription.y > max.y\r\n            ) {\r\n                this._clearTileSubscription(zKey);\r\n            }\r\n        }\r\n    },\r\n\r\n    _getScreenTile: function (tilePoint, zoom) {\r\n        var gmx = this._gmx,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            subscription = gmx.tileSubscriptions[zKey],\r\n            screenTile = null;\r\n        if (subscription) {\r\n            if (subscription.screenTile) {\r\n                screenTile = subscription.screenTile;\r\n            } else {\r\n                subscription.screenTile = screenTile = new ScreenVectorTile(this, tilePoint, zoom);\r\n            }\r\n        }\r\n        return screenTile;\r\n    },\r\n\r\n    _gmxDrawTile: function (tilePoint, zoom, data) {\r\n        var gmx = this._gmx,\r\n            cancelled = false,\r\n            screenTileDrawPromise = null,\r\n            def = new L.gmx.Deferred(function() {\r\n                cancelled = true;\r\n                screenTileDrawPromise && screenTileDrawPromise.cancel();\r\n            });\r\n\r\n        if (!this._map) {\r\n            def.reject();\r\n            return def;\r\n        }\r\n        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\r\n        if (screenTile) {\r\n            gmx.styleManager.deferred.then(function () {\r\n                if (!cancelled) {\r\n                    screenTileDrawPromise = screenTile.drawTile(data);\r\n                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\r\n                }\r\n            });\r\n        }\r\n       return def;\r\n    },\r\n\r\n    _getTilesByBounds: function (bounds) {    // Получить список gmxTiles по bounds\r\n        var gmx = this._gmx,\r\n            zoom = this._map._zoom,\r\n            shiftX = gmx.shiftX || 0,   // Сдвиг слоя\r\n            shiftY = gmx.shiftY || 0,   // Сдвиг слоя + OSM\r\n            minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\r\n            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\r\n            screenBounds = this._map.getBounds(),\r\n            sw = screenBounds.getSouthWest(),\r\n            ne = screenBounds.getNorthEast(),\r\n            dx = 0;\r\n\r\n        if (ne.lng - sw.lng < 360) {\r\n            if (maxLatLng.lng < sw.lng) {\r\n                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\r\n            } else if (minLatLng.lng > ne.lng) {\r\n                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\r\n            }\r\n        }\r\n        minLatLng.lng += dx;\r\n        maxLatLng.lng += dx;\r\n\r\n        var pixelBounds = this._map.getPixelBounds(),\r\n            minPoint = this._map.project(minLatLng),\r\n            maxPoint = this._map.project(maxLatLng);\r\n\r\n        var minY, maxY, minX, maxX;\r\n        if (pixelBounds) {\r\n            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\r\n            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\r\n            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\r\n            minX = Math.floor((minX + shiftX) / 256);\r\n            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\r\n            maxX = Math.floor((maxX + shiftX) / 256);\r\n        } else {\r\n            minY = Math.floor((maxPoint.y + shiftY) / 256);\r\n            maxY = Math.floor((minPoint.y + shiftY) / 256);\r\n            minX = Math.floor((minPoint.x + shiftX) / 256);\r\n            maxX = Math.floor((maxPoint.x + shiftX) / 256);\r\n        }\r\n        var gmxTiles = {};\r\n        for (var x = minX; x <= maxX; x++) {\r\n            for (var y = minY; y <= maxY; y++) {\r\n                var zKey = this._tileCoordsToKey({x: x, y: y}, zoom);\r\n                gmxTiles[zKey] = true;\r\n            }\r\n        }\r\n        return gmxTiles;\r\n    },\r\n\r\n    _updateProperties: function (prop) {\r\n        var gmx = this._gmx,\r\n            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\r\n\r\n        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tprop = this.options.parentOptions;\r\n\t\t}\r\n\r\n        gmx.identityField = prop.identityField; // ogc_fid\r\n        gmx.GeometryType = (prop.GeometryType || '').toLowerCase();   // тип геометрий обьектов в слое\r\n        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1;// мин. zoom для растров\r\n        gmx.minZoomQuicklooks = gmx.minZoomRasters; // по умолчанию minZoom для квиклуков и КР равны\r\n\r\n        var type = prop.type || 'Vector';\r\n        if (prop.Temporal) { type += 'Temporal'; }\r\n        gmx.layerType = type;   // VectorTemporal Vector\r\n        gmx.items = {};\r\n\r\n        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\r\n        if (gmx.dataManager) {\r\n            gmx.dataManager.setOptions(prop);\r\n        }\r\n        if ('ZIndexField' in prop) {\r\n            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\r\n                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField];   // sort field index\r\n            }\r\n        }\r\n        if (this._objectsReorder) {\r\n            this._objectsReorder.initialize();\r\n        }\r\n\r\n        // if ('clusters' in prop) {\r\n            // gmx.clusters = prop.clusters;\r\n        // }\r\n\r\n        gmx.filter = prop.filter; \t// for dataSource attr\r\n        gmx.dateBegin = prop.dateBegin;\r\n        gmx.dateEnd = prop.dateEnd;\r\n        gmx.dataSource = prop.dataSource;\r\n        if ('MetaProperties' in gmx.rawProperties) {\r\n            var meta = gmx.rawProperties.MetaProperties;\r\n            if ('parentLayer' in meta) {  // фильтр слоя\t\t// todo удалить после изменений вов вьювере\r\n                gmx.dataSource = meta.parentLayer.Value || '';\r\n            }\r\n            if ('filter' in meta) {  // фильтр слоя\r\n                gmx.filter = meta.filter.Value || '';\r\n            }\r\n            if ('dateBegin' in meta) {  // фильтр для мультивременного слоя\r\n                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\r\n            }\r\n            if ('dateEnd' in meta) {  // фильтр для мультивременного слоя\r\n                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\r\n            }\r\n            if ('shiftX' in meta || 'shiftY' in meta) {  // сдвиг всего слоя\r\n                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\r\n                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\r\n            }\r\n            if ('shiftXfield' in meta || 'shiftYfield' in meta) {    // поля сдвига растров объектов слоя\r\n                if (meta.shiftXfield) { gmx.shiftXfield = meta.shiftXfield.Value; }\r\n                if (meta.shiftYfield) { gmx.shiftYfield = meta.shiftYfield.Value; }\r\n            }\r\n            if ('quicklookPlatform' in meta) {    // тип спутника\r\n                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\r\n                if (gmx.quicklookPlatform === 'image') { delete gmx.quicklookPlatform; }\r\n            }\r\n            if ('quicklookX1' in meta) { gmx.quicklookX1 = meta.quicklookX1.Value; }\r\n            if ('quicklookY1' in meta) { gmx.quicklookY1 = meta.quicklookY1.Value; }\r\n            if ('quicklookX2' in meta) { gmx.quicklookX2 = meta.quicklookX2.Value; }\r\n            if ('quicklookY2' in meta) { gmx.quicklookY2 = meta.quicklookY2.Value; }\r\n            if ('quicklookX3' in meta) { gmx.quicklookX3 = meta.quicklookX3.Value; }\r\n            if ('quicklookY3' in meta) { gmx.quicklookY3 = meta.quicklookY3.Value; }\r\n            if ('quicklookX4' in meta) { gmx.quicklookX4 = meta.quicklookX4.Value; }\r\n            if ('quicklookY4' in meta) { gmx.quicklookY4 = meta.quicklookY4.Value; }\r\n\r\n            if ('multiFilters' in meta) {    // проверка всех фильтров для обьектов слоя\r\n                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\r\n            }\r\n            if ('isGeneralized' in meta) {    // Set generalization\r\n                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\r\n            }\r\n            if ('isFlatten' in meta) {        // Set flatten geometry\r\n                this.options.isFlatten = meta.isFlatten.Value !== 'false';\r\n            }\r\n        }\r\n        if (prop.Temporal) {    // Clear generalization flag for Temporal layers\r\n            this.options.isGeneralized = false;\r\n        }\r\n\r\n        if (prop.IsRasterCatalog) {\r\n            gmx.IsRasterCatalog = prop.IsRasterCatalog;\r\n            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\r\n            if (layerLink) {\r\n                gmx.rasterBGfunc = function(x, y, z, item) {\r\n                    var properties = item.properties;\r\n                    return 'http://' + gmx.hostName\r\n                        + '/TileSender.ashx?ModeKey=tile'\r\n                        + '&x=' + x\r\n                        + '&y=' + y\r\n                        + '&z=' + z\r\n                        + '&LayerName=' + properties[layerLink]\r\n                        + '&key=' + encodeURIComponent(gmx.sessionKey);\r\n                };\r\n            }\r\n        }\r\n        if (prop.Quicklook) {\r\n            var quicklookParams;\r\n\r\n            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом\r\n            if (prop.Quicklook[0] === '{') {\r\n                quicklookParams = JSON.parse(prop.Quicklook);\r\n            } else {\r\n                quicklookParams = {\r\n                    minZoom: gmx.minZoomRasters,\r\n                    template: prop.Quicklook\r\n                };\r\n            }\r\n\r\n            if ('X1' in quicklookParams) { gmx.quicklookX1 = quicklookParams.X1; }\r\n            if ('Y1' in quicklookParams) { gmx.quicklookY1 = quicklookParams.Y1; }\r\n            if ('X2' in quicklookParams) { gmx.quicklookX2 = quicklookParams.X2; }\r\n            if ('Y2' in quicklookParams) { gmx.quicklookY2 = quicklookParams.Y2; }\r\n            if ('X3' in quicklookParams) { gmx.quicklookX3 = quicklookParams.X3; }\r\n            if ('Y3' in quicklookParams) { gmx.quicklookY3 = quicklookParams.Y3; }\r\n            if ('X4' in quicklookParams) { gmx.quicklookX4 = quicklookParams.X4; }\r\n            if ('Y4' in quicklookParams) { gmx.quicklookY4 = quicklookParams.Y4; }\r\n\r\n            var template = gmx.Quicklook = quicklookParams.template;\r\n            if ('minZoom' in quicklookParams) { gmx.minZoomQuicklooks = quicklookParams.minZoom; }\r\n            gmx.quicklookBGfunc = function(item) {\r\n                var url = template,\r\n                    reg = /\\[([^\\]]+)\\]/,\r\n                    matches = reg.exec(url);\r\n                while (matches && matches.length > 1) {\r\n                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\r\n                    matches = reg.exec(url);\r\n                }\r\n                return url;\r\n            };\r\n            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\r\n        }\r\n        this.options.attribution = prop.Copyright || '';\r\n    },\r\n\r\n    _onVersionChange: function () {\r\n        this._updateProperties(this._gmx.rawProperties);\r\n    },\r\n\r\n    getViewRasters: function() {\r\n        var gmx = this._gmx,\r\n\t\t\thash = {},\r\n\t\t\tout = [];\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey],\r\n\t\t\t\tscreenTile = subscription.screenTile;\r\n            if (screenTile) {\r\n                screenTile.itemsView.forEach(function(it) {\r\n\t\t\t\t\thash[it.id] = true;\r\n\t\t\t\t});\r\n            }\r\n        }\r\n        for (var id in hash) {\r\n\t\t\tout.push(id);\r\n\t\t}\r\n\r\n        return out;\r\n    },\r\n\r\n    getPropItem: function (key, propArr) {\r\n        return gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar StyleManager = function(gmx) {\r\n    this.gmx = gmx;\r\n    this.deferred = new L.gmx.Deferred();\r\n\r\n    this._maxVersion = 0;\r\n    this._maxStyleSize = 0;\r\n    this._styles = [];\r\n    this._deferredIcons = [];\r\n    this._parserFunctions = {};\r\n    this._serverStylesParsed = false;\r\n\r\n    var minZoom = Infinity,\r\n        maxZoom = -Infinity,\r\n        arr = gmx.properties.styles || [];\r\n\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n        var st = arr[i];\r\n        minZoom = Math.min(minZoom, st.MinZoom);\r\n        maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n    }\r\n    this.minZoom = minZoom === Infinity ? 0 : minZoom;\r\n    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\r\n};\r\nStyleManager.prototype = {\r\n    _getMaxStyleSize: function(zoom) {  // estimete style size for arbitrary object\r\n        var maxSize = 0;\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom > style.MaxZoom || zoom < style.MinZoom) { continue; }\r\n            var RenderStyle = style.RenderStyle;\r\n            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\r\n            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\r\n                maxSize = StyleManager.MAX_STYLE_SIZE;\r\n                break;\r\n            }\r\n            var maxShift = 0;\r\n            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\r\n                maxShift = Math.max(\r\n                    Math.abs(RenderStyle.iconAnchor[0]),\r\n                    Math.abs(RenderStyle.iconAnchor[1])\r\n                );\r\n            }\r\n            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\r\n        }\r\n        return maxSize;\r\n    },\r\n\r\n    getStyleBounds: function(gmxTilePoint) {\r\n        if (!gmxTilePoint) {\r\n            return gmxAPIutils.bounds();\r\n        }\r\n\r\n        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\r\n\r\n        var mercSize = 2 * this._maxStyleSize * gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\r\n        return gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\r\n    },\r\n\r\n    //is any style is visible at given zoom?\r\n    isVisibleAtZoom: function(zoom) {\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    getIcons: function(callback) {\r\n        var _this = this;\r\n        this.deferred.then(function() {\r\n            var out = [];\r\n            for (var i = 0, len = _this._styles.length; i < len; i++) {\r\n                var style = _this._styles[i],\r\n                    pt = {};\r\n                if (style.RenderStyle) {\r\n                    pt.RenderStyle = {image: style.RenderStyle.image};\r\n                }\r\n                if (style.HoverStyle) {\r\n                    pt.HoverStyle = {image: style.HoverStyle.image};\r\n                }\r\n                out.push(pt);\r\n            }\r\n            if (callback) {\r\n                callback(out);\r\n            }\r\n        });\r\n        this.initStyles();\r\n    },\r\n\r\n    _chkReady: function() {\r\n        if (this._needLoadIcons < 1) {\r\n            var _this = this;\r\n\t\t\tif (this.gmx.dataManager) {\r\n\t\t\t\tthis.gmx.dataManager.addFilter('styleFilter', function(it) { return _this._chkStyleFilter(it); });\r\n\t\t\t}\r\n            this.deferred.resolve();\r\n        }\r\n    },\r\n\r\n    initStyles: function() {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\r\n            this._getImageSize(this._deferredIcons[i]);\r\n        }\r\n        this._deferredIcons = [];\r\n        this._chkReady();\r\n        return this.deferred;\r\n    },\r\n\r\n    getStyles: function () {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        var out = [];\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = L.extend({}, this._styles[i]);\r\n            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\r\n            if (style.HoverStyle) {\r\n                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\r\n            }\r\n            delete style.filterFunction;\r\n            delete style.version;\r\n            delete style.common;\r\n            delete style.type;\r\n            out.push(style);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    clearStyles: function () {\r\n        this._styles = [];\r\n        this.gmx.balloonEnable = false;\r\n        this.gmx.labelsLayer = false;\r\n    },\r\n\r\n    _changeStylesVersion: function () {\r\n        var _this = this;\r\n        this._styles.map(function(it) {\r\n            it.version = ++_this._maxVersion;\r\n        });\r\n    },\r\n\r\n    setStyle: function(st, num, createFlag) {\r\n        num = num || 0;\r\n        if (num < this._styles.length || createFlag) {\r\n            var style = this._styles[num];\r\n            if (!style) {\r\n                style = this._prepareItem({});\r\n                this._styles[num] = style;\r\n            }\r\n            this.deferred = new L.gmx.Deferred();\r\n            style.version = ++this._maxVersion;\r\n            if ('Filter' in st) {\r\n                style.Filter = st.Filter;\r\n                var type = typeof (st.Filter);\r\n                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'))\r\n                    : type === 'function' ? style.Filter : null;\r\n\r\n                this._changeStylesVersion();\r\n            }\r\n            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\r\n                var key = StyleManager.DEFAULT_KEYS[i];\r\n                if (key in st) { style[key] = st[key]; }\r\n            }\r\n            if (st.RenderStyle) {\r\n                style.RenderStyle = this._parseStyle(st.RenderStyle);\r\n            }\r\n            if (st.HoverStyle) { style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle); }\r\n            this._checkStyles();\r\n        }\r\n        return this.initStyles();\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var item = this.gmx.dataManager.getItem(id),\r\n            currentFilter = item ? item.currentFilter : 0,\r\n            style = this._styles[currentFilter];\r\n        return style ? {\r\n                DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\r\n                DisableBalloonOnClick: style.DisableBalloonOnClick || false,\r\n                templateBalloon: style.Balloon || null,\r\n                isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\r\n            }\r\n            : null\r\n        ;\r\n    },\r\n\r\n    // apply styleHook func\r\n    // applyStyleHook: function(item, hoverFlag) {\r\n        // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\r\n    // },\r\n\r\n    getObjStyle: function(item) {\r\n        this._chkStyleFilter(item);\r\n        var style = this._styles[item.currentFilter],\r\n            version;\r\n\r\n        if (!style) { return null; }\r\n        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\r\n            if (style.HoverStyle) {\r\n                version = style.HoverStyle.version || -1;\r\n                if (version !== item.styleVersion) {\r\n                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\r\n                }\r\n                return style.HoverStyle;\r\n            } else {\r\n                delete item.parsedStyleHover;\r\n            }\r\n            return null;\r\n        }\r\n        version = style.version || -1;\r\n        if (version !== item.styleVersion) {\r\n            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\r\n        }\r\n        return style.RenderStyle;\r\n    },\r\n\r\n    _needLoadIcons: 0,\r\n    _getImageSize: function(pt) {     // check image size\r\n        var url = pt.iconUrl || pt.fillIconUrl,\r\n            opt = pt.iconAngle || pt.iconScale ? {crossOrigin: 'anonymous'} : {},\r\n            _this = this;\r\n\r\n        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\r\n            opt = {};   // skip bug in IE11\r\n        }\r\n        opt.layerID = this.gmx.layerID;\r\n        ++this._needLoadIcons;\r\n        L.gmx.imageLoader.unshift(url, opt).def.then(\r\n            function(it) {\r\n                pt.version = ++_this._maxVersion;\r\n                if (pt.fillIconUrl) {\r\n                    pt.imagePattern = it;\r\n                } else {\r\n                    var w = it.width,\r\n                        h = it.height;\r\n                    if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {   // skip bug in IE11\r\n                        document.body.appendChild(it);\r\n                        w = it.offsetWidth;\r\n                        h = it.offsetHeight;\r\n                        document.body.removeChild(it);\r\n                    }\r\n                    pt.sx = w;\r\n                    pt.sy = h;\r\n                    pt.image = it;\r\n                    var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\r\n                    if (!pt.scaleFunction && !pt.rotateFunction) {\r\n                        if (pt.iconScale || pt.iconScale === 1) { maxSize *= pt.iconScale; }\r\n                        pt.common = true;\r\n                    }\r\n                    pt.maxSize = Number(maxSize.toFixed());\r\n                }\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n            },\r\n            function() {\r\n                pt.version = ++_this._maxVersion;\r\n                pt.sx = 1;\r\n                pt.sy = 0;\r\n                pt.image = null;\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n                console.log({url: url, func: '_getImageSize', Error: 'image not found'});\r\n            }\r\n        );\r\n    },\r\n\r\n    getCurrentFilters: function(propArray, zoom) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            types = gmx.tileAttributeTypes,\r\n            z = zoom || 1,\r\n            out = [];\r\n\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n            if (z > st.MaxZoom || z < st.MinZoom\r\n                || (st.filterFunction && !st.filterFunction(propArray, indexes, types))) {\r\n                continue;\r\n            }\r\n            out.push(i);\r\n            if (!gmx.multiFilters) { break; }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    _chkStyleFilter: function(item) {\r\n        var gmx = this.gmx,\r\n            zoom = gmx.currentZoom,\r\n            fnum = gmx.multiFilters ? -1 : item.currentFilter,\r\n            curr = this._styles[fnum],\r\n            needParse = !curr || curr.version !== item.styleVersion;\r\n\r\n        if (needParse || item._lastZoom !== zoom) {\r\n            item.currentFilter = -1;\r\n            item.multiFilters = [];\r\n            var filters = this.getCurrentFilters(item.properties, zoom);\r\n            for (var i = 0, len = filters.length; i < len; i++) {\r\n                var num = filters[i],\r\n                    st = this._styles[num];\r\n                item.hoverDiff = st.hoverDiff;\r\n                item.currentFilter = num;\r\n                if (needParse || fnum !== num) {\r\n                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\r\n                        parsedHover = null;\r\n\r\n                    item.parsedStyleKeys = parsed;\r\n                    if (st.HoverStyle) {\r\n                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\r\n                        item.parsedStyleHover = parsedHover;\r\n                    }\r\n                    if (gmx.multiFilters) {\r\n                        item.multiFilters.push({\r\n                            style: st.RenderStyle,\r\n                            styleHover: st.HoverStyle,\r\n                            parsedStyle: parsed,\r\n                            parsedStyleHover: parsedHover\r\n                        });\r\n                    }\r\n                }\r\n                item.styleVersion = st.version;\r\n                if (!gmx.multiFilters) { break; }\r\n            }\r\n            item._lastZoom = zoom;\r\n        }\r\n        if (this._styles[item.currentFilter]) {\r\n            return true;\r\n        } else {\r\n            item.currentFilter = -1;\r\n            return false;\r\n        }\r\n    },\r\n\r\n    _parseServerStyles: function() {\r\n        var gmx = this.gmx,\r\n            props = gmx.properties,\r\n            arr = props.styles || [{MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE}],\r\n            len = Math.max(arr.length, gmx.styles.length);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            if (!this._styles[i]) {\r\n                var gmxStyle = gmx.styles[i] || arr[i];\r\n                if (!gmxStyle.RenderStyle) { gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE; }\r\n                if (gmxStyle.HoverStyle === undefined) {\r\n                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\r\n                    if (hoveredStyle.outline) { hoveredStyle.outline.thickness += 1; }\r\n                    gmxStyle.HoverStyle = hoveredStyle;\r\n                } else if (gmxStyle.HoverStyle === null) {\r\n                    delete gmxStyle.HoverStyle;\r\n                }\r\n                var pt = this._prepareItem(gmxStyle);\r\n                this._styles.push(pt);\r\n                if (this._isLabel(pt.RenderStyle)) { gmx.labelsLayer = true; }\r\n            }\r\n        }\r\n        this._checkStyles();\r\n        this._serverStylesParsed = true;\r\n    },\r\n\r\n    _checkStyles: function() {\r\n        var minZoom = Infinity,\r\n            maxZoom = -Infinity,\r\n            balloonEnable = false,\r\n            labelsLayer = false;\r\n\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n\r\n            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\r\n            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\r\n            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\r\n                balloonEnable = true;\r\n                st.BalloonEnable = true;\r\n            }\r\n            st.hoverDiff = null;\r\n            st.common = {};\r\n            if (st.RenderStyle) {\r\n                if (!labelsLayer) {\r\n                    if (this._isLabel(st.RenderStyle)) {\r\n                        labelsLayer = true;\r\n                    }\r\n                }\r\n                if (st.RenderStyle.common) {\r\n                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\r\n                }\r\n                if (st.HoverStyle) {\r\n                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\r\n                }\r\n            }\r\n            if (st.HoverStyle && st.HoverStyle.common) {\r\n                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\r\n            }\r\n            minZoom = Math.min(minZoom, st.MinZoom);\r\n            maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n        }\r\n        if (this.minZoom !== Infinity) { this.minZoom = minZoom; }\r\n        if (this.maxZoom !== -Infinity) { this.maxZoom = maxZoom; }\r\n        this.gmx.balloonEnable = balloonEnable;\r\n        this.gmx.labelsLayer = labelsLayer;\r\n    },\r\n\r\n    _parseStyle: function(st, renderStyle) {\r\n        if (st) {\r\n            st.common = true;\r\n            for (var key in st) {\r\n                if (gmxAPIutils.styleFuncKeys[key]) {\r\n                    var fkey = gmxAPIutils.styleFuncKeys[key],\r\n                        val = st[key];\r\n                    if (typeof (val) === 'string') {\r\n                        st.common = false;\r\n                        if (renderStyle && renderStyle[key] === val) {\r\n                            st[fkey] = renderStyle[fkey];\r\n                        } else {\r\n                            if (!this._parserFunctions[val]) {\r\n                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\r\n                            }\r\n                            st[fkey] = this._parserFunctions[val];\r\n                        }\r\n                    } else if (typeof (val) === 'function') {\r\n                        st.common = false;\r\n                        st[fkey] = val;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var type = '';\r\n            if ('iconUrl' in st) {\r\n                type = 'image';\r\n                if (st.iconUrl) {\r\n                    st.maxSize = 256;\r\n                    this._deferredIcons.push(st);\r\n                }\r\n            } else if (st.fillIconUrl) {\r\n                type = 'square';\r\n                this._deferredIcons.push(st);\r\n            } else if (st.fillPattern) {\r\n                type = 'square';\r\n                st.common = StyleManager.parsePattern(st.fillPattern);\r\n                st.canvasPattern = gmxAPIutils.getPatternIcon(null, st);\r\n            } else if (st.iconCircle) {\r\n                type = 'circle';\r\n                if (!('iconSize' in st)) { st.iconSize = 4; }\r\n            } else if (st.iconPath) {\r\n                type = 'iconPath';\r\n                var iconSize = 0,\r\n                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\r\n                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function(it, i) {\r\n                    var z = arr[i] || it;\r\n                    iconSize = Math.max(iconSize, z);\r\n                    return z;\r\n                });\r\n                st.iconSize = 2 * iconSize;\r\n            } else if (st.fillRadialGradient) {\r\n                type = 'circle';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\r\n                if (size === null) {\r\n                    st.common = false;\r\n                } else {\r\n                    st.iconSize = size;\r\n                }\r\n            } else if (st.fillLinearGradient) {\r\n                type = 'square';\r\n                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\r\n            } else if (st.iconSize) {\r\n                type = 'square';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n            }\r\n            st.type = type;\r\n            if (st.common && !st.maxSize) {\r\n                st.maxSize = st.iconSize || 0;\r\n                st.maxSize += st.weight ? st.weight : 0;\r\n                if ('iconScale' in st) { st.maxSize *= st.iconScale; }\r\n            }\r\n        }\r\n        return st;\r\n    },\r\n\r\n    _prepareItem: function(style) { // Style Scanex->leaflet\r\n        var pt = {\r\n            MinZoom: style.MinZoom || 0,\r\n            MaxZoom: style.MaxZoom || 18,\r\n            Filter: style.Filter || null,\r\n            Balloon: style.Balloon || '',\r\n            RenderStyle: (style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {}),\r\n            version: ++this._maxVersion\r\n        };\r\n        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\r\n        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\r\n        if (style.HoverStyle) {\r\n            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\r\n        }\r\n\r\n        if ('Filter' in style) {\r\n            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (ph) { pt.filterFunction = ph; }\r\n        }\r\n        return pt;\r\n    },\r\n\r\n    _isLabel: function(st) {\r\n        var indexes = this.gmx.tileAttributeIndexes;\r\n        return (st && (st.labelTemplate || (st.labelField && st.labelField in indexes)));\r\n    },\r\n\r\n    _itemStyleParser: function(item, pt) {\r\n        pt = pt || {};\r\n        var out = {}, arr, i, len,\r\n            indexes = this.gmx.tileAttributeIndexes,\r\n            prop = item.properties || {},\r\n            itemType = item.type,\r\n            type = pt.type,\r\n            color = 'color' in pt ? pt.color : 255,\r\n            opacity = 'opacity' in pt ? pt.opacity : 1;\r\n\r\n        out.sx = pt.sx;\r\n        out.sy = pt.sy;\r\n        if (pt.maxSize) {\r\n            out.maxSize = pt.maxSize;\r\n        }\r\n        if (pt.iconAngle) {\r\n            var rotateRes = pt.iconAngle || 0;\r\n            if (rotateRes && typeof (rotateRes) === 'string') {\r\n                rotateRes = (pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0);\r\n            }\r\n            out.rotate = rotateRes || 0;\r\n        }\r\n        if ('iconColor' in pt) {\r\n            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\r\n        }\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if (type === 'image') {\r\n            out.type = type;\r\n            if (pt.iconUrl) { out.iconUrl = pt.iconUrl; }\r\n            if (pt.image) { out.image = pt.image; }\r\n        } else if (pt.fillRadialGradient) {\r\n            var rgr = pt.fillRadialGradient,\r\n                r1 = (rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1),\r\n                r2 = (rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2),\r\n                x1 = (rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1),\r\n                y1 = (rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1),\r\n                x2 = (rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2),\r\n                y2 = (rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2);\r\n            if (rgr.r2max) {\r\n                r2 = Math.min(r2, rgr.r2max);\r\n            }\r\n            var colorStop = [];\r\n            len = rgr.addColorStop.length;\r\n            if (!rgr.addColorStopFunctions) {\r\n                rgr.addColorStopFunctions = new Array(len);\r\n            }\r\n            for (i = 0; i < len; i++) {\r\n                arr = rgr.addColorStop[i];\r\n                var arrFunc = rgr.addColorStopFunctions[i] || [],\r\n                    p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0]),\r\n                    p3 = arr[3];\r\n                if (arr.length < 4) {\r\n                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\r\n                    p3 = gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\r\n                 }\r\n                colorStop.push([p0, p3]);\r\n            }\r\n            out.maxSize = out.sx = out.sy = out.iconSize = r2;\r\n            out.fillRadialGradient = {\r\n                x1:x1, y1:y1, r1:r1, x2:x2, y2:y2, r2:r2,\r\n                addColorStop: colorStop\r\n            };\r\n            out._radialGradientParsed = {\r\n                create: [x1, y1, r1, x2, y2, r2],\r\n                colorStop: colorStop\r\n            };\r\n        } else if (pt.fillLinearGradient) {\r\n            out.fillLinearGradient = pt.fillLinearGradient;\r\n        } else {\r\n            if (pt.fillPattern) {\r\n                out.canvasPattern = (pt.canvasPattern ? pt.canvasPattern : gmxAPIutils.getPatternIcon(item, pt, indexes));\r\n            }\r\n\r\n            if (type === 'iconPath') {\r\n                out.type = type;\r\n                out.iconPath = pt.iconPath;\r\n            }\r\n\r\n            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\r\n                type = 'polygon';\r\n            }\r\n            if (pt.iconSize) {\r\n                var iconSize = ('sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize);\r\n                out.sx = out.sy = iconSize;\r\n                // iconSize += pt.weight ? pt.weight : 0;\r\n                out.iconSize = iconSize;\r\n                if ('iconScale' in pt) {\r\n                    out.iconSize *= pt.iconScale;\r\n                }\r\n                out.maxSize = iconSize;\r\n            }\r\n            out.stroke = true;\r\n            if ('colorFunction' in pt || 'opacityFunction' in pt) {\r\n                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\r\n                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\r\n            }\r\n            out.strokeStyle = gmxAPIutils.dec2color(color, opacity);\r\n            out.lineWidth = 'weight' in pt ? pt.weight : 1;\r\n        }\r\n\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if ('iconAnchor' in pt) {\r\n            out.iconAnchor = pt.iconAnchor;\r\n        }\r\n        if ('iconCenter' in pt) {\r\n            out.iconCenter = pt.iconCenter;\r\n        }\r\n\r\n        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\r\n            out.type = type;\r\n            var fop = pt.fillOpacity,\r\n                fc = pt.fillColor,\r\n                fcDec = typeof (fc) === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\r\n\r\n            if ('fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, 1);\r\n            }\r\n            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\r\n                color = ('fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255);\r\n                opacity = ('fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1);\r\n                out.fillStyle = gmxAPIutils.dec2color(color, opacity);\r\n            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, fop);\r\n            }\r\n        }\r\n\r\n        if ('dashArray' in pt) { out.dashArray = pt.dashArray; }\r\n        if ('dashOffset' in pt) { out.dashOffset = pt.dashOffset; }\r\n\r\n        if (this.gmx.labelsLayer) {\r\n            arr = gmxAPIutils.styleKeys.label.client;\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                var it = arr[i];\r\n                if (it in pt) {\r\n                    if (it === 'labelField') {\r\n                        if (!indexes[pt[it]]) {\r\n                            continue;\r\n                        }\r\n                    } else if (it === 'labelTemplate') {\r\n                        var properties = gmxAPIutils.getPropertiesHash(prop, indexes);\r\n                        out.labelText = gmxAPIutils.parseTemplate(pt[it], properties);\r\n                    }\r\n                    out[it] = pt[it];\r\n                }\r\n            }\r\n            if ('labelAnchor' in pt) {\r\n                out.labelAnchor = pt.labelAnchor;\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n};\r\nStyleManager.MAX_STYLE_SIZE = 256;\r\n//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\r\nStyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8}};\r\nStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\r\nStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10];  // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\r\n\r\nStyleManager.parsePattern = function(pattern) {\r\n    var common = true,\r\n        parsers = L.gmx.Parsers;\r\n    if ('step' in pattern && typeof (pattern.step) === 'string') {\r\n        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\r\n        common = false;\r\n    }\r\n    if ('width' in pattern && typeof (pattern.width) === 'string') {\r\n        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\r\n        common = false;\r\n    }\r\n    if ('colors' in pattern) {\r\n        var arr = [];\r\n        for (var i = 0, len = pattern.colors.length; i < len; i++) {\r\n            var rt = pattern.colors[i];\r\n            if (typeof (rt) === 'string') {\r\n                arr.push(parsers.parseExpression(rt));\r\n                common = false;\r\n            } else {\r\n                arr.push(null);\r\n            }\r\n        }\r\n        pattern.patternColorsFunction = arr;\r\n    }\r\n    return common;\r\n};\r\n\r\nStyleManager.getStyleKeys = function(style) {\r\n    var out = {};\r\n    for (var key in gmxAPIutils.styleKeys) {\r\n        var keys = gmxAPIutils.styleKeys[key];\r\n        for (var i = 0, len = keys.client.length; i < len; i++) {\r\n            var key1 = keys.client[i];\r\n            if (key1 in style) {\r\n                if (style[key1] !== undefined) {\r\n                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\r\n                }\r\n                if (key1 === 'fillPattern') { delete out[key1].patternColorsFunction; }\r\n                else if (key1 === 'fillLinearGradient') { delete out[key1].addColorStopFunctions; }\r\n            }\r\n        }\r\n    }\r\n    if ('iconAnchor' in style) {\r\n        out.iconAnchor = style.iconAnchor;\r\n    }\r\n    if ('labelAnchor' in style) {\r\n        out.labelAnchor = style.labelAnchor;\r\n    }\r\n    return out;\r\n};\r\n\r\nStyleManager.checkDiff = function(st, st1) {\r\n    for (var key in st) {\r\n        if (st[key] !== st1[key]) {\r\n            return key;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nStyleManager.parseRadialGradient = function(rg) {\r\n    //\tx1,y1,r1 — координаты центра и радиус первой окружности;\r\n    //\tx2,y2,r2 — координаты центра и радиус второй окружности.\r\n    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\r\n    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\r\n    //\t\tcolor — код цвета или формула.\r\n    //\t\topacity — прозрачность\r\n    //\t\tcanvasStyleColor — результрующий цвет в формате canvas\r\n    var common = true,\r\n        parsers = L.gmx.Parsers,\r\n        i = 0,\r\n        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (!rg[it]) { rg[it] = 0; }\r\n        if (typeof (rg[it]) === 'string') {\r\n            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\r\n            common = false;\r\n        }\r\n    }\r\n\r\n    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\r\n    rg.addColorStopFunctions = [];\r\n    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\r\n        arr = rg.addColorStop[i];\r\n        var resFunc = [\r\n                (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n                (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n                (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n            ];\r\n        rg.addColorStopFunctions.push(resFunc);\r\n        if (resFunc[1] === null && resFunc[2] === null) {\r\n            arr[3] = gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\r\n        } else {\r\n            common = false;\r\n        }\r\n    }\r\n    if ('r2Function' in rg) { common = false; }\r\n    return common ? Math.max(rg.r1, rg.r2) : null;\r\n};\r\n\r\nStyleManager.parseLinearGradient = function(lg) {\r\n    var common = true;\r\n    //\tx1,y1 — координаты начальной точки\r\n    //\tx2,y2 — координаты конечной точки\r\n    //\taddColorStop - стоп цвета объекта градиента [[position, color]...]\r\n    //\t\tposition — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);\r\n    //\t\tcolor — код цвета или формула.\r\n    //\t\topacity — прозрачность\r\n    var i = 0,\r\n        parsers = L.gmx.Parsers,\r\n        arr = ['x1', 'y1', 'x2', 'y2'],\r\n        def = [0, 0, 0, 256],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (it in lg) {\r\n            if (typeof (lg[it]) === 'string') {\r\n                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\r\n                common = false;\r\n            }\r\n        } else {\r\n            lg[it] = def[i];\r\n        }\r\n    }\r\n\r\n    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\r\n    lg.addColorStopFunctions = [];\r\n    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\r\n        arr = lg.addColorStop[i];\r\n        lg.addColorStopFunctions.push([\r\n            (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n            (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n            (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n        ]);\r\n    }\r\n    return common;\r\n};\r\nexport {StyleManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/StyleManager.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n// Single tile on screen with vector data\r\nfunction ScreenVectorTile(layer, tilePoint, zoom) {\r\n    this.layer = layer;\r\n    this.tilePoint = tilePoint;\r\n    this.zoom = zoom;\r\n    this.gmx = layer._gmx;\r\n    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\r\n    var utils = gmxAPIutils;\r\n    this.worldWidthMerc = utils.worldWidthMerc;\r\n    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\r\n    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\r\n    this.tpx = 256 * gmxTilePoint.x;\r\n    this.tpy = 256 * (1 + gmxTilePoint.y);\r\n    this.gmxTilePoint = gmxTilePoint;\r\n\r\n    this.showRaster =\r\n        (zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx) ||\r\n        (zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx);\r\n    this.rasters = {}; //combined and processed canvases for each vector item in tile\r\n    this.rasterRequests = {};   // all cached raster requests\r\n    this.itemsView = [];   \t\t// items on screen tile + todo: without not visible\r\n    this._uniqueID = 0;         // draw attempt id\r\n    this.gmx.badTiles = this.gmx.badTiles || {};\r\n}\r\n\r\nScreenVectorTile.prototype = {\r\n\r\n    //return promise, which resolves with object {gtp, image}\r\n    _loadTileRecursive: function (gtp, urlFunction) {\r\n        var gmx = this.gmx,\r\n            _this = this,\r\n            requestPromise = null,\r\n            currentUrl,\r\n            def = new L.gmx.Deferred(function() {\r\n                if (requestPromise) {\r\n                    //don't store cancelled requests in request cache\r\n                    delete _this.rasterRequests[currentUrl];\r\n                    requestPromise.cancel();\r\n                }\r\n            });\r\n\r\n        var tryLoad = function(gtp, crossOrigin) {\r\n            var rUrl = urlFunction(gtp);\r\n\r\n            var tryHigherLevelTile = function() {\r\n                if (gtp.z > 1) {\r\n                    tryLoad({\r\n                        x: Math.floor(gtp.x / 2),\r\n                        y: Math.floor(gtp.y / 2),\r\n                        z: gtp.z - 1\r\n                    }, ''); // 'anonymous' 'use-credentials'\r\n                } else {\r\n                    def.reject();\r\n                }\r\n            };\r\n\r\n            if (gmx.badTiles[rUrl] || (gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z)) {\r\n                tryHigherLevelTile();\r\n                return;\r\n            }\r\n            var request = _this.rasterRequests[rUrl];\r\n            if (!request) {\r\n                if (gmx.rasterProcessingHook) {\r\n                    crossOrigin = 'anonymous';\r\n                }\r\n                request = L.gmx.imageLoader.push(rUrl, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    zoom: _this.zoom,\r\n                    cache: true,\r\n                    crossOrigin: crossOrigin || ''\r\n                });\r\n                _this.rasterRequests[rUrl] = request;\r\n            } else {\r\n                request.options.tileRastersId = _this._uniqueID;\r\n            }\r\n            currentUrl = rUrl;\r\n            requestPromise = request.def;\r\n\r\n            requestPromise.then(\r\n                function(imageObj) {\r\n                    def.resolve({gtp: gtp, image: imageObj});\r\n                },\r\n                function() {\r\n                    gmx.badTiles[rUrl] = true;\r\n                    tryHigherLevelTile();\r\n                }\r\n            );\r\n        };\r\n\r\n        tryLoad(gtp);\r\n        return def;\r\n    },\r\n\r\n    _rasterHook: function (attr) {\r\n        var source = attr.sourceTilePoint || attr.destinationTilePoint,\r\n            info = {\r\n                geoItem: attr.geoItem,\r\n                destination: {\r\n                    z: attr.destinationTilePoint.z,\r\n                    x: attr.destinationTilePoint.x,\r\n                    y: attr.destinationTilePoint.y\r\n                },\r\n                source: {\r\n                    z: source.z,\r\n                    x: source.x,\r\n                    y: source.y\r\n                }\r\n            };\r\n        if (attr.url) { info.quicklook = attr.url; }\r\n        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(\r\n            attr.res, attr.image,\r\n            attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256,\r\n            attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256,\r\n            info\r\n        );\r\n    },\r\n\r\n    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\r\n    _defaultRasterHook: function (res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n        var ptx = res.getContext('2d');\r\n        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    },\r\n\r\n    // get pixels parameters for shifted object\r\n    _getShiftPixels: function (it) {\r\n        var w = it.dx + (it.dx < 0 ? 256 : 0),\r\n            h = it.dy + (it.dy < 0 ? 256 : 0),\r\n            sx = 0, sw = 256 - w, dx = w, dw = sw;\r\n        if (it.tx > it.x) {\r\n            sx = sw; sw = w; dx = 0; dw = sw;\r\n        }\r\n        if (sx === 256 || sw < 1) { return null; }\r\n\r\n        var sy = h, sh = 256 - h, dy = 0, dh = sh;\r\n        if (it.ty > it.y) {\r\n            sy = 0; dy = sh; sh = h; dh = sh;\r\n        }\r\n        if (sy === 256 || sh < 1) { return null; }\r\n\r\n        return {\r\n            sx: sx, sy: sy, sw: sw, sh: sh,\r\n            dx: dx, dy: dy, dw: dw, dh: dh\r\n        };\r\n    },\r\n\r\n    // get tiles parameters for shifted object\r\n    _getShiftTilesArray: function (bounds, shiftX, shiftY) {\r\n        var mInPixel = this.gmx.mInPixel,\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            px = shiftX * mInPixel,\r\n            py = shiftY * mInPixel,\r\n            deltaX = Math.floor(0.5 + px % 256),            // shift on tile in pixel\r\n            deltaY = Math.floor(0.5 + py % 256),\r\n            tileSize = 256 / mInPixel,\r\n            tminX = gmxTilePoint.x - shiftX / tileSize,     // by screen tile\r\n            tminY = gmxTilePoint.y - shiftY / tileSize,\r\n            rminX = Math.floor(tminX),\r\n            rmaxX = rminX + (tminX === rminX ? 0 : 1),\r\n            rminY = Math.floor(tminY),\r\n            rmaxY = rminY + (tminY === rminY ? 0 : 1),\r\n            minX = Math.floor((bounds.min.x - shiftX) / tileSize),  // by geometry bounds\r\n            maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\r\n            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\r\n            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\r\n\r\n        if (rminX < minX) { rminX = minX; }\r\n        if (rmaxX > maxX) { rmaxX = maxX; }\r\n        if (rminY < minY) { rminY = minY; }\r\n        if (rmaxY > maxY) { rmaxY = maxY; }\r\n\r\n        var arr = [];\r\n        for (var j = rminY; j <= rmaxY; j++) {\r\n            for (var i = rminX; i <= rmaxX; i++) {\r\n                arr.push({\r\n                    z: gmxTilePoint.z,\r\n                    x: i,\r\n                    y: j,\r\n                    dx: deltaX,\r\n                    dy: deltaY,\r\n                    tx: tminX,\r\n                    ty: tminY\r\n                });\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    // Loads missing rasters for single item and combines them in canvas.\r\n    // Stores resulting canvas in this.rasters\r\n    _getItemRasters: function (geo) {\r\n        var properties = geo.properties,\r\n            idr = properties[0],\r\n            _this = this,\r\n            gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            rasters = this.rasters,\r\n            mainRasterLoader = null,\r\n            recursiveLoaders,\r\n            shiftX = Number(gmx.shiftXfield ? gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\r\n            shiftY = Number(gmx.shiftYfield ? gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\r\n            isShift = shiftX || shiftY,\r\n            urlBG = gmxAPIutils.getPropItem('urlBG', properties, indexes),\r\n            url = '',\r\n            itemImageProcessingHook = null,\r\n            isTiles = false,\r\n            item = gmx.dataManager.getItem(idr),\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            resCanvas = null,\r\n            imageItem = null;\r\n\r\n        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\r\n            isTiles = true;                     // Raster Layer\r\n        } else if (gmx.quicklookBGfunc) {\r\n            url = gmx.quicklookBGfunc(item);    // Quicklook\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        } else if (urlBG) {\r\n            url = urlBG;                        // Image urlBG from properties\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        }\r\n        if (isTiles) {\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                recursiveLoaders.forEach(function(it) {\r\n                    it.cancel();\r\n                });\r\n                recursiveLoaders = null;\r\n            });\r\n        } else {\r\n            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey;  //  for browser cache from another tabs\r\n            var request = this.rasterRequests[url];\r\n            if (!request) {\r\n                request = L.gmx.imageLoader.push(url, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    crossOrigin: gmx.crossOrigin || 'anonymous'\r\n                });\r\n                this.rasterRequests[url] = request;\r\n            } else {\r\n                request.options.tileRastersId = this._uniqueID;\r\n            }\r\n\r\n            // in fact, we want to return request.def, but need to do additional action during cancellation.\r\n            // so, we consctruct new promise and add pipe it with request.def\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                //don't cache cancelled requests\r\n                delete _this.rasterRequests[url];\r\n                request.def.cancel();\r\n            });\r\n            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\r\n        }\r\n        var itemRasterPromise = new L.gmx.Deferred(function() {\r\n            if (mainRasterLoader) {\r\n                mainRasterLoader.cancel();\r\n                mainRasterLoader = null;\r\n            }\r\n        });\r\n\r\n        if (isTiles) {\r\n            var dataOption = geo.dataOption || {},\r\n                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\r\n                cnt = tileToLoadPoints.length,\r\n                chkReadyRasters = function() {\r\n                    if (cnt < 1) { mainRasterLoader.resolve(); }\r\n                },\r\n                skipRasterFunc = function() {\r\n                    cnt--;\r\n                    chkReadyRasters();\r\n                },\r\n                urlFunction = function(gtp) {\r\n                    return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\r\n                },\r\n                onLoadFunction = function(gtp, p, img) {\r\n                    item.skipRasters = false;\r\n                    var isImage = true;\r\n\r\n                    if (itemImageProcessingHook) {\r\n                        img = itemImageProcessingHook(img, {\r\n                            gmx: gmx,\r\n                            geoItem: geo,\r\n                            item: item,\r\n                            gmxTilePoint: gtp\r\n                        });\r\n                        isImage = false;\r\n                    }\r\n\r\n                    var info = {\r\n                            geoItem: geo,\r\n                            image: img,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            sourceTilePoint: gtp,\r\n                            sx: 0, sy: 0, sw: 256, sh: 256,\r\n                            dx: 0, dy: 0, dw: 256, dh: 256\r\n                        };\r\n\r\n                    if (isShift) {\r\n                        var pos = _this._getShiftPixels(p);\r\n                        if (pos === null) {\r\n                            skipRasterFunc();\r\n                            return;\r\n                        }\r\n                        L.extend(info, pos);\r\n                        isImage = false;\r\n                    }\r\n\r\n                    if (gtp.z !== gmxTilePoint.z) {\r\n                        var posInfo = gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\r\n                        if (posInfo.size < 1 / 256) {// меньше 1px\r\n                            chkReadyRasters();\r\n                            return;\r\n                        }\r\n                        isImage = false;\r\n                        info.sx = Math.floor(posInfo.x);\r\n                        info.sy = Math.floor(posInfo.y);\r\n                        info.sw = info.sh = posInfo.size;\r\n                        if (isShift) {\r\n                            var sw = Math.floor(info.dw / posInfo.zDelta);\r\n                            info.sx = (info.dx === 0 ? info.sw : 256) - sw;\r\n                            info.sw = sw;\r\n\r\n                            var sh = Math.floor(info.dh / posInfo.zDelta);\r\n                            info.sy = (info.dy === 0 ? info.sh : 256) - sh;\r\n                            info.sh = sh;\r\n                        }\r\n                    }\r\n                    if (isImage && !gmx.rasterProcessingHook) {\r\n                        cnt--;\r\n                        resCanvas = img;\r\n                        chkReadyRasters();\r\n                    } else {\r\n                        if (!resCanvas) {\r\n                            resCanvas = document.createElement('canvas');\r\n                            resCanvas.width = resCanvas.height = 256;\r\n                        }\r\n                        info.res = resCanvas;\r\n                        var hookResult = _this._rasterHook(info),\r\n                            then = function() {\r\n                                cnt--;\r\n                                p.resImage = resCanvas;\r\n                                chkReadyRasters();\r\n                            };\r\n\r\n                        if (hookResult) {\r\n                            if (hookResult instanceof L.gmx.Deferred) {\r\n                                hookResult.then(then);\r\n                            }\r\n                        } else if (hookResult === null) {\r\n                            item.skipRasters = true;\r\n                            skipRasterFunc();\r\n                        } else {\r\n                            then();\r\n                        }\r\n                    }\r\n                };\r\n            recursiveLoaders = tileToLoadPoints.map(function(it) {\r\n                var loader = _this._loadTileRecursive(it, urlFunction);\r\n                loader.then(function(loadResult) {\r\n                    onLoadFunction(loadResult.gtp, it, loadResult.image);\r\n                }, skipRasterFunc);\r\n                return loader;\r\n            });\r\n\r\n            mainRasterLoader.then(function() {\r\n                rasters[idr] = resCanvas;\r\n                itemRasterPromise.resolve();\r\n            });\r\n        } else {\r\n            // for quicklook\r\n            item.skipRasters = false;\r\n            var imageLoaded = function(img) {\r\n                var imgAttr = {\r\n                    gmx: gmx,\r\n                    geoItem: geo,\r\n                    item: item,\r\n                    gmxTilePoint: gmxTilePoint\r\n                };\r\n                if (!resCanvas) {\r\n                    resCanvas = document.createElement('canvas');\r\n                    resCanvas.width = resCanvas.height = 256;\r\n                }\r\n                var prepareItem = function(imageElement) {\r\n                    var promise = _this._rasterHook({\r\n                            geoItem: geo,\r\n                            res: resCanvas,\r\n                            image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            url: url\r\n                        }),\r\n                        then = function() {\r\n                            rasters[idr] = resCanvas;\r\n                            itemRasterPromise.resolve();\r\n                        };\r\n                    if (promise) {\r\n                        if (promise instanceof L.gmx.Deferred) {\r\n                            promise.then(then);\r\n                        }\r\n                    } else if (promise === null) {\r\n                        item.skipRasters = true;\r\n                        itemRasterPromise.resolve();\r\n                    } else {\r\n                        then();\r\n                    }\r\n                };\r\n                prepareItem(img);\r\n                delete _this.rasterRequests[url];\r\n            };\r\n            if (imageItem) {\r\n                imageLoaded(imageItem);\r\n            } else {\r\n                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\r\n            }\r\n        }\r\n        itemRasterPromise.always(function() {\r\n            mainRasterLoader = null;\r\n            if (recursiveLoaders) {\r\n                recursiveLoaders = null;\r\n            }\r\n        });\r\n        return itemRasterPromise;\r\n    },\r\n\r\n    _getVisibleItems: function (geoItems) {\r\n        if (geoItems.length < 2) {\r\n\t\t\tthis.itemsView = geoItems;\r\n            return geoItems;\r\n        }\r\n        if (!gmxAPIutils._tileCanvas) {\r\n            gmxAPIutils._tileCanvas = document.createElement('canvas');\r\n            gmxAPIutils._tileCanvas.width = gmxAPIutils._tileCanvas.height = 256;\r\n        }\r\n        var i, len,\r\n            gmx = this.gmx,\r\n            dm = gmx.dataManager,\r\n            canvas = gmxAPIutils._tileCanvas,\r\n            ctx = canvas.getContext('2d'),\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        ctx.clearRect(0, 0, 256, 256);\r\n        ctx.imageSmoothingEnabled = false;\r\n        for (i = 0, len = geoItems.length; i < len; i++) {\r\n            ctx.fillStyle = gmxAPIutils.dec2rgba(i + 1, 1);\r\n            var geoItem = geoItems[i];\r\n            L.gmxUtil.drawGeoItem(\r\n                geoItem,\r\n                dm.getItem(geoItem.properties[0]),\r\n                dattr,\r\n                {fillStyle: ctx.fillStyle}\r\n            );\r\n        }\r\n        var items = {},\r\n            data = ctx.getImageData(0, 0, 256, 256).data;\r\n\r\n        for (i = 0, len = data.length; i < len; i += 4) {\r\n            if (data[i + 3] === 255) {\r\n                var color = data[i + 2];\r\n                if (data[i + 1]) { color += (data[i + 1] << 8); }\r\n                if (data[i]) { color += (data[i] << 16); }\r\n                if (color) { items[color] = true; }\r\n            }\r\n        }\r\n        var out = [];\r\n        for (var num in items) {\r\n            var it = geoItems[Number(num) - 1];\r\n            if (it) { out.push(it); }\r\n        }\r\n\t\tthis.itemsView = out;\r\n        return out;\r\n    },\r\n\r\n    _getNeedRasterItems: function (geoItems) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            tbounds = this.tbounds,\r\n            out = [];\r\n        for (var i = 0, len = geoItems.length; i < len; i++) {\r\n            var geo = geoItems[i],\r\n                properties = geo.properties,\r\n                idr = properties[0],\r\n                dataOption = geo.dataOption || {},\r\n                skipRasters = false;\r\n\r\n            if (gmx.quicklookBGfunc && !gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\r\n                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) { continue; }\r\n                var platform = gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\r\n                if ((!platform || platform === 'imageMercator') &&\r\n                    !gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)\r\n                ) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (gmx.styleHook) {\r\n                geo.styleExtend = gmx.styleHook(\r\n                    gmx.dataManager.getItem(idr),\r\n                    gmx.lastHover && idr === gmx.lastHover.id\r\n                );\r\n                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\r\n            }\r\n            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                out.push(geo);\r\n            }\r\n        }\r\n        return this._getVisibleItems(out);\r\n    },\r\n\r\n    _getTileRasters: function (geoItems) {   //load all missing rasters for items we are going to render\r\n        var itemPromises = [],\r\n            def = new L.gmx.Deferred(function() {\r\n                itemPromises.forEach(function(promise) {\r\n                    promise.cancel();\r\n                });\r\n                itemPromises = null;\r\n            }),\r\n            itemRasters = this._getNeedRasterItems(geoItems),\r\n            needLoadRasters = itemRasters.length;\r\n\r\n        if (needLoadRasters) {\r\n            var _this = this,\r\n                chkReadyRasters = function() {\r\n                    if (needLoadRasters < 1) {\r\n                        def.resolve();\r\n                    }\r\n                };\r\n            itemRasters.forEach(function (geo) {\r\n                var itemRasterPromise = _this._getItemRasters(geo);\r\n                itemRasterPromise.then(function() {\r\n                    needLoadRasters--;\r\n                    chkReadyRasters();\r\n                });\r\n                itemPromises.push(itemRasterPromise);\r\n            });\r\n        } else {\r\n            def.resolve();\r\n        }\r\n        return def;\r\n    },\r\n\r\n    _chkItems: function (data) {\r\n        var layer = this.layer;\r\n        if (!layer._map) {\r\n            return null;\r\n        }\r\n        var items = data && data.added && data.added.length ? data.added : null;\r\n\r\n        if (!items) {\r\n            var tLink = layer._tiles[this.zKey];\r\n            if (tLink && tLink.el) {\r\n                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\r\n            }\r\n            return null;\r\n        }\r\n        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\r\n    },\r\n\r\n    _cancelRastersPromise: function () {\r\n        if (this.rastersPromise) {\r\n            this.rastersPromise.cancel();\r\n            this.rastersPromise = null;\r\n        }\r\n    },\r\n\r\n    drawTile: function (data) {\r\n        var drawPromise = this.currentDrawPromise,\r\n            _this = this;\r\n\r\n        this._uniqueID++;       // count draw attempt\r\n\r\n        if (drawPromise) {\r\n            this._cancelRastersPromise();\r\n            if (this._preRenderPromise) {\r\n                this._preRenderPromise.cancel();        // cancel preRenderHooks chain if exists\r\n            }\r\n            if (this._renderPromise) {\r\n                this._renderPromise.cancel();           // cancel renderHooks chain if exists\r\n            }\r\n            drawPromise.reject();\r\n        }\r\n        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\r\n        drawPromise.always(function() {\r\n            _this._drawDone();\r\n            _this.currentDrawPromise = null;\r\n            _this.rastersPromise = null;\r\n            _this._preRenderPromise = null;\r\n            _this._renderPromise = null;\r\n        });\r\n\r\n        this.currentDrawPromise = drawPromise;\r\n\r\n        var geoItems = this._chkItems(data);\r\n        if (!geoItems) {\r\n            drawPromise.resolve();\r\n            return drawPromise;\r\n        }\r\n        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\r\n            tile = tileLink.el,\r\n            ctx = tile.getContext('2d'),\r\n            gmx = this.gmx,\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                rasters: this.rasters,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        tile.zKey = tileLink.el._zKey = this.zKey;\r\n\r\n        var doDraw = function() {\r\n            ctx.clearRect(0, 0, 256, 256);\r\n            var hookInfo = {\r\n                    tpx: _this.tpx,\r\n                    tpy: _this.tpy,\r\n                    x: _this.tilePoint.x,\r\n                    y: _this.tilePoint.y,\r\n                    z: _this.zoom\r\n                },\r\n                bgImage = null;\r\n\r\n            _this._preRenderPromise = new L.gmx.Deferred();\r\n            _this._preRenderPromise.resolve(bgImage);\r\n\r\n            gmx.preRenderHooks.forEach(function (f) {\r\n                _this._preRenderPromise = _this._preRenderPromise.then(function(hookBgImage) {\r\n\r\n                    //in-place modifications are possible\r\n                    bgImage = hookBgImage || bgImage;\r\n\r\n                    if (!bgImage) {\r\n                        bgImage = document.createElement('canvas');\r\n                        bgImage.width = bgImage.height = 256;\r\n                    }\r\n                    return f(bgImage, hookInfo);\r\n                });\r\n            });\r\n            _this._preRenderPromise.then(function(hookBgImage) {\r\n                bgImage = hookBgImage || bgImage;\r\n                if (bgImage) { dattr.bgImage = bgImage; }\r\n                //ctx.save();\r\n                for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                    var geoItem = geoItems[i],\r\n                        id = geoItem.id,\r\n                        item = gmx.dataManager.getItem(id);\r\n                    if (item) {     // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\r\n                        var style = gmx.styleManager.getObjStyle(item),\r\n                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\r\n\r\n                        if (gmx.multiFilters) {\r\n                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                                var it = item.multiFilters[j];\r\n                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\r\n                            }\r\n                        } else {\r\n                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\r\n                        }\r\n                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\r\n                            gmx._needPopups[id] = true;\r\n                        }\r\n                    }\r\n                }\r\n                //ctx.restore();\r\n                _this.rasters = {}; // clear rasters\r\n                if (_this.layer._map && !tile.parentNode) {\r\n                    _this.layer.appendTileToContainer(tile);\r\n                }\r\n                //async chain\r\n                _this._renderPromise = new L.gmx.Deferred();\r\n                _this._renderPromise.resolve(tile);\r\n                gmx.renderHooks.forEach(function (f) {\r\n                    _this._renderPromise = _this._renderPromise.then(function(hookTile) {\r\n                        tile = hookTile || tile;\r\n                        return f(tile, hookInfo);\r\n                    });\r\n                });\r\n                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\r\n            }, drawPromise.reject);\r\n        };\r\n\r\n        if (this.showRaster) {\r\n            this.rastersPromise = this._getTileRasters(geoItems);\r\n            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\r\n        } else {\r\n            doDraw();\r\n        }\r\n\r\n        return drawPromise;\r\n    },\r\n\r\n    destructor: function () {\r\n        this._cancelRastersPromise();\r\n        this._clearCache();\r\n\r\n        this.currentDrawPromise && this.currentDrawPromise.reject();\r\n    },\r\n\r\n    _drawDone: function () {\r\n        for (var url in this.rasterRequests) {\r\n            var req = this.rasterRequests[url];\r\n            if (this._uniqueID !== req.options.tileRastersId) {\r\n                req.remove();\r\n                delete this.rasterRequests[url];\r\n            }\r\n        }\r\n        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\r\n    },\r\n\r\n    _clearCache: function () {\r\n        for (var url in this.rasterRequests) {\r\n            this.rasterRequests[url].remove();\r\n        }\r\n        this.rasterRequests = {};\r\n    }\r\n};\r\nexport {ScreenVectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ScreenVectorTile.js","/*\r\n * ObjectsReorder  - Reorder objects in Gemixer layer\r\n */\r\n(function() {\r\n\r\nvar MAX = 1000000,\r\n    ObjectsReorder = function (layer) {\r\n        this.all = {};\r\n        this.userSetSortFunc = false;     // user sort func flag\r\n        this.sortFunc = null;\r\n        this.count = 0;\r\n        this.disabled = false;\r\n        this.layer = layer;\r\n        layer.on('add', this.onAdd, this);\r\n        layer.on('remove', this.onRemove, this);\r\n    };\r\n    ObjectsReorder.prototype = {\r\n        addToReorder: function (id, bottomFlag) {\r\n            ++this.count;\r\n            this.all[id] = bottomFlag ? -this.count : this.count;\r\n        },\r\n        clickFunc: function (ev) {\r\n            if (!this.disabled) {\r\n                var id = ev.gmx.id;\r\n                this.addToReorder(id, ev.originalEvent.ctrlKey);\r\n                this.layer.redrawItem(id);\r\n            }\r\n        },\r\n        sortItems: function(a, b) {     // layer context\r\n            var reorder = this._objectsReorder;\r\n            if (reorder.count > 0) {\r\n                var ap = reorder.all[a.id],\r\n                    bp = reorder.all[b.id];\r\n\r\n                if (ap || bp) {\r\n                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\r\n                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\r\n                    return ap - bp;\r\n                }\r\n            }\r\n            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\r\n        },\r\n        resetSortFunc: function () {\r\n            var layer = this.layer,\r\n                gmx = layer._gmx,\r\n                zIndexField = gmx.zIndexField;\r\n            gmx.sortItems = this.sortItems;\r\n            this.sortFunc = (zIndexField && !this.userSetSortFunc ?\r\n                function(a, b) {    // layer context\r\n                    var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\r\n                    return res ? res : a.id - b.id;\r\n                }\r\n                :\r\n                function(a, b) {\r\n                    return a.id - b.id;\r\n                }\r\n            );\r\n        },\r\n        initialize: function () {\r\n            var gmx = this.layer._gmx;\r\n            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\r\n                this.resetSortFunc();\r\n            }\r\n        },\r\n        onAdd: function () {\r\n            this.initialize();\r\n            this.layer.on('click', this.clickFunc, this);\r\n        },\r\n        onRemove: function () {\r\n            this.layer.off('click', this.clickFunc, this);\r\n        }\r\n    };\r\n\r\nL.gmx.VectorLayer.include({\r\n    _objectsReorder: null,\r\n\r\n    _objectsReorderInit: function () {\r\n        if (!this._objectsReorder) {\r\n            this._objectsReorder = new ObjectsReorder(this);\r\n        }\r\n    },\r\n\r\n    getReorderArrays: function () {\r\n        var out = {top: [], bottom: []};\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder,\r\n                arr = Object.keys(reorder.all).sort(function(a, b) {\r\n                    return reorder.all[a] - reorder.all[b];\r\n                });\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                if (reorder.all[id] > 0) {\r\n                    out.top.push(id);\r\n                } else {\r\n                    out.bottom.push(id);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    bringToTopItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    bringToBottomItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id, true);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    clearReorderArrays: function () {\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder;\r\n            reorder.all = {};\r\n            reorder.count = 0;\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    setReorderArrays: function (top, bottom) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.all = {};\r\n        reorder.count = 0;\r\n        bottom.forEach(function (id) { reorder.addToReorder(id, true); });\r\n        top.forEach(function (id) { reorder.addToReorder(id); });\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    getSortedItems: function (arr) {\r\n        this._objectsReorderInit();\r\n        return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\r\n    },\r\n\r\n    setSortFunc: function (func) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.sortFunc = func;\r\n        reorder.userSetSortFunc = func ? true : false;\r\n        this._gmx.sortItems = reorder.sortItems;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n    disableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = true;\r\n        return this;\r\n    },\r\n    enableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = false;\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ObjectsReorder.js","L.gmx.VectorLayer.include({\r\n    bindPopup: function (content, options) {\r\n        var popupOptions = L.extend({maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID}, options);\r\n\r\n        if (this._popup) { this.unbindPopup(); }\r\n        if (content instanceof L.Popup) {\r\n            this._popup = content;\r\n        } else {\r\n            if (!this._popup || options) {\r\n                this._popup = new L.Popup(popupOptions);\r\n            }\r\n            this._popup.setContent(content);\r\n        }\r\n        this._popup._initContent = content;\r\n        this._popup._state = '';\r\n\r\n        if (!this._popupHandlersAdded) {\r\n            this\r\n                .on('click', this._openClickPopup, this)\r\n                .on('mousemove', this._movePopup, this)\r\n                .on('mouseover', this._overPopup, this)\r\n                .on('mouseout', this._outPopup, this)\r\n                .on('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupHandlersAdded = true;\r\n        }\r\n        if (popupOptions && popupOptions.popupopen) {\r\n            this._popupopen = popupOptions.popupopen;\r\n        }\r\n\r\n        this._popup.updateLayout = this._popup._updateLayout;\r\n\r\n        return this;\r\n    },\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openClickPopup, this)\r\n                .off('mousemove', this._movePopup, this)\r\n\t\t\t    .off('mouseover', this._overPopup, this)\r\n                .off('mouseout', this._outPopup, this)\r\n                .off('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupopen = null;\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n        this._gmx.balloonEnable = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n    _chkNeedOpenPopup: function () {\r\n        for (var id in this._gmx._needPopups) {\r\n            if (this._gmx._needPopups[id]) {\r\n                this.addPopup(id);\r\n                delete this._gmx._needPopups[id];\r\n            }\r\n        }\r\n    },\r\n\r\n    disablePopup: function () {\r\n        this._popupDisabled = true;\r\n\t\treturn this;\r\n    },\r\n\r\n    enablePopup: function () {\r\n        this._popupDisabled = false;\r\n\t\treturn this;\r\n    },\r\n\r\n\topenPopup: function (latlng, options) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\toptions = options || {};\r\n            options.latlng = latlng;\r\n            this._openPopup(options);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n            this.fire('popupclose', {popup: this._popup});\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n    _movePopup: function (options) {\r\n        if (this._popup._state === 'mouseover') {\r\n            var id = this._popup.options._gmxID || -1;\r\n            if (id !== options.gmx.id) {\r\n                this._setPopupContent(options);\r\n            }\r\n            this._popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _overPopup: function (options) {\r\n        var _popup = this._popup;\r\n        if (!_popup._map) {\r\n            this._openPopup(options);\r\n        } else {\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: this._setPopupContent(options, _popup)\r\n            });\r\n        }\r\n        if (_popup._state === 'mouseover') {\r\n            _popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _outPopup: function (ev) {\r\n        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\r\n            this.closePopup();\r\n        }\r\n    },\r\n\r\n    _callBalloonHook: function (props, div) {\r\n\r\n        var spans = div.getElementsByTagName('span'),\r\n            hooksCount = {},\r\n            key, i, len;\r\n        for (key in this._balloonHook) {    // collect hook counts\r\n            var hookID = this._balloonHook[key].hookID;\r\n            hooksCount[key] = 0;\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                if (spans[i].id === hookID) {\r\n                    hooksCount[key]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (key in this._balloonHook) {\r\n            var hook = this._balloonHook[key],\r\n                fid = hook.hookID,\r\n                notFound = true;\r\n\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                var node = spans[i];\r\n                if (node.id === fid) {\r\n                    notFound = false;\r\n                    node.id += '_' + i;\r\n                    hook.callback(props, div, node, hooksCount);\r\n                }\r\n            }\r\n            if (notFound) {\r\n                hook.callback(props, div, null, hooksCount);\r\n            }\r\n        }\r\n    },\r\n\r\n    _setPopupContent: function (options, _popup) {\r\n        if (!_popup) { _popup = this._popup; }\r\n        var gmx = options.gmx || {},\r\n            balloonData = gmx.balloonData || {},\r\n            properties = L.extend({}, gmx.properties),\r\n            target = gmx.target || {},\r\n            geometry = target.geometry || {},\r\n            offset = target.offset,\r\n            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\r\n            type = options.type,\r\n            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\r\n            outItem = {\r\n                id: gmx.id,\r\n                type: type,\r\n                nodePoint: gmx.nodePoint,\r\n                latlng: options.latlng,\r\n                properties: properties,\r\n                templateBalloon: templateBalloon\r\n            };\r\n\r\n        if (geometry.type === 'POINT') {\r\n            var coord = geometry.coordinates;\r\n            outItem.latlng = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n        }\r\n        if (offset) {\r\n            var protoOffset = L.Popup.prototype.options.offset;\r\n            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\r\n        }\r\n\r\n        if (this._popupopen) {\r\n            this._popupopen({\r\n                popup: _popup,\r\n                latlng: outItem.latlng,\r\n                layerPoint: options.layerPoint,\r\n                contentNode: _popup._contentNode,\r\n                containerPoint: options.containerPoint,\r\n                originalEvent: options.originalEvent,\r\n                gmx: outItem\r\n            });\r\n        } else if (!(templateBalloon instanceof L.Popup)) {\r\n            if (!(templateBalloon instanceof HTMLElement)) {\r\n                var geometries,\r\n                    summary = '',\r\n                    unitOptions = this._map ? this._map.options : {};\r\n\r\n                if (!skipSummary) {\r\n                    geometries = target.geometry ? [target.geometry] : (gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || []);\r\n                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                if (this._balloonHook) {\r\n                    if (!templateBalloon) {\r\n                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\r\n                    }\r\n                    for (var key in this._balloonHook) {\r\n                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\r\n                    }\r\n                }\r\n                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\r\n                    properties: properties,\r\n                    tileAttributeTypes: this._gmx.tileAttributeTypes,\r\n                    unitOptions: unitOptions,\r\n                    summary: summary,\r\n                    geometries: geometries\r\n                });\r\n            }\r\n\r\n            var contentDiv = L.DomUtil.create('div', '');\r\n            contentDiv.innerHTML = templateBalloon;\r\n            _popup.setContent(contentDiv);\r\n            if (this._balloonHook) {\r\n                this._callBalloonHook(gmx.properties, _popup.getContent());\r\n            }\r\n            //outItem.templateBalloon = templateBalloon;\r\n        }\r\n        _popup.options._gmxID = gmx.id;\r\n        return outItem;\r\n    },\r\n\r\n    _openClickPopup: function (options) {\r\n        var originalEvent = options.originalEvent || {},\r\n            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                gmx = options.gmx,\r\n                balloonData = gmx.balloonData,\r\n                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\r\n                item = gmx.target;\r\n\r\n            if (flag && item.options.isGeneralized && !item.geometry) {\r\n                var layerProp = gmx.layer.getGmxProperties();\r\n                gmxAPIutils.getLayerItemFromServer({\r\n                    options: options,\r\n                    layerID: layerProp.name,\r\n                    value: item.id,\r\n                    field: layerProp.identityField\r\n                }).then(function(json, params) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        var pArr = json.Result.values[0];\r\n                        params.options.gmx.target.fromServerProps = pArr;\r\n                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\r\n                        this._openPopup(params.options);\r\n                    }\r\n                }.bind(this));\r\n            } else {\r\n                this._openPopup(options);\r\n            }\r\n        }\r\n    },\r\n\r\n    _openPopup: function (options, notSkip) {\r\n        var map = this._map,\r\n            originalEvent = options.originalEvent || {},\r\n            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                _popup = this._popup,\r\n                gmx = options.gmx || {},\r\n                balloonData = gmx.balloonData || {};\r\n\r\n            if (type === 'click') {\r\n                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) { return; }\r\n\r\n                if (!('_gmxPopups' in map)) {\r\n                    map._gmxPopups = [];\r\n                }\r\n                if (!('maxPopupCount' in map.options)) { map.options.maxPopupCount = 1; }\r\n                if (!this._gmx._gmxPopupsInit) {\r\n                    this._gmx._gmxPopupsInit = true;\r\n                    map.on({\r\n                        layerremove: function (ev) {\r\n                            if (ev.layer instanceof L.Popup) {\r\n                                this._clearPopup(ev.layer);\r\n                            } else if (ev.layer === this) {\r\n                                if (map._gmxPopups) {\r\n                                    var layerId = this._gmx.layerID;\r\n                                    map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                                        if (c._map) {\r\n                                            if (c.options.layerId === layerId) { c._map.removeLayer(c); }\r\n                                            else { p.push(c); }\r\n                                        }\r\n                                        return p;\r\n                                    }, []);\r\n                                }\r\n                                this.closePopup();\r\n                            }\r\n                        }\r\n                    }, this);\r\n                }\r\n\r\n                this._clearPopup(gmx.id);\r\n                var opt = this._popup ? this._popup.options : {maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID};\r\n                _popup = new L.Popup(L.extend({}, opt, {closeOnClick: map.options.maxPopupCount === 1, autoPan: true}));\r\n            } else if (type === 'mouseover') {\r\n                if (balloonData.DisableBalloonOnMouseMove) {\r\n                    _popup._state = '';\r\n                    return;\r\n                }\r\n                _popup.options.autoPan = false;\r\n            } else {\r\n                return;\r\n            }\r\n            _popup.options.objectId = gmx.id;\r\n            _popup._state = type;\r\n            var outItem = this._setPopupContent(options, _popup);\r\n            _popup.setLatLng(outItem.latlng);\r\n\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: outItem\r\n            });\r\n            if (type === 'click') {\r\n                if (map._gmxPopups.length >= map.options.maxPopupCount) {\r\n                    map.removeLayer(map._gmxPopups.shift());\r\n                }\r\n                map._gmxPopups.push(_popup);\r\n            }\r\n            _popup.addTo(map);    // this._map.openPopup(_popup);\r\n\r\n            if (_popup._closeButton) {\r\n                var closeStyle = _popup._closeButton.style;\r\n                if (type === 'mouseover' && closeStyle !== 'hidden') {\r\n                    closeStyle.visibility = 'hidden';\r\n                    _popup._container.style.marginBottom = '7px';\r\n                    _popup._container.style.pointerEvents = 'none';\r\n                } else if (type === 'click' && closeStyle !== 'inherit') {\r\n                    closeStyle.visibility = 'inherit';\r\n                    _popup._container.style.marginBottom = '';\r\n                    _popup._container.style.pointerEvents = '';\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\t_clearPopup: function (item /* <L.Popup> or objectId */) {\r\n        var map = this._map;\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID,\r\n                flagPopup = item instanceof L.Popup;\r\n            map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                if (c._map) {\r\n                    if (flagPopup && c === item) { c._map.removeLayer(c); }\r\n                    else if (c.options.layerId === layerId && c.options.objectId === item) { c._map.removeLayer(c); }\r\n                    else { p.push(c); }\r\n                }\r\n                return p;\r\n            }, []);\r\n        }\r\n    },\r\n\r\n    getPopups: function (flag) {\r\n        var map = this._map,\r\n            out = [];\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID;\r\n            map._gmxPopups.reduce(function(p, c) {\r\n                if (c.options.layerId === layerId) { p.push(flag ? c : c.options.objectId); }\r\n                return p;\r\n            }, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    addPopup: function (id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        if (!item || !this._map) {\r\n            gmx._needPopups[id] = false;\r\n        } else {\r\n            var center = item.bounds.getCenter(),\r\n                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\r\n            this._openPopup({\r\n                type: 'click',\r\n                latlng: latlng,\r\n                gmx: this.getHoverOption(item)\r\n            }, true);\r\n            delete gmx._needPopups[id];\r\n        }\r\n        return this;\r\n    },\r\n\r\n    addPopupHook: function (key, callback) {\r\n        if (!this._balloonHook) { this._balloonHook = {}; }\r\n        if (!this._balloonHook[key]) {\r\n            var hookID = '_' + L.stamp({});\r\n            this._balloonHook[key] = {\r\n                key: key,\r\n                hookID: hookID,\r\n                resStr: '<span id=\"' + hookID + '\"></span>',\r\n                callback: callback\r\n            };\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removePopupHook: function(key) {\r\n        if (this._balloonHook) { delete this._balloonHook[key]; }\r\n        return this;\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Popup.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nL.gmx.VectorLayer.include({\r\n    _gmxFirstObjectsByPoint: function (geoItems, mercPoint, bounds) {    // Получить верхний объект по координатам mouseClick\r\n        var gmx = this._gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            j,\r\n            len;\r\n\r\n        for (var i = geoItems.length - 1; i >= 0; i--) {\r\n            var geoItem = geoItems[i].properties,\r\n                idr = geoItem[0],\r\n                dataOption = geoItems[i].dataOption || {},\r\n                item = gmx.dataManager.getItem(idr),\r\n                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n                iconScale = currentStyle.iconScale || 1,\r\n                iconCenter = currentStyle.iconCenter,\r\n                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\r\n                parsedStyle = gmx.styleManager.getObjStyle(item),\r\n                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\r\n                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\r\n                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\r\n                offset = [\r\n                    iconScale * sx / 2,\r\n                    iconScale * sy / 2\r\n                ],\r\n                point = mercPoint,\r\n                geom = geoItem[geoItem.length - 1],\r\n                type = geom.type;\r\n\r\n            if (type === 'POINT' && parsedStyle.type === 'circle') {\r\n                offset[0] *= 2;\r\n                offset[1] *= 2;\r\n            }\r\n            var radius = offset[0],\r\n                objBounds = gmxAPIutils.bounds()\r\n                    .extendBounds(dataOption.bounds)\r\n                    .addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n            if (iconAnchor) {\r\n                offset = [\r\n                    iconAnchor[0] - offset[0],\r\n                    iconAnchor[1] - offset[1]\r\n                ];\r\n                point = [\r\n                    mercPoint[0] + offset[0] / mInPixel,\r\n                    mercPoint[1] - offset[1] / mInPixel\r\n                ];\r\n            }\r\n            if (!objBounds.contains(point)) { continue; }\r\n\r\n            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\r\n                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\r\n                chktype = type,\r\n                hiddenLines = dataOption.hiddenLines || [],\r\n                boundsArr = dataOption.boundsArr,\r\n                coords = geom.coordinates,\r\n                nodePoint = null,\r\n                ph = {\r\n                    point: mercPoint,\r\n                    bounds: bounds,\r\n                    coords: coords,\r\n                    boundsArr: boundsArr\r\n                };\r\n\r\n            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\r\n                if (marker) {\r\n                    chktype = 'POINT';\r\n                } else if (!fill) {\r\n                    if (type === 'POLYGON') {\r\n                        chktype = 'MULTILINESTRING';\r\n                        hiddenLines = hiddenLines[0];\r\n                    } else {\r\n                        chktype = 'LIKEMULTILINESTRING';\r\n                    }\r\n                    ph.hidden = hiddenLines;\r\n                }\r\n            }\r\n\r\n            if (chktype === 'LINESTRING') {\r\n                if (!gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\r\n                    nodePoint = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'LIKEMULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                var flag = false;\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    ph.coords = coords[j];\r\n                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\r\n                    ph.boundsArr = boundsArr[j];\r\n                    if (gmxAPIutils.isPointInLines(ph)) {\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'MULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                ph.hidden = hiddenLines;\r\n                if (!gmxAPIutils.isPointInLines(ph)) {\r\n                    var pBounds = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n                    for (j = 0, len = coords.length; j < len; j++) {\r\n                        nodePoint = pBounds.isNodeIntersect(coords[j]);\r\n                        if (nodePoint !== null) {\r\n                            nodePoint.ring = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\r\n                var chkPoint = mercPoint;\r\n                flag = false;\r\n                if (chktype === 'POLYGON') {\r\n                    coords = [geom.coordinates];\r\n                    boundsArr = [dataOption.boundsArr];\r\n                }\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    var arr = coords[j],\r\n                        bbox = boundsArr[j];\r\n                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\r\n                        var b = bbox[j1];\r\n                        if (b.intersects(bounds)) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\r\n                                flag = j1 === 0 ? true : false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'POINT') {\r\n                if (parsedStyle.type === 'circle') {\r\n                    var x = (coords[0] - point[0]) * mInPixel,\r\n                        y = (coords[1] - point[1]) * mInPixel;\r\n                    if (x * x + y * y > radius * radius) { continue; }\r\n                }\r\n            }\r\n            if (!this.isPointInClipPolygons(mercPoint)) {\r\n                continue;\r\n            }\r\n\r\n            return {\r\n                id: idr,\r\n                properties: item.properties,\r\n                geometry: geom,\r\n                bounds: item.bounds,\r\n                nodePoint: nodePoint,\r\n                offset: iconAnchor ? offset : null,\r\n                parsedStyle: parsedStyle\r\n            };\r\n        }\r\n        return null;\r\n    },\r\n\r\n    gmxEventCheck: function (ev, skipOver) {\r\n        if (!this._map) {\r\n            return 0;\r\n        }\r\n        var layer = this,\r\n            gmx = layer._gmx,\r\n            type = ev.type,\r\n            lastHover = gmx.lastHover,\r\n            chkHover = function (evType) {\r\n                if (lastHover && type === 'mousemove') {\r\n                    if (evType && layer.hasEventListeners(evType)) {\r\n                        ev.gmx = lastHover;\r\n                        layer.fire(evType, ev);\r\n                    }\r\n                    if (lastHover.hoverDiff) { layer.redrawItem(lastHover.id); }\r\n                }\r\n            };\r\n\r\n        var zoom = this._map.getZoom();\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            skipOver = true;\r\n        }\r\n        if (skipOver) {\r\n            if (lastHover) { lastHover.prevId = null; }\r\n            chkHover('mouseout');\r\n            gmx.lastHover = null;\r\n        } else if (\r\n            this.hasEventListeners('mouseover') ||\r\n            this.hasEventListeners('mouseout') ||\r\n            this.hasEventListeners(type) ||\r\n            (type === 'mousemove' && gmx.properties.fromType !== 'Raster')\r\n            ) {\r\n\r\n            var lng = ev.latlng.lng % 360,\r\n                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : (lng > 180 ? -360 : 0))),\r\n                point = L.Projection.Mercator.project(latlng)._subtract(\r\n                    {x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0}\r\n                ),\r\n                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\r\n                mercatorPoint = [point.x, point.y];\r\n\r\n            //создаём observer только для того, чтобы сделать выборку данных вокруг курсора\r\n            var observerOptions = {\r\n                type: 'resend',\r\n                bbox: gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\r\n                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\r\n                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                active: false //делаем его неактивным, так как потом будем явно выбирать данные\r\n            };\r\n            if (this.options.isGeneralized) {\r\n                observerOptions.targetZoom = zoom;\r\n            }\r\n\r\n            gmx.dataManager.addObserver(observerOptions, 'hover');\r\n\r\n            var geoItems = gmx.dataManager.getItems('hover');\r\n\r\n            gmx.dataManager.removeObserver('hover');\r\n\r\n            if (geoItems && geoItems.length) {\r\n                if (geoItems.length > 1 && gmx.sortItems) { geoItems = this.getSortedItems(geoItems); }\r\n\r\n                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\r\n                if (target) {\r\n                    var idr = target.id,\r\n                        item = gmx.dataManager.getItem(idr),\r\n                        prevId = lastHover ? lastHover.id : null,\r\n                        changed = !lastHover || lastHover.id !== idr;\r\n                    if (type === 'mousemove' && lastHover) {\r\n                        if (!changed) {\r\n                            ev.gmx = lastHover;\r\n                            this.fire(type, ev);\r\n                            return idr;\r\n                        }\r\n                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\r\n                        gmx.lastHover = null;\r\n                    }\r\n\r\n                    ev.gmx = L.extend(this.getHoverOption(item), {\r\n                        targets: geoItems,\r\n                        nodePoint: target.nodePoint,\r\n                        prevId: prevId,\r\n                        hoverDiff: item.hoverDiff\r\n                    });\r\n                    if (this.hasEventListeners(type)) { this.fire(type, ev); }\r\n                    if (type === 'mousemove' && changed) {\r\n                        lastHover = gmx.lastHover = ev.gmx;\r\n                        chkHover('mouseover');\r\n                        gmx.lastMouseover = gmx.lastHover;\r\n                    }\r\n                    this._map.doubleClickZoom.disable();\r\n                    return idr;\r\n                }\r\n            }\r\n        }\r\n        if (this._map) {\r\n            this._map.doubleClickZoom.enable();\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    getHoverOption: function (item) {\r\n        return {\r\n            layer: this,\r\n            target: item,\r\n            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\r\n            properties: this.getItemProperties(item.properties),\r\n            currentFilter: item.currentFilter || 0,\r\n            id: item.id\r\n        };\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Hover.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n(function() {\r\nvar delay = 20000,\r\n    layers = {},\r\n    dataManagersLinks = {},\r\n    script = '/Layer/CheckVersion.ashx',\r\n    intervalID = null,\r\n    timeoutID = null,\r\n    lastLayersStr = '';\r\n\r\nvar isExistsTiles = function(prop) {\r\n    var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\r\n    return tilesKey in prop;\r\n};\r\nvar getParams = function(prop, dm, layerDateInterval) {\r\n    var pt = {\r\n        Name: prop.name,\r\n        Version: isExistsTiles(prop) ? prop.LayerVersion : -1\r\n    };\r\n\tif (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\r\n\t\tvar maxDateInterval = dm.getMaxDateInterval(),\r\n\t\t\tbeginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\r\n\t\t\tendDate = maxDateInterval.endDate || layerDateInterval.endDate;\r\n        if (beginDate) { pt.dateBegin = Math.floor(beginDate.getTime() / 1000); }\r\n        if (endDate) { pt.dateEnd = Math.floor(endDate.getTime() / 1000); }\r\n    }\r\n    return pt;\r\n};\r\nvar getRequestParams = function(layer) {\r\n    var hosts = {},\r\n        prop, hostName, dm, layerDateInterval;\r\n    if (layer) {\r\n        if (layer instanceof L.gmx.DataManager) {\r\n\t\t\tdm = layer;\r\n\t\t\tprop = dm.options;\r\n\t\t} else {\r\n\t\t\tprop = layer._gmx.properties;\r\n\t\t\tdm = layer._gmx.dataManager;\r\n\t\t\tlayerDateInterval = layer._gmx;\r\n\t\t}\r\n        hostName = prop.hostName || layer._gmx.hostName;\r\n\t\thosts[hostName] = [getParams(prop, dm, layerDateInterval)];\r\n    } else {\r\n        var skipItems = {};\r\n        for (var id in layers) {\r\n            var obj = layers[id],\r\n\t\t\t\tisDataManager = obj instanceof L.gmx.DataManager;\r\n            if (obj.options.chkUpdate || isDataManager) {\r\n\t\t\t\tdm = isDataManager ? obj : obj._gmx.dataManager;\r\n                prop = isDataManager ? obj.options : obj._gmx.properties;\r\n\t\t\t\tlayerDateInterval = isDataManager ? obj : obj._gmx;\r\n                hostName = prop.hostName || obj._gmx.hostName;\r\n                var pt = getParams(prop, dm, layerDateInterval),\r\n                    key = pt.Name + pt.Version;\r\n                if (!skipItems[key]) {\r\n                    if (hosts[hostName]) { hosts[hostName].push(pt); }\r\n                    else { hosts[hostName] = [pt]; }\r\n                }\r\n                skipItems[key] = true;\r\n            }\r\n        }\r\n    }\r\n    return hosts;\r\n};\r\n\r\nvar chkVersion = function (layer, callback) {\r\n    var processResponse = function(res) {\r\n        if (res && res.Status === 'ok' && res.Result) {\r\n            for (var i = 0, len = res.Result.length; i < len; i++) {\r\n                var item = res.Result[i],\r\n                    id = item.properties.name;\r\n\r\n\t\t\t\tif (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) { layer.updateVersion(item); }\r\n                for (var key in layers) {\r\n                    var curLayer = layers[key];\r\n\t\t\t\t\tif (layer && layer === curLayer) { continue; }\r\n                    if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\t// слои\r\n\t\t\t\t\t\tcurLayer.updateVersion(item);\r\n\t\t\t\t\t} else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\t// источники данных\r\n\t\t\t\t\t\tcurLayer.updateVersion(item.properties);\r\n\t\t\t\t\t}\r\n                }\r\n            }\r\n        }\r\n        lastLayersStr = '';\r\n        if (callback) { callback(res); }\r\n    };\r\n\r\n    if (document.body && !gmxAPIutils.isPageHidden()) {\r\n        var hosts = getRequestParams(layer),\r\n            chkHost = function(hostName) {\r\n                var url = 'http://' + hostName + script,\r\n                    layersStr = JSON.stringify(hosts[hostName]);\r\n\r\n                if (lastLayersStr !== layersStr) {\r\n                    lastLayersStr = layersStr;\r\n                    if ('FormData' in window) {\r\n                        gmxAPIutils.request({\r\n                            url: url,\r\n                            async: true,\r\n                            headers: {\r\n                                'Content-type': 'application/x-www-form-urlencoded'\r\n                            },\r\n                            type: 'POST',\r\n                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\r\n                            withCredentials: true,\r\n                            callback: function(response) {\r\n                                processResponse(JSON.parse(response));\r\n                            },\r\n                            onError: function(response) {\r\n                                console.log('Error: LayerVersion ', response);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        gmxAPIutils.sendCrossDomainPostRequest(url, {\r\n                            WrapStyle: 'message',\r\n                            layers: layersStr\r\n                        }, processResponse);\r\n                    }\r\n                    var timeStamp = Date.now();\r\n                    for (var key in layers) {\r\n                        var it = layers[key];\r\n                        var options = it._gmx || it.options;\r\n                        if (options.hostName === hostName) { options._stampVersionRequest = timeStamp; }\r\n                    }\r\n                }\r\n            };\r\n        for (var hostName in hosts) {\r\n            chkHost(hostName);\r\n        }\r\n    }\r\n};\r\n\r\nvar layersVersion = {\r\n\r\n    addDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\t\tdataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\tlayers[id] = dataManager;\r\n    },\r\n\r\n    removeDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n\t\t\tdataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\t\tdelete layers[id];\r\n\t\t}\r\n    },\r\n\r\n    remove: function(layer) {\r\n        delete layers[layer._leaflet_id];\r\n        var _gmx = layer._gmx,\r\n\t\t\tpOptions = layer.options.parentOptions;\r\n\t\tif (pOptions) {\r\n\t\t\tvar pId = pOptions.name;\r\n\t\t\tif (dataManagersLinks[pId]) {\r\n\t\t\t\tdelete dataManagersLinks[pId][_gmx.properties.name];\r\n\t\t\t\tif (!Object.keys(dataManagersLinks[pId]).length) {\r\n\t\t\t\t\tlayersVersion.removeDataManager(_gmx.dataManager);\r\n\t\t\t\t\tdelete dataManagersLinks[pId];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t}\r\n    },\r\n\r\n    add: function(layer) {\r\n        var id = layer._leaflet_id;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\r\n        var _gmx = layer._gmx,\r\n            prop = _gmx.properties;\r\n        if ('LayerVersion' in prop) {\r\n            layers[id] = layer;\r\n            _gmx._chkVersion = function () {\r\n                chkVersion(layer);\r\n            };\r\n            _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t\tvar pOptions = layer.options.parentOptions;\r\n\t\t\tif (pOptions) {\r\n\t\t\t\tvar pId = pOptions.name;\r\n\t\t\t\tlayersVersion.addDataManager(_gmx.dataManager);\r\n\t\t\t\tif (!dataManagersLinks[pId]) { dataManagersLinks[pId] = {}; }\r\n\t\t\t\tdataManagersLinks[pId][prop.name] = layer;\r\n\t\t\t}\r\n\r\n            layersVersion.start();\r\n            if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\r\n\t\t\t\tlayersVersion.now();\r\n            }\r\n        }\r\n    },\r\n\r\n    chkVersion: chkVersion,\r\n\r\n    now: function() {\r\n\t\tif (timeoutID) { clearTimeout(timeoutID); }\r\n\t\ttimeoutID = setTimeout(chkVersion, 0);\r\n    },\r\n\r\n    stop: function() {\r\n        if (intervalID) { clearInterval(intervalID); }\r\n        intervalID = null;\r\n    },\r\n\r\n    start: function(msec) {\r\n        if (msec) { delay = msec; }\r\n        layersVersion.stop();\r\n        intervalID = setInterval(chkVersion, delay);\r\n    }\r\n};\r\n\r\nif (!L.gmx) { L.gmx = {}; }\r\nL.gmx.layersVersion = layersVersion;\r\n\r\nL.gmx.VectorLayer.include({\r\n    updateVersion: function (layerDescription) {\r\n        if (layerDescription) {\r\n            var gmx = this._gmx;\r\n            if (layerDescription.geometry) {\r\n                gmx.geometry = layerDescription.geometry;\r\n            }\r\n            if (layerDescription.properties) {\r\n                L.extend(gmx.properties, layerDescription.properties);\r\n                gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\r\n                gmx.rawProperties = gmx.properties;\r\n                this.fire('versionchange');\r\n\t\t\t\tif (!gmx.dataSource) {\r\n\t\t\t\t\tgmx.dataManager.updateVersion(gmx.rawProperties);\r\n\t\t\t\t}\r\n            }\r\n        }\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LayersVersion.js","//Raster layer is just vector layer with the single object and special background tiles\r\nL.gmx.RasterLayer = L.gmx.VectorLayer.extend(\r\n{\r\n    options: {\r\n        isGeneralized: false,\r\n        zIndexOffset: 0\r\n        //clickable: false\r\n    },\r\n    initFromDescription: function(ph) {\r\n        var props = ph.properties,\r\n            styles = props.styles[0] || {MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21},\r\n            vectorProperties = {\r\n                type: 'Vector',\r\n                fromType: props.type,\r\n                identityField: 'ogc_fid',\r\n                GeometryType: 'POLYGON',\r\n                IsRasterCatalog: true,\r\n                Copyright: props.Copyright || '',\r\n                RCMinZoomForRasters: styles.MinZoom,\r\n                visible: props.visible,\r\n                styles: [{\r\n                    DisableBalloonOnClick: true,\r\n                    MinZoom: styles.MinZoom,\r\n                    MaxZoom: styles.MaxZoom,\r\n                    RenderStyle: {outline: {thickness: 0}, fill: {opacity: 100}},\r\n                    HoverStyle: null\r\n                }]\r\n            },\r\n            gmx = this._gmx,\r\n            worldSize = gmxAPIutils.tileSizes[1];\r\n\r\n        if (props.MaxZoom) {\r\n            gmx.maxNativeZoom = props.MaxZoom;\r\n        }\r\n        if (!ph.geometry) {\r\n            ph.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n\t\tL.gmx.VectorLayer.prototype.initFromDescription.call(this, {geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties});\r\n\r\n        gmx.rasterBGfunc = function(x, y, z) {\r\n\t\t\treturn 'http://' + gmx.hostName + '/' +\r\n\t\t\t\t'TileSender.ashx?ModeKey=tile' +\r\n\t\t\t\t'&key=' + encodeURIComponent(gmx.sessionKey) +\r\n\t\t\t\t'&LayerName=' + gmx.layerID +\r\n\t\t\t\t'&z=' + z +\r\n\t\t\t\t'&x=' + x +\r\n\t\t\t\t'&y=' + y;\r\n\t\t};\r\n\r\n\t\tvar vectorDataProvider = {load: function(x, y, z, v, s, d, callback) {\r\n            var objects = [[777, ph.geometry]],\r\n                itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\r\n                bounds = itemBounds.bounds;\r\n\r\n            if (bounds.max.x > worldSize) {\r\n                // for old layers geometry\r\n                var ww2 = 2 * worldSize,\r\n                    id = 777,\r\n                    coords = ph.geometry.coordinates,\r\n                    bboxArr = itemBounds.boundsArr;\r\n\r\n                objects = [];\r\n                if (ph.geometry.type === 'POLYGON') {\r\n                    coords = [coords];\r\n                    bboxArr = [bboxArr];\r\n                }\r\n\r\n                for (var i = 0, len = coords.length; i < len; i++) {\r\n                    var it = coords[i],\r\n                        bbox = bboxArr[i][0],\r\n                        arr = it;\r\n                    objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    if (bbox.max.x > worldSize) {\r\n                        arr = [];\r\n                        for (var j = 0, len1 = it.length; j < len1; j++) {\r\n                            var it1 = it[j];\r\n                            for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\r\n                                var it2 = it1[j1];\r\n                                arr1.push([it2[0] - ww2, it2[1]]);\r\n                            }\r\n                            arr.push(arr1);\r\n                        }\r\n                        objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    }\r\n                }\r\n            }\r\n\t\t\tcallback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\r\n\t\t}};\r\n\t\tgmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, {x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2});\r\n\t\tgmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\r\n\r\n        return this;\r\n    },\r\n\r\n    setZoomBounds: function(minZoom, maxZoom) {\r\n        var styles = this.getStyles().slice(0);\r\n        styles[0] = L.extend({}, styles[0]);\r\n        styles[0].MinZoom = minZoom;\r\n        styles[0].MaxZoom = maxZoom;\r\n        this.setStyles(styles);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/RasterLayer.js","/*\r\n (c) 2014, Sergey Alekseev\r\n Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n*/\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nL.LabelsLayer = L.Class.extend({\r\n\r\n    options: {\r\n        pane: 'overlayPane'\r\n    },\r\n\r\n    initialize: function (map, options) {\r\n        L.setOptions(this, options);\r\n        this._observers = {};\r\n        this._styleManagers = {};\r\n        this._labels = {};\r\n        var _this = this;\r\n\r\n        this.bbox = gmxAPIutils.bounds();\r\n\r\n        var chkData = function (data, layer) {\r\n            if (!data.added && !data.removed) { return; }\r\n\r\n            var opt = layer.options,\r\n                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\r\n                layerId = '_' + layer._leaflet_id,\r\n                gmx = layer._gmx,\r\n                labels = {};\r\n\r\n            for (var i = 0, len = added.length; i < len; i++) {\r\n                var item = added[i].item,\r\n                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\r\n                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\r\n\r\n                if (gmx.styleHook) {\r\n                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\r\n                    if (styleExtend) {\r\n                        currentStyle = L.extend({}, currentStyle, styleExtend);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (item.multiFilters) {\r\n                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                        var st = item.multiFilters[j].parsedStyle;\r\n                        if ('labelField' in st || 'labelText' in st) {\r\n                            currentStyle = st;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                var style = gmx.styleManager.getObjStyle(item) || {},\r\n                    labelText = currentStyle.labelText || style.labelText,\r\n                    labelField = currentStyle.labelField || style.labelField,\r\n                    fieldType = gmx.tileAttributeTypes[labelField],\r\n                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\r\n\r\n                if (style.labelTemplate) {\r\n\t\t\t\t\tvar reg = /\\[([^\\]]*)\\]/g,\r\n\t\t\t\t\t\tmatch;\r\n\t\t\t\t\ttxt = style.labelTemplate;\r\n\r\n\t\t\t\t\twhile ((match = reg.exec(style.labelTemplate))) {\r\n\t\t\t\t\t\tif (match.length === 2) {\r\n\t\t\t\t\t\t\tlabelField = match[1];\r\n\t\t\t\t\t\t\tfieldType = gmx.tileAttributeTypes[labelField];\r\n\t\t\t\t\t\t\tvar val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\r\n\t\t\t\t\t\t\ttxt = txt.replace(match[0], val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                }\r\n\t\t\t\tif (txt || txt === 0) {\r\n                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\r\n                        id = '_' + item.id,\r\n                        changed = true,\r\n                        width = 0,\r\n\t\t\t\t\t\tarrTxtWidth,\r\n                        options = item.options,\r\n                        labelStyle = {\r\n                            font: fontSize + 'px \"Arial\"',\r\n                            labelHaloColor: ('labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : ('labelHaloColor' in style ? style.labelHaloColor : 0xffffff)),\r\n                            labelColor: currentStyle.labelColor || style.labelColor,\r\n                            labelAlign: currentStyle.labelAlign || style.labelAlign,\r\n                            labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\r\n                            labelFontSize: fontSize\r\n                        };\r\n                    if (options) {\r\n                        if (!('center' in options)) {\r\n                            var center = gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\r\n                            if (!center) { continue; }\r\n                            options.center = center;\r\n                        }\r\n                        if (options.label) {\r\n                            width = options.label.width;\r\n                            arrTxtWidth = options.label.arrTxtWidth;\r\n                            var pstyle = options.label.style;\r\n                            changed = options.label.txt !== txt ||\r\n                                pstyle.labelHaloColor !== labelStyle.labelHaloColor ||\r\n                                pstyle.labelColor !== labelStyle.labelColor ||\r\n                                pstyle.labelAlign !== labelStyle.labelAlign ||\r\n                                pstyle.labelAnchor !== labelStyle.labelAnchor ||\r\n                                pstyle.labelFontSize !== labelStyle.labelFontSize;\r\n                        }\r\n                    }\r\n                    if (changed) {\r\n\t\t\t\t\t\twidth = 0;\r\n                        arrTxtWidth = gmxAPIutils.getLabelWidth(txt, labelStyle);\r\n\t\t\t\t\t\tif (arrTxtWidth) {\r\n\t\t\t\t\t\t    arrTxtWidth.forEach(function(it) {\r\n\t\t\t\t\t\t\t\twidth = Math.max(width, it[1]);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n                        if (!width) {\r\n                            delete labels[id];\r\n                            continue;\r\n                        }\r\n                        width += 4;\r\n                        item.options.labelStyle = null;\r\n                    }\r\n                    options.label = {\r\n                        isPoint: isPoint,\r\n                        width: width,\r\n                        sx: style.sx || 0,\r\n                        txt: txt,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        style: labelStyle\r\n                    };\r\n                    labels[id] = item;\r\n                }\r\n            }\r\n            _this._labels[layerId] = labels;\r\n        };\r\n\r\n        var addObserver = function (layer) {\r\n            var gmx = layer._gmx,\r\n                filters = ['styleFilter', 'userFilter'],\r\n                options = {\r\n                    type: 'resend',\r\n                    bbox: _this.bbox,\r\n                    filters: filters,\r\n                    callback: function(data) {\r\n                        chkData(data, layer);\r\n                        _this.redraw();\r\n                    }\r\n                };\r\n            if (gmx.beginDate && gmx.endDate) {\r\n                options.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n            return gmx.dataManager.addObserver(options, '_Labels');\r\n        };\r\n        this.add = function (layer) {\r\n            var id = layer._leaflet_id,\r\n                gmx = layer._gmx;\r\n\r\n            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\r\n                gmx.styleManager.deferred.then(function () {\r\n                    var observer = addObserver(layer),\r\n\t\t\t\t\t\t_zoom = _this._map._zoom;\r\n                    if (layer.options.isGeneralized) {\r\n                        observer.targetZoom = _zoom;\t//need update to current zoom\r\n                    }\r\n                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\r\n                        observer.deactivate();\r\n                    }\r\n                    _this._observers[id] = observer;\r\n                    _this._styleManagers[id] = gmx.styleManager;\r\n\r\n                    _this._labels['_' + id] = {};\r\n                    _this._updateBbox();\r\n                });\r\n            }\r\n        };\r\n        this.remove = function (layer) {\r\n            var id = layer._leaflet_id;\r\n            if (_this._observers[id]) {\r\n                var gmx = layer._gmx,\r\n                    dataManager = gmx.dataManager;\r\n                dataManager.removeObserver(_this._observers[id].id);\r\n                delete _this._observers[id];\r\n                delete _this._styleManagers[id];\r\n                delete _this._labels['_' + id];\r\n                _this.redraw();\r\n            }\r\n        };\r\n        this._layeradd = function (ev) {\r\n            _this.add(ev.layer);\r\n        };\r\n        this._layerremove = function (ev) {\r\n            _this.remove(ev.layer);\r\n        };\r\n    },\r\n\r\n    redraw: function () {\r\n        if (!this._frame && !this._map._animating) {\r\n            this._frame = L.Util.requestAnimFrame(this._redraw, this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    _addToPane: function () {\r\n        var pane = this._map.getPanes()[this.options.pane];\r\n        if (pane) {\r\n            pane.insertBefore(this._canvas, pane.firstChild);\r\n        }\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n\r\n        if (!this._canvas) {\r\n            this._initCanvas();\r\n        }\r\n        // this._addToPane();\r\n\r\n        map.on('moveend', this._reset, this);\r\n        map.on({\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        });\r\n        if (map.options.zoomAnimation && L.Browser.any3d) {\r\n            map.on('zoomanim', this._animateZoom, this);\r\n        }\r\n\r\n        this._reset();\r\n    },\r\n\r\n    onRemove: function (map) {\r\n        if (this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n\r\n        map.off('moveend', this._reset, this);\r\n        map.off('layeradd', this._layeradd);\r\n        map.off('layerremove', this._layerremove);\r\n\r\n        if (map.options.zoomAnimation) {\r\n            map.off('zoomanim', this._animateZoom, this);\r\n        }\r\n    },\r\n\r\n    addTo: function (map) {\r\n        map.addLayer(this);\r\n        return this;\r\n    },\r\n\r\n    _initCanvas: function () {\r\n        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\r\n            size = this._map.getSize();\r\n        canvas.width  = size.x; canvas.height = size.y;\r\n        canvas.style.pointerEvents = 'none';\r\n        this._canvas = canvas;\r\n\r\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\r\n        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\r\n    },\r\n\r\n    _updateBbox: function () {\r\n        var _map = this._map,\r\n            screenBounds = _map.getBounds(),\r\n            southWest = screenBounds.getSouthWest(),\r\n            northEast = screenBounds.getNorthEast(),\r\n            m1 = L.Projection.Mercator.project(southWest),\r\n            m2 = L.Projection.Mercator.project(northEast),\r\n\t\t\t_zoom = _map.getZoom();\r\n\r\n        this.mInPixel = gmxAPIutils.getPixelScale(_zoom);\r\n        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\r\n        for (var id in this._observers) {\r\n\t\t\tvar observer = this._observers[id];\r\n\t\t\tif (observer.targetZoom) {\r\n\t\t\t\tobserver.targetZoom = _zoom;\r\n\t\t\t}\r\n            observer.setBounds({\r\n                min: {x: southWest.lng, y: southWest.lat},\r\n                max: {x: northEast.lng, y: northEast.lat}\r\n            });\r\n        }\r\n    },\r\n\r\n    _reset: function () {\r\n        this._updateBbox();\r\n        for (var id in this._observers) {\r\n            var observer = this._observers[id];\r\n            if (!observer.isActive() &&\r\n                this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())\r\n            ) {\r\n                observer.activate();\r\n            }\r\n            observer.fire('update');\r\n        }\r\n    },\r\n\r\n    _redraw: function () {\r\n        var out = [],\r\n            _map = this._map,\r\n            mapSize = _map.getSize(),\r\n            _canvas = this._canvas,\r\n            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\r\n            topLeft = _map.containerPointToLayerPoint(offset);\r\n\r\n\t\t_canvas.width = mapSize.x; _canvas.height = mapSize.y;\r\n        L.DomUtil.setPosition(_canvas, topLeft);\r\n\r\n        var w2 = 2 * this.mInPixel * gmxAPIutils.worldWidthMerc,\r\n            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\r\n            ctx = _canvas.getContext('2d'),\r\n            i, len, it;\r\n\r\n        for (var layerId in this._labels) {\r\n            var labels = this._labels[layerId];\r\n            for (var id in labels) {\r\n                it = labels[id];\r\n                var options = it.options,\r\n                    label = options.label,\r\n                    style = label.style,\r\n\t\t\t\t\tlabelAlign = style.labelAlign || 'center',\r\n                    arrTxtWidth = label.arrTxtWidth,\r\n\t\t\t\t\tcount = arrTxtWidth.length || 1,\r\n                    width = label.width,\r\n                    width2 = width / 2,\r\n                    size = style.labelFontSize || 12,\r\n                    size2 = size / 2,\r\n                    center = options.center,\r\n                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\r\n                    isFiltered = false;\r\n\r\n                if (label.isPoint) {\r\n                    var delta = label.sx;\r\n                    if (labelAlign === 'left') {\r\n                        pos[0] += width2 + delta;\r\n                    } else if (labelAlign === 'right') {\r\n                        pos[0] -= width + delta;\r\n                    }\r\n                }\r\n                pos[0] -= width2 + this._ctxShift[0];\r\n                pos[1] = -size2 - pos[1] + this._ctxShift[1];\r\n\t\t\t\tsize2 *= count;\r\n                if (style.labelAnchor) {\r\n                    pos[0] += style.labelAnchor[0];\r\n                    pos[1] += style.labelAnchor[1];\r\n                }\r\n\r\n                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\r\n                    var coord = [Math.floor(tx), Math.floor(pos[1])],\r\n                        bbox = gmxAPIutils.bounds([\r\n                            [coord[0] - width2, coord[1] - size2],\r\n                            [coord[0] + width2, coord[1] + size2]\r\n                        ]);\r\n                    for (i = 0, len = out.length; i < len; i++) {\r\n                        if (bbox.intersects(out[i].bbox)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (isFiltered) { continue; }\r\n\r\n                    if (!options.labelStyle) {\r\n                        options.labelStyle = {\r\n                            font: size + 'px \"Arial\"',\r\n                            fillStyle: gmxAPIutils.dec2color(style.labelColor || 0, 1),\r\n                            shadowBlur: 4\r\n                        };\r\n                        if (style.labelHaloColor !== -1) {\r\n                            options.labelStyle.strokeStyle =\r\n                            options.labelStyle.shadowColor =\r\n                                gmxAPIutils.dec2color(style.labelHaloColor, 1);\r\n                        }\r\n                    }\r\n                    out.push({\r\n                        arr: it.properties,\r\n                        bbox: bbox,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        width2: labelAlign === 'center' ? width2 : 0,\r\n                        txt: label.txt,\r\n                        style: options.labelStyle,\r\n                        size: size,\r\n                        coord: coord\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (out.length) {\r\n            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\r\n            for (i = 0, len = out.length; i < len; i++) {\r\n                it = out[i];\r\n\t\t\t\tit.arrTxtWidth.forEach(function(pt, nm) {\r\n\t\t\t\t\tvar coord = [it.coord[0] + it.width2 - pt[1]/2, it.coord[1] + nm * it.size];\r\n\t\t\t\t\tgmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\r\n\t\t\t\t});\r\n            }\r\n            if (!_canvas.parentNode) { this._addToPane(); }\r\n        } else if (_canvas.parentNode) {\r\n            _canvas.parentNode.removeChild(_canvas);\r\n        }\r\n\r\n        this._frame = null;\r\n    },\r\n\r\n    _animateZoom: function (e) {\r\n        var scale = this._map.getZoomScale(e.zoom),\r\n            pixelBoundsMin = this._map.getPixelBounds().min;\r\n\r\n        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\r\n        if (pixelBoundsMin.y < 0) {\r\n            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\r\n        }\r\n\r\n        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\r\n    }\r\n});\r\n\r\nL.labelsLayer = function (map, options) {\r\n    return new L.LabelsLayer(map, options);\r\n};\r\n\r\nL.Map.addInitHook(function () {\r\n\t// Check to see if Labels has already been initialized.\r\n    if (!this._labelsLayer) {\r\n        this._labelsLayer = new L.LabelsLayer(this);\r\n        this._labelsLayer.addTo(this);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LabelsLayer.js","(function() {\r\nvar isBoundsIntersects = function (bounds, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].intersects(bounds)) { return true; }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\nvar isObserverIntersects = function (observer, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (observer.intersects(bbox[j1])) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar isPointInClipPolygons = function (chkPoint, clipPolygons) {\r\n    if (!clipPolygons || Object.keys(clipPolygons).length === 0) { return true; }\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].contains(chkPoint)) {\r\n                        var coords = it.geometry.coordinates,\r\n                            isIn = false;\r\n                        if (type === 'Polygon') { coords = [coords]; }\r\n                        for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\r\n                                isIn = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (isIn) { return true; }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar getClipPolygonItem = function (geo) {\r\n    var geometry = gmxAPIutils.convertGeometry(geo),\r\n        bboxArr = gmxAPIutils.geoItemBounds(geometry);\r\n    bboxArr.geometry = geometry;\r\n    return bboxArr;\r\n};\r\n\r\nvar clipTileByPolygon = function (dattr) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = canvas.height = 256;\r\n    var ctx = canvas.getContext('2d'),\r\n        clipPolygons = dattr.clipPolygons;\r\n\r\n    dattr.ctx = ctx;\r\n    ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\r\n\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var geo = arr[i].geometry,\r\n                coords = geo.coordinates;\r\n            if (geo.type === 'Polygon') { coords = [coords]; }\r\n            for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\r\n                var coords1 = coords[i1];\r\n                ctx.beginPath();\r\n                for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\r\n                    dattr.coords = coords1[j1];\r\n                    var pixels = gmxAPIutils.getRingPixels(dattr);\r\n                    dattr.coords = pixels.coords;\r\n                    gmxAPIutils.polygonToCanvasFill(dattr);\r\n                }\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    ctx = dattr.tile.getContext('2d');\r\n    ctx.clearRect(0, 0, 256, 256);\r\n    ctx.drawImage(canvas, 0, 0);\r\n};\r\n\r\nL.gmx.VectorLayer.include({\r\n\r\n    isPointInClipPolygons: function (point) { // point [x, y] in Mercator\r\n        return isPointInClipPolygons(point, this._gmx._clipPolygons);\r\n    },\r\n\r\n    addClipPolygon: function (polygon) { // (L.Polygon) or (L.GeoJSON with Polygons)\r\n        var item = [],\r\n            i, len;\r\n\r\n        if ('coordinates' in polygon && 'type' in polygon) {\r\n            item.push(getClipPolygonItem(polygon));\r\n        } else if (polygon instanceof L.Polygon) {\r\n            item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\r\n        } else if (polygon instanceof L.GeoJSON) {\r\n            var layers = polygon.getLayers();\r\n            for (i = 0, len = layers.length; i < len; i++) {\r\n                var layer = layers[i];\r\n                if (layer instanceof L.Polygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                } else if (layer instanceof L.MultiPolygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                }\r\n            }\r\n        }\r\n        if (item.length) {\r\n            var gmx = this._gmx,\r\n                dataManager = gmx.dataManager,\r\n                _this = this,\r\n                id = L.stamp(polygon);\r\n\r\n            if (!this._gmx._clipPolygons) { this._gmx._clipPolygons = {}; }\r\n            this._gmx._clipPolygons[id] = item;\r\n            dataManager.setTileFilteringHook(function (tile) {\r\n                return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipFilter', function (item, tile, observer) {\r\n                return isObserverIntersects(observer, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipPointsFilter', function (item) {\r\n                if (item.type === 'POINT') {\r\n                    var propArr = item.properties,\r\n                        geom = propArr[propArr.length - 1];\r\n                    return isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\r\n                }\r\n                return true;\r\n            });\r\n            if (Object.keys(this._gmx._clipPolygons).length === 1) {\r\n                gmx.renderHooks.unshift(function (tile, hookInfo) {\r\n                    if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\r\n                        clipTileByPolygon({\r\n                            tile: tile,\r\n                            tpx: hookInfo.tpx,\r\n                            tpy: hookInfo.tpy,\r\n                            gmx: {mInPixel: gmx.mInPixel},\r\n                            clipPolygons: _this._gmx._clipPolygons\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeClipPolygon: function (polygon) {\r\n        var id = L.stamp(polygon);\r\n        if (this._gmx._clipPolygons) {\r\n            delete this._gmx._clipPolygons[id];\r\n            if (Object.keys(this._gmx._clipPolygons).length === 0) {\r\n                this._gmx.dataManager.removeTileFilteringHook();\r\n                this._gmx.dataManager.removeFilter('clipFilter');\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ClipPolygon.js","L.gmx.gmxImageTransform = function(img, hash) {\r\n    var gmx = hash.gmx,\r\n        gmxTilePoint = hash.gmxTilePoint,\r\n        mInPixel = gmx.mInPixel,\r\n        geoItem = hash.geoItem,\r\n        properties = geoItem.properties,\r\n        dataOption = geoItem.dataOption || {},\r\n        // geom = properties[properties.length - 1],\r\n        // coord = geom.coordinates[0],\r\n        indexes = gmx.tileAttributeIndexes,\r\n        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\r\n        points = {};\r\n\r\n    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\r\n    if (quicklookPlatform === 'LANDSAT8') {\r\n        points.x1 = dataOption.bounds.min.x; points.y1 = dataOption.bounds.max.y;\r\n        points.x2 = dataOption.bounds.max.x; points.y2 = dataOption.bounds.max.y;\r\n        points.x3 = dataOption.bounds.max.x; points.y3 = dataOption.bounds.min.y;\r\n        points.x4 = dataOption.bounds.min.x; points.y4 = dataOption.bounds.min.y;\r\n    } else {\r\n        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\r\n    }\r\n\r\n    var x1 = mInPixel * points.x1, y1 = mInPixel * points.y1,\r\n        x2 = mInPixel * points.x2, y2 = mInPixel * points.y2,\r\n        x3 = mInPixel * points.x3, y3 = mInPixel * points.y3,\r\n        x4 = mInPixel * points.x4, y4 = mInPixel * points.y4,\r\n        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\r\n        ww = Math.round(boundsP.max.x - boundsP.min.x),\r\n        hh = Math.round(boundsP.max.y - boundsP.min.y),\r\n        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\r\n        itbounds = geoItem.item.bounds,\r\n        wMerc = gmxAPIutils.worldWidthMerc,\r\n        tpx = gmxTilePoint.x;\r\n\r\n    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\t// For points intersects 180 deg\r\n\t\ttpx += Math.round(wMerc * mInPixel / 128);\r\n\t}\r\n\tvar dx = boundsP.min.x - 256 * tpx;\r\n\r\n    x1 -= boundsP.min.x; y1 = boundsP.max.y - y1;\r\n    x2 -= boundsP.min.x; y2 = boundsP.max.y - y2;\r\n    x3 -= boundsP.min.x; y3 = boundsP.max.y - y3;\r\n    x4 -= boundsP.min.x; y4 = boundsP.max.y - y4;\r\n\r\n    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\r\n\r\n    if (!gmx.ProjectiveImage) {\r\n        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\r\n    }\r\n    var pt = gmx.ProjectiveImage.getCanvas({\r\n        imageObj: img,\r\n        points: shiftPoints,\r\n        wView: ww,\r\n        hView: hh,\r\n        deltaX: dx,\r\n        deltaY: dy\r\n    });\r\n    return pt.canvas;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ImageTransform.js","(function() {\r\nvar ProjectiveImageWebGL = L.Class.extend({\r\n    options: {\r\n        antialias: true,\r\n        depth: false,\r\n        preserveDrawingBuffer: true,\r\n        shaderVS: 'attribute vec2 aVertCoord;\\\r\n            uniform mat4 uTransformMatrix;\\\r\n            varying vec2 vTextureCoord;\\\r\n            void main(void) {\\\r\n                vTextureCoord = aVertCoord;\\\r\n                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n            }\\\r\n        ',\r\n        shaderFS: 'precision mediump float;\\\r\n            varying vec2 vTextureCoord;\\\r\n            uniform sampler2D uSampler;\\\r\n            void main(void) {\\\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n            }\\\r\n        '\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        L.setOptions(this, options);\r\n    },\r\n\r\n    initialize: function(options) {\r\n        this.setOptions(options);\r\n\r\n        var canvas = document.createElement('canvas'),\r\n            glOpts = {\r\n                antialias: this.options.antialias,\r\n                depth: this.options.depth,\r\n                preserveDrawingBuffer: this.options.preserveDrawingBuffer\r\n            },\r\n            gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\r\n        if (!gl) { return; }\r\n        var glResources = this._setupGlContext(gl);\r\n        if (!glResources) { return; }\r\n\r\n        canvas.width = canvas.height = 256;\r\n        glResources.canvas = canvas;\r\n\r\n        this.glResources = glResources;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n    },\r\n\r\n    _getShader: function (type, source, gl) {\r\n        var shader = gl.createShader(type);\r\n\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return shader;\r\n    },\r\n\r\n    _setupGlContext: function (gl) {\r\n        // Store return values here\r\n        var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\r\n            fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\r\n\r\n        if (vertexShader && fragmentShader) {\r\n            // Compile the program\r\n            var shaderProgram = gl.createProgram();\r\n            gl.attachShader(shaderProgram, vertexShader);\r\n            gl.attachShader(shaderProgram, fragmentShader);\r\n            gl.linkProgram(shaderProgram);\r\n\r\n            if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n                // Find and set up the uniforms and attributes\r\n                gl.useProgram(shaderProgram);\r\n                this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n                var vertexBuffer = gl.createBuffer(),    // Create a buffer to hold the vertices\r\n                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\r\n\r\n                // draw the triangles\r\n                gl.enableVertexAttribArray(vertAttrib);\r\n                gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\r\n                return {\r\n                    transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\r\n                    samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\r\n                    screenTexture: gl.createTexture() // Create a texture to use for the screen image\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    _bindTexture: function (gl, image, texture) {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n        // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        // Prevents s-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        // Prevents t-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    getCanvas: function (attr) {\r\n        var p = attr.points,\r\n            deltaX = attr.deltaX,\r\n            deltaY = attr.deltaY,\r\n            dstPoints = new Float32Array([\r\n                (p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128,\r\n                (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128,\r\n                (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128,\r\n                (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128\r\n            ]);\r\n\r\n        var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\r\n            gl = this.gl,\r\n            glResources = this.glResources;\r\n\r\n        this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\r\n\r\n        gl.viewport(0, 0, 256, 256);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    // set background to full transparency\r\n\r\n        gl.uniformMatrix4fv(\r\n            glResources.transMatUniform,\r\n            false, [\r\n                v[0], v[3],    0, v[6],\r\n                v[1], v[4],    0, v[7],\r\n                   0,    0,    1,    0,\r\n                v[2], v[5],    0,    1\r\n            ]);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\r\n        gl.uniform1i(glResources.samplerUniform, 0);\r\n\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        return this;\r\n    }\r\n});\r\n\r\nfunction adj(m) { // Compute the adjugate of m\r\n    return [\r\n        m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4],\r\n        m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5],\r\n        m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]\r\n    ];\r\n}\r\n\r\nfunction multmm(a, b) { // multiply two matrices\r\n    var c = Array(9);\r\n    for (var i = 0; i !== 3; ++i) {\r\n        for (var j = 0; j !== 3; ++j) {\r\n            var cij = 0;\r\n            for (var k = 0; k !== 3; ++k) {\r\n                cij += a[3 * i + k] * b[3 * k + j];\r\n            }\r\n            c[3 * i + j] = cij;\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction multmv(m, v) { // multiply matrix and vector\r\n    return [\r\n        m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\r\n        m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\r\n        m[6] * v[0] + m[7] * v[1] + m[8] * v[2]\r\n    ];\r\n}\r\n\r\nfunction basisToPoints(p) {\r\n    var m = [\r\n        p[0], p[2], p[4],\r\n        p[1], p[3], p[5],\r\n        1,  1,  1\r\n    ];\r\n    var v = multmv(adj(m), [p[6], p[7], 1]);\r\n    return multmm(m, [\r\n        v[0], 0, 0,\r\n        0, v[1], 0,\r\n        0, 0, v[2]\r\n    ]);\r\n}\r\n\r\nProjectiveImageWebGL.Utils = {\r\n    general2DProjection: function(from, to) {\r\n        var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\r\n        if (arr[8]) {\r\n            for (var i = 0; i !== 9; ++i) {\r\n                arr[i] = arr[i] / arr[8];\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    getWebGlResources: function(options) {\r\n        var obj = new ProjectiveImageWebGL(options);\r\n        return obj.gl ? obj : null;\r\n    }\r\n};\r\nL.gmx.projectiveImageWebGL = function(options) {\r\n    var res = new ProjectiveImageWebGL(options);\r\n    return res.gl ? res : null;\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImageWebGL.js","(function() {\r\n// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\r\nvar ProjectiveImage = function() {\r\n\tvar cnt = 0,\r\n        limit = 4,\r\n        patchSize = 64,\r\n        transform = null;\r\n\r\n\tvar allocate = function (w, h) {\r\n\t  var values = [];\r\n\t  for (var i = 0; i < h; ++i) {\r\n\t\tvalues[i] = [];\r\n\t\tfor (var j = 0; j < w; ++j) {\r\n\t\t  values[i][j] = 0;\r\n\t\t}\r\n\t  }\r\n\t  return values;\r\n\t};\r\n\r\n\tvar Matrix = function (w, h, values) {\r\n\t  this.w = w;\r\n\t  this.h = h;\r\n\t  this.values = values || allocate(h);\r\n\t};\r\n\r\n\tvar cloneValues = function (values) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0; i < values.length; ++i) {\r\n\t\t\tclone[i] = [].concat(values[i]);\r\n\t\t}\r\n\t\treturn clone;\r\n\t};\r\n\r\n\tMatrix.prototype = {\r\n\t\tadd : function (operand) {\r\n\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix add size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (var x = 0; x < this.w; ++x) {\r\n\t\t\t\t  values[y][x] = this.values[y][x] + operand.values[y][x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t},\r\n\t\ttransformProjectiveVector : function (operand) {\r\n\t\t\tvar out = [], x, y;\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tout[y] = 0;\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar zn = out[out.length - 1];\r\n\t\t\tif (zn) {\r\n\t\t\t\tvar iz = 1 / (out[out.length - 1]);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tout[y] *= iz;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\tmultiply : function (operand) {\r\n\t\t\tvar values, x, y;\r\n\t\t\tif (+operand !== operand) {\r\n\t\t\t\t// Matrix mult\r\n\t\t\t\tif (operand.h !== this.w) {\r\n\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\r\n\t\t\t\t}\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\r\n\t\t\t\t\t\tvar accum = 0;\r\n\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\r\n\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[y][x] = accum;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(operand.w, this.h, values);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Scalar mult\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t\t}\r\n\t\t},\r\n\t\trowEchelon : function () {\r\n\t\t\tif (this.w <= this.h) {\r\n\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = cloneValues(this.values);\r\n\r\n\t\t\t// Do Gauss-Jordan algorithm.\r\n\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\r\n\t\t\t\t// Look up pivot value.\r\n\t\t\t\tvar pivot = temp[yp][yp];\r\n\t\t\t\twhile (pivot === 0) {\r\n\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\r\n\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\r\n\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\r\n\t\t\t\t\t\t\t// Swap rows.\r\n\t\t\t\t\t\t\tvar tmpRow = temp[ys];\r\n\t\t\t\t\t\t\ttemp[ys] = temp[yp];\r\n\t\t\t\t\t\t\ttemp[yp] = tmpRow;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (ys === this.h) {\r\n\t\t\t\t\t\t// No suitable pivot found. Abort.\r\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpivot = temp[yp][yp];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Normalize this row.\r\n\t\t\t\tvar scale = 1 / pivot;\r\n\t\t\t\tfor (var x = yp; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[yp][x] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\t// Subtract this row from all other rows (scaled).\r\n\t\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tif (y === yp) { continue; }\r\n\t\t\t\t\tvar factor = temp[y][yp];\r\n\t\t\t\t\ttemp[y][yp] = 0;\r\n\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\r\n\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t},\r\n\t\tinvert : function () {\r\n\t\t\tvar x, y;\r\n\r\n\t\t\tif (this.w !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix invert size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = allocate(this.w * 2, this.h);\r\n\r\n\t\t\t// Initialize augmented matrix\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[y][x] = this.values[y][x];\r\n\t\t\t\t\ttemp[y][x + this.w] = (x === y) ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\r\n\t\t\ttemp = temp.rowEchelon();\r\n\r\n\t\t\t// Extract right block matrix.\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (y = 0; y < this.w; ++y) {\r\n\t\t\t\t// @todo check if \"x < this.w;\" is mistake\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t}\r\n\t};\r\n\r\n\tvar getProjectiveTransform = function (points) {\r\n\t  var eqMatrix = new Matrix(9, 8, [\r\n\t\t[1, 1, 1,   0, 0, 0, -points[2][0], -points[2][0], -points[2][0]],\r\n\t\t[0, 1, 1,   0, 0, 0,  0, -points[3][0], -points[3][0]],\r\n\t\t[1, 0, 1,   0, 0, 0, -points[1][0], 0, -points[1][0]],\r\n\t\t[0, 0, 1,   0, 0, 0,  0, 0, -points[0][0]],\r\n\r\n\t\t[0, 0, 0,  -1, -1, -1,  points[2][1], points[2][1], points[2][1]],\r\n\t\t[0, 0, 0,   0, -1, -1,  0, points[3][1], points[3][1]],\r\n\t\t[0, 0, 0,  -1,  0, -1,  points[1][1], 0, points[1][1]],\r\n\t\t[0, 0, 0,   0,  0, -1,  0, 0, points[0][1]]\r\n\r\n\t  ]);\r\n\r\n\t  var kernel = eqMatrix.rowEchelon().values;\r\n\t  var transform = new Matrix(3, 3, [\r\n\t\t[-kernel[0][8], -kernel[1][8], -kernel[2][8]],\r\n\t\t[-kernel[3][8], -kernel[4][8], -kernel[5][8]],\r\n\t\t[-kernel[6][8], -kernel[7][8],             1]\r\n\t  ]);\r\n\t  return transform;\r\n\t};\r\n\r\n\tvar divide = function (u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\r\n\t\tif (limit) {\r\n\t\t\t// Measure patch non-affinity.\r\n\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\r\n\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\r\n\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\r\n\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\r\n\r\n\t\t\t// Measure patch area.\r\n\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\r\n\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\r\n\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\r\n\r\n\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\r\n\t\t\t// The non-affinity measure is used as a correction factor.\r\n\t\t\tif ((u1 === 0 && u4 === 1) || ((.25 + r * 5) * area > (patchSize * patchSize))) {\r\n\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\r\n\t\t\t\tvar umid = (u1 + u4) / 2;\r\n\t\t\t\tvar vmid = (v1 + v4) / 2;\r\n\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\r\n\t\t\t\tvar pt   = transform.transformProjectiveVector([umid, v1, 1]);\r\n\t\t\t\tvar pb   = transform.transformProjectiveVector([umid, v4, 1]);\r\n\t\t\t\tvar pl   = transform.transformProjectiveVector([u1, vmid, 1]);\r\n\t\t\t\tvar pr   = transform.transformProjectiveVector([u4, vmid, 1]);\r\n\r\n\t\t\t\t// Subdivide.\r\n\t\t\t\tlimit--;\r\n\t\t\t\tdivide.call(this, u1,   v1, umid, vmid,   p1,   pt,   pl, pmid, limit, attr);\r\n\t\t\t\tdivide.call(this, umid,   v1,   u4, vmid,   pt,   p2, pmid,   pr, limit, attr);\r\n\t\t\t\tdivide.call(this, u1,  vmid, umid,   v4,   pl, pmid,   p3,   pb, limit, attr);\r\n\t\t\t\tdivide.call(this, umid, vmid,   u4,   v4, pmid,   pr,   pb,   p4, limit, attr);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar ctx = attr.ctx;\r\n\r\n\t\t// Get patch edge vectors.\r\n\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\r\n\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\r\n\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\r\n\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\r\n\r\n\t\t// Find the corner that encloses the most area\r\n\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\r\n\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\r\n\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\r\n\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\r\n\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\r\n\t\tvar dx = 0, dy = 0, padx = 0, pady = 0;\r\n\r\n\t\t// Align the transform along this corner.\r\n\t\t// Calculate 1.05 pixel padding on vector basis.\r\n\t\tif (amax === a1) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t} else if (amax === a2) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1],  d24[0],  d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t} else if (amax === a4) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t\t\tdy = -1;\r\n\t\t} else if (amax === a3) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t\t\tdy = -1;\r\n\t\t}\r\n\r\n\t\t// Calculate image padding to match.\r\n\t\tvar du = (u4 - u1);\r\n\t\tvar dv = (v4 - v1);\r\n\t\tpadx++;\r\n\t\tpady++;\r\n\r\n        var iw = attr.imageObj.width,\r\n            ih = attr.imageObj.height,\r\n            sx = Math.floor(u1 * iw),\r\n            sy = Math.floor(v1 * ih),\r\n            sw = Math.floor(Math.min(padx * du, 1) * iw),\r\n            sh = Math.floor(Math.min(pady * dv, 1) * ih);\r\n\r\n\t\tcnt++;\r\n        ctx.drawImage(\r\n            attr.imageObj,\r\n            sx, sy,\r\n            sw, sh,\r\n            dx, dy,\r\n            padx, pady\r\n        );\r\n\t};\r\n\r\n\tthis.getCanvas = function (attr) {\r\n\t\tcnt = 0;\r\n\t\ttransform = getProjectiveTransform(attr.points);\r\n\t\t// Begin subdivision process.\r\n\r\n\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\r\n            ptr = transform.transformProjectiveVector([1, 0, 1]),\r\n            pbl = transform.transformProjectiveVector([0, 1, 1]),\r\n            pbr = transform.transformProjectiveVector([1, 1, 1]);\r\n\r\n\t\tvar canvas = document.createElement('canvas');\r\n\t\tcanvas.width = canvas.height = 256;\r\n\t\tattr.canvas = canvas;\r\n\t\tattr.ctx = canvas.getContext('2d');\r\n\r\n\t\tvar\tboundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\r\n            maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\r\n\r\n\t\tlimit = 'limit' in attr ? attr.limit : (maxSize < 200 ? 1 : 4);\r\n\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\r\n\r\n\t\ttry {\r\n\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\r\n\t\t} catch (e) {\r\n\t\t\tconsole.log('Error: ProjectiveImage event:', e);\r\n\t\t\tcanvas = null;\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tcanvas: canvas,\r\n\t\t\tptl: ptl,\r\n\t\t\tptr: ptr,\r\n\t\t\tpbl: pbl,\r\n\t\t\tpbr: pbr,\r\n\t\t\tcnt: cnt\r\n\t\t};\r\n\t};\r\n};\r\nL.gmx.projectiveImage = function() {\r\n    return new ProjectiveImage();\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImage.js","// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\r\n\r\nL.RotatedMarker = L.Marker.extend({\r\n    options: {\r\n        angle: 0\r\n    },\r\n\r\n    statics: {\r\n        TRANSFORM_ORIGIN: L.DomUtil.testProp(\r\n            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\r\n    },\r\n\r\n    _initIcon: function() {\r\n        L.Marker.prototype._initIcon.call(this);\r\n\r\n        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\r\n    },\r\n\r\n    _getTransformOrigin: function() {\r\n        var iconAnchor = this.options.icon.options.iconAnchor;\r\n\r\n        if (!iconAnchor) {\r\n            return '50% 50%';\r\n        }\r\n\r\n        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\r\n    },\r\n\r\n    _setPos: function(pos) {\r\n        L.Marker.prototype._setPos.call(this, pos);\r\n\r\n        if (L.DomUtil.TRANSFORM) {\r\n            // use the CSS transform rule if available\r\n            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n        } else if (L.Browser.ie) {\r\n            // fallback for IE6, IE7, IE8\r\n            var rad = this.options.angle * (Math.PI / 180),\r\n                costheta = Math.cos(rad),\r\n                sintheta = Math.sin(rad);\r\n            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' +\r\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';\r\n        }\r\n    },\r\n\r\n    setAngle: function(ang) {\r\n        this.options.angle = ang;\r\n    }\r\n});\r\n\r\nL.rotatedMarker = function(pos, options) {\r\n    return new L.RotatedMarker(pos, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/RotatedMarker.js","L.gmx.ExternalLayer = L.Class.extend({\r\n    createExternalLayer: function () {          // extend: must return <ILayer> or null = this.externalLayer\r\n        return null;\r\n    },\r\n\r\n    isExternalVisible: function (/*zoom*/) {    // extend: return true view this.externalLayer, return false view this.parentLayer\r\n        return true;\r\n    },\r\n\r\n    updateData: function (/*data*/) {           // extend: for data update in this.externalLayer\r\n    },\r\n\r\n    setDateInterval: function () {\r\n        if (this._observer) {\r\n            var gmx = this.parentLayer._gmx;\r\n            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\r\n        }\r\n    },\r\n\r\n    options: {\r\n        useDataManager: true,\r\n        observerOptions: {\r\n            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\r\n        }\r\n    },\r\n\r\n    initialize: function (options, layer) {\r\n        L.setOptions(this, options);\r\n        this.parentLayer = layer;\r\n        layer\r\n            .on('add', this._addEvent, this)\r\n            .on('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this.options.useDataManager) {\r\n            this._addObserver(this.options.observerOptions);\r\n        }\r\n\r\n        this.externalLayer = this.createExternalLayer();\r\n\r\n        if (layer._map) {\r\n            this._addEvent({target:{_map: layer._map}});\r\n            this._updateBbox();\r\n        }\r\n    },\r\n\r\n    _addObserver: function (opt) {\r\n        this._items = {};\r\n        this._observer = this.parentLayer.addObserver(\r\n            L.extend({\r\n                bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\r\n                callback: L.bind(this.updateData, this)\r\n            }, opt)\r\n        ).deactivate();\r\n    },\r\n\r\n    unbindLayer: function () {\r\n        this.parentLayer\r\n            .off('add', this._addEvent, this)\r\n            .off('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this._observer) { delete this.parentLayer.repaintObservers[this._observer.id]; }\r\n        var map = this._map || this.parentLayer._map;\r\n        this._onRemove(!map);\r\n        this._removeMapHandlers();\r\n    },\r\n\r\n    _addMapHandlers: function (map) {\r\n        this._map = map;\r\n        this._map.on({\r\n            moveend: this._updateBbox,\r\n            zoomend: this._chkZoom,\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        }, this);\r\n    },\r\n\r\n    _removeMapHandlers: function () {\r\n        if (this._map) {\r\n            this._map.off({\r\n                moveend: this._updateBbox,\r\n                zoomend: this._chkZoom,\r\n                layeradd: this._layeradd,\r\n                layerremove: this._layerremove\r\n            }, this);\r\n        }\r\n        this._map = null;\r\n    },\r\n\r\n    _addEvent: function (ev) {\r\n        this._addMapHandlers(ev.target._map);\r\n        this._updateBbox();\r\n        this._chkZoom();\r\n    },\r\n\r\n    _isParentLayer: function (ev) {\r\n        var layer = ev.layer;\r\n        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\r\n    },\r\n\r\n    _layeradd: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._chkZoom();\r\n        }\r\n    },\r\n\r\n    _layerremove: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._onRemove(true);\r\n            this._removeMapHandlers();\r\n        }\r\n    },\r\n\r\n    _onRemove: function (fromMapFlag) {    // remove external layer from parent layer\r\n        if (this._observer) {\r\n            this._observer.deactivate();\r\n        }\r\n        var map = this._map;\r\n        if (map) {\r\n            if (map.hasLayer(this.externalLayer)) {\r\n                this._chkZoom();\r\n                map.removeLayer(this.externalLayer);\r\n            }\r\n            if (!fromMapFlag) {\r\n                this.parentLayer.onAdd(map);\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkZoom: function () {\r\n        if (!this._map) { return; }\r\n\r\n        var layer = this.parentLayer,\r\n            observer = this._observer,\r\n            map = this._map,\r\n            isExtLayerOnMap = map.hasLayer(this.externalLayer);\r\n\r\n        layer.setCurrentZoom(map);\r\n        if (!this.isExternalVisible(map.getZoom())) {\r\n            if (observer) { observer.deactivate(); }\r\n            if (!layer._map) {\r\n                if (isExtLayerOnMap) {\r\n                    map.removeLayer(this.externalLayer);\r\n                }\r\n                layer.onAdd(map);\r\n            }\r\n            layer.enablePopup();\r\n        } else if (layer._map) {\r\n            layer.onRemove(map);\r\n            if (!isExtLayerOnMap) {\r\n                map.addLayer(this.externalLayer);\r\n            }\r\n            this.setDateInterval();\r\n            if (observer) {\r\n                layer.getIcons(function () {\r\n                    observer.activate();\r\n                }.bind(this));\r\n            }\r\n            layer.disablePopup();\r\n        }\r\n    },\r\n\r\n\r\n    _updateBbox: function () {\r\n        if (!this._map || !this._observer) { return; }\r\n\r\n        var screenBounds = this._map.getBounds(),\r\n            p1 = screenBounds.getNorthWest(),\r\n            p2 = screenBounds.getSouthEast(),\r\n            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\r\n        this._observer.setBounds(bbox);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/ExternalLayer.js","(function() {\r\n    'use strict';\r\n    var BindWMS = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minZoom: 1,\r\n            maxZoom: 6,\r\n            useDataManager: false,\r\n            format: 'png',\r\n            transparent: true\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var poptions = this.parentLayer.options,\r\n                opt = {\r\n                    map: poptions.mapID,\r\n                    layers: poptions.layerID,\r\n                    format: this.options.format,\r\n                    transparent: this.options.transparent\r\n                },\r\n                rawProperties = this.parentLayer.getGmxProperties();\r\n\r\n            if (rawProperties && rawProperties.Temporal) { this._extendOptionsByDateInterval(opt); }\r\n            if (this.options.apikey) { opt.apikey = this.options.apikey; }\r\n            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\r\n        },\r\n\r\n        _extendOptionsByDateInterval: function (options) {\r\n            var dateInterval = this.parentLayer.getDateInterval(),\r\n                beginDate = dateInterval.beginDate,\r\n                endDate = dateInterval.endDate;\r\n            L.extend(options, {\r\n                StartDate: beginDate && beginDate.toLocaleDateString(),\r\n                EndDate: endDate && endDate.toLocaleDateString()\r\n            });\r\n        },\r\n\r\n        setDateInterval: function () {\r\n            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\r\n            this.externalLayer.redraw();\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindWMS: function (options) {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n            }\r\n            this._layerWMS = new BindWMS(options, this);\r\n            this.isExternalVisible = this._layerWMS.isExternalVisible;\r\n            return this;\r\n        },\r\n\r\n        unbindWMS: function () {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n                this._layerWMS = null;\r\n                this.isExternalVisible = null;\r\n                this.enablePopup();\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/BindWMS.js","(function() {\r\n    'use strict';\r\n    var GmxHeatMap = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minHeatMapZoom: 1,\r\n            maxHeatMapZoom: 6,\r\n            intensityField: '',\r\n            intensityScale: 1,\r\n            observerOptions: {\r\n                type: 'resend'\r\n            }\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            return L.heatLayer([], L.extend({\r\n                 // minOpacity: 0.05,\r\n                 // maxZoom: 18,\r\n                 // radius: 25,\r\n                 // blur: 15,\r\n                 // max: 1.0\r\n            }, this.options));\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            if (data.added) {\r\n                var latlngs = [],\r\n                    indexes = this.parentLayer.getTileAttributeIndexes(),\r\n                    altIndex = null,\r\n                    intensityField = this.options.intensityField || '',\r\n                    intensityScale = this.options.intensityScale || 1;\r\n\r\n                if (intensityField && intensityField in indexes) {\r\n                    altIndex = indexes[intensityField];\r\n                }\r\n                for (var i = 0, len = data.added.length; i < len; i++) {\r\n                    var it = data.added[i].properties,\r\n                        alt = altIndex !== null ? it[altIndex] : 1,\r\n                        geo = it[it.length - 1],\r\n                        coord = geo.coordinates,\r\n                        point = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n\r\n                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\r\n                }\r\n                this.externalLayer.setLatLngs(latlngs);\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindHeatMap: function (options) {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                }\r\n                this._heatmap = new GmxHeatMap(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindHeatMap: function () {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                    this._heatmap = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/HeatMap.js","(function() {\r\n    'use strict';\r\n    var _DEFAULTS = {\r\n        radiusFunc: function (count) {\r\n            var r = Math.floor(count / 15);\r\n            if (r > 40) {\r\n                r = 40;\r\n            } else if (r < 20) {\r\n                r = 20;\r\n            }\r\n            return r;\r\n        },\r\n        text: {\r\n            stroke: 'black',\r\n            'stroke-width': 1,\r\n            'text-anchor': 'middle',\r\n            fill: 'white'\r\n        }\r\n    };\r\n    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            observerOptions: {\r\n                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\r\n            },\r\n            spiderfyOnMaxZoom: true,\r\n            minZoom: 1,\r\n            maxZoom: 6\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var mOptions = L.extend({\r\n                showCoverageOnHover: false,\r\n                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\r\n            }, this.options);\r\n\r\n            if ('clusterIconOptions' in this.options) {\r\n                var opt = this.options.clusterIconOptions;\r\n                if ('radialGradient' in opt) {\r\n                    var radialGradient = opt.radialGradient,\r\n                        text = opt.text || _DEFAULTS.text;\r\n                    mOptions.iconCreateFunction = function (cluster) {\r\n                        var childCount = cluster.getChildCount();\r\n\r\n                        text.count = childCount;\r\n                        return  L.gmxUtil.getSVGIcon({\r\n                            type: 'circle',\r\n                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\r\n                            text: text,\r\n                            fillRadialGradient: radialGradient\r\n                        });\r\n                    };\r\n                }\r\n            }\r\n\r\n            if (this.options.clusterclick) {\r\n                mOptions.clusterclick = this.options.clusterclick;\r\n                if (mOptions.clusterclick === true) { mOptions.zoomToBoundsOnClick = false; }\r\n            }\r\n\r\n            this._popup = new L.Popup({maxWidth: 10000, className: 'gmxPopup'});\r\n            var markers = new L.MarkerClusterGroup(mOptions);\r\n\r\n            // текущий развёрнутый кластер\r\n            var currentSpiderfiedCluster = null;\r\n\r\n            markers\r\n                .on('click', function (ev) {\r\n                    var propsArr = ev.layer.options.properties,\r\n                        properties = this.parentLayer.getItemProperties(propsArr),\r\n                        geometry = [propsArr[propsArr.length - 1]],\r\n                        id = propsArr[0];\r\n\r\n                    if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\r\n                        currentSpiderfiedCluster.unspiderfy();\r\n                        markers.once('unspiderfied', function () {\r\n                            this._openPopup(propsArr, ev.latlng);\r\n                        }, this);\r\n                    } else {\r\n                        this._openPopup(propsArr, ev.latlng);\r\n                    }\r\n\r\n                    this.parentLayer.fire('click', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'click',\r\n                        gmx: {\r\n                            id: id,\r\n                            layer: this.parentLayer,\r\n                            properties: properties,\r\n                            target: {\r\n                                id: id,\r\n                                properties: propsArr,\r\n                                geometry: geometry\r\n                            }\r\n                        }\r\n                    }));\r\n                }, this)\r\n                .on('animationend', function () {\r\n                    if (this._popup && this._popup._map) {\r\n                        this._popup._map.removeLayer(this._popup);\r\n                    }\r\n                }, this)\r\n                .on('clusterclick', function (ev) {\r\n                    this.parentLayer.fire('clusterclick', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'clusterclick'\r\n                    }));\r\n                }, this)\r\n                .on('spiderfied', function (ev) {\r\n                    currentSpiderfiedCluster = ev.cluster;\r\n                }, this)\r\n                .on('unspiderfied', function () {\r\n                    currentSpiderfiedCluster = null;\r\n                }, this);\r\n\r\n            if (mOptions.clusterclick) {\r\n                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\r\n                    a.layer.spiderfy();\r\n                });\r\n            }\r\n\r\n            return markers;\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            var arr = [],\r\n                i, len, vectorTileItem, id, marker;\r\n            if (data.removed) {\r\n                for (i = 0, len = data.removed.length; i < len; i++) {\r\n                    vectorTileItem = data.removed[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    if (marker) {\r\n                        arr.push(marker);\r\n                    }\r\n                    delete this._items[id];\r\n                }\r\n                this.externalLayer.removeLayers(arr);\r\n                arr = [];\r\n            }\r\n            if (data.added) {\r\n                for (i = 0, len = data.added.length; i < len; i++) {\r\n                    vectorTileItem = data.added[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    var item = vectorTileItem.properties;\r\n                    if (marker && item.processing) {\r\n                        this.externalLayer.removeLayer(marker);\r\n                        marker = null;\r\n                    }\r\n                    if (!marker) {\r\n                        if (!vectorTileItem.item.parsedStyleKeys) {\r\n                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\r\n                        }\r\n                        var geo = item[item.length - 1],\r\n                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\r\n                            p = geo.coordinates,\r\n                            latlng = L.Projection.Mercator.unproject({x: p[0], y: p[1]}),\r\n                            opt = {\r\n                                properties: vectorTileItem.properties,\r\n                                mPoint: p\r\n                            };\r\n\r\n                        if (this.options.notClusteredIcon) {\r\n                            var icon = this.options.notClusteredIcon;\r\n                            if (icon instanceof L.Icon) {\r\n                                opt.icon = icon;\r\n                            } else {\r\n                                opt.icon = L.icon(icon);\r\n                            }\r\n                        } else if (parsedStyle) {\r\n                            if (parsedStyle.iconUrl) {\r\n                                var iconAnchor = parsedStyle.iconAnchor;\r\n                                if (!iconAnchor) {\r\n                                    var style = this.parentLayer.getItemStyle(id);\r\n                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\r\n                                }\r\n                                opt.icon = L.icon({\r\n                                    iconAnchor: iconAnchor,\r\n                                    iconUrl: parsedStyle.iconUrl\r\n                                });\r\n                            } else {\r\n                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\r\n                            }\r\n                        }\r\n                        if (parsedStyle.rotate) {\r\n                            marker = L.rotatedMarker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        } else {\r\n                            marker = L.marker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        }\r\n                        this._items[id] = marker;\r\n                    }\r\n                    arr.push(marker);\r\n                }\r\n                this.externalLayer.addLayers(arr);\r\n            }\r\n        },\r\n\r\n        _openPopup: function (propsArr, latlng) {\r\n            var gmx = this.parentLayer._gmx,\r\n                id = propsArr[0],\r\n                balloonData = gmx.styleManager.getItemBalloon(id),\r\n                properties = this.parentLayer.getItemProperties(propsArr),\r\n                geometry = [propsArr[propsArr.length - 1]];\r\n\r\n            if (balloonData && !balloonData.DisableBalloonOnClick) {\r\n                var style = this.parentLayer.getItemStyle(id);\r\n                if (style && style.iconAnchor) {\r\n                    var protoOffset = L.Popup.prototype.options.offset;\r\n                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2,\r\n                        protoOffset[1] - style.iconAnchor[1] + style.sy / 2\r\n                    ];\r\n                }\r\n                this._popup\r\n                    .setLatLng(latlng)\r\n                    .setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\r\n                        properties: properties,\r\n                        tileAttributeTypes: gmx.tileAttributeTypes,\r\n                        unitOptions: this._map.options || {},\r\n                        geometries: geometry\r\n                    }))\r\n                    .openOn(this._map);\r\n            }\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindClusters: function (options) {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                }\r\n                this._clusters = new GmxMarkerCluster(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindClusters: function () {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                    this._clusters = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/MarkerCluster.js","L.gmx = L.gmx || {};\r\nimport {gmxAPIutils} from './Utils.js';\r\n\r\nvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\r\nvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\r\n\r\n//Build in layer classes\r\nL.gmx._layerClasses = {\r\n    'Raster': L.gmx.RasterLayer,\r\n    'Vector': L.gmx.VectorLayer,\r\n    'VectorView': L.gmx.DummyLayer\r\n};\r\n\r\nL.gmx._loadingLayerClasses = {};\r\n\r\nL.gmx.addLayerClass = function(type, layerClass) {\r\n    L.gmx._layerClasses[type] = layerClass;\r\n};\r\n\r\nL.gmx._layerClassLoaders = [];\r\n\r\nL.gmx.addLayerClassLoader = function(layerClassLoader) {\r\n    L.gmx._layerClassLoaders.push(layerClassLoader);\r\n\r\n    //delete all loading promises to ensure that new loader will be invoked\r\n    L.gmx._loadingLayerClasses = {};\r\n};\r\n\r\nL.gmx._loadLayerClass = function(type) {\r\n    if (!L.gmx._loadingLayerClasses[type]) {\r\n        var promise = new L.gmx.Deferred();\r\n        promise.resolve();\r\n\r\n        L.gmx._layerClassLoaders.forEach(function(loader) {\r\n            promise = promise.then(function(layerClass) {\r\n                if (layerClass) {\r\n                    L.gmx._layerClasses[type] = layerClass;\r\n                    return layerClass;\r\n                }\r\n\r\n                return loader(type);\r\n            },\r\n            function(){\r\n                //just skip loader errors\r\n            });\r\n        });\r\n\r\n        promise = promise.then(function(layerClass) {\r\n            if (layerClass) {\r\n                L.gmx._layerClasses[type] = layerClass;\r\n                return layerClass;\r\n            }\r\n        }, function(){\r\n            //just skip loader errors\r\n        });\r\n\r\n        L.gmx._loadingLayerClasses[type] = promise;\r\n    }\r\n\r\n    return L.gmx._loadingLayerClasses[type];\r\n};\r\n\r\nL.gmx.loadLayer = function(mapID, layerID, options) {\r\n\r\n    var promise = new L.gmx.Deferred(),\r\n        layerParams = {\r\n            mapID: mapID,\r\n            layerID: layerID\r\n        };\r\n\r\n    options = options || {};\r\n\r\n    for (var p in options) {\r\n        layerParams[p] = options[p];\r\n    }\r\n\r\n    var hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n    layerParams.hostName = hostName;\r\n\r\n    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(\r\n        function() {\r\n            var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\r\n\r\n            if (!layerInfo) {\r\n                promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\r\n                return;\r\n            }\r\n\r\n            //to know from what host the layer was loaded\r\n            layerInfo.properties.hostName = hostName;\r\n\r\n            var type = layerInfo.properties.ContentID || layerInfo.properties.type;\r\n\r\n            var doCreateLayer = function() {\r\n                var layer = L.gmx.createLayer(layerInfo, layerParams);\r\n                if (layer) {\r\n                    promise.resolve(layer);\r\n                } else {\r\n                    promise.reject('Unknown type of layer ' + layerID);\r\n                }\r\n            };\r\n\r\n            if (type in L.gmx._layerClasses) {\r\n                doCreateLayer();\r\n            } else {\r\n                L.gmx._loadLayerClass(type).then(doCreateLayer);\r\n            }\r\n        },\r\n        function(response) {\r\n            promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\r\n        }\r\n    );\r\n\r\n    return promise;\r\n};\r\n\r\nL.gmx.loadLayers = function(layers, globalOptions) {\r\n    var defs = layers.map(function(layerInfo) {\r\n        var options = L.extend({}, globalOptions, layerInfo.options);\r\n        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\r\n    });\r\n\r\n    return L.gmx.Deferred.all.apply(null, defs);\r\n};\r\n\r\nL.gmx.loadMap = function(mapID, options) {\r\n    options = L.extend({}, options);\r\n    options.hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n\r\n    var def = new L.gmx.Deferred();\r\n\r\n    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function(mapInfo) {\r\n        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\r\n\r\n        loadedMap.layersCreated.then(function() {\r\n            if (options.leafletMap || options.setZIndex) {\r\n                var curZIndex = 0,\r\n                    layer, rawProperties;\r\n\r\n                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\r\n                    layer = loadedMap.layers[l];\r\n\t\t\t\t\trawProperties = layer.getGmxProperties();\r\n\t\t\t\t\tif (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\r\n                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\r\n                    }\r\n                    if (options.setZIndex && layer.setZIndex) {\r\n                        layer.setZIndex(++curZIndex);\r\n                    }\r\n\r\n                    if (options.leafletMap && rawProperties.visible) {\r\n                        layer.addTo(options.leafletMap);\r\n                    }\r\n                }\r\n            }\r\n            def.resolve(loadedMap);\r\n        });\r\n    },\r\n    function(response) {\r\n        var errorMessage = (response && response.ErrorInfo && response.ErrorInfo.ErrorMessage) || 'Server error';\r\n        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\r\n    });\r\n    return def;\r\n};\r\n\r\nL.gmx.DummyLayer = function(props) {\r\n    this.onAdd = this.onRemove = function() {};\r\n    this.getGmxProperties = function() { return props; };\r\n};\r\n\r\nL.gmx.createLayer = function(layerInfo, options) {\r\n    if (!layerInfo) { layerInfo = {}; }\r\n    if (!layerInfo.properties) { layerInfo.properties = {type: 'Vector'}; }\r\n\r\n    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\r\n        layer;\r\n\r\n\t\tif (type in L.gmx._layerClasses) {\r\n        try {\r\n            layer = new L.gmx._layerClasses[type](options);\r\n            layer = layer.initFromDescription(layerInfo);\r\n        } catch (e) {\r\n            layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n        }\r\n    } else {\r\n        layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n    }\r\n\r\n    return layer;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/LayerFactory.js","/** GeoMixer virtual layer for standard tile raster layers (L.TileLayer)\r\n*/\r\n(function (){\r\n\r\n'use strict';\r\n\r\n//this function is copied from L.Utils and modified to allow missing data attributes\r\nvar template = function (str, data) {\r\n    return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n        var value = data[key];\r\n        if (value === undefined) {\r\n            value = '';\r\n        } else if (typeof value === 'function') {\r\n            value = value(data);\r\n        }\r\n        return value;\r\n    });\r\n};\r\n\r\nvar GmxVirtualTileLayer = function() {}\r\n\r\nGmxVirtualTileLayer.prototype.initFromDescription = function(layerDescription) {\r\n    var props = layerDescription.properties,\r\n        meta = props.MetaProperties,\r\n        urlTemplate = meta['url-template'] && meta['url-template'].Value,\r\n        isMercator = !!meta['merc-projection'],\r\n        options = {};\r\n\r\n    if (!urlTemplate) {\r\n        return new L.gmx.DummyLayer(props);\r\n    }\r\n\r\n    if (props.Copyright) {\r\n        options.attribution = props.Copyright;\r\n    }\r\n\r\n    if (meta.minZoom) {\r\n        options.minZoom = meta.minZoom.Value;\r\n    }\r\n\r\n    if (meta.maxZoom) {\r\n        options.maxZoom = meta.maxZoom.Value;\r\n    }\r\n\r\n    var layer = (isMercator ? L.tileLayer.Mercator : L.tileLayer)(urlTemplate, options);\r\n\r\n    layer.getGmxProperties = function() {\r\n        return props;\r\n    }\r\n\r\n    return layer;\r\n}\r\n\r\nL.gmx.addLayerClass('TMS', GmxVirtualTileLayer);\r\n\r\n//depricated - use \"TMS\" instead\r\nL.gmx.addLayerClass('TiledRaster', GmxVirtualTileLayer);\r\n\r\nvar GmxVirtualWMSLayer = function() {}\r\n\r\nGmxVirtualWMSLayer.prototype.initFromDescription = function(layerDescription) {\r\n    var WMS_OPTIONS = ['layers', 'styles', 'format', 'transparent', 'version', 'minZoom', 'maxZoom', 'tileSize', 'f', 'bboxSR', 'imageSR', 'size'];\r\n    var WMS_OPTIONS_PROCESSORS = {tileSize: parseInt};\r\n    var props = layerDescription.properties,\r\n        meta = props.MetaProperties,\r\n        baseURL = meta['base-url'] && meta['base-url'].Value,\r\n        options = {};\r\n\r\n    if (!baseURL) {\r\n        return new L.gmx.DummyLayer(props);\r\n    }\r\n\r\n    if (props.Copyright) {\r\n        options.attribution = props.Copyright;\r\n    }\r\n\r\n    for (var p in meta) {\r\n        if (WMS_OPTIONS.indexOf(p) !== -1) {\r\n            options[p] = WMS_OPTIONS_PROCESSORS[p] ? WMS_OPTIONS_PROCESSORS[p](meta[p].Value) : meta[p].Value;\r\n        }\r\n    }\r\n\r\n    var layer = L.tileLayer.wms(baseURL, options);\r\n\r\n    layer.getGmxProperties = function() {\r\n        return props;\r\n    };\r\n\r\n    var balloonTemplate = meta['balloonTemplate'] && meta['balloonTemplate'].Value;\r\n    if (meta['clickable'] && balloonTemplate) {\r\n        layer.options.clickable = true;\r\n\r\n        layer.onRemove = function(map) {\r\n            lastOpenedPopup && map.removeLayer(lastOpenedPopup);\r\n            L.TileLayer.WMS.prototype.onRemove.apply(this, arguments);\r\n        }\r\n\r\n        var lastOpenedPopup;\r\n        layer.gmxEventCheck = function(event) {\r\n            if (event.type === 'click') {\r\n                var p = this._map.project(event.latlng),\r\n                    tileSize = layer.options.tileSize,\r\n                    I = p.x % tileSize,\r\n                    J = p.y % tileSize,\r\n                    tilePoint = p.divideBy(tileSize).floor(),\r\n                    url = this.getTileUrl(tilePoint);\r\n\r\n                url = url.replace('=GetMap', '=GetFeatureInfo');\r\n                url += '&X=' + I + '&Y=' + J + '&INFO_FORMAT=application/geojson&QUERY_LAYERS=' + options.layers;\r\n\r\n                fetch(url).then(function(geoJSON) {\r\n                // $.getJSON(url).then(function(geoJSON) {\r\n                    if (geoJSON.features[0]) {\r\n                        var html = template(balloonTemplate, geoJSON.features[0].properties);\r\n                        lastOpenedPopup = L.popup()\r\n                            .setLatLng(event.latlng)\r\n                            .setContent(html)\r\n                            .openOn(this._map);\r\n                    }\r\n                }.bind(this));\r\n            }\r\n\r\n            return 1;\r\n        };\r\n    }\r\n\r\n    return layer;\r\n}\r\n\r\nL.gmx.addLayerClass('WMS', GmxVirtualWMSLayer);\r\n\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/GmxVirtualTileLayer.js"],"sourceRoot":""}