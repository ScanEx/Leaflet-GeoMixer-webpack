{"version":3,"sources":["webpack:///dist/geomixer.js","webpack:///webpack/bootstrap 5b6cea09a4e9f0707831","webpack:///./src/includes.js","webpack:///./src/Parsers.js","webpack:///./src/Deferred.js","webpack:///./src/ImageLoader.js","webpack:///./src/Utils.js","webpack:///./src/DrawCanvas.js","webpack:///./src/SessionManager.js","webpack:///./src/MapManager.js","webpack:///./src/GeomixerMap.js","webpack:///./src/EventsManager.js","webpack:///./src/Locale.js","webpack:///./src/lang_ru.js","webpack:///./src/lang_en.js","webpack:///./src/DataManager/VectorTileLoader.js","webpack:///./src/DataManager/VectorTile.js","webpack:///./src/DataManager/Observer.js","webpack:///./src/DataManager/TilesTree.js","webpack:///./src/DataManager/DataManager.js","webpack:///./src/Layer/VectorLayer.js","webpack:///./src/Layer/StyleManager.js","webpack:///./src/Layer/ScreenVectorTile.js","webpack:///./src/Layer/ObjectsReorder.js","webpack:///./src/Layer/VectorLayer.Popup.js","webpack:///./src/Layer/VectorLayer.Hover.js","webpack:///./src/Layer/LayersVersion.js","webpack:///./src/Layer/RasterLayer.js","webpack:///./src/Layer/LabelsLayer.js","webpack:///./src/Layer/ClipPolygon.js","webpack:///./src/Layer/ImageTransform.js","webpack:///./src/Layer/ProjectiveImageWebGL.js","webpack:///./src/Layer/ProjectiveImage.js","webpack:///./src/Layer/external/RotatedMarker.js","webpack:///./src/Layer/external/ExternalLayer.js","webpack:///./src/Layer/external/BindWMS.js","webpack:///./src/Layer/external/HeatMap.js","webpack:///./src/Layer/external/MarkerCluster.js","webpack:///./src/LayerFactory.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","regexExpression","regexMath","Parsers","functionFromExpression","s","Function","replace","makePair","t1","t2","head","tail","LinkedList","ParserState","fail","failed","state","advance","n","token","tok","len","length","substr","caseInsensitiveToken","toLowerCase","range","startChar","endChar","startCode","charCodeAt","endCode","code","anythingExcept","parser","sequence","parsers","i","choice","newState","nothing","maybe","repeat","minCount","count","separatedList","separator","parser1","whitespace","whitespaceSeparatedList","whitespaceSeparatedSequence","newParsers","push","capture","action","func","oldState","fieldName","fieldNameWithSpaces","quotedFieldName","stringLiteral","digits","numberLiteral","literal","applyParser","opTerm","op","referenceValue","matchPattern","toUpperCase","fieldValue","_matchFrom","referenceIdx","fieldIdx","referenceChar","charAt","fieldChar","props","indexes","types","rValue","L","gmxUtil","getUnixTimeFromStr","f1","f2","parseFloat","inTerm","node","value","_term","_expression","notTerm","innerTerm","andExpression","flag","orExpression","whereClause","parseSQL","str","result","_additiveExpression","_multiplicativeExpression","pos","term","multiplicativeTerm","res","Math","floor","arithmeticExpression","parseExpression","svgPath","coords","reverse","parseSVGPath","gmx","Deferred","cancelFunc","fulfilledData","resolveCallbacks","rejectCallbacks","isFulfilled","isResolved","onceAdded","isCancelled","fulfill","this","_fulfill","resolved","callbacks","slice","arguments","forEach","callback","apply","resolve","concat","reject","cancel","then","resolveCallback","rejectCallback","userFuncDef","def","fulfillFunc","once","onceResolveCallback","always","getFulfilledData","all","defArray","resdef","left","results","Array","ImageRequest","url","options","_id","imageLoader","_cancelRequest","bind","remove","_removeRequestFromCache","GmxImageLoader","Class","extend","includes","Mixin","Events","statics","MAX_COUNT","initialize","curCount","requests","inProgress","requestsCache","uniqueID","_resolveRequest","request","image","canceled","cache","cacheItem","cacheKey","fire","_imageLoaded","resolveRequest","it","loaderStatus","_nextLoad","shift","k","splice","_loadImage","width","imageObj","Image","_this","crossOrigin","onload","onerror","src","loadingImg","Util","falseFn","emptyImageUrl","_clearCacheItem","Object","keys","_add","atBegin","unshift","defineProperty","_typeof","Symbol","iterator","obj","constructor","prototype","gmxAPIutils","lastMapId","newId","uniqueGlobalName","thing","window","isPageHidden","document","hidden","msHidden","webkitHidden","mozHidden","normalizeHostname","hostName","parsedHost","parseUri","host","directory","substring","getLayerItemFromServer","query","field","req","WrapStyle","geometry","layer","layerID","border","requestJSONP","serverBase","getCadastreFeatures","latlng","text","lat","lng","tolerance","getFormData","json","arr","key","val","JSON","stringify","join","params","script","createElement","setAttribute","callbackParamName","urlParams","gmxMapManager","syncParams","callbackName","paramsStringItems","encodeURIComponent","indexOf","e","parentNode","removeChild","getElementsByTagName","item","appendChild","getXmlHttp","xmlhttp","XMLHttpRequest","ActiveXObject","E","ph","xhr","open","type","async","headers","setRequestHeader","reqId","withCredentials","onreadystatechange","readyState","status","responseText","onError","getSyncParams","send","Error","tileSizes","getTileNumFromLeaflet","tilePoint","zoom","z","pz","pow","tx","x","ty","y","getTilePosZoomDelta","zoomFrom","zoomTo","dz","size","dx","dy","zDelta","geoItemBounds","geo","bounds","boundsArr","coordinates","b","arr1","j","len1","extendBounds","getUnFlattenGeo","isLikePolygon","coordsOut","isPolygon","ring","unFlattenRing","cnt","geoFlatten","flattenRing","CurArray","Float64Array","isRectangle","getGeometryBounds","pt","getMarkerPolygon","min","max","getQuicklookPointsFromProperties","pArr","tileAttributeIndexes","points","x1","getPropItem","quicklookX1","y1","quicklookY1","x2","quicklookX2","y2","quicklookY2","x3","quicklookX3","y3","quicklookY3","x4","quicklookX4","y4","quicklookY4","quicklookPlatform","merc","Projection","Mercator","project","latLng","getPropertiesHash","properties","dec2rgba","a","r","g","dec2hex","toString","dec2color","oneDay","isTileKeysIntersects","tk1","tk2","t","rotatePoints","angle","iconScale","center","out","PI","sin","cos","getPatternIcon","style","fillPattern","notFunc","pattern","prop","step","patternDefaults","minWidth","maxWidth","minStep","maxStep","patternStepFunction","patternWidthFunction","fillOpacity","opacityFunction","rgb","colors","resColors","col","patternColorsFunction","delta","allSize","rad","hh","ww","flagRotate","console","log","alert","canvas","height","ptx","getContext","clearRect","translate","rotate","beginPath","fillStyle","xx1","moveTo","lineTo","arc","fillRect","closePath","fill","canvas1","ptx1","drawImage","getSVGIcon","svg","Path","SVG_NS","stroke","strokeStyle","strokeWidth","lineWidth","iconOptions","className","iconSize","fillRadialGradient","stopColor","colorStop","addColorStop","html","DivIcon","toPixels","tpx","tpy","mInPixel","px1","py1","getPixelPoint","attr","currentStyle","parsedStyleKeys","iconCenter","sx","sy","weight","iconAnchor","px","py","worldWidthMerc","getImageData","img","isIE9","isIE10","data","DEFAULT_REPLACEMENT_COLOR","isIE","v","getIEversion","gtIE","ua","navigator","userAgent","msie","parseInt","trident","rv","edge","replaceColor","color","fromData","imageData","createImageData","toData","putImageData","drawIconPath","path","isArray","ctx","trFlag","radian","rotateRes","degRad","setTransform","pointToCanvas","pointAttr","px1sx","py1sy","iconPath","iconColor","globalAlpha","opacity","transformFlag","fillColor","circle","rgr","r2","radgrad","createRadialGradient","r1","strokeRect","lineToCanvasAsIcon","pixels","getLineDash","setLineDash","lineToCanvas","lastX","lastY","getCoordsPixels","hiddenLines","hiddenFlag","hash","coords1","hiddenLines1","pixels1","hidden1","j1","getRingPixels","currentZoom","cntHide","vectorSize","lineIsOnEdge","round","polygonToCanvas","polygonToCanvasFill","isPatternNode","HTMLCanvasElement","HTMLImageElement","labelCanvasContext","getLabelWidth","txt","font","split","map","fillText","measureText","setLabel","coord","shadowColor","shadowBlur","strokeText","rMajor","ang","distVincenty","lon1","lat1","lon2","lat2","p1","lon","p2","f","L1","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","lambda","lambdaP","iterLimit","abs","sinLambda","cosLambda","sinSigma","sqrt","cosSigma","sigma","atan2","sinAlpha","cosSqAlpha","cos2SigmaM","isNaN","C","NaN","uSq","A","B","deltaSigma","_vfi","fi","getCircleLatLngs","LatLng","R","d","Rd","VR","latlngs","limit","acos","asin","parseCoordinates","crs","regex","exec","match","ii","mul","SphericalMercator","unproject","Point","_divideBy","pad2","trunc","formatDegrees","format","a1","a2","a3","toPrecision","st","undefined","latLonFormatCoordinates","formatCoordinates","latLonFormatCoordinates2","formatCoordinates2","getPixelScale","forEachPoint","ret","getItemCenter","geoItems","isPoint","geom","dataOption","bbox","contains","len2","getHSegmentsInPolygon","poly","isGt1","isGt2","sort","index","segArr","isPointInPolygonArr","chkPoint","isIn","xmin","xmax","ymax","xinters","isPointInPolygonWithHoles","isClockwise","area","isPointInPolyLine","lineHeight","nullPoint","minx","maxx","miny","maxy","sqDist","LineUtil","_sqClosestPointOnSegment","isPointInLines","point","getLength","isMerc","prettifyDistance","km","gmxLocale","getText","geoJSONGetLength","geoJSON","geometries","features","getRingLength","lnglat","geoJSONGetArea","getRingArea","geoJSONGetLatLng","ipp","lambertCoefX","lambertCoefY","getArea","prettifyArea","km2","geoLength","geometryToGeoJSON","mercFlag","coordsFromMercator","convertGeometry","fromMerc","coordsToMercator","geoJSONtoGeometry","_coordsConvert","toMerc","resCoords","transformGeometry","geoArea","getGeoJSONSummary","unitOptions","units","squareUnit","distanceUnit","getCoordinatesString","num","formats","CRS","EPSG3857","getGeometriesSummary","coordinatesFormat","getGeometrySummary","chkOnEdge","ext","getHidden","tb","prev","getNormalizeBounds","screenBounds","mercDeltaY","northWest","getNorthWest","southEast","getSouthEast","minX","maxX","w","minX1","maxX1","m1","m2","m11","m12","prec","zn","getTileBounds","tileSize","parseTemplate","matches","key1","getDefaultBalloonTemplate","tileAttributeTypes","parseBalloonTemplate","attrToString","summary","styleKeys","marker","server","client","outline","label","styleFuncKeys","iconAngle","styleFuncError","defaultStyles","MinZoom","MaxZoom","Filter","Balloon","DisableBalloonOnMouseMove","DisableBalloonOnClick","RenderStyle","linestring","polygon","getDefaultStyle","from","toServerStyle","fromServerStyle","newKey","Number","trim","Date","UTC","getDateFromStr","dt","getUTCdate","utime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCtime","h","getUTCdateTime","time","getTileAttributes","attributes","attrs","attrTypes","identityField","Bounds","MAX_VALUE","extendArray","addBuffer","dxmin","dymin","dxmax","dymax","getCenter","addOffset","offset","intersects","min2","max2","intersectsWithDelta","isEqual","isNodeIntersect","clipPolygon","cp1","cp2","clip","inside","intersection","dc","dp","n1","n2","n3","outputList","inputList","clipPolyLine","angleFlag","codeB","lastCode","bitCode","getAngle","intersect","codeA","part","o","strictMode","uri","q","name","$0","$1","$2","hostOnly","authority","strict","loose","isIE11","gtIE11","createPostIframe2","uniqueId","lastRequestId","iframe","DomUtil","create","display","parsedURL","origin","protocol","location","processMessage","dataStr","decodeURIComponent","dataObj","parse","ev","Status","ErrorInfo","ErrorMessage","ExceptionType","StackTrace","CallbackName","DomEvent","on","sendCrossDomainPostRequest","baseForm","form","originalFormAction","getAttribute","target","Browser","ielt9","hiddenParamsDiv","paramName","input","body","submit","removeAttribute","_Utils","styleCanvasKeys","styleCanvasKeysLen","setCanvasStyle","valKey","dashArray","dashes","dashOffset","lineDashOffset","lineCap","lineJoin","canvasPattern","createPattern","fillLinearGradient","x1Function","y1Function","x2Function","y2Function","lineargrad","createLinearGradient","arrFunc","addColorStopFunctions","p0","drawGeoItem","geoItem","propsArr","idr","rasters","tbounds","styleHook","styleExtend","lastHover","geoType","dattr","lastImage","lastImageData","pixelsMap","flagPixels","coordsToCanvas","flagFill","bgImage","skipRasters","imagePattern","rasterOpacity","maxSize","save","restore","gmxSessionManager","APIKEY_PARAM","SCRIPT_REGEXP","_scriptSearched","_scriptAPIKey","_searchScriptAPIKey","scripts","parsedParam","requestSessionKey","serverHost","apiKey","_sessionKeys","Key","response","Result","getSessionKey","keyPromise","getMap","mapName","skipTiles","maps","_maps","promise","sessionKey","MapName","ModeKey","setSyncParams","stringFlag","findLayerInfo","mapID","hostMaps","mapInfo","layers","serverData","iterateLayers","layerInfo","treeInfo","iterate","content","children","gmxMap","commonLayerOptions","layersByTitle","layersByID","dataManagers","BaseLayers","rawTree","layersCreated","missingLayerTypes","dataSources","meta","MetaProperties","ContentID","layerOptions","dataSource","parentLayer","Value","info","_layerClasses","addLayer","createLayer","loaders","_loadLayerClass","hosts","opt","pId","pLayer","parentOptions","getGmxProperties","dataManager","DataManager","prefix","Layer","Layers","ids","addDataManager","DummyLayer","pid","getDataManager","title","removeLayer","addLayersToMap","leafletMap","l","visible","GmxEventsManager","Handler","_map","_layers","_lastLayer","_lastId","_drawstart","_lastCursor","isDrawing","gmxControlsManager","drawingControl","get","activeIcon","_container","cursor","getDomIndex","container","childNodes","skipNodeName","IMG","DIV","clearLastHover","gmxEventCheck","eventCheck","skipNode","originalEvent","gmxMouseDown","webkit","which","buttons","nodeName","hasClass","_animatingZoom","_skipClick","layerPoint","_gmxMouseLatLng","gmxMousePos","getPixelOrigin","add","la","lb","oa","ob","za","zIndexOffset","zIndex","zb","foundLayer","_animating","clickable","hasEventListeners","zoomend","setTimeout","click","dblclick","mousedown","mouseup","mousemove","contextmenu","layeradd","_leaflet_id","layerremove","Map","addInitHook","_gmxEventsManager","isGmxDrawing","removeHooks","DEFAULT_LANGUAGE","_setKeyText","lang","setLanguage","_language","getLanguage","language","gmxLocaleMixin","addText","newHash","k1","locale","keyArr","rus","Coordinates","Length","nodeLength","edgeLength","Area","Perimeter","nm","ha","m2html","km2html","eng","gmxVectorTileLoader","_loadedTiles","_getKey","ti","load","tileSenderPrefix","tileInfo","requestParams","LayerName","Level","Span","gmxAPI","_vectorTileReceiver","level","span","values","VectorTile","dataProvider","loadDef","dataOptions","isGeneralized","isFlatten","gmxTilePoint","vectorTileKey","makeTileKey","dateZero","beginDate","valueOf","endDate","addData","removeData","dataBounds","_parseItem","clear","needFlatten","edgeBounds","edgeArr","createTileKey","parseTileKey","gmxTileKey","boundsFromTileKey","Observer","_callback","_items","filters","targetZoom","active","setBounds","bbox1","world","dateInterval","_setDateInterval","hasFilter","filterName","activate","deactivate","toggleActive","isActive","updateData","prevItems","newItems","added","removed","tileKey","items","latLngBounds","sw","getSouthWest","ne","getNorthEast","minY","maxY","intersectsWithTile","tile","di","setDateInterval","isValid","temporalFilter","observer","TilesTree","_rootNodes","tiles","TemporalTiles","vers","TemporalVers","periods","TemporalPeriods","maxPeriod","smin","ZeroDate","getTime","getTimezoneOffset","zeroUT","addTile","pd","childrenCount","sChild","ds","pdOneDay","dmax","dmaxOneDay","cs","selectTiles","t1Val","t2Val","minLevel","dateIntervalLength","maxLevel","getCountOfIntersected","tileBounds","selectTilesForNode","nodes","childrenRes","intersectCount","resTilesArr","resNodesArr","resTiles","nodeSelection","resTilesHash","getNode","findNode","tilesTree","_VectorTile","_VectorTileLoader","ObserverTileLoader","_dataManager","_observerData","_tileData","addObserver","leftToLoad","loadingState","_updateObserver","removeObserver","obsTiles","tileId","observers","leftToLoadDelta","_tileLoadedCallback","tileObservers","obsInfo","removeTile","tileData","observerData","startLoadTiles","_getActiveTileKeys","obsData","getTileObservers","getObserverLoadingState","newObserverTiles","tilesVers","LayerVersion","GeoProcessing","Temporal","TemporalColumnName","setOptions","_clearProcessing","processingTile","_chkProcessing","optionsLink","_isTemporalLayer","tileAttributes","_needCheckActiveTiles","_vectorTileDataProviderLoad","clearVersion","_tilesTree","_activeTileKeys","_endDate","_beginDate","_tiles","_filters","_freeSubscrID","_observers","_needCheckDateInterval","_vectorTileDataProvider","_observerTileLoader","event","_updateItemsFromTile","treeNode","needRefresh","getItems","addFilter","unixTimeStamp","dates","_chkMaxDateInterval","newTileKeys","initTilesTree","_updateActiveTilesList","initTilesList","_getObserversByFilterName","oKeys","filterFunc","_triggerObservers","removeFilter","oId","resItems","filter","putData","getItem","isFiltered","activeTileKeys","tkey","geomIndex","processing","currentFilter","fromTiles","getMaxDateInterval","newBeginDate","newEndDate","_waitCheckObservers","checkObserver","getActiveObserversCount","getObserver","getItemsBounds","_itemsBounds","getItemMembers","members","objIndex","getItemGeometries","geomItems","checkObservers","_checkObserversTimer","clearTimeout","_removeDataFromObservers","preloadTiles","dateBegin","dateEnd","tileKeys","loadingDefs","_getVectorTile","newTilesList","_tileFilteringHook","filteredTilesList","tk","oldTilesList","observersToUpdate","_rasterVectorTile","checkSubscription","vKey","observerIds","sid","_propertiesToArray","fromServerProps","needProcessingFilter","skip","Deleted","Inserted","Updated","enableGeneralization","_resetTilesTree","disableGeneralization","updateVersion","_getDataKeys","chkKeys","_getProcessingTile","vTile","createFlag","_addVectorTile","_getGeneralizedTileKeys","vTilePoint","temp","gKey","newActiveTileKeys","tKey","tHash","generalizedKeys","newTiles","gKeys","gPoint","setTileFilteringHook","filteringHook","removeTileFilteringHook","_StyleManager","_ScreenVectorTile","VectorLayer","TileLayer","Canvas","openPopups","minZoom","useWebGL","initPromise","_drawQueue","_drawQueueHash","_drawInProgress","_anyDrawings","repaintObservers","_gmx","sortItems","styles","tileSubscriptions","_tilesToLoad","shiftXlayer","shiftYlayer","renderHooks","preRenderHooks","_needPopups","_clearTileSubscription","zKey","_removeTile","tileLink","el","onAdd","EPSG3395","shiftY","applyShift","getZoom","styleManager","initStyles","_zoomStart","_zoomEnd","_moveEnd","pointerEvents","balloonEnable","_popup","bindPopup","_onStyleChange","_onVersionChange","layersVersion","onRemove","off","viewreset","_reset","moveend","_update","_animated","zoomanim","_animateZoom","_endZoomAnim","updateWhenIdle","_limitedUpdate","_clearAllSubscriptions","_initContainer","_prpZoomData","setZIndexOffset","_updateZIndex","isExternalVisible","_zoom","deferred","__update","_addTile","myLayer","layerType","isVisibleAtZoom","_tileLoaded","_tileCoordsToKey","isDrawnFirstTime","done","getStyleBounds","_drawTileAsync","_chkDrawingState","_getLoadedTilesPercentage","_tileComplete","addClass","_tileContainer","_setClearBgBuffer","_tileOnLoad","_tileOnError","tileDrawn","_getTiledPixelBounds","shiftPoint","shiftX","pixelCenter","_tileZoom","_floor","halfSize","getSize","divideBy","subtract","_pxBoundsToTileRange","_round","initFromDescription","_initDone","worldSize","rawProperties","_updateProperties","StyleManager","maxZoom","chkUpdate","_objectsReorderInit","clusters","bindClusters","redraw","setRasterOpacity","repaint","getStyles","getIcons","setStyles","clearStyles","setStyle","getStyle","setStyleHook","removeStyleHook","setRasterHook","rasterProcessingHook","removeRasterHook","setFilter","maxShownPeriod","msecPeriod","gmxSkipTiles","UseTiles","now","getDateInterval","setPositionOffset","getPositionOffset","zKeys","redrawItem","gmxTiles","_getTilesByBounds","gmxGetCanvasTile","_getTile","current","_tilePoint","appendTileToContainer","tilePos","_getTilePos","setPosition","chrome","android23","getStylesByProperties","propArray","getCurrentFilters","getItemStyle","getObjStyle","getTileAttributeTypes","getTileAttributeIndexes","getItemBalloon","getItemProperties","addPreRenderHook","renderHook","removePreRenderHook","hook","addRenderHook","removeRenderHook","getBounds","proj","gmxBounds","LatLngBounds","getGeometry","latLngGeometry","subscription","screenTile","destructor","zoomstart","setCurrentZoom","unbindPopup","_updateZoomLevels","labelsLayer","_labelsLayer","parsedKey","_removeInProgressDrawing","queue","isEmpty","drawNextTile","queueItem","drawDef","_gmxDrawTile","tp","gtp","elem","_updateShiftY","deltaY","zd","_clearBgBufferTimer","_bgBuffer","_clearBgBuffer","_getNeedPopups","pixelBounds","tileRange","_getWrapTileNum","_chkTileSubscriptions","_getScreenTile","ScreenVectorTile","cancelled","screenTileDrawPromise","drawTile","minLatLng","maxLatLng","getPixelBounds","minPoint","maxPoint","apikeyRequestHost","GeometryType","minZoomRasters","RCMinZoomForRasters","minZoomQuicklooks","ZIndexField","zIndexField","_objectsReorder","shiftXfield","shiftYfield","multiFilters","IsRasterCatalog","layerLink","GMX_RasterCatalogID","rasterBGfunc","Quicklook","quicklookParams","template","X1","Y1","X2","Y2","X3","Y3","X4","Y4","quicklookBGfunc","reg","imageQuicklookProcessingHook","gmxImageTransform","attribution","Copyright","getViewRasters","itemsView","propArr","_maxVersion","_maxStyleSize","_styles","_deferredIcons","_parserFunctions","_serverStylesParsed","Infinity","_getMaxStyleSize","_needLoadIcons","MAX_STYLE_SIZE","maxShift","mercSize","HoverStyle","_chkReady","_chkStyleFilter","_parseServerStyles","_getImageSize","getStyleKeys","filterFunction","version","common","_changeStylesVersion","_prepareItem","DEFAULT_KEYS","_parseStyle","_checkStyles","templateBalloon","isSummary","test","hoverDiff","styleVersion","parsedStyleHover","_itemStyleParser","iconUrl","fillIconUrl","offsetWidth","offsetHeight","scaleFunction","rotateFunction","toFixed","fnum","curr","needParse","_lastZoom","parsed","parsedHover","styleHover","parsedStyle","DEFAULT_STYLE","gmxStyle","hoveredStyle","thickness","_isLabel","BalloonEnable","checkDiff","renderStyle","fkey","parsePattern","iconCircle","DEFAULT_ICONPATH","parseRadialGradient","parseLinearGradient","labelTemplate","labelField","itemType","iconColorFunction","r1Function","r2Function","r2max","p3","_radialGradientParsed","sizeFunction","colorFunction","fop","fc","fcDec","fillColorFunction","fillOpacityFunction","labelText","labelAnchor","rt","st1","rg","resFunc","lg","utils","showRaster","rasterRequests","_uniqueID","badTiles","_loadTileRecursive","urlFunction","currentUrl","requestPromise","tryLoad","rUrl","tryHigherLevelTile","maxNativeZoom","tileRastersId","_rasterHook","source","sourceTilePoint","destinationTilePoint","destination","quicklook","_defaultRasterHook","sh","dw","dh","_getShiftPixels","_getShiftTilesArray","deltaX","tminX","tminY","rminX","rmaxX","rminY","rmaxY","_getItemRasters","recursiveLoaders","mainRasterLoader","isShift","urlBG","itemImageProcessingHook","isTiles","resCanvas","imageItem","itemRasterPromise","tileToLoadPoints","chkReadyRasters","skipRasterFunc","onLoadFunction","isImage","posInfo","hookResult","resImage","loader","loadResult","imageLoaded","imgAttr","prepareItem","imageElement","_getVisibleItems","_tileCanvas","dm","imageSmoothingEnabled","_getNeedRasterItems","platform","_getTileRasters","itemPromises","itemRasters","needLoadRasters","_chkItems","tLink","getSortedItems","_cancelRastersPromise","rastersPromise","drawPromise","currentDrawPromise","_preRenderPromise","_renderPromise","_drawDone","_zKey","doDraw","hookInfo","hookBgImage","hover","hookTile","_clearCache","MAX","ObjectsReorder","userSetSortFunc","sortFunc","disabled","addToReorder","bottomFlag","clickFunc","ctrlKey","reorder","ap","bp","resetSortFunc","include","getReorderArrays","top","bottom","bringToTopItem","bringToBottomItem","clearReorderArrays","setReorderArrays","setSortFunc","disableFlip","enableFlip","popupOptions","layerId","Popup","setContent","_initContent","_state","_popupHandlersAdded","_openClickPopup","_movePopup","_overPopup","_outPopup","_chkNeedOpenPopup","popupopen","_popupopen","updateLayout","_updateLayout","addPopup","disablePopup","_popupDisabled","enablePopup","openPopup","_latlng","_latlngs","_openPopup","closePopup","_close","popup","_gmxID","_setPopupContent","setLatLng","prevId","_callBalloonHook","div","spans","hooksCount","_balloonHook","hookID","fid","notFound","balloonData","skipSummary","outItem","nodePoint","protoOffset","contentNode","_contentNode","containerPoint","HTMLElement","resStr","contentDiv","innerHTML","getContent","altKey","shiftKey","layerProp","notSkip","_gmxPopups","maxPopupCount","_gmxPopupsInit","_clearPopup","reduce","closeOnClick","autoPan","objectId","addTo","_closeButton","closeStyle","visibility","marginBottom","flagPopup","getPopups","getHoverOption","addPopupHook","stamp","removePopupHook","_gmxFirstObjectsByPoint","mercPoint","radius","objBounds","chktype","pBounds","isPointInClipPolygons","skipOver","chkHover","evType","fromType","_subtract","mercatorPoint","observerOptions","changed","targets","lastMouseover","doubleClickZoom","disable","enable","delay","dataManagersLinks","intervalID","timeoutID","lastLayersStr","isExistsTiles","tilesKey","getParams","layerDateInterval","Name","Version","maxDateInterval","getRequestParams","skipItems","isDataManager","chkVersion","processResponse","curLayer","chkHost","layersStr","Content-type","timeStamp","_stampVersionRequest","removeDataManager","pOptions","_chkVersion","start","stop","clearInterval","msec","setInterval","layerDescription","RasterLayer","vectorProperties","vectorDataProvider","objects","itemBounds","ww2","bboxArr","it1","it2","setZoomBounds","LabelsLayer","pane","_styleManagers","_labels","chkData","labels","fieldType","String","arrTxtWidth","fontSize","labelFontSize","labelStyle","labelHaloColor","labelColor","labelAlign","pstyle","_updateBbox","_layeradd","_layerremove","_frame","requestAnimFrame","_redraw","_addToPane","getPanes","insertBefore","_canvas","firstChild","_initCanvas","zoomAnimation","any3d","animated","southWest","northEast","_ctxShift","mapSize","latLngToContainerPoint","topLeft","containerPointToLayerPoint","w2","width2","size2","scale","getZoomScale","pixelBoundsMin","_getCenterOffset","_multiplyBy","_getMapPanePos","multiplyBy","TRANSFORM","getTranslateString","isBoundsIntersects","clipPolygons","isObserverIntersects","_isPointInClipPolygons","j2","len3","getClipPolygonItem","clipTileByPolygon","i1","_clipPolygons","addClipPolygon","Polygon","toGeoJSON","GeoJSON","getLayers","feature","MultiPolygon","removeClipPolygon","boundsP","itbounds","wMerc","shiftPoints","ProjectiveImage","projectiveImageWebGL","projectiveImage","getCanvas","wView","hView","adj","multmm","cij","multmv","basisToPoints","ProjectiveImageWebGL","antialias","depth","preserveDrawingBuffer","shaderVS","shaderFS","glOpts","gl","glResources","_setupGlContext","_getShader","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","useProgram","vertices","Float32Array","vertexBuffer","createBuffer","vertAttrib","getAttribLocation","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","transMatUniform","getUniformLocation","samplerUniform","screenTexture","createTexture","_bindTexture","texture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","dstPoints","Utils","general2DProjection","viewport","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","uniformMatrix4fv","activeTexture","TEXTURE0","uniform1i","drawArrays","TRIANGLE_STRIP","to","getWebGlResources","patchSize","transform","allocate","Matrix","cloneValues","clone","operand","transformProjectiveVector","iz","multiply","accum","rowEchelon","yp","pivot","ys","tmpRow","factor","invert","getProjectiveTransform","eqMatrix","kernel","divide","u1","v1","u4","v4","p4","d1","d2","d3","umid","vmid","pmid","pb","pl","pr","d12","d24","d43","d31","a4","amax","padx","pady","du","dv","iw","ih","ptl","ptr","pbl","pbr","RotatedMarker","Marker","TRANSFORM_ORIGIN","testProp","_initIcon","_icon","_getTransformOrigin","icon","_setPos","ie","costheta","sintheta","setAngle","rotatedMarker","ExternalLayer","createExternalLayer","_observer","useDataManager","_addEvent","_addObserver","externalLayer","unbindLayer","_onRemove","_removeMapHandlers","_addMapHandlers","_chkZoom","_isParentLayer","fromMapFlag","hasLayer","isExtLayerOnMap","BindWMS","transparent","poptions","_extendOptionsByDateInterval","apikey","tileLayer","wms","StartDate","toLocaleDateString","EndDate","wmsParams","bindWMS","_layerWMS","unbindWMS","GmxHeatMap","minHeatMapZoom","maxHeatMapZoom","intensityField","intensityScale","heatLayer","altIndex","alt","setLatLngs","bindHeatMap","_heatmap","unbindHeatMap","_DEFAULTS","radiusFunc","stroke-width","text-anchor","GmxMarkerCluster","spiderfyOnMaxZoom","mOptions","showCoverageOnHover","disableClusteringAtZoom","clusterIconOptions","radialGradient","iconCreateFunction","cluster","childCount","getChildCount","clusterclick","zoomToBoundsOnClick","markers","MarkerClusterGroup","currentSpiderfiedCluster","getAllChildMarkers","unspiderfy","eventFrom","originalEventType","spiderfy","vectorTileItem","removeLayers","mPoint","notClusteredIcon","Icon","addLayers","openOn","_clusters","unbindClusters","DEFAULT_HOSTNAME","DEFAULT_VECTOR_LAYER_ZINDEXOFFSET","Raster","Vector","VectorView","_loadingLayerClasses","addLayerClass","layerClass","_layerClassLoaders","addLayerClassLoader","layerClassLoader","loadLayer","layerParams","doCreateLayer","error","loadLayers","globalOptions","defs","loadMap","loadedMap","setZIndex","curZIndex","LayerOrder","errorMessage"],"mappings":"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lCYpC,EACboC,YNwlCCR,aMxlCa5B,EACd4B,aNwlCCE,oBMxlCoB9B,EACrB8B,oBNwlCCvE,QMxlCQyC,EACTzC,QNwlCC4D,uBMxlCuBnB,EACxBmB,uBNwlCC2iB,gBMxlCgB9jB,EACjB8jB,gBNwlCCD,cMxlCc7jB,EACf6jB,cNwlCCF,gBMxlCgB3jB,EACjB2jB,gBNwlCCld,OMxlCOzG,EACRyG,ONwlCCoB,kBMxlCkB7H,EACnB6H,kBNwlCCzC,UMxlCUpF,EACXoF,UNwlCCgf,eMxlCepkB,EAChBokB,eNwlCC7sB,mBMxlCmByI,EACpBzI,mBNwlCC+sB,WMxlCWtkB,EACZskB,WNwlCCK,WMxlCW3kB,EACZ2kB,WNwlCCE,eMxlCe7kB,EAChB6kB,eNwlCCvC,aMxlCatiB,EACdsiB,aNwlCCyC,kBMxlCkB/kB,EACnB+kB,kBNwlCClK,kBMxlCkB,SAAU9Y,EAAQuC,GNylChC,MMxlCMtE,GAAY,qBAAuBsE,EAAO,IAAM,KAAKvC,EAAOG,IAAKH,EAC3EE,MNylCAmY,cMxlCcpa,EACfoa,cNwlCCF,KMxlCKla,EACNka,KNwlCC/P,QMxlCQnK,EACZmK,QNwlCIJ,SMxlCM/J,EACP+J,SNwlCCoQ,MMxlCMna,EACPma,MNwlCCS,wBMxlCwB5a,EACzB4a,wBNwlCCE,yBMxlCyB9a,EAC1B8a,yBNwlCC0C,UMxlCUxd,EACXwd,UNwlCCqB,UMxlCU7e,EACX6e,UNwlCCnB,iBMxlCiB1d,EAClB0d,iBNwlCCgB,QMxlCQ1e,EACT0e,QNwlCCC,aMxlCa3e,EACd2e,aNwlCCc,QMxlCQzf,EACTyf,QNwlCC4C,qBMxlCqBriB,EACtBqiB,qBNwlCCjU,WMxlCWpO,EACZoO,WNwlCC2R,qBMxlCqB/f,EACtB+f,qBNwlCCK,qBMxlCqBpgB,EACtBogB,qBNwlCCE,mBMxlCmBtgB,EACpBsgB,mBNwlCCZ,kBMxlCkB1f,EACnB0f,kBNwlCC7V,kBMxlCkB7J,EACnB6J,kBNwlCCuM,aMxlCapW,EACdoW,aNwlCCmD,iBMxlCiBvZ,EAClBuZ,iBNwlCCuF,kBMxlCkB9e,EACnB8e,kBN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CjBy9B,EAAUz9B,UACd,EAAyB,KAArBA,UAAU7G,SZ8xJTskC,EY5xJDP,EZ6xJCA,EY5xJJ,KZ8xJA,KY7xJI,GAAIr5B,KAAK45B,GZ8xJT,GY7xJY,OAATP,EZ8xJC,IY7xJI,GAAIQ,KAAMD,GAAQ55B,GZ8xJlBo5B,EY7xJWp5B,EAAG65B,EAAID,EAAQ55B,GAAG65B,GACjC/9B,UZ+xJAs9B,GY7xJWC,EAAMr5B,EAAG45B,EAAQ55B,GAChClE,KZ+xJJ,OY5xJJA,OZ+xJA2jB,QY7xJQ,SAAStb,GZkyJb,IY7xJI,GAJDk1B,GAAOpgC,EAAEumB,UAAUga,cACnBM,EAASh+B,KAAKu9B,OAEdU,EAAS51B,EAAMA,EAAIkT,MAAM,SACpBhhB,EAAI,EAAGhB,EAAM0kC,EAAOzkC,OAAQe,EAAIhB,GAChCykC,EADqCzjC,IZiyJzCyjC,EY/xJQA,EAAOC,EACnB1jC,GZgyJA,OY9xJJyjC,KZiyJJ7gC,EY/xJCqF,OAAOrF,EAAEumB,UAAWvmB,EACzBygC,oBZmyJK,SAASjmC,EAAQD,GAEtB,Yav1JDyF,GAAEqF,OAAOrF,EAAEumB,Wb01JNwa,KACIC,Yax1JD,aby1JCC,Oax1JD,Qby1JCC,Wax1JD,kBby1JCC,Wax1JD,iBby1JCC,Kax1JD,Uby1JCC,Uax1JD,Wby1JC9Y,OACI3tB,Eax1JD,Iby1JC0mC,Gax1JD,Sby1JChb,Gax1JD,Kby1JC8D,Gax1JD,Qby1JC7C,Iax1JD,Sby1JCga,Gax1JD,Kby1JCC,Oax1JD,Uby1JCC,Qaz1JQ,gBbg2Jf,SAASjnC,EAAQD,GAEtB,Ycl3JDyF,GAAEqF,OAAOrF,EAAEumB,Wdq3JNmb,KACIV,Ycn3JD,cdo3JCC,Ocn3JD,Sdo3JCC,Wcn3JD,mBdo3JCC,Wcn3JD,iBdo3JCC,Kcn3JD,Odo3JCC,Ucn3JD,Ydo3JC9Y,OACI3tB,Ecn3JD,Ido3JC0mC,Gcn3JD,Mdo3JChb,Gcn3JD,Kdo3JC8D,Gcn3JD,Qdo3JC7C,Icn3JD,Sdo3JCga,Gcn3JD,Kdo3JCC,Ocn3JD,Udo3JCC,Qcp3JQ,gBd23Jf,SAASjnC,EAAQD,EAASH,GAE/B,YAEA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B,GnB+sLI04B,EmB9sLeJ,GACnBO,GnBktLZ,GmB9sLGH,EnB+sLC,ImB9sLIJ,IAAQI,GnB+sLRhY,EmB9sLMgY,EACPJ,GnB8sLCE,EmB9sLM5I,EAAA1G,WAAWqB,cAClB7J,GAAKiY,EAASH,KACLpvC,KAAKspC,OAAO8F,InB+sLZpvC,KmB/sL0B8uC,eAAuBxX,GnBitLrDiY,EmBhtLQH,GAAQpvC,KAAKspC,OACtB8F,GnBgtLCD,EmBhtLiBC,IACrB,EnBmtLRpvC,MmBhtLIspC,OACLiG,EAAIvvC,KAAK0oC,iBnBitLJ1oC,KmBhtLIspC,OAAOtpC,KAAK0oC,eAAerI,gBnBitL3BkD,KmBhtLKvjC,KAEb0oC,iBnBktLJ1oC,KmBhtLIwqC,uBACR2E,InBotLAO,qBmBhtLqB,SAASC,GnBitL1B3vC,KmBhtLIotC,mBACLuC,EnBgtLC3vC,KmBhtLI+oC,uBACL,EnBgtLC/oC,KmBhtLI8nC,sBnBmtLR8H,wBmBhtLwB,WnBitLpB5vC,KmBhtLIotC,mBACL,KnBgtLCptC,KmBhtLI+oC,uBACL,EnBgtLC/oC,KmBhtLI8nC,uBAIb3qC,GAAEkC,IAAMlC,EAAEkC,QACVlC,EAAEkC,IAAI84B,YAAcA,GnBotLd,SAASxgC,EAAQD,EAASH,GAE/B,YoBxvNyB,IAAAu5B,GAAAv5B,EAAA,GACCs4C,EAAAt4C,EAAA,IACIu4C,EAAAv4C,EAAA,GAE/B4F,GAAEkC,IAAI0wC,YAAA5yC,EAAgB6yC,UAAUC,OAAOztC,QpB6vNlCT,SACImuC,cACAC,QoB1vND,EpB2vNCrU,aoB1vND,EpB2vNCoE,eoB1vND,EpB2vNCC,WoB1vND,EpB2vNCiQ,UoB1vND,EpB2vNCjU,WoBxvNL,GpB2vNCr5B,WoB3vNW,SAASf,GpB4vNhBA,EoB3vNS5E,EAAEqrC,WAAWxoC,KAEvB+B,GpB2vNC/B,KoB3vNIqwC,YAAc,GAAIlzC,GAAEkC,IAEzBC,SpB2vNCU,KoB3vNIswC,cpB4vNJtwC,KoB3vNIuwC,kBpB6vNJvwC,KoB3vNIwwC,mBpB6vNJxwC,KoB3vNIywC,cAAe,EpB4vNnBzwC,KoB3vNI0wC,mBpB6vNJ,IoB3vNGlsC,GAEJxE,IpB2vNCA,MoB3vNI2wC,MpB4vNAhqC,SoB3vNSmqB,EAAAhrB,YAAYY,kBAAkB3E,EAAQ4E,UAChD,uBpB2vNCouB,QoB3vNQhzB,EACT2zB,MpB2vNC0a,SoB3vNSruC,EACVquC,SpB2vNC5oC,QoB3vNQzF,EACTyF,QpB2vNCg5B,UoB3vNUz+B,EACXy+B,UpB2vNCE,QoB3vNQ3+B,EACT2+B,QpB2vNCkQ,UoB3vNU7uC,EAAQ6uC,WACnB,KpB2vNCC,OoB3vNO9uC,EAAQ8uC,WpB4vNfC,qBACAC,aoB1vND,EpB2vNCC,YoB1vND,EpB2vNCC,YoB1vND,EpB2vNCC,eACAC,kBACAC,gBoBzvNDrvC,EAAQ0C,cpB4vNPzE,KoB3vNI2wC,KAAKlsC,YAAc1C,EAC3B0C,apB6vNAzE,KoB3vNI+vB,GAAG,aAAc,SAASzmB,GpB4vN1B9E,EoB3vNK6sC,uBAAuB/nC,EAAEi6B,KAClC+N,SpB+vNJC,YoB3vNY,SAAUD,GpB4vNlB,GoB3vNGE,GAAWxxC,KAAKspC,OACpBgI,EpB2vNC,IoB3vNGE,EACA,CpB2vNC,GoB3vNGjO,GAAOiO,EACXC,EAAIlO,IAAQA,EAAKh6B,YpB4vNZg6B,EoB3vNIh6B,WAAWC,YACnB+5B,SAEMvjC,MAAKspC,OACfgI,KpB8vNJI,MoB3vNM,SAASl2B,GpB4vNX,GoB3vNGA,EAAIzZ,QAAQud,MAAQniB,EAAE6oB,IAAIC,UAAYzK,EAAIzZ,QAAQud,MAAQniB,EAAE6oB,IAAI2rB,SpB4vN/D,KoB1vNJ,sEpB4vNA,IoB3vNGtyC,GAAMW,KAEV2wC,IpB2vNCtxC,GoB3vNGuyC,OACJ,EpB2vNCvyC,EoB3vNGwyC,WAAar2B,EAAIzZ,QAAQud,MAAQniB,EAAE6oB,IACvCC,SpB2vNC5mB,EoB3vNGob,YAAce,EAClBs2B,UpB2vNCzyC,EoB3vNG0yC,aAEJC,apB2vNC70C,EoB3vNC6yC,UAAUC,OAAOpqC,UAAU6rC,MAAM55C,KAAKkI,KAExCwb,GpB2vNCA,EoB3vNGuU,GAAG,YAAa/vB,KAAKiyC,WACzBjyC,MpB2vNCwb,EoB3vNGuU,GAAG,UAAW/vB,KAAKkyC,SACvBlyC,MAA4B,WAAxBX,EAAIuQ,WAAWxF,MpB4vNdoR,EoB3vNGuU,GAAG,UAAW/vB,KAAKmyC,SAC1BnyC,MACGA,KAAK+B,QAAQo6B,aAAc,IpB4vN1Bn8B,KoB3vNI+5B,WAAW7oB,MAAMkhC,cACzB,QACG/yC,EAAIgzC,gBAAkBryC,KAAKsyC,QpB4vN1BtyC,KoB5vNyCuyC,UAAgB,IpB8vN7DvyC,KoB7vNI+vB,GAAG,cAAe/vB,KAAKwyC,eAC5BxyC,MpB6vNCA,KoB7vNI+vB,GAAG,gBAAiB/vB,KAAKyyC,iBAE9BzyC,MpB8vNC7C,EoB7vNCkC,IAAIqzC,cAAclX,IACpBx7B,MpB6vNCA,KoB7vNI2D,KACR,QpB+vNAgvC,SoB7vNS,SAASn3B,GACXxb,KAAK+5B,YpB8vNJ/5B,KoB7vNI+5B,WAAWxwB,WAAWC,YAAYxJ,KAC1C+5B,YpB+vNAve,EoB7vNGo3B,KpB8vNCC,UoB7vNY7yC,KACb8yC,OpB6vNCC,QoB7vNU/yC,KAAKgzC,SAGpBhzC,MAAIA,KAAKizC,WpB8vNJz3B,EoB7vNGo3B,KpB8vNCM,SoB7vNWlzC,KACZmzC,apB6vNC9W,QoB7vNUr8B,KAAKozC,cAEvBpzC,MAEIA,KAAK+B,QAAQsxC,gBpB8vNb73B,EoB7vNGo3B,IAAI,OAAQ5yC,KAAKszC,eACxBtzC,MpB8vNAA,KoB7vNI+5B,WACL,KpB6vNC/5B,KoB7vNIo5B,KAEL,KpB6vNCp5B,KoB5vNDuzC,yBpB6vNC/3B,EoB7vNGo3B,IAAI,YAAa5yC,KAAKiyC,WAC1BjyC,MpB6vNCwb,EoB7vNGo3B,IAAI,UAAW5yC,KAAKkyC,SACxBlyC,MpB6vNCA,KoB7vNI4yC,IAAI,cAAe5yC,KAAKwyC,eAE7BxyC,KpB6vNC,IoB7vNGX,GAAMW,KAEV2wC,WAAOtxC,GACPmc,IAA4B,WAAxBnc,EAAIuQ,WAAWxF,MpB8vNdoR,EoB7vNGo3B,IAAI,UAAW5yC,KAAKmyC,SAC3BnyC,MACGX,EAAI64B,cAAgB74B,EAAI64B,YAAY8T,2BpB8vNnC7uC,EoB7vNCkC,IAAIqzC,cAActwC,OACvBpC,MpB8vNAA,KoB7vNI2D,KACR,WpB+vNA6vC,eoB7vNe,WpB8vNXr2C,EoB7vNC6yC,UAAUC,OAAOpqC,UAAU2tC,eAAe17C,KAC5CkI,MpB6vNCA,KoB5vNDyzC,epB6vNCzzC,KoB5vNJ0zC,mBpB+vNAC,coB7vNc,WpB8vNV,GoB7vNG3zC,KAAK+5B,WACL,CpB6vNC,GoB7vNGh4B,GAAU/B,KAAK+B,QACfg6B,EAASh6B,EAAQg6B,QAAU,EAC3BD,EAAe/5B,EAAQ+5B,cAE3B,CpB6vNC97B,MoB7vNI+5B,WAAW7oB,MAAM6qB,OAASD,EAClCC,IpBgwNJiX,QoB7vNQ,WpB8vNJ,OoB7vNIhzC,KAAKo5B,MACNp5B,KAAK4zC,mBAAqB5zC,KAAK4zC,kBAAkB5zC,KAAKo5B,KAAKya,WpB8vNtD7zC,MoB3vNLuzC,6BpB8vNHvzC,MoB5vNI2wC,KAAKoB,aAAa+B,SAASjzC,KAAKb,KAAK+zC,SAAS5xC,KACtDnC,QpB8vNAg0C,SoB5vNS,SAAU5oC,GpB6vNf,GoB5vNG6oC,GAAUj0C,KACVqL,EAAOrL,KAAKo5B,KAAKya,MACjBx0C,EAAMW,KAEV2wC,IpB4vNC,KoB5vNItxC,EAAI60C,YAAc70C,EAAI0yC,aAAaoC,gBAAgB9oC,GAGvD,WpB0vNIrL,MoB3vNDo0C,apB+vNH,IoB5vNG9C,GAAOtxC,KAAKq0C,iBAAiBjpC,EACjCC,EpB4vNC,KoB5vNIhM,EAAIyxC,kBAAkBQ,GACvB,CpB4vNCjyC,EoB3vND0xC,cpB4vNC,IoB5vNGuD,IAAmB,EACnBlU,EAAetP,EAAAhrB,YAAYqF,sBAAsBC,EAAWC,GAC5DkpC,EAAO,WACED,IpB6vNJj1C,EoB3vNG0xC,epB4vNHkD,EoB3vNGG,cpB4vNHE,GoB3vNA,IAEL5+B,GpB6vNCtL,KoB3vNG,SpB4vNHw3B,QoB3vNG,EpB4vNHtgB,KoB5vNSjiB,EAAI0yC,aAAayC,eACvBpU,GpB4vNHsB,SoB5vNa,aAAc,cAAgBriC,EAAImI,QAAS,cACrD,cpB4vNHjH,SoB5vNa,SAASkW,GpB6vNlBw9B,EoB5vNWQ,eAAerpC,EAAWC,EAAMoL,GAAMpV,OACjDkzC,IAELv0C,MAAK+B,QAAQm+B,gBpB6vNZxqB,EoB5vNIisB,WACRt2B,GACqB,mBAAlBhM,EAAI60C,YpB6vNHx+B,EoB5vNIssB,cAAgB3iC,EAAImhC,UAAWnhC,EACvCqhC;ApB8vNA,GoB5vNGkD,GAAWvkC,EAAI64B,YAAY4O,YAAYpxB,EAC3C47B,EpB4vNC1N,GoB5vNQ7T,GAAG,WAAY,WAGf6T,EAASrB,YAEbgS,MpB+vNJ3Q,EoB5vNQ7T,GAAG,oBAAqB/vB,KAAK00C,iBAEtC10C,MpB4vNCX,EoB5vNGyxC,kBAAkBQ,IpB6vNjBhmC,EoB3vNDD,EpB4vNCK,EoB5vNEN,EACHM,EpB4vNCE,EoB5vNER,EACHQ,EpB4vNCsK,GoB5vNG,IAAMkqB,EACV10B,EpB4vNCyK,GoB5vNG,KAAO,EAAIiqB,EAEnBx0B,IpB4vNCg4B,EoB3vNJxB,apB+vNJsS,iBoB5vNiB,WpB6vNb,GoB5vNGr1C,GAAMW,KAAK2wC,KACXjX,EAAY15B,KAAKswC,WAAW92C,OAAS,GAAK0L,OAAOC,KAAKnF,KAAKwwC,iBAAiBh3C,OAEhF,CpB4vNC,KoB5vNIkgC,EpB6vNA,IoB5vNI,GAAIrxB,KAAOhJ,GAAIyxC,kBAChB,CpB4vNC,GoB5vNGlN,GAAWvkC,EAAI64B,YAAY+T,YAC/B5jC,EpB4vNC,IoB5vNGu7B,GAAYvkC,EAAI64B,YAAY+P,wBAAwBrE,GACpD,CpB4vNClK,GoB3vND,CACH,SAIJA,GAAa15B,KAAKywC,apB6vNlBzwC,KoB5vNI2D,KACR,YAAW+1B,IAAc15B,KAAKywC,cpB6vN1BzwC,KoB5vNI2D,KACR,apB8vNA3D,KoB5vNIywC,aACR/W,GpB8vNAib,0BoB5vN0B,SAAUza,GpB6vNhC,IoB5vNIA,EpB6vNA,MoB7vNwB,EpB+vN5B,IoB9vNG3gC,GAAM,EAAGuB,EACb,EAAIsN,GAAO,MACX,SpB+vNC,KoB/vNI,GAAIC,KAAOD,GACZ,CpB+vNC,GoB/vNG27B,GAAQ7J,EAAUzwB,qBAAqBrB,EAC3CC,GpB+vNC,IoB/vNG07B,GAASA,EAAMvqC,OAAS,EACxB,CpB+vNCD,GoB/vNMwqC,EACPvqC,MpB+vNC,KoB/vNI,GAAIe,GAAI,EAAGsS,EAAOk3B,EAAMvqC,OAAQe,EAAIsS,EAAMtS,IACvCwpC,EAAMxpC,GAAGq6C,eAEZ95C,KpBmwNZ,MoB/vNGvB,GAAM,EAAgB,EACnBuB,EACVvB,GpBmwNA66C,YoBjwNY,WACLp0C,KAAKizC,WpBkwNJ91C,EoBjwNCwxB,QAAQkmB,SAAS70C,KAAK80C,eAC3B,yBAC8B,IAA3B90C,KAAK2wC,KAAKI,epBkwNT/wC,KoBjwNI2D,KAEL,QAAI3D,KAAKizC,WpBmwNJjzC,KoBjwNI+0C,kBACR,KpBqwNRC,YoBjwNY,SAAUzR,GACfA,GpBkwNCpmC,EoBlwNSwxB,QAAQkmB,SAAStR,EAA+B,uBpBowN7DvjC,KoBlwNJo0C,epBqwNAa,aoBnwNa,apBqwNbC,UoBlwNU,SAAU3R,GpBmwNhBvjC,KoBlwNIg1C,YACRzR,IpBswNA8Q,iBoBlwNiB,SAAUn1C,EAAQmM,GpBmwN/B,MoBlwNMnM,GAAOwM,EAAI,IAAMxM,EAAO0M,EAAI,KAAO1M,EAAOoM,GACpDD,IpBowNA8pC,qBoBlwNqB,SAAUvkC,GpBmwN3B,GoBlwNG4K,GAAMxb,KAAKo5B,KACX/5B,EAAMW,KAAK2wC,KACXyE,EAAa,GAAIj4C,GAAE2iB,MAAMzgB,EAAIg2C,OAAQh2C,EAAIuyC,QACzC0D,EAAc95B,EAAI/L,QAAQmB,EAAQ5Q,KAAKu1C,WAAW/Z,IAAI4Z,GAAYI,SAClEC,EAAWj6B,EAAIk6B,UAAUC,SAE7B,EpBkwNC,OoBlwNM,IAAIx4C,GAAE+tB,OAAOoqB,EAAYM,SAASH,GAAWH,EAAY9Z,IACnEia,KpBowNAI,qBoBlwNqB,SAAUtpC,GpBmwN3B,GoBlwNGsb,GAAW7nB,KAAK+B,QACpB8lB,QpBkwNC,OoBlwNM,IAAI1qB,GAAE+tB,OACT3e,EAAOuB,IAAI6nC,SAAS9tB,GAAU2tB,SAC9BjpC,EAAOwB,IAAI4nC,SAAS9tB,GAC3BiuB,WpBqwNAC,oBoBhwNoB,SAAS9rC,GpBiwNzB,GoBhwNG5K,GAAMW,KAEV2wC,IpBywNC,IATAtxC,EoBhwNGuQ,WAAa3F,EACjB2F,WpBgwNCvQ,EoBhwNGiI,SAAW2C,EAEf3C,SAAIjI,EAAIuQ,WAAWomC,iBACR32C,GAAIuQ,WAAWvQ,EAAIuQ,WAAW04B,SAAW,gBACnD,SpBkwNAjpC,EoBjwNGuQ,WAAWomC,WAEf,GAAK32C,EAAIiI,SACL,CpBiwNC,GoBjwNG2uC,GAAYnlB,EAAAhrB,YAAYoF,UAC5B,EpBiwNC7L,GoBjwNGiI,UpBkwNC8C,KoBhwND,UpBiwNCqC,gBoBjwNgBwpC,GAAYA,KAAcA,EAAWA,IAAaA,EAAWA,IAAaA,GAAYA,KAAcA,GAE5HA,MpB4yNA,GAtCA52C,EoBjwNG62C,cAAgBjsC,EAAGisC,eAAiBjsC,EAExC2F,WpBiwNC5P,KoBjwNIm2C,kBAAkBlsC,EAEvB2F,YpBiwNC3F,EoBjwNE2F,WAAWswB,cAAgBlgC,KAAK+B,QACnCm+B,cpBiwNCj2B,EoBjwNE2F,WAAWuwB,UAAYngC,KAAK+B,QAE/Bo+B,UpBiwNC9gC,EoBjwNG64B,YAAcl4B,KAAK+B,QAAQm2B,aAAe,GAAI/6B,GAAEkC,IAAI84B,YAAYluB,EAEpE2F,YAAI5P,KAAK+B,QAAQi2B,gBACjB/tB,EAAG2F,WAAWihC,SpBkwNL5mC,EoBlwNkB2F,WAAWihC,OAAS7wC,KAAK+B,QAAQi2B,cAAuB6Y,QpBowN9ExxC,EoBnwNN64B,YAAYnI,GAAG,gBAAiB/vB,KAAKyyC,iBACzCzyC,OpBqwNMX,EoBnwNH0yC,aAAmB,GAAAlC,GAAAuG,aACjB/2C,GpBmwNCW,KoBnwNI+B,QAAQouC,QAAU9wC,EAAI0yC,aAC3B5B,QpBmwNCnwC,KoBnwNI+B,QAAQs0C,QAAUh3C,EAAI0yC,aAE3BsE,QpBmwNCh3C,EoBnwNG64B,YAAYnI,GAAG,mBAAoB,WAC/B1wB,EAAI64B,YAAY8T,0BpBowNf7uC,EoBnwNCkC,IAAIqzC,cAAclX,IACvBx7B,MpBowNI7C,EoBnwNCkC,IAAIqzC,cAActwC,OACvBpC,OAGLA,MAA4B,WAAxBX,EAAIuQ,WAAWxF,MAAuB,aAAepK,MAAK+B,UpBowNzD/B,KoBnwNI+B,QAAQu0C,WAAY,GAEE,WAA3Bj3C,EAAI62C,cAAc9rC,MAAqBpK,KAAKu2C,qBpBowN3Cv2C,KoBnwNIu2C,oBACRv2C,MAEGX,EAAIm3C,UpBowNHx2C,KoBnwNIy2C,aAAaluC,KAAK+mB,MAAMjwB,EAChCm3C,WACGn3C,EAAI4rC,OACJ,CpBmwNC,GoBnwNGxvC,GAAO0B,EAAEkC,IAAIjH,QAAQgG,SAASiB,EAAI4rC,OAAOzyC,QAAQ,UACrD,KAAIiD,IpBowNC4D,EoBnwNT64B,YAAYgS,UAAU,cAAgB7qC,EAAImI,QAAA,SAAkBkC,GpBowN/C,MoBnwNTrK,GAAImI,UAAYxH,KAAK2wC,KAAKnpC,UAAY/L,GAAQA,EAAKiO,EAAKkG,WAAYvQ,EAAI6O,sBAAwBxE,EAAKkG,WAC5G,MAACzN,KACOnC,OpB0wNJ,MoBxwNGX,GAAIytC,WAAaztC,EAAI0tC,SpBowNpB/sC,KoBnwNIyjC,gBAAgBpkC,EAAIytC,UAAWztC,EACvC0tC,SpBqwNA/sC,KoBnwNIqwC,YACL5vC,UACHT,MpBqwNA24B,eoBnwNe,WpBowNX,MoBnwNA34B,MAAK2wC,KACTzY,apBqwNAmW,qBoBnwNqB,WACbruC,KAAK+B,QAAQm+B,gBpBowNblgC,KoBnwNI+B,QAAQm+B,eACb,EAAIlgC,KAAK2wC,KAAKzY,cpBowNTl4B,KoBlwNDuzC,yBpBmwNCvzC,KoBnwNI2wC,KAAKzY,YACVmW,uBpBmwNCruC,KoBlwNJ02C,YpBuwNRnI,sBoBnwNsB,WACfvuC,KAAK+B,QAAQm+B,gBpBowNZlgC,KoBnwNI+B,QAAQm+B,eACb,EAAIlgC,KAAK2wC,KAAKzY,cpBowNTl4B,KoBlwNDuzC,yBpBmwNCvzC,KoBnwNI2wC,KAAKzY,YACVqW,wBpBmwNCvuC,KoBlwNJ02C,YpBuwNRC,iBoBnwNiB,SAAU79B,GpBowNvB,GoBnwNGtU,GACJxE,IpBywNC,OoBzwNGA,MAAK2wC,KAAKld,gBAAkB3a,IpBowN3B9Y,KoBnwNI2wC,KAAKld,cACV3a,EpBmwNC9Y,KoBnwNIqwC,YAAYxvC,KAAK,WpBowNjB2D,EoBlwNJoyC,aAGR52C,MpBqwNA62C,UoBnwNU,WpBowNN,MoBnwNM72C,MAAK2wC,KAAKoB,aACpB8E,apBqwNAC,SoBnwNS,SAAUv2C,GpBqwNf,MADAP,MoBnwNI2wC,KAAKoB,aAAa+E,SACvBv2C,GACHP,MpBqwNA+2C,UoBnwNU,SAAUlG,GpBowNhB,GoBnwNGrsC,GAEJxE,IpB6wNC,OAVAA,MoBnwNIqwC,YAAYxvC,KAAK,WpBowNjB2D,EoBnwNKmsC,KAAKoB,aACXiF,cAAInG,EpBowNCA,EoBnwNMvwC,QAAQ,SAASwD,EAAIvJ,GpBowNvBiK,EoBnwNKyyC,SAASnzC,EAAIvJ,GACtB,KpBqwNAiK,EoBnwNKb,KACT,iBAGR3D,MpBqwNAk3C,SoBnwNS,SAAUpxB,GpBowNf,MoBnwNM9lB,MAAK62C,YACf/wB,IpBqwNAmxB,SoBnwNS,SAAU/lC,EAAO4U,EAAK+oB,GpBowN3B,GoBnwNGrqC,GAAQxE,KACRX,EAAMW,KACV2wC,IpBwwNC,OALA3wC,MoBnwNIqwC,YAAYxvC,KAAK,WpBowNjBxB,EoBnwNG0yC,aAAakF,SAAS/lC,EAAO4U,EAAK+oB,GAAYhuC,KAAK,WpBowNlD2D,EoBnwNKb,KAAK,eAAgBmiB,IAAKA,GACnC,QAGR9lB,MpBqwNAm3C,aoBnwNa,SAAU17C,GpBswNnB,MAFAuE,MoBnwNI2wC,KAAKhe,UACVl3B,EpBmwNCuE,KoBlwND42C,UACH52C,MpBqwNAo3C,gBoBnwNgB,WpBqwNZ,MADAp3C,MoBnwNI2wC,KAAKhe,UACV,KACH3yB,MpBqwNAq3C,coBnwNc,SAAU57C,GpBswNpB,MAFAuE,MoBnwNI2wC,KAAK2G,qBACV77C,EpBmwNCuE,KoBlwND42C,UACH52C,MpBqwNAu3C,iBoBnwNiB,WpBswNb,MAFAv3C,MoBnwNI2wC,KAAK2G,qBACV,KpBmwNCt3C,KoBlwND42C,UACH52C,MpBqwNAw3C,UoBnwNU,SAAU/7C,GpBowNhB,GoBnwNG4D,GAAMW,KACV2wC,IpBswNC,OAHAtxC,GoBnwNG64B,YAAYgS,UAAU,sBAAuBxgC,GpBowN5C,MoBnwNMrK,GAAImI,UAAYxH,KAAK2wC,KAAKnpC,UAAY/L,GAAQA,EAAKiO,GAAQA,EAAKkG,WAC1E,MAACzN,KACFnC,OACHA,MpBqwNA8qC,aoBnwNa,WpBqwNT,MADA9qC,MoBnwNI2wC,KAAKzY,YAAY4S,aACtB,cACH9qC,MpBqwNAyjC,gBoBnwNgB,SAAUjD,EAAWE,GpBowNjC,GoBnwNGrhC,GAAMW,KAEV2wC,IpBywNC,IoBzwNGtxC,EAAIytC,WAAaztC,EAAI0tC,UpBowNpBvM,EoBnwNEnhC,EACZytC,UpBmwNUpM,EoBnwNArhC,EACV0tC,UAGU1tC,EAAImhC,YAAeA,IACnBnhC,EAAIqhC,UAAaA,GAClBF,GAAcnhC,EAAImhC,UAAUC,YAAcD,EAAUC,WACpDC,GAAYrhC,EAAIqhC,QAAQD,YAAcC,EAAQD,UAE9C,CpB+vNC,GoB/vNGphC,EAAI62C,cAAcuB,gBAAkBjX,EACpC,CpB+vNC,GoB/vNGkX,GAAgD,GAAnCr4C,EAAI62C,cAAcuB,eAAsB,KACzD,GpB+vNCjX,GoB/vNW,GAAIxW,MAAKnrB,KAAKkP,IAAIyyB,EAAUC,UAAWC,EAAQD,UAC9DiX,IpBiwNAr4C,EoB/vNGmhC,UACJA,EpB+vNCnhC,EoB/vNGqhC,QAEJA,CpB+vNC,IoB/vNGkD,GAAW,KACvB1L,EAAc74B,EACN64B,WpB+vNC,KoB/vNI,GAAI7vB,KAAOhJ,GAAIyxC,kBpBgwNflN,EoB/vNU1L,EAAY+T,YACvB5jC,GpB+vNCu7B,EoB/vNQH,gBAAgBjD,EAC5BE,EpBgwNAkD,GoB/vNU1L,EAAY+T,YACvB,WAAIrI,GpBgwNCA,EoB/vNQH,gBAAgBjD,EAC5BE,GACkB,eAAxBv6B,OAAOwxC,cAAiCt4C,EAAIuQ,WAAWgoC,YAAa,IpBgwN1Dv4C,EoB/vNTuQ,WAAWw4B,cAAe,EpBgwNjBlQ,EoB/vNDsQ,YAAYJ,cAAc,IAClCpoC,KAAKo5B,MpBgwNQj8B,EoB/vNdkC,IAAIqzC,cACNmF,OpBiwNQ73C,KoB/vNI2D,KACR,uBpBiwNA,MoB9vNJ3D,OpBiwNA83C,gBoB/vNgB,WpBgwNZ,OACItX,UoB/vNUxgC,KAAK2wC,KAChBnQ,UpB+vNCE,QoB/vNQ1gC,KAAK2wC,KAErBjQ,UpBiwNAoG,YoB/vNY,SAAU/kC,GpBgwNlB,MoB/vNM/B,MAAK2wC,KAAKzY,YAAY4O,YAChC/kC,IpBiwNAmlC,eoB/vNe,SAAStD,GpBgwNpB,MoB/vNM5jC,MAAK2wC,KAAKzY,YAAYgP,eAAetD,EAC/ChsC,KpBiwNAmgD,kBoB/vNkB,SAAS7rC,EAAIC,GpBgwN3B,GoB/vNG9M,GAAMW,KACV2wC,IpBkwNC,OAHAtxC,GoB/vNG2xC,YACJ9kC,EpB+vNC7M,EoB/vNG4xC,YACJ9kC,EpB+vNCnM,KoB9vNDgzC,UACHhzC,MpBiwNAg4C,kBoB/vNkB,WpBgwNd,GoB/vNG34C,GAAMW,KACV2wC,IpB+vNC,QoB/vNO0E,OAAQh2C,EAAI2xC,YAAaY,OAAQvyC,EAC5C4xC,cpBiwNAyC,gBoB/vNgB,SAAU9nB,GpBowNtB,MoBnwNGvrB,WAAU7G,SpBgwNTwG,KoB/vNI+B,QAAQ+5B,aAChBlQ,GpBgwNA5rB,KoB9vND2zC,gBACH3zC,MpBiwNA42C,QoB/vNQ,SAAUqB,GpBgwNd,GoB/vNGj4C,KAAKo5B,KACL,CpB+vNC,IoB/vNI6e,EACD,CpB+vNCA,IACA,KoB/vNI,GAAI5vC,KAAOrI,MAAK2wC,KAAKG,kBpBgwNrBmH,EoBhwNgD5vC,IAAc,CpBkwNlElL,GoBjwNCqF,OAAOy1C,EAAOj4C,KACnB0wC,kBpBkwNA1wC,KoBjwNI2wC,KAAKzY,YAAY2S,kBACzBoN,KpBowNJC,WoBjwNW,SAAUtgD,GpBkwNjB,GoBjwNGoI,KAAKo5B,KACL,CpBiwNC,GoBjwNG1vB,GAAO1J,KAAK2wC,KAAKzY,YAAYiT,QAAQvzC,GACrCugD,EAAWn4C,KAAKo4C,kBAAkB1uC,EAEtC6C,OpBiwNCvM,MoBjwNI42C,QACRuB,KpBowNJE,iBoBjwNiB,SAAUjtC,GpBkwNvB,GoBjwNGkmC,GAAOtxC,KAAKq0C,iBAEhBjpC,EpBiwNC,IoBjwNGkmC,IAAQtxC,MAAKspC,OpBkwNZ,MoBjwNMtpC,MAAKspC,OACfgI,EpBmwNA,IoBjwNG/N,GAAOvjC,KACXs4C,UpB4wNC,OAXAt4C,MoBjwNIspC,OAAOgI,IpBkwNPG,GoBhwNDlO,EpBiwNCrkC,OoBhwNDkM,EpBiwNCmtC,SoB9vNL,GpBkwNChV,EoBjwNIsQ,MAAQ7zC,KAAKo5B,KAClBya,MpBiwNCtQ,EoBjwNIqR,eACL,EpBiwNCrR,EoBjwNIiV,WACLptC,EpBiwNCpL,KoBjwNIk1C,UACL3R,GAAOvjC,KAAKspC,OACfgI,IpBmwNAmH,sBoBjwNsB,SAAUlV,GpBkwN5BvjC,KoBjwNI80C,eAAenrC,YACpB45B,EpBiwNC,IoBjwNGmV,GAAU14C,KAAK24C,YAAYpV,EAC/BiV,WpBiwNCr7C,GoBjwNCwxB,QAAQiqB,YAAYrV,EAAMmV,EAASv7C,EAAEmzB,QAAQuoB,QAAU17C,EAAEmzB,QAC9DwoB,YpBmwNAnY,QoBjwNQ,SAASlqB,EAAM1U,GpBuwNnB,MoBtwNI/B,MAAK2wC,KAAK5b,UpBmwNV/0B,KoBlwNI2wC,KAAKzY,YAAYyI,QAAQlqB,EAC9B1U,GpBkwNC/B,KoBjwNJ42C,WAEJ52C,MpBowNA4gC,WoBlwNW,SAASnqB,EAAM1U,GpBwwNtB,MoBvwNI/B,MAAK2wC,KAAK5b,UpBowNV/0B,KoBnwNI2wC,KAAKzY,YAAY0I,WAAWnqB,EACjC1U,GpBmwNC/B,KoBlwNJ42C,WAEJ52C,MpBqwNA+4C,sBoBnwNsB,SAASC,EAAW3tC,GpBowNtC,MoBnwNMrL,MAAK2wC,KAAKoB,aAAakH,kBAAkBD,EACnD3tC,IpBqwNA6tC,aoBnwNa,SAASthD,GpBowNlB,GoBnwNGyH,GAAMW,KAAK2wC,KACXjnC,EAAOrK,EAAI64B,YAAYiT,QAC3BvzC,EpBmwNC,OoBnwNMyH,GAAI0yC,aAAaoH,YAC3BzvC,IpBqwNA0vC,sBoBnwNsB,WpBowNlB,MoBnwNMp5C,MAAK2wC,KACfzoB,oBpBqwNAmxB,wBoBnwNwB,WpBowNpB,MoBnwNMr5C,MAAK2wC,KACfziC,sBpBqwNAorC,eoBnwNe,SAAS1hD,GpBowNpB,GoBnwNGyH,GAAMW,KAAK2wC,KACXjnC,EAAOrK,EAAI64B,YAAYiT,QAAQvzC,GAC/Bi5C,EAAS7wC,KAAK62C,YACdhmC,EAEJ,EpBmwNC,IoBnwNGnH,GAAQmnC,EAAOnnC,EAAK+hC,eACpB,CpBmwNC,GoBnwNGlZ,GAAW7oB,EACfkG,UpBmwNCiB,GAAM1T,EoBnwNCC,QAAQ+qB,qBAAqB0oB,EAAOnnC,EAAK+hC,eAAetiB,SpBowN3DvZ,WoBnwNW5P,KAAKu5C,kBACjBhnB,GpBmwNCzO,YoBnwNYyO,EAASA,EAAS/4B,OAC/B,IpBmwNC0uB,mBoBnwNmB7oB,EACpB6oB,mBpBmwNCzC,YoBnwNYzlB,KAAKo5B,KAAOp5B,KAAKo5B,KAAKr3B,apBswN1C,MoBlwNJ8O,IpBqwNA0oC,kBoBnwNkB,SAASP,GpBowNvB,GoBnwNGppC,MACA5S,EAAUgD,KAAK2wC,KACnBziC,oBpBmwNC,KoBnwNI,GAAI7F,KAAOrL,GpBowNX4S,EoBnwNUvH,GAAO2wC,EAAUh8C,EAC/BqL,GpBowNA,OoBlwNJuH,IpBqwNA4pC,iBoBnwNiB,SAASC,GpBowNtBz5C,KoBnwNI2wC,KAAKQ,eAAe71C,KACzBm+C,GpBmwNCz5C,KoBlwNJ42C,WpBqwNA8C,oBoBnwNoB,SAASC,GpBqwNzB,IoBnwNI,GADDvxC,GAAMpI,KAAK2wC,KACfQ,eAAS52C,EAAI,EAAGhB,EAAM6O,EAAI5O,OAAQe,EAAIhB,EAAKgB,IpBowNtC,GoBnwNG6N,EAAI7N,KAAOo/C,EACX,CpBmwNCvxC,EoBnwNGjE,OAAO5J,EACX,GpBmwNCyF,KoBlwND42C,SACH,SpBuwNRgD,coBnwNc,SAASH,GpBowNnBz5C,KoBnwNI2wC,KAAKO,YAAY51C,KACtBm+C,GpBmwNCz5C,KoBlwNJ42C,WpBqwNAiD,iBoBnwNiB,SAASF,GpBqwNtB,IoBnwNI,GADDvxC,GAAMpI,KAAK2wC,KACfO,YAAS32C,EAAI,EAAGhB,EAAM6O,EAAI5O,OAAQe,EAAIhB,EAAKgB,IpBowNtC,GoBnwNG6N,EAAI7N,KAAOo/C,EACX,CpBmwNCvxC,EoBnwNGjE,OAAO5J,EACX,GpBmwNCyF,KoBlwND42C,SACH,SpBwwNR3e,iBoBnwNiB,WpBowNb,MoBnwNMj4B,MAAK2wC,KACfuF,epBswNA4D,UoBnwNU,WpBowNN,GoBnwNGC,GAAO58C,EAAEoS,WAAWC,SACpBwqC,EAAYh6C,KAAK2wC,KAAKnpC,QAAUspB,EAAAhrB,YAAYuG,cAAcrM,KAAK2wC,KAAKrpC,UAAUiF,OAASvM,KAAK2wC,KAAKzY,YAErGgU,gBpBmwNC,OoBnwNG8N,GACO78C,EAAE4lC,cAAcgX,EAAKl6B,UAAUm6B,EAAUlsC,KAAMisC,EAAKl6B,UAAUm6B,EACxEjsC,OACU,GAAI5Q,GACd88C,cpBswNJC,YoBnwNY,WpBwwNR,MoBvwNIl6C,MAAK2wC,KAAKwJ,iBpBowNVn6C,KoBnwNI2wC,KAAKwJ,eAAiBh9C,EAAEC,QAAQwnB,kBAAkB5kB,KAAK2wC,KAAKrpC,UACpE,IAEMtH,KAAK2wC,KACfwJ,gBpBswNA9I,uBoBnwNuB,SAASC,GpBowN5B,GoBnwNGjyC,GAAMW,KAEV2wC,IpBmwNC,IoBnwNGW,IAAQjyC,GAAIyxC,kBACZ,CpBmwNC,GoBnwNGsJ,GAAe/6C,EAAIyxC,kBACvBQ,EAAI8I,GAAaC,YpBowNZD,EoBnwNYC,WAChBC,YpBowNA,IoBnwNN1W,GAAWvkC,EAAI64B,YAAY+T,YACtBqF,EAAI1N,IpBowNCA,EoBpwNmCvB,mBACjChjC,GAAIyxC,kBACXQ,GpBqwNCtxC,KoBrwNIuxC,YAELD,GAAItxC,KAAKywC,cpBswNJzwC,KoBpwNJ00C,mBAGDpD,IAAQtxC,MAAKuwC,gBpBswNZvwC,KoBrwNIuwC,eAAee,GACvB1wC,UpBwwNJ2yC,uBoBrwNuB,WpBswNnB,KoBrwNMvzC,KAAKswC,WAAW92C,QpBswNlBwG,KoBrwNIswC,WAAW,GAAGrvC,IACtBL,QpBuwNA,IoBrwNGvB,GAAMW,KAEV2wC,IpBqwNC,KoBrwNI,GAAIW,KAAQjyC,GAAIyxC,kBACjB,CpBqwNC,GoBrwNGsJ,GAAe/6C,EAAIyxC,kBACvBQ,EAAI8I,GAAaC,YpBswNZD,EoBrwNYC,WAChBC,YpBswNA,IoBrwNN1W,GAAWvkC,EAAI64B,YAAY+T,YACtBqF,EAAI1N,IpBswNCA,EoBtwNmCvB,apBwwNvChjC,EoBvwNG64B,YAAYgP,eAChBoK,SAAOjyC,GAAIyxC,kBACXQ,SAAOtxC,MAAKspC,OACfgI,GAEGtxC,KAAKywC,cpBwwNJzwC,KoBtwNJ00C,mBpBywNAr1C,EoBvwNG0xC,aACP,GpBywNAkB,WoBvwNW,WpBwwNPjyC,KoBvwNI2wC,KAAK4J,WACb,GpBywNArI,SoBvwNS,WpBwwNLlyC,KoBvwNI2wC,KAAK4J,WACV,EpBuwNCv6C,KoBvwNIw6C,eAAex6C,KACpBo5B,OpB0wNH+Y,SoBvwNS,WACF,eAAiBnyC,MAAK2wC,MpBwwNrB3wC,KoBvwNI2wC,KAAKzY,YAAYv0B,KACzB,YpB0wNJ6uC,eoBvwNe,WpBwwNX,GoBvwNGnzC,GAAMW,KACV2wC,IpB4wNC,KoB5wNItxC,EAAIgzC,eAAiBryC,KAAKsyC,OpBwwN1BtyC,KoBtwNJy6C,cAAUp7C,EAAIgzC,gBAAkBryC,KAAKsyC,QpBwwNjCtyC,KoBvwNIuyC,UACR,IACGvyC,KAAKo5B,KpBkxNJ,GoBjxNGp5B,KAAK+B,QAAQouC,UAAY9wC,EAAI0yC,aAAa5B,SAAWnwC,KAAK+B,QAAQs0C,UAAYh3C,EAAI0yC,aAAasE,UpBwwN9Fr2C,KoBvwNI+B,QAAQouC,QAAU9wC,EAAI0yC,aAC3B5B,QpBuwNCnwC,KoBvwNI+B,QAAQs0C,QAAUh3C,EAAI0yC,aAC3BsE,QpBuwNCr2C,KoBvwNIo5B,KACRshB,qBACGr7C,EAAIs7C,YpBwwNH36C,KoBvwNIo5B,KAAKwhB,aAAapf,IAC1Bx7B,MAAWX,EAAIs7C,apBwwNX36C,KoBvwNIo5B,KAAKwhB,aAAax4C,OAC1BpC,MACGkF,OAAOC,KAAK9F,EAAIyxC,mBAAmBt3C,OAAS,EpBwwN3C,IoBvwNI,GAAI6O,KAAOhJ,GAAIyxC,kBAAwB,CpBywNvC,GoBxwNGlN,GAAWvkC,EAAI64B,YAAY+T,YAAY5jC,GACvCwyC,EAAYx7C,EAAIyxC,kBAAkBzoC,GAClC+3B,EAAetP,EAAAhrB,YAAYqF,sBAAsB0vC,EAAWA,EAAUvvC,GACtEgW,EAAOjiB,EAAI0yC,aAAayC,eAC5BpU,EpBwwNC,KoBxwNIwD,EAAStiB,KAAK2K,QAAQ3K,GACvB,CpBwwNC,GoBxwNGy4B,GAAO58C,EAAEoS,WACbC,QpBwwNCo0B,GoBxwNQ/B,UAAU1kC,EAAE4lC,cAAcgX,EAAKl6B,UAAUyB,EAAKxT,KAAMisC,EAAKl6B,UAAUyB,EAC/EvT,apB2wNJ/N,MoBvwNJ02C,UpB4wNRoE,yBoBxwNyB,SAASxJ,SACxBtxC,MAAKwwC,gBACZc,GpBwwNCtxC,KoBvwNJ00C,oBpB0wNAD,eoBxwNe,SAAUrpC,EAAWC,EAAMoL,GpBywNtC,GoBxwNGskC,GAAQ/6C,KAAKswC,WACb0K,EAA2B,IAAjBD,EAAMvhD,OAChB83C,EAAOtxC,KAAKq0C,iBAAiBjpC,EAAWC,GACxC7G,EAEJxE,IAAIA,MAAKuwC,eAAee,IpBywNnBtxC,KoBxwNIuwC,eAAee,GACvB1wC,QpB0wNA,IoBxwNGq6C,GAAe,QAAAA,KpB2wNd,GAFAz2C,EoBtwNDkwC,mBAAKqG,EAAMvhD,OpBwwNV,CAIA,GoBxwNG0hD,GAAYH,EAChB92C,cAAOO,GAAM+rC,eAAe2K,EAC5B5J,MAAI9sC,EAAM40B,MAAQ8hB,EAAU5vC,IAAM9G,EAAM40B,KAAKya,OpBywNxCqH,EoBxwNSC,QAAU32C,EAAM42C,aAAaF,EAAUG,GAAIH,EAAU5vC,EAAG4vC,EAElEzkC,MpBwwNCjS,EoBxwNKgsC,gBAAgB0K,EAAU5J,OAEhC,EpBwwNC4J,EoBxwNSC,QAAQ95C,OAAOmD,EAAMs2C,yBAAyB34C,KAAKqC,EAAO02C,EAEpE5J,OpBwwNC4J,EoBxwNSC,QAAQt6C,KACdq6C,EAAUj6C,IAAIR,QAAQ0B,KAAK+4C,EAAUj6C,IAAKi6C,EAAUzkC,MACpDykC,EAAUj6C,IAEjBN,SpBswNIu6C,EoBrwNSj6C,IACbN,SpBswNA27B,WoBrwNU2e,EACd,KAEGK,EAAMxqB,EAAAhrB,YAAYqF,sBAAsBC,EAC5CC,GAAI6vC,GAAaI,IAAKA,EAAKD,GAAIjwC,EAAWE,EAAGD,EAAMimC,KAAMA,EAAM76B,KAC/DA,GAAIxV,EAAMi6C,EAAUj6C,IAAA,GAAU9D,GAAEkC,IAAIC,SAAS,WpBswNxC47C,EoBrwNSC,SAAWD,EAAUC,QAE/Bv6C,SpBqwNC4D,EoBrwNKs2C,yBAENxJ,SAAO9sC,GAAM+rC,eACbe,EpBqwNC,KoBrwNI,GAAI/2C,GAAIwgD,EAAMvhD,OAAS,EAAGe,GAAK,EAAGA,IACnC,CpBqwNC,GoBrwNGghD,GAAOR,EACXxgD,EpBqwNC,IoBrwNGghD,EAAKjK,OAASA,EACd,CpBqwNCyJ,EoBrwNK52C,OAAO5J,EACb,EACH,UpBgxNR,OARAwgD,GoBrwNKz/C,KAEN4/C,GpBqwNCl7C,KoBrwNIuwC,eAAee,GAEpBrwC,EAAI+5C,GpBswNC1e,WoBrwNU2e,EACd,GAGJh6C,GpBuwNAu6C,coBrwNc,WpBswNV,GoBrwNGn8C,GAAMW,KAAK2wC,KACXn1B,EAAMxb,KAAKo5B,KACXqiB,EAEJ,CpBqwNC,IoBrwNGjgC,EACA,CpBqwNC,GoBrwNG/c,GAAM+c,EACVkQ,WpBqwNC+vB,GoBrwNQjgC,EAAIzZ,QAAQud,IAAI7P,QAAQhR,GAAKmN,EAAIzO,EAAEoS,WAAWC,SAASC,QAAQhR,GAC3EmN,EpBuwNAvM,EoBrwNGg2C,OAASx2C,KAAKC,MAAMO,EAAIiW,UAAYjW,EAAI2xC,aAC5C,IpBqwNC3xC,EoBrwNGuyC,OAAS/yC,KAAKC,MAAMO,EAAIiW,UAAYmmC,GAAUp8C,EAAI4xC,aACtD,KpBqwNC5xC,EoBrwNG+1C,WAAa,GAAIj4C,GAAE2iB,MAAMzgB,EAAIg2C,QAASh2C,EAAIuyC,QpBuwN7Cz0C,EoBrwNCwxB,QAAQiqB,YAAY54C,KAAK80C,eAAgBz1C,EAC9C+1C,apBuwNA3B,aoBrwNa,WpBswNTzzC,KoBrwNIw6C,eAAex6C,KACpBo5B,OpBwwNHohB,eoBrwNe,SAASh/B,GpBswNpB,GoBrwNGnc,GAAMW,KACV2wC,IpBqwNCtxC,GoBrwNGob,YAAce,EAClBq4B,MpBqwNCx0C,EoBrwNGwoB,SAAWiJ,EAAAhrB,YAAYoF,UAAU7L,EACrCob,apBqwNCpb,EoBrwNGiW,SAAW,IAAMjW,EACxBwoB,UpBkxNAktB,kBoBrwNkB,SAAU2G,GACrB17C,KAAK27C,qBpBswNJhP,aoBtwNwC3sC,KAA4B27C,oBpBwwNxE,IoBvwNGn3C,GACJxE,IpBuwNCA,MoBvwNI27C,oBAAArf,WAAiC,WAC9B93B,EAAMo3C,WpBwwNLp3C,EoBtwNJq3C,kBACFH,GACN,IpBywNAI,eoBvwNe,WpB0wNX,IoBvwNI,GAFDjrC,MACAq/B,EAAalwC,KAAK+B,QACtBmuC,WAAS31C,EAAI,EAAGhB,EAAM22C,EAAW12C,OAAQe,EAAIhB,EAAKgB,IpBwwN7CsW,EoBvwNGq/B,EAAW31C,KAClB,CpBwwNA,OoBtwNJsW,IpBywNAkjC,SoBvwNS,WpBwwNL,GoBvwNGv4B,GAAMxb,KACVo5B,IpBuwNC,IoBvwNI5d,EpBuwNJ,CAGA,GoBzwNGnQ,GAAOmQ,EAAIs2B,UACXlhC,EAAS4K,EAEbkQ,WAAI1rB,MAAK2wC,KAAKkB,YpB0wNT7xC,KoBxwNJw7C,gBpB0wNAx7C,KoBzwNIu1C,UACLlqC,EAAIrL,KAAK+B,QAAQmuC,WAAW12C,SpB0wNvBwG,KoBzwNI2wC,KAAKS,YAAcpxC,KACxB87C,iBpBywNC97C,KoBzwNI+B,QAAQmuC,cpB4wNhB,IoBzwNG6L,GAAc/7C,KAAKm1C,qBAAqBvkC,GACxCorC,EAAYh8C,KAAK61C,qBAAqBkG,GACtC78B,EAAQlf,KAEZi8C,iBpBkxNC,IoBlxNGD,EAAUluC,IAAIlC,EAAI,IpB0wNjBowC,EoB1wNgCluC,IAAIlC,EAAQ,GAC7CowC,EAAUjuC,IAAInC,GAAKsT,EAAMtT,IpB4wNxBowC,EoB5wNuCjuC,IAAInC,EAAIsT,EAAMtT,EAAQ,GpB+wNjE5L,KoB7wNIk8C,sBAAsB7wC,EAE3B2wC,GAAI3wC,EAAOrL,KAAK+B,QAAQs0C,SAAWhrC,EAAOrL,KAAK+B,QAAQouC,QAGtD,WpB2wNInwC,MoB7wNI+0C,kBACL,IpBixNH,KoB7wNI,GAAInoC,GAAIovC,EAAUluC,IAAIlC,EAAGgB,GAAKovC,EAAUjuC,IAAInC,EAAGgB,IpB8wN/C,IoB7wNI,GAAIrS,GAAIyhD,EAAUluC,IAAIpC,EAAGnR,GAAKyhD,EAAUjuC,IAAIrC,EAAGnR,IAChD,CpB6wNC,GoB7wNG2E,GAAS,GAAI/B,GAAE2iB,MAAMvlB,EACzBqS,EpB6wNC1N,GoB7wNMoM,EAAItL,KAEXu1C,UAAKv1C,KAAKspC,OAAOtpC,KAAKq0C,iBAAiBn1C,KpB8wNlCc,KoB7wNIg0C,SACR90C,MpBkxNZg9C,sBoB7wNsB,SAAU7wC,EAAM2wC,GpBgxNlC,GoB7wNG38C,GAAMW,KAAK2wC,KACX7iC,EAAMkuC,EAAUluC,IAChBC,EAAMiuC,EAEVjuC,GpB6wNC,KoB7wNI,GAAIujC,KAAQjyC,GAAIyxC,kBACjB,CpB6wNC,GoB7wNGsJ,GAAe/6C,EAAIyxC,kBACvBQ,IAAI8I,EAAa9uC,IAAMD,GAChB+uC,EAAa1uC,EAAIoC,EAAIpC,GACrB0uC,EAAa1uC,EAAIqC,EAAIrC,GACrB0uC,EAAaxuC,EAAIkC,EAAIlC,GACrBwuC,EAAaxuC,EAAImC,EAAInC,IpB0wNvB5L,KoBxwNIqxC,uBACRC,KpB4wNR6K,eoBxwNe,SAAU/wC,EAAWC,GpBywNhC,GoBxwNGhM,GAAMW,KAAK2wC,KACXW,EAAOtxC,KAAKq0C,iBAAiBjpC,EAAWC,GACxC+uC,EAAe/6C,EAAIyxC,kBAAkBQ,GACrC+I,EACJ,IpB+wNC,OoB/wNGD,KACIA,EAAaC,WpBywNZA,EoBxwNYD,EAChBC,WpBywNID,EoBxwNYC,WAAaA,EAAiB,GAAAvK,GAAAsM,iBAAiBp8C,KAAMoL,EACrEC,IAGRgvC,GpB0wNAe,aoBxwNa,SAAUhwC,EAAWC,EAAMoL,GpBywNpC,GoBxwNGpX,GAAMW,KAAK2wC,KACX0L,GAAY,EACZC,EAAwB,KACxBr7C,EAAA,GAAU9D,GAAEkC,IAAIC,SAAS,WpBywNxB+8C,GoBvwNG,EpBwwNHC,GoBxwN4BA,EAC5B17C,UpB0wNJ,KoBxwNIZ,KAAKo5B,KpB0wNL,MADAn4B,GoBvwNDN,SACHM,CpBywNA,IoBxwNGo5C,GAAar6C,KAAKm8C,eAAe/wC,EAAWC,GAAQrL,KAAKo5B,KAC7Dya,MpBgxNC,OoBhxNGwG,IpBywNCh7C,EoBxwNG0yC,aAAa+B,SAASjzC,KAAK,WACtBw7C,IpBywNAC,EoBxwNuBjC,EAAWkC,SACnC9lC,GpBwwNC6lC,EoBxwNqBz7C,KAAKI,EAAIR,QAAQ0B,KAAKlB,EAAKwV,GAAOxV,EAC3DN,WAIZM,GpB0wNAm3C,kBoBxwNkB,SAAU7rC,GpB0wNxB,GoBzwNGlN,GAAMW,KAAK2wC,KACXtlC,EAAOrL,KAAKo5B,KAAKya,MACjBwB,EAASh2C,EAAIg2C,QAAU,EpB4wN1BzD,EoB3wNYvyC,EAAIuyC,QAAU,EpB8wN1B4K,EoB7wNer/C,EAAEoS,WAAWC,SAASqQ,UAAU,GAAI1iB,GAAE2iB,MAAMvT,EAAOuB,IAAIpC,EAAGa,EAAOuB,IAAIlC,IACjF6wC,EAAYt/C,EAAEoS,WAAWC,SAASqQ,UAAU,GAAI1iB,GAAE2iB,MAAMvT,EAAOwB,IAAIrC,EAAGa,EAAOwB,IAAInC,IACjF+a,EAAe3mB,KAAKo5B,KAAK0gB,YACzB9W,EAAKrc,EAAasc,eAClBC,EAAKvc,EAAawc,eAClBj3B,EAEJ,CAAIg3B,GAAGl7B,IAAMg7B,EAAGh7B,IAAM,MACdy0C,EAAUz0C,IAAMg7B,EAAGh7B,IpB8wNlBkE,EoB7wNI,KAAO,EAAIrN,KAAKC,OAAOkkC,EAAGh7B,IAAMy0C,EAAUz0C,KAClD,MAAUw0C,EAAUx0C,IAAMk7B,EAAGl7B,MpB8wNzBkE,EoB7wNI,IAAMrN,KAAKC,OAAOokC,EAAGl7B,IAAMw0C,EAAUx0C,KAC7C,OpB+wNJw0C,EoB7wNSx0C,KACVkE,EpB6wNCuwC,EoB7wNSz0C,KAEVkE,CpB6wNC,IoBzwNGk3B,GAAMC,EAAMpc,EAChBC,EALI60B,EAAc/7C,KAAKo5B,KAAKsjB,iBACxBC,EAAW38C,KAAKo5B,KAAK3pB,QAAQ+sC,GAC7BI,EAAW58C,KAAKo5B,KAAK3pB,QAEzBgtC,EACIV,IpB8wNC3Y,EoB7wNMvkC,KAAKC,OAAOD,KAAKkP,IAAI6uC,EAAShxC,EAAGmwC,EAAYjuC,IAAIlC,GAAKgmC,GAC7D,KpB6wNCvO,EoB7wNMxkC,KAAKC,OAAOD,KAAKiP,IAAI6uC,EAAS/wC,EAAGmwC,EAAYhuC,IAAInC,GAAKgmC,GAC7D,KpB6wNC3qB,EoB7wNMu1B,EAAUx0C,MAAO,IAAO+zC,EAAYjuC,IAAIpC,EAAI7M,KAAKkP,IAAI4uC,EAASjxC,EAAGqwC,EAAYjuC,IACpFpC,GpB6wNCub,EoB7wNMpoB,KAAKC,OAAOmoB,EAAOouB,GAC1B,KpB6wNCnuB,EoB7wNMu1B,EAAUz0C,KAAO,IAAM+zC,EAAYhuC,IAAIrC,EAAI7M,KAAKiP,IAAI8uC,EAASlxC,EAAGqwC,EAAYhuC,IACnFrC,GpB6wNCwb,EoB7wNMroB,KAAKC,OAAOooB,EAAOmuB,GAC7B,OpB8wNIjS,EoB7wNMvkC,KAAKC,OAAO89C,EAAShxC,EAAIgmC,GAChC,KpB6wNCvO,EoB7wNMxkC,KAAKC,OAAO69C,EAAS/wC,EAAIgmC,GAChC,KpB6wNC3qB,EoB7wNMpoB,KAAKC,OAAO69C,EAASjxC,EAAI2pC,GAChC,KpB6wNCnuB,EoB7wNMroB,KAAKC,OAAO89C,EAASlxC,EAAI2pC,GACnC,KpB+wNA,KoB7wNI,GADD8C,MACKzsC,EAAIub,EAAMvb,GAAKwb,EAAMxb,IpB8wNzB,IoB7wNI,GAAIE,GAAIw3B,EAAMx3B,GAAKy3B,EAAMz3B,IAC1B,CpB6wNC,GoB7wNG0lC,GAAOtxC,KAAKq0C,kBAAkB3oC,EAAGA,EAAGE,EAAGA,GAC3CP,EpB6wNC8sC,GoB7wNQ7G,IACZ,EpB+wNJ,MoB5wNJ6G,IpB+wNAhC,kBoB7wNkB,SAAU7kC,GpB8wNxB,GoB7wNGjS,GAAMW,KAAK2wC,KACXkM,EAAoB78C,KAAK+B,QAAQ86C,mBAAqBx9C,EAE1DsH,QpB6wNCtH,GoB7wNG+1B,WAAa9jB,EAAK8jB,WAAap1B,KAAK+B,QAAQqzB,YAAcj4B,EAAEkC,IAAIw0B,kBAAkBe,cAAcioB,GAEhG78C,KAAK+B,QAAQi2B,gBpB8wNZ1mB,EoB7wNHtR,KAAK+B,QACZi2B,epB+wNM34B,EoB7wNG4rB,cAAgB3Z,EAAK2Z,cpB8wNxB5rB,EoB7wNGy9C,cAAgBxrC,EAAKwrC,cAAgB,IAAInjD,cpB8wN5C0F,EoB7wNG09C,eAAiBzrC,EAAK0rC,qBAAuB,EpB8wNhD39C,EoB7wNG49C,kBAAoB59C,EAAI09C,cpB+wN3B,IoB7wNG3yC,GAAOkH,EAAKlH,MAChB,QpBwyNC,IoBxyNGkH,EAAKg3B,WpB8wNJl+B,GoB9wNqC,YpBgxNzC/K,EoB/wNG60C,UAAY9pC,EpBgxNf/K,EoB/wNGyjC,SpBixNH3lC,EoB/wNCqF,OAAOnD,EAAKlC,EAAEC,QAAQytB,kBACxBvZ,IAAIjS,EAAI64B,apBgxNH74B,EoB/wNG64B,YAAYsQ,WACnBl3B,GACG,eAAiBA,IACbA,EAAK4rC,cAAe79C,GAAI6O,uBpBgxNvB7O,EoB/wNG89C,YAAc99C,EAAI6O,qBAAqBoD,EAAK4rC,cAGpDl9C,KAAKo9C,iBpBgxNJp9C,KoB/wNIo9C,gBACRt6C,apBqxNAzD,EoB/wNG4rC,OAAS35B,EAAK25B,OpBgxNjB5rC,EoB/wNGytC,UAAYx7B,EAChBw7B,UpB+wNCztC,EoB/wNG0tC,QAAUz7B,EACdy7B,QpB+wNC1tC,EoB/wNG83B,WAAa7lB,EACjB6lB,WAAI,kBAAoB93B,GAAI62C,cACxB,CpB+wNC,GoB/wNGnf,GAAO13B,EAAI62C,cACflf,cAAI,gBAAiBD,KpBixNhB13B,EoBhxNG83B,WAAaJ,EAAKK,YAAYC,OACrC,IACG,UAAYN,KpBkxNX13B,EoBjxNG4rC,OAASlU,EAAKkU,OAAO5T,OAC5B,IACG,aAAeN,KpBmxNd13B,EoBlxNGytC,UAAY3vC,EAAEC,QAAQ8sB,eAAe6M,EAAK+V,UAAUzV,OAC3D,eACG,WAAaN,KpBoxNZ13B,EoBnxNG0tC,QAAU5vC,EAAEC,QAAQ8sB,eAAe6M,EAAKgW,QAAQ1V,OACvD,gBACG,UAAYN,IAAQ,UAAYA,MpBqxN/B13B,EoBpxNG2xC,YAAcja,EAAKse,OAASvrB,OAAOiN,EAAKse,OAAOhe,OACnD,EpBoxNCh4B,EoBpxNG4xC,YAAcla,EAAK6a,OAAS9nB,OAAOiN,EAAK6a,OAAOva,OACtD,IACG,eAAiBN,IAAQ,eAAiBA,MACtCA,EAAKsmB,cpBsxNJh+C,EoBtxNuBg+C,YAActmB,EAAKsmB,YAAoBhmB,OAC/DN,EAAKumB,cpBwxNJj+C,EoBxxNuBi+C,YAAcvmB,EAAKumB,YAAoBjmB,QAEnE,qBAAuBN,KpB2xNtB13B,EoB1xNGgQ,kBAAoB0nB,EAAK1nB,kBAC7BgoB,MAA8B,UAA1Bh4B,EAAIgQ,yBAAwChQ,GAAwBgQ,mBAExE,eAAiB0nB,KpB6xNhB13B,EoB7xN4BiP,YAAcyoB,EAAKzoB,YAAoB+oB,OACpE,eAAiBN,KpB+xNhB13B,EoB/xN4BmP,YAAcuoB,EAAKvoB,YAAoB6oB,OACpE,eAAiBN,KpBiyNhB13B,EoBjyN4BqP,YAAcqoB,EAAKroB,YAAoB2oB,OACpE,eAAiBN,KpBmyNhB13B,EoBnyN4BuP,YAAcmoB,EAAKnoB,YAAoByoB,OACpE,eAAiBN,KpBqyNhB13B,EoBryN4ByP,YAAcioB,EAAKjoB,YAAoBuoB,OACpE,eAAiBN,KpBuyNhB13B,EoBvyN4B2P,YAAc+nB,EAAK/nB,YAAoBqoB,OACpE,eAAiBN,KpByyNhB13B,EoBzyN4B6P,YAAc6nB,EAAK7nB,YAAoBmoB,OACpE,eAAiBN,KpB2yNhB13B,EoB3yN4B+P,YAAc2nB,EAAK3nB,YAAoBioB,OAEpE,gBAAkBN,KpB8yNjB13B,EoB7yNGk+C,aAA2C,MAA5BxmB,EAAKwmB,aAAalmB,OAErC,iBAAmBN,KpB+yNlB/2B,KoB9yNI+B,QAAQm+B,cAChB,UADgCnJ,EAAKmJ,cAAc7I,OAEhD,aAAeN,KpBgzNd/2B,KoB/yNI+B,QAAQo+B,UAChB,UAD4BpJ,EAAKoJ,UAAU9I,OpBuzN/C,GoBpzNG/lB,EAAKg3B,WpBizNJtoC,KoBhzNI+B,QAAQm+B,eAChB,GAEG5uB,EAAKksC,gBACL,CpBgzNCn+C,EoBhzNGm+C,gBAAkBlsC,EACtBksC,epBgzNC,IoBhzNGC,GAAYp+C,EAAI6O,qBACpBwvC,mBAAID,KpBizNCp+C,EoBhzNGs+C,aAAe,SAASjyC,EAAGE,EAAGN,EAAG5B,GpBizNhC,GoBhzNGkG,GAAalG,EACjBkG,UpBgzNC,OoBhzNM,UAAYvQ,EAAIsH,SACjB,mCACQ+E,EACR,MAAQE,EACR,MAAQN,EACR,cAAgBsE,EAAW6tC,GAC3B,QAAUr0C,mBAAmB/J,EACtC+1B,cpB6yNR,GoB1yNG9jB,EAAKssC,UACL,CpB0yNC,GoBxyNDC,EpB4yNKA,GoB3yNqB,MAAtBvsC,EAAKssC,UAAU,GACGr1C,KAAK+mB,MAAMhe,EAChCssC,YpB4yNQzN,QoB1yNQ9wC,EACT09C,epB0yNCe,SoB1yNSxsC,EAEjBssC,WAEG,MAAQC,KpB2yNPx+C,EoB3yN8BiP,YAAcuvC,EAAqBE,IAClE,MAAQF,KpB6yNPx+C,EoB7yN8BmP,YAAcqvC,EAAqBG,IAClE,MAAQH,KpB+yNPx+C,EoB/yN8BqP,YAAcmvC,EAAqBI,IAClE,MAAQJ,KpBizNPx+C,EoBjzN8BuP,YAAcivC,EAAqBK,IAClE,MAAQL,KpBmzNPx+C,EoBnzN8ByP,YAAc+uC,EAAqBM,IAClE,MAAQN,KpBqzNPx+C,EoBrzN8B2P,YAAc6uC,EAAqBO,IAClE,MAAQP,KpBuzNPx+C,EoBvzN8B6P,YAAc2uC,EAAqBQ,IAClE,MAAQR,KpByzNPx+C,EoBzzN8B+P,YAAcyuC,EAAqBS,GpB4zNrE,IoB1zNGR,GAAWz+C,EAAIu+C,UAAYC,EAC/BC,QAAI,YAAaD,KpB2zNZx+C,EoB3zNmC49C,kBAAoBY,EAA0B1N,SpB6zNrF9wC,EoB5zNGk/C,gBAAkB,SAAS70C,GpBg0N1B,IAHA,GoB5zNG5H,GAAMg8C,EACNU,EAAM,eACNz2B,EAAUy2B,EAAIh/B,KAClB1d,GAAOimB,GAAWA,EAAQvuB,OAAS,GpB6zN9BsI,EoB5zNKA,EAAItJ,QAAQuvB,EAAQ,GAAIre,EAAKkG,WAAWvQ,EAAI6O,qBAAqB6Z,EACvE,MpB4zNCA,EoB5zNSy2B,EAAIh/B,KACjB1d,EpB6zNA,OoB3zNJA,IpB6zNAzC,EoB5zNGo/C,6BAA+BthD,EAAEkC,IACxCq/C,kBpB6zNA1+C,KoB5zNI+B,QAAQ48C,YAAcrtC,EAAKstC,WACnC,IpB8zNAnM,iBoB5zNiB,WpB6zNbzyC,KoB5zNIm2C,kBAAkBn2C,KAAK2wC,KAC/BuF,gBpB8zNA2I,eoB5zNe,WpB6zNX,GoB5zNGx/C,GAAMW,KAAK2wC,KACpBz2B,KACArJ,IpB8zNM,KoB5zNI,GAAIygC,KAAQjyC,GAAIyxC,kBACjB,CpB4zNC,GoB5zNGsJ,GAAe/6C,EAAIyxC,kBAAkBQ,GACjD+I,EAAaD,EACLC,UAAIA,IpB6zNCA,EoB5zNUyE,UAAUx+C,QAAQ,SAASwD,GpB6zNjCoW,EoB5zNXpW,EAAGlM,KACR,IpB+zNI,IoB5zNI,GAAIA,KAAMsiB,GpB6zNVrJ,EoB5zNNvV,KACJ1D,EpB8zNM,OoB3zNJiZ,IpB8zNAxC,YoB5zNY,SAAUhG,EAAK02C,GpB6zNvB,MoB5zNMjuB,GAAAhrB,YAAYuI,YAAYhG,EAAK02C,EAAS/+C,KAAK2wC,KACrDziC,0BpBi0NC,SAASvW,EAAQD,EAASH,GAE/B,YAEA2N,QAAOK,eAAe7N,EAAS,cAC3BiG,OAAO,IAEXjG,EAAQ0+C,aAAe31B,MAEvB,IAAIjb,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,IqBpmQ7OmrB,EAAAv5B,EAAA,GAEtB6+C,EAAe,SAAS/2C,GrBumQvBW,KqBtmQIX,IACLA,ErBsmQCW,KqBtmQI8zC,SAAW,GAAI32C,GAAEkC,IAEtBC,SrBsmQCU,KqBtmQIg/C,YACL,ErBsmQCh/C,KqBtmQIi/C,cACL,ErBsmQCj/C,KqBtmQIk/C,WrBumQJl/C,KqBtmQIm/C,kBrBumQJn/C,KqBtmQIo/C,oBrBumQJp/C,KqBtmQIq/C,qBAEL,CrB0mQC,KqBtmQI,GAJDlP,GAAUmP,IACVjJ,IAAWiJ,KACXl3C,EAAM/I,EAAIuQ,WAAWihC,WAEhBt2C,EAAI,EAAGhB,EAAM6O,EAAI5O,OAAQe,EAAIhB,EAAKgB,IACvC,CrBsmQC,GqBtmQGimB,GAAKpY,EACT7N,ErBsmQC41C,GqBtmQStxC,KAAKiP,IAAIqiC,EAAS3vB,EAC5BwI,SrBsmQCqtB,EqBtmQSx3C,KAAKkP,IAAIsoC,EAAS71B,EAC/ByI,SrBumQAjpB,KqBtmQImwC,QAAUA,IAAYmP,IAAW,EACtCnP,ErBsmQCnwC,KqBtmQIq2C,QAAUA,MAAaiJ,KAAW,GAC1CjJ,EACDD,GAAavwC,WrBumQR05C,iBqBtmQiB,SAASl0C,GrBymQtB,IqBvmQI,GADDqoB,GACJ,EAASn5B,EAAI,EAAGhB,EAAMyG,KAAKk/C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IAChD,CrBumQC,GqBvmQG2W,GAAQlR,KAAKk/C,QACjB3kD,ErBumQC,MqBvmQG8Q,EAAO6F,EAAM+X,SAAW5d,EAAO6F,EAAM8X,SrBumQxC,CAGA,GqBzmQGM,GAAcpY,EAClBoY,WrB0mQC,IqBzmQGtpB,KAAKw/C,iBAAmBl2B,KAAiB,WAAaA,IACtD,CrBymQCoK,EqBzmQS0iB,EACVqJ,cACH,OrB0mQA,GqBzmQGC,GACJ,CAAI,eAAgBp2B,KAAgBA,EAAYzT,arB0mQ3C6pC,EqBzmQU7gD,KAAKkP,IACZlP,KAAK0e,IAAI+L,EAAYrT,WAAW,IAChCpX,KAAK0e,IAAI+L,EAAYrT,WAE5B,MrBumQAyd,EqBtmQS70B,KAAKkP,IAAIub,EAAYoK,QAAUgsB,EAC5ChsB,IrBumQA,MqBrmQJA,IrBwmQA8gB,eqBtmQe,SAASpU,GrBumQpB,IqBtmQIA,ErBumQA,MqBtmQMtP,GAAAhrB,YACVyG,QrBwmQAvM,MqBtmQIi/C,cAAgBj/C,KAAKu/C,iBAAiBv/C,KAAKX,IAEhDob,YrBsmQC,IqBtmQGklC,GAAW,EAAI3/C,KAAKi/C,cAAgBnuB,EAAAhrB,YAAYoF,UAAUk1B,EAAa90B,GAAK,GrBumQ/E,OqBtmQMwlB,GAAAhrB,YAAY8hB,cAAcwY,EAAa10B,EAAG00B,EAAax0B,EAAGw0B,EAAa90B,GAAG+f,UACpFs0B,IrBymQAxL,gBqBtmQgB,SAAS9oC,GrBumQrB,IqBtmQI,GAAI9Q,GAAI,EAAGhB,EAAMyG,KAAKk/C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IAChD,CrBsmQC,GqBtmQG2W,GAAQlR,KAAKk/C,QACjB3kD,ErBsmQC,IqBtmQG8Q,GAAQ6F,EAAM8X,SAAW3d,GAAQ6F,EAAM+X,QrBumQtC,OqBrmQJ,ErBwmQJ,OqBrmQJ,GrBwmQA6tB,SqBtmQS,SAASv2C,GrBumQd,GqBtmQGiE,GACJxE,IrBsmQCA,MqBtmQI8zC,SAASjzC,KAAK,WrBwmQd,IqBtmQI,GADDgQ,MACKtW,EAAI,EAAGhB,EAAMiL,EAAM06C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IACjD,CrBsmQC,GqBtmQG2W,GAAQ1M,EAAM06C,QAAQ3kD,GACtBqT,IACAsD,GAAMoY,crBumQL1b,EqBtmQE0b,aAAehmB,MAAO4N,EAAMoY,YAClChmB,QACG4N,EAAM0uC,arBumQLhyC,EqBtmQEgyC,YAAct8C,MAAO4N,EAAM0uC,WACjCt8C,QrBumQAuN,EqBtmQGvV,KACPsS,GACGrN,GrBumQCA,EqBrmQJsQ,KrBwmQJ7Q,KqBrmQJgyC,crBwmQA6N,UqBtmQU,WrBumQN,GqBtmQG7/C,KAAKw/C,eAAiB,EACtB,CrBsmQC,GqBtmQGh7C,GACbxE,IAAIA,MAAKX,IAAI64B,arBumQCl4B,KqBtmQRX,IAAI64B,YAAYgS,UAAU,cAAe,SAASpmC,GrBumQtC,MqBvmQmDU,GAAMs7C,gBAAsBh8C,KrB0mQvF9D,KqBxmQI8zC,SACRrzC,YrB2mQJuxC,WqBxmQW,WACHhyC,KAAKq/C,qBrBymQLr/C,KqBvmQJ+/C,oBrBymQA,KqBxmQI,GAAIxlD,GAAI,EAAGhB,EAAMyG,KAAKm/C,eAAe3lD,OAAQe,EAAIhB,EAAKgB,IrBymQtDyF,KqBxmQIggD,cAAchgD,KAAKm/C,eAC3B5kD,GrB2mQA,OAFAyF,MqBxmQIm/C,kBrBymQJn/C,KqBvmQD6/C,YAAO7/C,KACV8zC,UrB0mQA+C,UqBxmQU,WACF72C,KAAKq/C,qBrBymQLr/C,KqBvmQJ+/C,oBrB0mQA,KqBxmQI,GADDlvC,MACKtW,EAAI,EAAGhB,EAAMyG,KAAKk/C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IAChD,CrBwmQC,GqBxmQG2W,GAAQ/T,EAAEqF,UAAWxC,KAAKk/C,QAC9B3kD,GrBwmQC2W,GqBxmQKoY,YAAc8sB,EAAa6J,aAAa/uC,EAC9CoY,aAAIpY,EAAM0uC,arBymQL1uC,EqBxmQK0uC,WAAaxJ,EAAa6J,aAAa/uC,EAChD0uC,mBACM1uC,GACPgvC,qBAAOhvC,GACPivC,cAAOjvC,GACPkvC,aAAOlvC,GACP9G,KrBwmQCyG,EqBxmQGvV,KACP4V,GrBymQA,MqBvmQJL,IrB0mQAmmC,YqBxmQY,WrBymQRh3C,KqBxmQIk/C,WrBymQJl/C,KqBxmQIX,IAAIgzC,eACT,ErBwmQCryC,KqBxmQIX,IAAIs7C,aACZ,GrB0mQA0F,qBqBxmQqB,WrBymQjB,GqBxmQG77C,GACJxE,IrBwmQCA,MqBxmQIk/C,QAAQ1jC,IAAI,SAAS1X,GrBymQrBA,EqBxmQEq8C,UAAY37C,EAClBw6C,erB2mQJ/H,SqBxmQS,SAASz2B,EAAIsF,EAAK+oB,GrB0mQvB,GADA/oB,EqBxmQKA,GACN,EAAIA,EAAM9lB,KAAKk/C,QAAQ1lD,QAAUq1C,EAC7B,CrBwmQC,GqBxmQG39B,GAAQlR,KAAKk/C,QACjBp5B,ErB8mQC,IqB9mQI5U,IrBymQAA,EqBxmQOlR,KAAKsgD,iBrBymQZtgD,KqBxmQIk/C,QAAQp5B,GAChB5U,GrBymQAlR,KqBxmQI8zC,SAAW,GAAI32C,GAAEkC,IACtBC,SrBwmQC4R,EqBxmQKivC,UAAYngD,KAClBg/C,YAAI,UAAYx+B,GACZ,CrBwmQCtP,EqBxmQKgY,OAAS1I,EACf0I,MrBwmQC,IqBxmQU9e,GAAA5E,EAAQgb,EACnB0I,OrBwmQChY,GqBxmQKgvC,eAA0B,WAAT91C,EAAoBjN,EAAEkC,IAAIjH,QAAQgG,SAAS8S,EAAMgY,OAAO1wB,QAAQ,UAAW,MACnF,aAAT4R,EAAsB8G,EAAMgY,OAElC,KrBumQClpB,KqBtmQJqgD,uBrBwmQA,IqBvmQI,GAAI9lD,GAAI,EAAGhB,EAAM68C,EAAamK,aAAa/mD,OAAQe,EAAIhB,EAAKgB,IAC7D,CrBumQC,GqBvmQG8N,GAAM+tC,EAAamK,aACvBhmD,EAAI8N,KAAOmY,KrBwmQNtP,EqBxmQkB7I,GAAOmY,EAAUnY,IAExCmY,EAAG8I,crB0mQFpY,EqBzmQKoY,YAActpB,KAAKwgD,YAAYhgC,EACxC8I,cACG9I,EAAGo/B,arB0mQF1uC,EqB1mQsB0uC,WAAa5/C,KAAKwgD,YAAYhgC,EAAGo/B,WAAY1uC,EAAqBoY,crB4mQ5FtpB,KqB1mQJygD,erB4mQA,MqB3mQMzgD,MACVgyC,crB6mQAsH,eqB3mQe,SAAS1hD,GrB4mQpB,GqB3mQG8R,GAAO1J,KAAKX,IAAI64B,YAAYiT,QAAQvzC,GACpC6zC,EAAgB/hC,EAAOA,EAAK+hC,cAAgB,EAC5Cv6B,EAAQlR,KAAKk/C,QACjBzT,ErB2mQC,OAAOv6B,IACHkY,0BqB3mQ8BlY,EAAMkY,4BACjC,ErB2mQHC,sBqB3mQ0BnY,EAAMmY,wBAC7B,ErB2mQHq3B,gBqB3mQoBxvC,EAAMiY,SACvB,KrB2mQHw3B,UqB3mQc,cAAcC,KAAK1vC,EAAMiY,UAI/C,MrBgnQAgwB,YqBzmQY,SAASzvC,GrB0mQjB1J,KqBzmQI8/C,gBACLp2C,ErBymQC,IqBtmQDy2C,GAHIjvC,EAAQlR,KAAKk/C,QAAQx1C,EAAK+hC,crB4mQ7B,OqBzmQIv6B,GACDA,EAAM2vC,WAAa7gD,KAAKX,IAAIwzB,WAAanpB,EAAK9R,KAAOoI,KAAKX,IAAIwzB,UAAUj7B,GACpEsZ,EAAM0uC,YrB4mQLO,EqB3mQSjvC,EAAM0uC,WAAWO,UAAW,EAClCA,IAAYz2C,EAAKo3C,erB4mQhBp3C,EqB3mQIq3C,iBAAmB/gD,KAAKghD,iBAAiBt3C,EAAMwH,EACvD0uC,aACM1uC,EACV0uC,mBACUl2C,GACVq3C,iBAEJ,OrB4mQAZ,EqB3mQSjvC,EAAMivC,UAAW,EACvBA,IAAYz2C,EAAKo3C,erB4mQhBp3C,EqB3mQIkM,gBAAkB5V,KAAKghD,iBAAiBt3C,EAAMwH,EACtDoY,cACMpY,EACVoY,aAlB+B,MrB+nQ/Bk2B,eqB1mQD,ErB2mQCQ,cqB3mQc,SAASpyC,GrB6mQnB,GqB5mQG9L,GAAM8L,EAAGqzC,SAAWrzC,EAAGszC,YACvBrpB,EAAMjqB,EAAGib,WAAajb,EAAG+C,WAAalM,YAAa,gBACnDD,EAEJxE,IAAI7C,GAAEC,QAAQixB,QAAU,SAASuyB,KAAK9+C,KrB6mQjC+1B,MAEJA,EqB5mQGrwB,QAAUxH,KAAKX,IACnBmI,UAAExH,KACFw/C,erB4mQCriD,EqB5mQCkC,IAAI4C,YAAYqD,QAAQxD,EAAK+1B,GAAK52B,IAAIJ,KACpC,SAASiD,GrB6mQR,GADA8J,EqB3mQMuyC,UAAY37C,EACfw6C,YAAIpxC,EAAGszC,YrB4mQNtzC,EqB3mQM4lB,aACN1vB,MACG,CrB2mQH,GqB3mQOqjB,GAAIrjB,EAAGO,MACPqmB,EAAI5mB,EACRkP,MAAI7V,GAAEC,QAAQixB,QAAU,SAASuyB,KAAK9+C,KrB6mQrCuE,SqB5mQYsqB,KAAKhnB,YACd7F,GrB4mQHqjB,EqB5mQOrjB,EACJq9C,YrB4mQHz2B,EqB5mQO5mB,EACJs9C,arB4mQH/6C,SqB5mQYsqB,KAAKnnB,YACjB1F,IrB6mQJ8J,EqB5mQMkI,GACHqR,ErB4mQHvZ,EqB5mQMmI,GACH2U,ErB4mQH9c,EqB5mQMtK,MACHQ,CrB4mQH,IqB5mQO4vB,GAAU9lB,EAAGib,UAAYhqB,KAAK8e,KAAK/P,EAAGkI,GAAKlI,EAAGkI,GAAKlI,EAAGmI,GAAKnI,EAAGmI,IAAMlX,KAAKkP,IAAIH,EAAGkI,GAAIlI,EACxFmI,GAAKnI,GAAGyzC,eAAkBzzC,EAAG0zC,kBACrB1zC,EAAG+C,WAA8B,IAAjB/C,EAAG+C,arB6mQtB+iB,GqB7mQoD9lB,EAAe+C,WrB+mQvE/C,EqB9mQMwyC,QACN,GrB+mQJxyC,EqB9mQM8lB,QAAU5J,OAAO4J,EACvB6tB,WrB+mQJ/8C,EqB7mQGg7C,iBrB8mQHh7C,EqB7mQAq7C,aACD,WrB8mQCjyC,EqB7mQMuyC,UAAY37C,EACfw6C,YrB6mQHpxC,EqB7mQMkI,GACH,ErB6mQHlI,EqB7mQMmI,GACH,ErB6mQHnI,EqB7mQMtK,MACH,KrB6mQHkB,EqB5mQGg7C,iBrB6mQHh7C,EqB5mQGq7C,YrB6mQHjtC,QqB7mQWC,KAAK/Q,IAAKA,EAAKrG,KAAM,gBAAiBwP,MACjD,uBrBgnQRguC,kBqB5mQkB,SAASD,EAAW3tC,GrB6mQlC,GqB5mQGhM,GAAMW,KAAKX,IACXrC,EAAUqC,EAAI6O,qBACdjR,EAAQoC,EAAI6oB,mBACZ5c,EAAID,GAAQ,EACZwF,IAEC7Q,MAAKq/C,qBrB6mQLr/C,KqB3mQJ+/C,oBrB6mQA,KqB5mQI,GAAIxlD,GAAI,EAAGhB,EAAMyG,KAAKk/C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IAChD,CrB4mQC,GqB5mQGimB,GAAKxgB,KAAKk/C,QACd3kD,ErB4mQC,MqB5mQG+Q,EAAIkV,EAAGyI,SAAW3d,EAAIkV,EAAGwI,SACrBxI,EAAG0/B,iBAAmB1/B,EAAG0/B,eAAelH,EAAWh8C,EAASC,KrB8mQnE4T,EqB3mQGvV,KACJf,GAAK8E,EAAIk+C,eAAwB,MrB+mQpC,MqB5mQJ1sC,IrB+mQAivC,gBqB7mQgB,SAASp2C,GrB8mQrB,GqB7mQGrK,GAAMW,KAAKX,IACXgM,EAAOhM,EAAIob,YACX+mC,EAAOniD,EAAIk+C,cAAe,EAAK7zC,EAAK+hC,cACpCgW,EAAOzhD,KAAKk/C,QAAQsC,GACpBE,GAAaD,GAAQA,EAAKtB,UAAYz2C,EAE1Co3C,YrB6mQC,IqB7mQGY,GAAah4C,EAAKi4C,YAAct2C,EAChC,CrB6mQC3B,EqB7mQI+hC,eAAgB,ErB8mQpB/hC,EqB7mQI6zC,erB+mQJ,KqB7mQI,GADD7b,GAAU1hC,KAAKi5C,kBAAkBvvC,EAAKkG,WAC1CvE,GAAS9Q,EAAI,EAAGhB,EAAMmoC,EAAQloC,OAAQe,EAAIhB,EAAKgB,IAC3C,CrB6mQC,GqB7mQGurB,GAAM4b,EAAQnnC,GACdimB,EAAKxgB,KAAKk/C,QACdp5B,ErB+mQC,IAFApc,EqB7mQIm3C,UAAYrgC,EACjBqgC,UrB6mQCn3C,EqB7mQI+hC,cACL3lB,EAAI47B,GAAaF,IAAS17B,EACtB,CrB6mQC,GqB7mQG87B,GAASphC,EAAG4/B,QAAU5/B,EAAG4/B,OAAO92B,aAAetpB,KAAKghD,iBAAiBt3C,EAAM8W,EAAG8I,aAC9Eu4B,EAEJ,IrB6mQCn4C,GqB7mQIkM,gBACLgsC,EAAIphC,EAAGo/B,arB8mQFiC,EqB7mQarhC,EAAG4/B,QAAU5/B,EAAG4/B,OAAOR,YAAc5/C,KAAKghD,iBAAiBt3C,EAAM8W,EAC/Eo/B,YrB6mQCl2C,EqB7mQIq3C,iBACRc,GACGxiD,EAAIk+C,crB8mQH7zC,EqB7mQI6zC,aAAajiD,MrB8mQb4V,MqB7mQMsP,EACP8I,YrB6mQCw4B,WqB7mQWthC,EACZo/B,WrB6mQCmC,YqB5mQDH,ErB6mQCb,iBqB3mQRc,IrBgnQJ,GADAn4C,EqB7mQIo3C,aAAetgC,EACpB2/B,SAAK9gD,EAAIk+C,aAAwB,MrBinQpC7zC,EqB/mQIi4C,UACRt2C,ErBgnQA,QqB/mQGrL,KAAKk/C,QAAQx1C,EAAK+hC,iBrBknQjB/hC,EqB/mQI+hC,eAAgB,GAExB,IrBknQJsU,mBqB/mQmB,WrBqnQf,IqB/mQI,GALD1gD,GAAMW,KAAKX,IACXtC,EAAQsC,EAAIuQ,WACZxH,EAAMrL,EAAM8zC,UAAY7nB,QAAS,EAAGC,QAAS,GAAIK,YAAa8sB,EAAa4L,gBAC3EzoD,EAAMsF,KAAKkP,IAAI3F,EAAI5O,OAAQ6F,EAAIwxC,OAEnCr3C,QAASe,EAAI,EAAGA,EAAIhB,EAAKgB,IrBgnQpB,IqB/mQIyF,KAAKk/C,QAAQ3kD,GACd,CrB+mQC,GqB/mQG0nD,GAAW5iD,EAAIwxC,OAAOt2C,IAAM6N,EAChC7N,ErBknQC,IqBlnQI0nD,EAAS34B,crBgnQT24B,EqBhnQiC34B,YAAc8sB,EAA6B4L,eACrDvhC,SAAxBwhC,EAASrC,WACT,CrBinQC,GqBjnQGsC,GAAe35C,KAAK+mB,MAAM/mB,KAAKC,UAAUy5C,EAC7C34B,aAAI44B,GAAax5B,UrBknQZw5B,EqBlnQoCx5B,QAAQy5B,WAAiB,GrBonQjEF,EqBnnQQrC,WACZsC,MAAkC,QAAxBD,EAASrC,kBACTqC,GACVrC,UrBonQA,IqBnnQGhyC,GAAK5N,KAAKsgD,aACd2B,ErBmnQCjiD,MqBnnQIk/C,QAAQ5jD,KACbsS,GAAI5N,KAAKoiD,SAASx0C,EAAG0b,erBonQhBjqB,EqBpnQoCs7C,aAAqB,GrBwnQrE36C,KqBpnQDygD,erBqnQCzgD,KqBrnQIq/C,qBACR,GrBunQAoB,aqBrnQa,WrB2nQT,IqBrnQI,GALDtQ,GAAUmP,IACVjJ,IAAWiJ,KACXjN,GAAgB,EAChBsI,GAEJ,EAASpgD,EAAI,EAAGhB,EAAMyG,KAAKk/C,QAAQ1lD,OAAQe,EAAIhB,EAAKgB,IAChD,CrBqnQC,GqBrnQGimB,GAAKxgB,KAAKk/C,QAEd3kD,ErBqnQCimB,GqBrnQE4I,0BAA4B5I,EAAG4I,6BAA8B,ErBsnQ/D5I,EqBrnQE6I,sBAAwB7I,EAAG6I,wBAC9B,EAAI7I,EAAG4I,6BAA8B,GAAS5I,EAAG6I,yBAA0B,IrBsnQtEgpB,GqBpnQD,ErBqnQC7xB,EqBrnQE6hC,eACN,GrBsnQA7hC,EqBrnQEqgC,UACH,KrBqnQCrgC,EqBrnQE4/B,UACC5/B,EAAG8I,cACEqxB,GACG36C,KAAKoiD,SAAS5hC,EAAG8I,erBsnQhBqxB,GqBpnQJ,GAEDn6B,EAAG8I,YAAY82B,SrBsnQd5/B,EqBrnQE4/B,OAAO92B,YAActpB,KAAKghD,oBAAqBxgC,EACrD8I,cACG9I,EAAGo/B,arBsnQFp/B,EqBrnQEqgC,UAAYzK,EAAakM,UAAU9hC,EAAG8I,YAAa9I,EACzDo/B,cAEDp/B,EAAGo/B,YAAcp/B,EAAGo/B,WAAWQ,SrBsnQ9B5/B,EqBrnQE4/B,OAAOR,WAAa5/C,KAAKghD,oBAAqBxgC,EACpDo/B,arBsnQAzP,EqBrnQStxC,KAAKiP,IAAIqiC,EAAS3vB,EAC5BwI,SrBqnQCqtB,EqBrnQSx3C,KAAKkP,IAAIsoC,EAAS71B,EAC/ByI,SACGjpB,KAAKmwC,UAAYmP,MrBsnQhBt/C,KqBtnQiCmwC,QAAoBA,GACtDnwC,KAAKq2C,YAAaiJ,OrBwnQjBt/C,KqBxnQkCq2C,QAAoBA,GrB0nQ1Dr2C,KqBznQIX,IAAIgzC,cACTA,ErBynQCryC,KqBznQIX,IAAIs7C,YACZA,GrB2nQA6F,YqBznQY,SAAShgC,EAAI+hC,GrB0nQrB,GqBznQG/hC,EACA,CrBynQCA,EqBznQE4/B,QACH,CrBynQC,KqBznQI,GAAI/3C,KAAOmY,GrB0nQX,GqBznQGsQ,EAAAhrB,YAAY8iB,cAAcvgB,GAC1B,CrBynQC,GqBznQGm6C,GAAO1xB,EAAAhrB,YAAY8iB,cAAcvgB,GACjCC,EAAMkY,EACVnY,EAAqB,iBAATC,IrB0nQPkY,EqBznQE4/B,QACH,EAAImC,GAAeA,EAAYl6C,KAASC,ErB0nQnCkY,EqBznQEgiC,GAAQD,EACdC,IACQxiD,KAAKo/C,iBAAiB92C,KrB0nQtBtI,KqBznQIo/C,iBAAiB92C,GAAOnL,EAAEkC,IAAIjH,QAAQ4G,gBAC9CsJ,IrB0nQAkY,EqBznQEgiC,GAAQxiD,KAAKo/C,iBACnB92C,KACuB,kBAATA,KrB0nQdkY,EqBznQE4/B,QACH,ErBynQC5/B,EqBznQEgiC,GACNl6C,GrB6nQR,GqBznQG8B,GACJ,ErBynQC,IqBznQG,WAAaoW,GrB0nQZpW,EqBxnQD,QAAIoW,EAAGygC,UrB0nQFzgC,EqBznQEkT,QACH,IrBynQC1zB,KqBznQIm/C,eAAe7jD,KACvBklB,QALL,IAMWA,EAAG0gC,YrB0nQT92C,EqBxnQD,SrBynQCpK,KqBznQIm/C,eAAe7jD,KACvBklB,OAHM,IAGIA,EAAGrP,YrB0nQT/G,EqBxnQD,SrBynQCoW,EqBznQE4/B,OAAShK,EAAaqM,aAAajiC,EACtCrP,arBynQCqP,EqBznQEiR,cAAgBX,EAAAhrB,YAAYmL,eAAe,KACjDuP,OAJM,IAIIA,EAAGkiC,WrB0nQTt4C,EqBxnQD,SAAM,YAAcoW,KrB0nQfA,EqB1nQyB5L,SAAe,OAF1C,IAGI4L,EAAG7H,SACV,CrB2nQCvO,EqB1nQD,UrB2nQC,IqB3nQGwK,GAAW,EACXxM,EAAMjL,EAAE2H,KAAKkT,QAAQwI,EAAG7H,UAAY6H,EAAG7H,SAAWy9B,EACtDuM,gBrB2nQCniC,GqB3nQE7H,SAAAy9B,EAAwBuM,iBAAiBnnC,IAAI,SAAS1X,EAAIvJ,GrB4nQxD,GqB3nQG+Q,GAAIlD,EAAI7N,IACZuJ,CrB4nQC,OADA8Q,GqB3nQU/V,KAAKkP,IAAI6G,EACpBtJ,GACHA,IrB4nQAkV,EqB3nQE5L,SAAW,EACjBA,MAVM,IAUI4L,EAAG3L,mBACV,CrB2nQCzK,EqB1nQD,SAAM,cAAgBoW,KrB4nQjBA,EqB5nQ2B3K,YAAoB,ErB8nQnD,IqB7nQG5J,GAAOmqC,EAAawM,oBAAoBpiC,EAC5C3L,mBAAa,QAAT5I,ErB8nQCuU,EqB7nQE4/B,QACN,ErB8nQI5/B,EqB7nQE5L,SACN3I,MACMuU,GAAGmR,oBrB8nQTvnB,EqB5nQD,SrB6nQCoW,EqB7nQE4/B,OAAShK,EAAayM,oBAAoBriC,EAChDmR,qBAAUnR,EAAG5L,WrB8nQTxK,EqB5nQD,SAAM,cAAgBoW,KrB8nQjBA,EqB9nQ2B3K,YAAoB,GrBioQvD2K,GqB/nQEpW,KACHA,EAAIoW,EAAG4/B,SAAW5/B,EAAGkT,UrBgoQhBlT,EqB/nQEkT,QAAUlT,EAAG5L,UAChB,ErB+nQC4L,EqB/nQEkT,SAAWlT,EAAGxK,OAASwK,EAAGxK,OAC7B,EAAI,aAAewK,KrBgoQdA,EqBhoQuBkT,SAAWlT,EAAe7P,YrBooQ7D,MqBhoQJ6P,IrBmoQA8/B,aqBjoQa,SAASpvC,GrBmoQlB,GqBloQGtD,IrBmoQCob,QqBloQQ9X,EAAM8X,SACf,ErBkoQCC,QqBloQQ/X,EAAM+X,SACf,GrBkoQCC,OqBloQOhY,EAAMgY,QACd,KrBkoQCC,QqBloQQjY,EAAMiY,SACf,GrBkoQCG,YqBloQapY,EAAMoY,YAActpB,KAAKwgD,YAAYrjD,EAAEC,QAAQwsB,gBAAgB1Y,EAAMoY,iBrBmoQlF62B,UqBloQUngD,KAEfg/C,YrBwoQC,IANApxC,EqBloQEwb,0BAA4BlY,EAAMkY,6BAA8B,ErBmoQlExb,EqBloQEyb,sBAAwBnY,EAAMmY,wBACjC,EAAInY,EAAM0uC,arBmoQLhyC,EqBloQEgyC,WAAa5/C,KAAKwgD,YAAYrjD,EAAEC,QAAQwsB,gBAAgB1Y,EAAM0uC,YAAahyC,EACjF0b,cAEG,UAAYpY,GACZ,CrBkoQC,GqBloQGjH,GAAK9M,EAAEkC,IAAIjH,QAAQgG,SAAS8S,EAAMgY,OAAO1wB,QAAQ,UACrD,KAAIyR,KrBmoQC2D,EqBnoQQsyC,eAAsBj2C,GrBsoQtC,MqBnoQJ2D,IrBsoQAw0C,SqBpoQS,SAAS5hC,GrBqoQd,GqBpoQGxjB,GAAUgD,KAAKX,IACnB6O,oBrBooQC,OqBpoQOsS,KAAOA,EAAGsiC,eAAkBtiC,EAAGuiC,YAAcviC,EAAGuiC,aAC3D/lD,KrBsoQAgkD,iBqBpoQiB,SAASt3C,EAAMkE,GrBqoQ5BA,EqBpoQIA,KrBqoQJ,IqBpoQaxF,GAAK7N,EAAGhB,EAAlBsX,KACA7T,EAAUgD,KAAKX,IAAI6O,qBACnBoD,EAAO5H,EAAKkG,eACZozC,EAAWt5C,EAAKU,KAChBA,EAAOwD,EAAGxD,KACVoN,EAAQ,SAAW5J,GAAKA,EAAG4J,MAAQ,IACnCsB,EAAU,WAAalL,GAAKA,EAAGkL,QAEnC,CrB4oQC,IALAjI,EqBvoQGiF,GAAKlI,EACTkI,GrBuoQCjF,EqBvoQGkF,GAAKnI,EACTmI,GAAInI,EAAG8lB,UrBwoQF7iB,EqBvoQG6iB,QAAU9lB,EACjB8lB,SACG9lB,EAAGib,UACH,CrBuoQC,GqBvoQGzQ,GAAYxK,EAAGib,WACnB,CAAIzQ,IAAoC,gBAAfA,KrBwoQpBA,EqBvoQYxK,EAAG0zC,eAAiB1zC,EAAG0zC,eAAehwC,EAAMtU,GAC5D,GrBwoQA6T,EqBvoQGwC,OAAS+E,GAChB,ErB8oQA,GqB7oQG,aAAexK,KrBwoQdiD,EqBvoQG+H,UAAY,qBAAuBhL,GAAKA,EAAGq1C,kBAAkB3xC,EAAMtU,GAAW4Q,EACrFgL,WACG,aAAehL,KrBwoQdiD,EqBvoQGF,UAAY,iBAAmB/C,GAAMA,EAAGyzC,cAAgBzzC,EAAGyzC,cAAc/vC,EAAMtU,GAAW,EAAK4Q,EACtG+C,WACY,UAATvG,ErBwoQCyG,EqBvoQGzG,KACJA,EAAIwD,EAAGqzC,UrBwoQFpwC,EqBxoQiBowC,QAAUrzC,EAAaqzC,SACzCrzC,EAAGtK,QrB0oQFuN,EqB1oQevN,MAAQsK,EAAWtK,WAH3C,IAIWsK,EAAGiH,mBACV,CrB2oQC,GqB3oQGqE,GAAMtL,EAAGiH,mBACTyE,EAAMJ,EAAIgqC,WAAahqC,EAAIgqC,WAAW5xC,EAAMtU,GAAWkc,EAAII,GAC3DH,EAAMD,EAAIiqC,WAAajqC,EAAIiqC,WAAW7xC,EAAMtU,GAAWkc,EAAIC,GAC3D/K,EAAM8K,EAAI0Y,WAAa1Y,EAAI0Y,WAAWtgB,EAAMtU,GAAWkc,EAAI9K,GAC3DG,EAAM2K,EAAI2Y,WAAa3Y,EAAI2Y,WAAWvgB,EAAMtU,GAAWkc,EAAI3K,GAC3DE,EAAMyK,EAAI4Y,WAAa5Y,EAAI4Y,WAAWxgB,EAAMtU,GAAWkc,EAAIzK,GAC3DE,EAAMuK,EAAI6Y,WAAa7Y,EAAI6Y,WAAWzgB,EAAMtU,GAAWkc,EAC3DvK,EAAIuK,GAAIkqC,QrB4oQHjqC,EqB3oQIta,KAAKiP,IAAIqL,EAAID,EACrBkqC,OrB4oQA,IqB3oQGruC,KrBgpQH,KAJAxb,EqB3oQK2f,EAAIlE,aACVxb,OAAK0f,EAAIiZ,wBrB4oQJjZ,EqB3oQGiZ,sBAAwB,GAAIvwB,OACnCrI,IACIgB,EAAI,EAAGA,EAAIhB,EAAKgB,IACjB,CrB2oQC6N,EqB3oQK8Q,EAAIlE,aACVza,ErB2oQC,IqB3oQG23B,GAAUhZ,EAAIiZ,sBAAsB53B,OACpC63B,EAAMF,EAAQ,GAAKA,EAAQ,GAAG5gB,EAAMtU,GAAWoL,EAAI,GACnDi7C,EAAKj7C,EACT,ErB2oQC,IqB3oQGA,EAAI5O,OAAS,EACb,CrB2oQC,GqB3oQG4C,GAAKgM,EAAI5O,OAAS,EAAI,EAAI04B,EAAQ,GAAKA,EAAQ,GAAG5gB,EAAMtU,GAAWoL,EACvE,ErB2oQCi7C,GqB3oQIvyB,EAAAhrB,YAAYqK,UAAU+hB,EAAQ,GAAKA,EAAQ,GAAG5gB,EAAMtU,GAAWoL,EAAI,GAC1EhM,GrB4oQD2Y,EqB3oQSzZ,MAAM82B,EACnBixB,IrB4oQAxyC,EqB3oQG6iB,QAAU7iB,EAAIiF,GAAKjF,EAAIkF,GAAKlF,EAAI+D,SACpCuE,ErB2oQCtI,EqB3oQGgE,oBrB4oQCzG,GqB3oQEA,EAAIG,GAAGA,EAAI+K,GAAGA,EAAI7K,GAAGA,EAAIE,GAAGA,EAAIwK,GACnCA,ErB2oQCnE,aqBzoQLD,GrB2oQClE,EqB3oQGyyC,uBrB4oQC10B,QqB3oQQxgB,EAAIG,EAAI+K,EAAI7K,EAAIE,EACzBwK,GrB2oQCpE,UqBzoQRA,OApCM,IAoCInH,EAAG+jB,mBrB4oQT9gB,EqB3oQG8gB,mBAAqB/jB,EAC5B+jB,uBACG,CrBupQC,GqBvpQG/jB,EAAGuD,crB4oQFN,EqB3oQG4gB,cAAiB7jB,EAAG6jB,cAAgB7jB,EAAG6jB,cAAgBX,EAAAhrB,YAAYmL,eAAevH,EAAMkE,EAC/F5Q,IAEY,aAAToN,IrB4oQCyG,EqB3oQGzG,KACJA,ErB2oQCyG,EqB3oQG8H,SAAW/K,EAClB+K,UAEgB,YAAbqqC,GAAuC,iBAAbA,GAAyD,YAA1BhjD,KAAKX,IAAIy9C,erB4oQjE1yC,EqB1oQJ,WACGwD,EAAGgH,SACH,CrB2oQC,GqB3oQGA,GAAY,gBAAkBhH,GAAKA,EAAG21C,aAAajyC,EAAMtU,GAAW4Q,EACxEgH,QrB2oQC/D,GqB3oQGiF,GAAKjF,EAAIkF,GACbnB,ErB4oQC/D,EqB3oQG+D,SACJA,EAAI,aAAehH,KrB4oQdiD,EqB3oQG+D,UAAYhH,EACnB+C,WrB4oQAE,EqB3oQG6iB,QACP9e,ErB4oQA/D,EqB3oQGyD,QACJ,GAAI,iBAAmB1G,IAAM,mBAAqBA,MrB4oQ7C4J,EqB3oQO,iBAAmB5J,GAAKA,EAAG41C,cAAclyC,EAAMtU,GACvDwa,ErB2oQCsB,EqB3oQS,mBAAqBlL,GAAKA,EAAGoE,gBAAgBV,EAAMtU,GAChE8b,GrB4oQAjI,EqB3oQG0D,YAAcuc,EAAAhrB,YAAYqK,UAAUqH,EACxCsB,GrB2oQCjI,EqB3oQG4D,UAAY,UAAY7G,GAAKA,EAAGoI,OACvC,ErBupQA,GqBrpQG,aAAepI,KrB4oQdiD,EqB3oQGF,UAAY,iBAAmB/C,GAAMA,EAAGyzC,cAAgBzzC,EAAGyzC,cAAc/vC,EAAMtU,GAAW,EAAK4Q,EACtG+C,WACG,cAAgB/C,KrB4oQfiD,EqB3oQGoF,WAAarI,EACpBqI,YACG,cAAgBrI,KrB4oQfiD,EqB3oQGgF,WAAajI,EACpBiI,YAEY,WAATzL,GAA8B,YAATA,GAA+B,WAATA,GAA8B,aAATA,EAChE,CrB2oQCyG,EqB3oQGzG,KACJA,CrB2oQC,IqB3oQGq5C,GAAM71C,EAAGmE,YACT2xC,EAAK91C,EAAGoL,UACR2qC,EAAwB,gBAARD,GAAmBvsC,SAASusC,EAAGlrD,QAAQ,IAAK,IAAK,IAErEkrD,CAAI,cAAe91C,KrB4oQdiD,EqB3oQG0C,UAAYud,EAAAhrB,YAAYqK,UAAUwzC,EACzC,IACG,qBAAuB/1C,IAAM,uBAAyBA,IrB4oQrD4J,EqB3oQQ,qBAAuB5J,GAAKA,EAAGg2C,kBAAkBtyC,EAAMtU,GAAW0mD,GAC3E,IrB2oQC5qC,EqB3oQU,uBAAyBlL,GAAKA,EAAGi2C,oBAAoBvyC,EAAMtU,GAAWymD,GACjF,ErB2oQC5yC,EqB3oQG0C,UAAYud,EAAAhrB,YAAYqK,UAAUqH,EACzCsB,IAAU,eAAiBlL,IAAM,aAAeA,KrB4oQ5CiD,EqB3oQG0C,UAAYud,EAAAhrB,YAAYqK,UAAUwzC,EACzCF,IrBqpQJ,GqBlpQG,aAAe71C,KrB4oQdiD,EqB5oQwBsgB,UAAYvjB,EAAeujB,WACpD,cAAgBvjB,KrB8oQfiD,EqB9oQyBwgB,WAAazjB,EAAgByjB,YAEvDrxB,KAAKX,IAAIs7C,YACT,CrBgpQC,IADAvyC,EqB/oQK0oB,EAAAhrB,YAAYwiB,UAAUK,MAC5BF,OAAKluB,EAAI,EAAGhB,EAAM6O,EAAI5O,OAAQe,EAAIhB,EAAKgB,IACnC,CrB+oQC,GqB/oQGuJ,GAAKsE,EACT7N,ErB+oQC,IqB/oQGuJ,IAAM8J,GACN,CrB+oQC,GqB/oQU,eAAP9J,GrBgpQC,IqB/oQI9G,EAAQ4Q,EAAG9J,IAEf,aACE,IAAW,kBAAPA,EACP,CrB+oQC,GqB/oQG8L,GAAakhB,EAAAhrB,YAAY6J,kBAAkB2B,EAC/CtU,ErB+oQC6T,GqB/oQGizC,UAAYhzB,EAAAhrB,YAAYgiB,cAAcla,EAAG9J,GAChD8L,GrBgpQAiB,EqB/oQG/M,GAAM8J,EACb9J,IAED,eAAiB8J,KrBgpQhBiD,EqB/oQGkzC,YAAcn2C,EACrBm2C,arBipQJ,MqB9oQJlzC,KAELulC,EAAaqJ,eAAiB,IAE9BrJ,EAAa4L,eAAiBt5B,SAAUlR,MAAO,IAAK2qC,UAAW,GAAI55B,QAAStc,KAAM,IAClFmqC,EAAamK,cAAgB,UAAW,UAAW,UAAW,gBAAiB,4BAA6B,yBAC5GnK,EAAauM,kBAAoB,EAAG,GAAI,GAAG,IAAK,GAAI,GAAK,EAAG,IAE5DvM,EAAaqM,aAAe,SAASpxC,GrBgpQhC,GqB/oQG+uC,IAAS,EACT9lD,EAAU6C,EAAEkC,IAChBjH,OrBupQC,IqBvpQG,QAAUiZ,IAAqC,gBAAlBA,GAAQE,OrBgpQpCF,EqB/oQOQ,oBAAsBvX,EAAQ0E,gBAAgBqS,EACtDE,MrB+oQC6uC,GqB9oQJ,GACG,SAAW/uC,IAAsC,gBAAnBA,GAAQhN,QrBgpQrCgN,EqB/oQOS,qBAAuBxX,EAAQ0E,gBAAgBqS,EACvDhN,OrB+oQC+7C,GqB9oQJ,GACG,UAAY/uC,GACZ,CrBgpQC,IqB/oQI,GADDjJ,MACK7N,EAAI,EAAGhB,EAAM8X,EAAQa,OAAO1Y,OAAQe,EAAIhB,EAAKgB,IAClD,CrB+oQC,GqB/oQGypD,GAAK3yC,EAAQa,OACjB3X;AAAoB,gBAARypD,IrBgpQP57C,EqB/oQG9M,KAAKhB,EAAQ0E,gBACjBglD,IrB+oQC5D,GqB9oQJ,GrBgpQIh4C,EqB/oQG9M,KACP,MrBipQJ+V,EqB/oQOgB,sBACXjK,ErBgpQA,MqB9oQJg4C,IAEDhK,EAAa6J,aAAe,SAAS/uC,GrBgpQhC,GqB/oQGL,KrBgpQH,KqB/oQI,GAAIxI,KAAOyoB,GAAAhrB,YAAYwiB,UrBipQvB,IqB/oQI,GADDnjB,GAAO2rB,EAAAhrB,YAAYwiB,UACvBjgB,GAAS9N,EAAI,EAAGhB,EAAM4L,EAAKsjB,OAAOjvB,OAAQe,EAAIhB,EAAKgB,IAC/C,CrB+oQC,GqB/oQGytB,GAAO7iB,EAAKsjB,OAChBluB,EAAIytB,KAAQ9W,KACYuP,SAAhBvP,EAAM8W,KrBgpQLnX,EqB/oQGmX,GAAQzf,KAAK+mB,MAAM/mB,KAAKC,UAAU0I,EACzC8W,MACY,gBAATA,QAAiCnX,GAAImX,GAA8B3V,sBACrD,uBAAT2V,SAAwCnX,GAAImX,GAA8BmK,uBrB4pQ9F,MqBxpQG,cAAgBjhB,KrBmpQfL,EqBlpQGoF,WAAa/E,EACpB+E,YACG,eAAiB/E,KrBmpQhBL,EqBlpQGkzC,YAAc7yC,EACrB6yC,aAEJlzC,GAEDulC,EAAakM,UAAY,SAAS9hC,EAAIyjC,GrBmpQjC,IqBlpQI,GAAI57C,KAAOmY,GrBmpQX,GqBlpQGA,EAAGnY,KAAS47C,EAAI57C,GrBmpQf,MqBjpQJA,ErBopQJ,OqBjpQJ,OAED+tC,EAAawM,oBAAsB,SAASsB,GrB0pQvC,GqBlpQG9D,IAAS,EACT9lD,EAAU6C,EAAEkC,IAAIjH,QAChBmC,EAAI,EACJ6N,GAAO,KAAM,KAAM,KAAM,KAAM,KAAM,MACrC7O,EAAM6O,EACV5O,MrBkpQC,KqBlpQIe,EAAI,EAAGA,EAAIhB,EAAKgB,IACjB,CrBkpQC,GqBlpQGuJ,GAAKsE,EACT7N,EAAK2pD,GAAGpgD,KrBmpQHogD,EqBnpQapgD,GAAU,GACJ,gBAAZogD,GAAGpgD,KrBqpQVogD,EqBppQEpgD,EAAK,YAAcxJ,EAAQ0E,gBAAgBklD,EAC9CpgD,IrBopQCs8C,GqBnpQJ,GrBypQJ,IAFA8D,EqBppQElvC,aAAekvC,EAAGlvC,gBAAkB,EAAG,SAAU,KAAO,EAAG,SAC9D,KrBopQCkvC,EqBppQE/xB,yBACE53B,EAAI,EAAGhB,EAAM2qD,EAAGlvC,aAAaxb,OAAQe,EAAIhB,EAAKgB,IAC/C,CrBopQC6N,EqBppQK87C,EAAGlvC,aACTza,ErBopQC,IqBppQG4pD,IACyB,gBAAZ/7C,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAAM,KAC7C,gBAAZA,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAAM,KAC7C,gBAAZA,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAEpE,KrBgpQC87C,GqBhpQE/xB,sBAAsB72B,KACzB6oD,GAAmB,OAAfA,EAAQ,IAA8B,OAAfA,EAAQ,GrBipQ9B/7C,EqBhpQG,GAAK0oB,EAAAhrB,YAAYqK,UAAU/H,EAAI,GAAIA,EAAI,GAAK,EAAIA,EAAI,GAAK,IAAMA,EACtE,IrBipQIg4C,GqB/oQJ,ErBqpQJ,MqBnpQG,cAAgB8D,KrBipQf9D,GqBjpQsC,GACpCA,EAASvhD,KAAKkP,IAAIm2C,EAAG5qC,GAAI4qC,EAAG/qC,IACtC,MAEDi9B,EAAayM,oBAAsB,SAASuB,GrBmpQvC,GqBlpQGhE,IACJ,EAMI7lD,EAAI,EACJD,EAAU6C,EAAEkC,IAAIjH,QAChBgQ,GAAO,KAAM,KAAM,KAAM,MACzBnH,GAAO,EAAG,EAAG,EAAG,KAChB1H,EAAM6O,EACV5O,MrBkpQC,KqBlpQIe,EAAI,EAAGA,EAAIhB,EAAKgB,IACjB,CrBkpQC,GqBlpQGuJ,GAAKsE,EACT7N,EAAIuJ,KAAMsgD,GACkB,gBAAZA,GAAGtgD,KrBmpQVsgD,EqBlpQEtgD,EAAK,YAAcxJ,EAAQ0E,gBAAgBolD,EAC9CtgD,IrBkpQCs8C,GqBjpQJ,GrBopQAgE,EqBlpQEtgD,GAAM7C,EACZ1G,GrBupQJ,IAFA6pD,EqBlpQEpvC,aAAeovC,EAAGpvC,gBAAkB,EAAG,WAAY,EACtD,WrBkpQCovC,EqBlpQEjyB,yBACE53B,EAAI,EAAGhB,EAAM6qD,EAAGpvC,aAAaxb,OAAQe,EAAIhB,EAAKgB,IrBmpQ9C6N,EqBlpQKg8C,EAAGpvC,aACTza,GrBkpQC6pD,EqBlpQEjyB,sBAAsB72B,MACA,gBAAZ8M,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAAM,KAC7C,gBAAZA,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAAM,KAC7C,gBAAZA,GAAI,GAAmB9N,EAAQ0E,gBAAgBoJ,EAAI,IAEnE,MrB+oQA,OqB7oQJg4C,IrB+oQA1oD,EqB9oQO0+C,gBrBkpQF,SAASz+C,EAAQD,EAASH,GAE/B,YsBh8RD,SAAS6kD,GAAiB70C,EAAO6D,EAAWC,GtB28RvCrL,KsB18RIuH,MACLA,EtB08RCvH,KsB18RIoL,UACLA,EtB08RCpL,KsB18RIqL,KACLA,EtB08RCrL,KsB18RIX,IAAMkI,EACXopC,KtB08RC3wC,KsB18RIsxC,KAAOtxC,KAAKuH,MAAM8sC,iBAAiBjpC,EACxCC,EtB08RC,IsBz8RDg5C,GAAAvzB,EAAAhrB,WtB08RC9F,MsB18RIoW,eAAiBiuC,EACtBjuC,ctB08RC,IsB18RGgqB,GAAeikB,EAAMl5C,sBAAsBC,EAC/CC,EtB08RCrL,MsB18RI0yB,QAAU2xB,EAAMz8B,cAAcwY,EAAa10B,EAAG00B,EAAax0B,EAAGw0B,EACnE90B,GtB08RCtL,KsB18RIoV,IAAM,IAAMgrB,EACjB10B,EtB08RC1L,KsB18RIqV,IAAM,KAAO,EAAI+qB,EACtBx0B,GtB08RC5L,KsB18RIogC,aAELA,EtB08RCpgC,KsB18RIskD,WACAj5C,GAAQrL,KAAKX,IAAI09C,gBAAkB,gBAAkB/8C,MAAKX,KAC1DgM,GAAQrL,KAAKX,IAAI49C,mBAAqB,mBAAqBj9C,MAChEX,ItBw8RCW,KsBx8RIyyB,WtBy8RJzyB,KsBx8RIukD,kBtBy8RJvkD,KsBx8RI8+C,atBy8RJ9+C,KsBx8RIwkD,UAAY,EtBy8RhBxkD,KsBx8RIX,IAAIolD,SAAWzkD,KAAKX,IAAIolD,atB66RhCv/C,OAAOK,eAAe7N,EAAS,cAC3BiG,OAAO,IAEXjG,EAAQ0kD,iBAAmB37B,MsBx8RF,IAAAqQ,GAAAv5B,EAAA,EA2B1B6kD,GAAiBv2C,WtB28RZ6+C,mBsBx8RmB,SAAUpJ,EAAKqJ,GtBy8R9B,GsBr8RGC,GAHAvlD,EAAMW,KAAKX,IACXmF,EAAQxE,KACR6kD,EAAiB,KAEjB5jD,EAAA,GAAU9D,GAAEkC,IAAIC,SAAS,WACjBulD,UAEOrgD,GAAM+/C,eACbK,GtBw8RHC,EsBv8RAjkD,YAGLkkD,EAAU,QAAAA,GAASxJ,EAAK72C,GtBy8RvB,GsBx8RGsgD,GAAOJ,EAEXrJ,GAAI0J,EAAqB,WACjB1J,EAAIhwC,EAAI,EtBy8RPw5C,GACIp5C,EsBx8RE7M,KAAKC,MAAMw8C,EAAI5vC,EAClB,GtBw8RCE,EsBx8RE/M,KAAKC,MAAMw8C,EAAI1vC,EAClB,GtBw8RCN,EsBx8REgwC,EAAIhwC,EAAI,GACZ,ItB08RFrK,EsBv8RJN,StB28RJ,IsBx8RGtB,EAAIolD,SAASM,IAAU1lD,EAAI4lD,eAAiB5lD,EAAI4lD,cAAgB3J,EAAIhwC,EAGvE,WADG05C,ItB08RH,IsBx8RG3hD,GAAUmB,EAAM+/C,eACpBQ,EAAK1hD,GtBo9RAA,EsBx8ROtB,QAAQmjD,cAAgB1gD,EACnCggD,WAZOnlD,EAAIi4C,uBtBy8RH7yC,EsBv8RJ,atBy8RApB,EAAUlG,EsBx8RCkC,IAAI4C,YAAY3G,KAAKypD,GtBy8R5BG,csBx8Rc1gD,EACfggD,UtBw8RCn5C,KsBx8RK7G,EACN6G,KtBw8RC7H,OsBv8RD,EtBw8RCiB,YsBx8RYA,GAEjB,KtBw8RCD,EsBx8RK+/C,eAAeQ,GACxB1hD,GtB28RAuhD,EsBv8RDG,EtBw8RCF,EsBx8RgBxhD,EAEjBpC,ItBw8RC4jD,EsBx8RchkD,KACX,SAASyD,GtBw8RRrD,EsBv8ROR,SAAS66C,IAAKA,EAAKh4C,MAC1BgB,KACD,WtBu8RCjF,EsBt8ROolD,SAASM,IACb,EACHC,MtB08RR,OADAF,GsBp8RDxJ,GACHr6C,GtBu8RAkkD,YsBr8RY,SAAUzvC,GtBs8RlB,GsBr8RG0vC,GAAS1vC,EAAK2vC,iBAAmB3vC,EAAK4vC,qBACtChuB,GtBs8RChF,QsBr8RY5c,EACT4c,QtBq8RHizB,aACIj6C,EsBr8RMoK,EAAK4vC,qBACRh6C,EtBq8RHI,EsBr8RMgK,EAAK4vC,qBACR55C,EtBq8RHE,EsBr8RM8J,EAAK4vC,qBAEZ15C,GtBq8RHw5C,QACI95C,EsBr8RM85C,EACH95C,EtBq8RHI,EsBr8RM05C,EACH15C,EtBq8RHE,EsBr8RMw5C,EAGfx5C,GtBw8RC,OsBx8RG8J,GAAK5T,MtBs8RJw1B,EsBt8RgBkuB,UAAY9vC,EAAW5T,MACpC9B,KAAKX,IAAIi4C,sBAAwBt3C,KAAKylD,oBAC1C/vC,EAAK9W,IAAK8W,EAAKpS,MACfoS,EAAKI,IAAM,EAAGJ,EAAKK,IAAM,EAAGL,EAAKstB,IAAM,IAAKttB,EAAKgwC,IAAM,IACvDhwC,EAAKxJ,IAAM,EAAGwJ,EAAKvJ,IAAM,EAAGuJ,EAAKiwC,IAAM,IAAKjwC,EAAKkwC,IAAM,IAG9DtuB,ItBq8RAmuB,mBsBl8RmB,SAAU7mD,EAAK0E,EAAOwS,EAAIC,EAAIitB,EAAI0iB,EAAIx5C,EAAIC,EAAIw5C,EAAIC,GtBm8RjE,GsBl8RG3yC,GAAMrU,EAAIsU,WACd,KtBk8RCD,GsBl8RGgB,UAAU3Q,EAAOwS,EAAIC,EAAIitB,EAAI0iB,EAAIx5C,EAAIC,EAAIw5C,EAChDC,ItBq8RAC,gBsBl8RgB,SAAU/hD,GtBm8RtB,GsBl8RGqjB,GAAIrjB,EAAGoI,IAAMpI,EAAGoI,GAAK,EAAI,IAAM,GAC/Bwe,EAAI5mB,EAAGqI,IAAMrI,EAAGqI,GAAK,EAAI,IAAM,GAC/B2J,EAAK,EAAGktB,EAAK,IAAM7b,EAAGjb,EAAKib,EAAGw+B,EAClC3iB,CtBw8RC,IsBx8RGl/B,EAAG2H,GAAK3H,EAAG4H,ItBs8RVoK,EsBr8RIktB,EAAIA,EAAK7b,EAAGjb,EAAK,EAAGy5C,EAC5B3iB,GACU,MAAPltB,GAAcktB,EAAK,EtBs8RlB,MsBt8RqC,KtBy8RzC,IsBv8RGjtB,GAAK2U,EAAGg7B,EAAK,IAAMh7B,EAAGve,EAAK,EAAGy5C,EAClCF,CtB68RC,OsB78RG5hD,GAAG6H,GAAK7H,EAAG8H,ItB28RVmK,EsB18RI,EAAG5J,EAAKu5C,EAAIA,EAAKh7B,EAAGk7B,EAC5BF,GACU,MAAP3vC,GAAc2vC,EAAK,EAAmB,MtB+8RrC5vC,GsB58RGA,EAAIC,GAAIA,EAAIitB,GAAIA,EAAI0iB,GACxBA,EtB48RCx5C,GsB58RGA,EAAIC,GAAIA,EAAIw5C,GAAIA,EAAIC,GAE/BA,ItB+8RAE,oBsB58RoB,SAAUv5C,EAAQ8oC,EAAQzD,GtB68R1C,GsB58RGt8B,GAAWtV,KAAKX,IAAIiW,SACpB8qB,EAAepgC,KAAKogC,aACpBlqB,EAAKm/B,EAAS//B,EACda,EAAKy7B,EAASt8B,EACdywC,EAASlnD,KAAKC,MAAM,GAAMoX,EAAK,KtB+8RlCulC,EsB98RY58C,KAAKC,MAAM,GAAMqX,EAAK,KAC/B0R,EAAW,IAAMvS,EACjB0wC,EAAQ5lB,EAAa10B,EAAI2pC,EAASxtB,EtBi9RrCo+B,EsBh9RW7lB,EAAax0B,EAAIgmC,EAAS/pB,EAClCq+B,EAAQrnD,KAAKC,MAAMknD,GACnBG,EAAQD,GAASF,IAAUE,EAAQ,EAAI,GACvCE,EAAQvnD,KAAKC,MAAMmnD,GACnBI,EAAQD,GAASH,IAAUG,EAAQ,EAAI,GACvCn/B,EAAOpoB,KAAKC,OAAOyN,EAAOuB,IAAIpC,EAAI2pC,GAAUxtB,GtBm9R/CX,EsBl9RUroB,KAAKC,OAAOyN,EAAOwB,IAAIrC,EAAI2pC,GAAUxtB,GAC5Cub,EAAOvkC,KAAKC,OAAOyN,EAAOuB,IAAIlC,EAAIgmC,GAAU/pB,GAC5Cwb,EAAOxkC,KAAKC,OAAOyN,EAAOwB,IAAInC,EAAIgmC,GAEtC/pB,EAAIq+B,GAAQj/B,ItBm9RPi/B,EsBn9R8Bj/B,GAC/Bk/B,EAAQj/B,ItBq9RPi/B,EsBr9R8Bj/B,GAC/Bk/B,EAAQhjB,ItBu9RPgjB,EsBv9R8BhjB,GAC/BijB,EAAQhjB,ItBy9RPgjB,EsBz9R8BhjB,EtB69RlC,KsB19RI,GADDj7B,MACKwE,EAAIw5C,EAAOx5C,GAAKy5C,EAAOz5C,ItB29R3B,IsB19RI,GAAIrS,GAAI2rD,EAAO3rD,GAAK4rD,EAAO5rD,ItB29R3B6N,EsB19RG9M,MtB29RCgQ,EsB19RE80B,EACH90B,EtB09RCI,EsBz9RDnR,EtB09RCqR,EsBz9RDgB,EtB09RCV,GsBz9RD65C,EtB09RC55C,GsBz9RDsvC,EtB09RChwC,GsBz9RDu6C,EtB09RCr6C,GsBx9RRs6C,GtB49RJ,OsBz9RJ79C,ItB89RAk+C,gBsB19RgB,SAAUh6C,GtB29RtB,GsBn9RGi6C,GAPA32C,EAAatD,EAAIsD,WACjB4iB,EAAM5iB,EAAW,GACjBpL,EAAQxE,KACRX,EAAMW,KAAKX,IACXrC,EAAUqC,EAAI6O,qBACdukB,EAAUzyB,KAAKyyB,QACf+zB,EAAmB,KAEnBnR,EAASvrB,OAAOzqB,EAAIg+C,YAAcvsB,EAAAhrB,YAAYuI,YAAYhP,EAAIg+C,YAAaztC,EAAY5S,GAAW,GAAKgD,KAAKoW,eAC5Gw7B,EAAS9nB,OAAOzqB,EAAIi+C,YAAcxsB,EAAAhrB,YAAYuI,YAAYhP,EAAIi+C,YAAa1tC,EAAY5S,GAAW,GAClGypD,EAAUpR,GAAUzD,EACpB8U,EAAQ51B,EAAAhrB,YAAYuI,YAAY,QAASuB,EAAY5S,GACrD8E,EAAM,GACN6kD,EAA0B,KAC1BC,GAAU,EACVl9C,EAAOrK,EAAI64B,YAAYiT,QAAQ3Y,GAC/B4N,EAAepgC,KAAKogC,aACpBymB,EAAY,KACZC,EAEJ,ItBm+RC,IsBn+RGznD,EAAIm+C,kBAA+C,WAA3Bn+C,EAAI62C,cAAc9rC,MAAqB0mB,EAAAhrB,YAAYuI,YAAY,sBAAuBuB,EAAY5S,ItB29RzH4pD,GsB19RS,EACHvnD,EAAIk/C,iBtB29RVz8C,EsB19RKzC,EAAIk/C,gBAAgB70C,GtB29RzBi9C,EsB19RyBtnD,EAC7Bo/C,8BAAUiI,ItB29RN5kD,EsB19RK4kD,EtB29RLC,EsB19RyBtnD,EAC7Bo/C,8BACGmI,EtB29RCJ,EAAmB,GsB19RGrpD,GAAEkC,IAAIC,SAAS,WtB29RjCinD,EsB19RgBjmD,QAAQ,SAASwD,GtB29R7BA,EsBz9RJlD,WtB29RA2lD,EsBz9RJ,WAED,CtB09RCzkD,IsB19ROA,EAAIuH,QAAQ,QAAS,EAAK,IAAM,KAAOhK,EAAI+1B,UtB29RlD,IsB19RG/xB,GAAUrD,KAAKukD,eACnBziD,EAAKuB,GtBi+RAA,EsB19ROtB,QAAQmjD,cAAgBllD,KACnCwkD,WtBm9RInhD,EAAUlG,EsB19RCkC,IAAI4C,YAAY3G,KAAKwG,GtB29R5BojD,csB19Rc1gD,EACfggD,UtB09RC//C,YsB19RYpF,EAAIoF,aAErB,ctB09RCzE,KsB19RIukD,eAAeziD,GACvBuB,GtBg+RAmjD,EAAmB,GsB19RGrpD,GAAEkC,IAAIC,SAAS,iBAE3BkF,GAAM+/C,eACbziD,GtB09RCuB,EsB19ROpC,IACXL,WtB29RAyC,EsB19ROpC,IAAIJ,KAAK2lD,EAAiB/lD,QAAS+lD,EAC9C7lD,QtB29RA,GsB19RGomD,GAAA,GAAwB5pD,GAAEkC,IAAIC,SAAS,WACnCknD,ItB29RCA,EsBz9RD5lD,StB09RC4lD,EsBz9RJ,OtB69RJ,IsB19RGI,EACA,CtB09RC,GsB19RGvlC,GAAa/U,EAAI+U,eACjB2lC,EAAmBP,EAAUzmD,KAAK8lD,oBAAoBzkC,EAAW9U,OAAQ8oC,EAAQzD,IAAWxR,GAC5F/yB,EAAM25C,EAAiBxtD,OACvBytD,EAAkB,WACV55C,EAAM,GtB29RTm5C,EsB39R2C/lD,WAEhDymD,EAAiB,WAEb75C,IACH45C,KACDtC,EAAc,SAASrJ,GtB69RtB,MsB59RUj8C,GAAIs+C,aAAarC,EAAI5vC,EAAG4vC,EAAI1vC,EAAG0vC,EAAIhwC,EAC7C5B,IACDy9C,EAAiB,SAAS7L,EAAKrjD,EAAGqe,GtB69RjC5M,EsB59RQ6pB,aACL,CtB49RH,IsB59RO6zB,IAEJ,CAAIT,KtB69RHrwC,EAAMqwC,EsB59R2BrwC,GtB69R7BjX,IsB39RGA,EtB49RHizB,QsB39RGhmB,EtB49RH5C,KsB39RGA,EtB49RH02B,asB19RDkb,ItB49RH8L,GsB39RA,EtB89RJ,IsB59RO9vB,ItB69RHhF,QsB39ROhmB,EtB49RPhJ,MsB39ROgT,EtB49RPgvC,qBsB39ROllB,EtB49RPilB,gBsB39RO/J,EtB49RPxlC,GsB59RW,EAAGC,GAAI,EAAGitB,GAAI,IAAK0iB,GACvB,ItB49RPx5C,GsB59RW,EAAGC,GAAI,EAAGw5C,GAAI,IAAKC,GAG/B,ItB49RH,IsB59ROa,EACA,CtB49RH,GsB59ROhoD,GAAM+F,EAAMqhD,gBAChB5tD,EtB49RH,IsB59Re,OAARwG,EAGH,WADGyoD,ItB89RP/pD,GsB59RKqF,OAAO80B,EACT74B,GtB49RH2oD,GsB39RA,EtB89RJ,GsB59RO9L,EAAIhwC,IAAM80B,EAAa90B,EACvB,CtB49RH,GsB59RO+7C,GAAUv2B,EAAAhrB,YAAY+F,oBAAoBu0B,EAAcA,EAAa90B,EAAGgwC,EAC5EhwC,EtB49RH,IsB59RO+7C,EAAQp7C,KAAO,EAAI,IAGtB,WADGg7C,ItBm+RP,IAJAG,GsB59RG,EtB69RH9vB,EsB79RQxhB,GAAKjX,KAAKC,MAAMuoD,EACrB37C,GtB69RH4rB,EsB79RQvhB,GAAKlX,KAAKC,MAAMuoD,EACrBz7C,GtB69RH0rB,EsB79RQ0L,GAAK1L,EAAKouB,GAAK2B,EACpBp7C,KAAIw6C,EACA,CtB69RH,GsB79ROzjB,GAAKnkC,KAAKC,MAAMw4B,EAAKquB,GAAK0B,EAC9Bj7C,OtB69RHkrB,GsB79RQxhB,IAAkB,IAAZwhB,EAAKprB,GAAWorB,EAAK0L,GAAK,KACrCA,EtB69RH1L,EsB79RQ0L,GAELA,CtB69RH,IsB79RO0iB,GAAK7mD,KAAKC,MAAMw4B,EAAKsuB,GAAKyB,EAC9Bj7C,OtB69RHkrB,GsB79RQvhB,IAAkB,IAAZuhB,EAAKnrB,GAAWmrB,EAAKouB,GAAK,KACrCA,EtB69RHpuB,EsB79RQouB,GACRA,GtB+9RR,GsB79RO0B,IAAY/nD,EAAIi4C,qBAEhBjqC,ItB69RHw5C,EsB59RGvwC,EACH2wC,QACG,CAAKJ,ItB89RJA,EsB79RexgD,SAASuC,cACrB,UtB69RHi+C,EsB79RaxiD,MAAQwiD,EAAU7zC,OAC/B,KtB89RJskB,EsB79RQ14B,IACLioD,CtB69RH,IsB79ROS,GAAa9iD,EAAM2gD,YAAY7tB,GAC/Bz2B,EAAO,WAEHwM,ItB69RPpV,EsB79RSsvD,SACFV,EACHI,IAEDK,GACIA,YAAsBnqD,GAAEkC,IAAIC,UtB89R/BgoD,EsB79RczmD,KACdA,GACqB,OAAfymD,GtB89RV59C,EsB79RQ6pB,aACL,EACH2zB,KAEArmD,KtBg+RZ0lD,GAAmBS,EsB79RgBxrC,IAAI,SAAS1X,GtB89R5C,GsB79RG0jD,GAAShjD,EAAMkgD,mBAAmB5gD,EACtC6gD,EtBg+RC,OAHA6C,GsB79RM3mD,KAAK,SAAS4mD,GtB89RhBN,EsB79RcM,EAAWnM,IAAKx3C,EAAI2jD,EACtCnkD,QACD4jD,GACHM,ItB+9RAhB,EsB79RgB3lD,KAAK,WtB89RjB4xB,EsB79ROD,GACRq0B,EtB69RCE,EsB59RJtmD,gBAED,CtB89RCiJ,EsB79RI6pB,aACL,CtB69RC,IsB79RGm0B,GAAc,SAASpxC,GtB89RtB,GsB79RGqxC,ItB89RCtoD,IsB59RDA,EtB69RCizB,QsB59RDhmB,EtB69RC5C,KsB59RDA,EtB69RC02B,asB39RLA,EAAKymB,KtB89RAA,EsB79RWxgD,SAASuC,cACrB,UtB69RCi+C,EsB79RSxiD,MAAQwiD,EAAU7zC,OAC/B,ItB89RA,IsB79RG40C,GAAc,SAASC,GtB89RtB,GsB79RG1yB,GAAA3wB,EAAgB2gD,atB89Rf7yB,QsB59RGhmB,EtB69RH1N,IsB59RGioD,EtB69RHvjD,MsB79RUqjD,EAA0BA,EAAwBkB,EAAcF,GACvEE,EtB69RHvC,qBsB59RGllB,EtB69RHt+B,IsB79RQA,IAETjB,EAAO,WtB89RN4xB,EsB79RWD,GACRq0B,EtB69RHE,EsB59RAtmD,UACD00B,GACIA,YAAmBh4B,GAAEkC,IAAIC,UtB89RxB61B,EsB79ROt0B,KACXA,GACkB,OAAZs0B,GtB89RNzrB,EsB79RI6pB,aACL,EtB69RCwzB,EsB59RJtmD,WAEAI,ItB+9RJ+mD,GsB59RDtxC,SAAO9R,GAAM+/C,eAChBziD,GACGglD,GtB89RCY,EsB59RJZ,GtB89RIN,EsB79RgB3lD,KAAK6mD,EAAYvlD,KAAKnC,MAAO+mD,EACjDtmD,StBq+RJ,MANAsmD,GsB79RiB1lD,OAAO,WtB89RpBmlD,EsB59RD,KAAID,ItB89RCA,EsB59RJ,QAGRQ,GtB+9RAe,iBsB79RiB,SAAU5mC,GtB89RvB,GsB79RGA,EAAS1nB,OAAS,EtB+9RjB,MADAwG,MsB79RL8+C,UACI59B,EACHA,CACI4P,GAAAhrB,YAAYiiD,ctB89RZj3B,EAAOhrB,YsB79RIiiD,YAAc1hD,SAASuC,cACnC,UtB69RCkoB,EAAOhrB,YsB79RIiiD,YAAY1jD,MAAQysB,EAAAhrB,YAAYiiD,YAAY/0C,OAC3D,ItB89RA,IsB79RGzY,GAAGhB,EACH8F,EAAMW,KAAKX,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nD,IACHtB,MtBg+RAoB,EsB/9RY/sD,KAChByrD,StBi+RA9lD,GsB99RJR,StBg+RA,OsB99RJQ,ItBi+RAunD,UsB/9RU,SAAU/xC,GtBg+RhB,GsB/9RGlP,GAAQvH,KACZuH,KtB+9RC,KsB/9RIA,EAAM6xB,KtBg+RN,MsB99RJ,KtBg+RA,IsB/9RG0J,GAAQrsB,GAAQA,EAAKksB,OAASlsB,EAAKksB,MAAMnpC,OAASid,EAAKksB,MAE3D,ItB+9RC,KsB/9RIG,EACD,CtB+9RC,GsB/9RG2lB,GAAQlhD,EAAM+hC,OAAOtpC,KACzBsxC,KtBk+RC,OsBl+RGmX,IAASA,EAAMhX,ItBg+RdgX,EsB/9RKhX,GAAGv+B,WAAW,MAAMC,UAAU,EAAG,EAAG,IAC7C,KAEJ,KtBg+RA,MsB/9RMnT,MAAKX,IAAIuxC,UAAYrpC,EAAMmhD,eAAe5lB,GACpDA,GtBi+RA6lB,sBsB/9RsB,WACf3oD,KAAK4oD,iBtBg+RJ5oD,KsB/9RI4oD,eACLhoD,StB+9RCZ,KsB/9RI4oD,eACR,OtBk+RJrM,SsB/9RS,SAAU9lC,GtBg+Rf,GsB/9RGoyC,GAAc7oD,KAAK8oD,mBACnBtkD,EAEJxE,ItB+9RCA,MsB/9RIwkD,YAEDqE,ItBg+RC7oD,KsB99RD2oD,wBAAI3oD,KAAK+oD,mBtBg+RJ/oD,KsB/9RI+oD,kBAAkBnoD,SAEvBZ,KAAKgpD,gBtBg+RJhpD,KsB/9RIgpD,eAAepoD,StBi+RvBioD,EsB99RJloD,UtBg+RAkoD,EsB/9Ra,GAAI1rD,GAAEkC,IAAIC,SAASU,KAAK2oD,sBAAsBxmD,KAC5DnC,OtB+9RC6oD,EsB/9RWxnD,OAAO,WtBg+RdmD,EsB99RDykD,YtB+9RCzkD,EsB/9RKskD,mBACN,KtB+9RCtkD,EsB/9RKokD,eACN,KtB+9RCpkD,EsB/9RKukD,kBACN,KtB+9RCvkD,EsB/9RKwkD,eACT,OtBi+RAhpD,KsB/9RI8oD,mBAELD,CtB+9RC,IsB/9RG3nC,GAAWlhB,KAAKwoD,UACpB/xC,EtB+9RC,KsB/9RIyK,EtBi+RA,MADA2nC,GsB99RDpoD,UACHooD,CtBg+RA,I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","file":"./dist/geomixer.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(20);\n\t\n\t__webpack_require__(21);\n\t\n\t__webpack_require__(19);\n\t\n\t__webpack_require__(22);\n\t\n\t__webpack_require__(23);\n\t\n\t__webpack_require__(24);\n\t\n\t__webpack_require__(25);\n\t\n\t__webpack_require__(26);\n\t\n\t__webpack_require__(27);\n\t\n\t__webpack_require__(28);\n\t\n\t__webpack_require__(29);\n\t\n\t__webpack_require__(30);\n\t\n\t__webpack_require__(31);\n\t\n\t__webpack_require__(32);\n\t\n\t__webpack_require__(33);\n\t\n\t__webpack_require__(34);\n\t\n\t__webpack_require__(35);\n\t\n\t__webpack_require__(36);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t   Single-pass recursive descent PEG parser library:\r\n\t      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n\t   Inspired by Chris Double's parser combinator library in JavaScript:\r\n\t      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t\t+  : Math.floor\r\n\t*/\n\t(function () {\n\t\tvar regexExpression = /\\[(.+?)\\]/g,\n\t\t    regexMath = /(floor\\()/g;\n\t\tvar Parsers = { // \n\t\t\tfunctionFromExpression: function functionFromExpression(s) {\n\t\t\t\t/*eslint-disable no-new-func*/\n\t\t\t\treturn new Function(\n\t\t\t\t/*eslint-enable */\n\t\t\t\t'props', 'indexes', 'return ' + s.replace(regexExpression, 'props[indexes[\"$1\"]]').replace(regexMath, 'Math.$1') + ';');\n\t\t\t}\n\t\t};\n\t\n\t\tvar makePair = function makePair(t1, t2) {\n\t\t\treturn { head: t1, tail: t2 };\n\t\t};\n\t\n\t\t// C-style linked list via recursive typedef.\n\t\t//   Used purely functionally to get shareable sublists.\n\t\t//typedef LinkedList = Pair<Dynamic, LinkedList>;\n\t\tvar LinkedList = function LinkedList(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser state contains position in string and some accumulated data.\n\t\t//typedef ParserState = Pair<Int, LinkedList>;\n\t\tvar ParserState = function ParserState(t1, t2) {\n\t\t\treturn makePair(t1, t2);\n\t\t};\n\t\n\t\t// Parser accepts string and state, returns another state.\n\t\t//typedef Parser = String->ParserState->ParserState;\n\t\n\t\t// A parser state that indicates failure.\n\t\tvar fail = new ParserState(-1, null);\n\t\n\t\t// Check for failure.\n\t\tvar failed = function failed(state) {\n\t\t\treturn state.head === -1;\n\t\t};\n\t\n\t\t// Advance a parser state by n characters.\n\t\tvar advance = function advance(state, n) {\n\t\t\treturn new ParserState(state.head + n, state.tail);\n\t\t};\n\t\n\t\t// Match a specified string.\n\t\tvar token = function token(tok) {\n\t\t\tvar len = tok.length;\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len) === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a string without regard to case.\n\t\tvar caseInsensitiveToken = function caseInsensitiveToken(tok) {\n\t\t\tvar len = tok.length;\n\t\t\ttok = tok.toLowerCase();\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.substr(state.head, len).toLowerCase() === tok ? advance(state, len) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a single character in a specified range.\n\t\tvar range = function range(startChar, endChar) {\n\t\t\tvar startCode = startChar.charCodeAt(0);\n\t\t\tvar endCode = endChar.charCodeAt(0);\n\t\t\treturn function (s, state) {\n\t\t\t\tvar code = s.charCodeAt(state.head);\n\t\t\t\treturn code >= startCode && code <= endCode ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match any character outside a certain set.\n\t\t//   This combinator is intended only for single character parsers.\n\t\tvar anythingExcept = function anythingExcept(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\treturn s.length > state.head && failed(parser(s, state)) ? advance(state, 1) : fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, then thing2, ..., then thingN.\n\t\tvar sequence = function sequence(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tstate = parsers[i](s, state);\n\t\t\t\t\tif (failed(state)) {\n\t\t\t\t\t\treturn fail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn state;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match thing1, or thing2, ..., or thingN.\n\t\tvar choice = function choice(parsers) {\n\t\t\treturn function (s, state) {\n\t\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\t\tvar newState = parsers[i](s, state);\n\t\t\t\t\tif (!failed(newState)) {\n\t\t\t\t\t\treturn newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match immediately, without regard to what's in the string.\n\t\tvar nothing = function nothing(s, state) {\n\t\t\treturn state;\n\t\t};\n\t\n\t\t// Match this thing or nothing.\n\t\tvar maybe = function maybe(parser) {\n\t\t\treturn choice([parser, nothing]);\n\t\t};\n\t\n\t\t// Match minCount or more repetitions of this thing.\n\t\tvar repeat = function repeat(minCount, parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar count = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tvar newState = parser(s, state);\n\t\t\t\t\tif (failed(newState)) {\n\t\t\t\t\t\treturn count >= minCount ? state : fail;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tstate = newState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// return fail;\n\t\t\t};\n\t\t};\n\t\n\t\t// Match a list of minCount or more instances of thing1, separated by thing2.\n\t\tvar separatedList = function separatedList(minCount, parser, separator) {\n\t\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\n\t\t\treturn minCount > 0 ? parser1 : choice([parser1, nothing]);\n\t\t};\n\t\n\t\tvar whitespace = repeat(0, choice([token(' '), token('\\t'), token('\\n')]));\n\t\n\t\t// Same as separatedList, but can have whitespace between items and separators.\n\t\tvar whitespaceSeparatedList = function whitespaceSeparatedList(minCount, parser, separator) {\n\t\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\n\t\t};\n\t\n\t\t// Same as sequence, but can have whitespace between items.\n\t\tvar whitespaceSeparatedSequence = function whitespaceSeparatedSequence(parsers) {\n\t\t\tvar newParsers = [];\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\n\t\t\t\tif (newParsers.length > 0) {\n\t\t\t\t\tnewParsers.push(whitespace);\n\t\t\t\t}\n\t\t\t\tnewParsers.push(parsers[i]);\n\t\t\t}\n\t\t\treturn sequence(newParsers);\n\t\t};\n\t\n\t\t// This combinator captures the string that the parser matched\n\t\t//   and adds it to the current parser state, consing a new state.\n\t\tvar capture = function capture(parser) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar newState = parser(s, state);\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// This combinator passes the accumulated parser state to a given\n\t\t//  function for processing. The result goes into the new state.\n\t\tvar action = function action(parser, func) {\n\t\t\treturn function (s, state) {\n\t\t\t\tvar oldState = state;\n\t\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\n\t\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\n\t\t\t};\n\t\t};\n\t\n\t\t// Define a syntactic subset of SQL WHERE clauses.\n\t\tvar fieldName = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('', ''), range('', ''), range('0', '9'), token('_')])));\n\t\n\t\tvar fieldNameWithSpaces = capture(repeat(1, choice([range('a', 'z'), range('A', 'Z'), range('', ''), range('', ''), range('0', '9'), token('_'), token(' ')])));\n\t\n\t\tvar quotedFieldName = choice([fieldName, sequence([token('\"'), fieldNameWithSpaces, token('\"')]), sequence([token('`'), fieldNameWithSpaces, token('`')])]);\n\t\n\t\tvar stringLiteral = sequence([token('\\''), capture(repeat(0, anythingExcept(token('\\'')))), token('\\'')]);\n\t\n\t\tvar digits = repeat(1, range('0', '9'));\n\t\n\t\tvar numberLiteral = capture(sequence([maybe(token('-')), digits, maybe(sequence([token('.'), digits]))]));\n\t\n\t\tvar literal = choice([numberLiteral, stringLiteral]);\n\t\n\t\tvar applyParser = function applyParser(s, parser) {\n\t\t\treturn parser(s, new ParserState(0, null));\n\t\t};\n\t\n\t\t// Order is important here: longer ops should be tried first.\n\t\tvar opTerm = action(whitespaceSeparatedSequence([quotedFieldName, capture(choice([token('=='), token('!='), token('<>'), token('<='), token('>='), token('='), token('<'), token('>'), caseInsensitiveToken('LIKE')])), choice([literal, quotedFieldName])]), function (state) {\n\t\t\t// Linked list contains fieldname, operation, value\n\t\t\t// (in reverse order).\n\t\n\t\t\tvar fieldName = state.tail.tail.head;\n\t\t\tvar op = state.tail.head;\n\t\t\tvar referenceValue = state.head;\n\t\n\t\t\tvar matchPattern = null;\n\t\t\tif (op.toUpperCase() === 'LIKE') {\n\t\t\t\tmatchPattern = function matchPattern(fieldValue) {\n\t\t\t\t\tvar _matchFrom = null;\n\t\t\t\t\t_matchFrom = function matchFrom(referenceIdx, fieldIdx) {\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\n\t\t\t\t\t\tif (referenceChar === '') {\n\t\t\t\t\t\t\treturn fieldChar === '';\n\t\t\t\t\t\t} else if (referenceChar === '%') {\n\t\t\t\t\t\t\treturn _matchFrom(referenceIdx + 1, fieldIdx) || fieldChar !== '' && _matchFrom(referenceIdx, fieldIdx + 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn referenceChar === fieldChar && _matchFrom(referenceIdx + 1, fieldIdx + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn _matchFrom(0, 0);\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\n\t\t\t\t    rValue = referenceValue;\n\t\t\t\tif (referenceValue in indexes) {\n\t\t\t\t\trValue = props[indexes[rValue]];\n\t\t\t\t}\n\t\t\t\tif (types[fieldName] === 'date' && typeof rValue === 'string') {\n\t\t\t\t\trValue = L.gmxUtil.getUnixTimeFromStr(rValue);\n\t\t\t\t}\n\t\t\t\tif (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\n\t\t\t\t\tfieldValue = fieldValue ? 'True' : 'False';\n\t\t\t\t}\n\t\t\t\tif (fieldValue === null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (matchPattern !== null) {\n\t\t\t\t\treturn matchPattern(fieldValue);\n\t\t\t\t\t/*eslint-disable eqeqeq */\n\t\t\t\t} else if (op === '=' || op === '==') {\n\t\t\t\t\treturn fieldValue == rValue;\n\t\t\t\t} else if (op === '!=' || op === '<>') {\n\t\t\t\t\treturn fieldValue != rValue;\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t} else {\n\t\t\t\t\tvar f1, f2;\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\n\t\t\t\t\t\tf2 = parseFloat(rValue);\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf1 = fieldValue;\n\t\t\t\t\t\tf2 = rValue;\n\t\t\t\t\t\tif (op === '<') {\n\t\t\t\t\t\t\treturn f1 < f2;\n\t\t\t\t\t\t} else if (op === '>') {\n\t\t\t\t\t\t\treturn f1 > f2;\n\t\t\t\t\t\t} else if (op === '<=') {\n\t\t\t\t\t\t\treturn f1 <= f2;\n\t\t\t\t\t\t} else if (op === '>=') {\n\t\t\t\t\t\t\treturn f1 >= f2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\tvar inTerm = action(whitespaceSeparatedSequence([quotedFieldName, caseInsensitiveToken('IN'), token('('), whitespaceSeparatedList(0, literal, token(',')), token(')')]), function (state) {\n\t\t\t// Linked list contains fieldname and multiple values\n\t\t\t//   (in reverse order).\n\t\n\t\t\tvar node = state;\n\t\t\twhile (node.tail != null) {\n\t\t\t\tnode = node.tail;\n\t\t\t}\n\t\t\tvar fieldName = node.head;\n\t\n\t\t\treturn function (props, indexes) {\n\t\t\t\tvar value = props[indexes[fieldName]];\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node.tail !== null) {\n\t\t\t\t\tif (node.head === value) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\t});\n\t\n\t\t// Forward declarations to allow mutually recursive grammar definitions.\n\t\tvar _term = function term(s, state) {\n\t\t\treturn _term(s, state);\n\t\t};\n\t\tvar _expression = function expression(s, state) {\n\t\t\treturn _expression(s, state);\n\t\t};\n\t\n\t\tvar notTerm = action(whitespaceSeparatedSequence([caseInsensitiveToken('NOT'), _term]), function (state) {\n\t\t\t// Linked list contains only processed inner term.\n\t\t\tvar innerTerm = state.head;\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn !innerTerm(props, indexes, types);\n\t\t\t};\n\t\t});\n\t\n\t\t_term = choice([notTerm, opTerm, inTerm, whitespaceSeparatedSequence([token('('), _expression, token(')')])]);\n\t\n\t\t// AND and OR expressions must have at least 2 terms,\n\t\t//   to disambiguate them from a single term.\n\t\n\t\tvar andExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('AND')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = true;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\tvar orExpression = action(whitespaceSeparatedList(2, _term, caseInsensitiveToken('OR')), function (state) {\n\t\t\t// Linked list contains multiple processed inner terms\n\t\t\t//   (in reverse order).\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar flag = false;\n\t\t\t\tvar node = state;\n\t\t\t\twhile (node != null) {\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\n\t\t\t\t\tnode = node.tail;\n\t\t\t\t}\n\t\t\t\treturn flag;\n\t\t\t};\n\t\t});\n\t\n\t\t// Order is important here: term should be tried last,\n\t\t//   because andExpression and orExpression start with it.\n\t\t_expression = choice([andExpression, orExpression, _term]);\n\t\n\t\tvar whereClause = sequence([whitespace, _expression, whitespace]);\n\t\n\t\tParsers.parseSQL = function (str) {\n\t\t\tvar result = applyParser(str, whereClause);\n\t\t\treturn result.head === str.length ? result.tail.head : applyParser(str, whitespace).head === str.length ? function () /*props*/{\n\t\t\t\treturn true;\n\t\t\t} : null;\n\t\t};\n\t\n\t\tvar _additiveExpression = function additiveExpression(s, state) {\n\t\t\treturn _additiveExpression(s, state);\n\t\t};\n\t\tvar _multiplicativeExpression = function multiplicativeExpression(s, state) {\n\t\t\treturn _multiplicativeExpression(s, state);\n\t\t};\n\t\t_additiveExpression = action(whitespaceSeparatedList(1, _multiplicativeExpression, capture(choice([token('+'), token('-')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 0.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm += pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '-') {\n\t\t\t\t\t\t\tterm = -term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tvar multiplicativeTerm = choice([action(numberLiteral, function (state) {\n\t\t\treturn function () /*props, indexes, types*/{\n\t\t\t\treturn parseFloat(state.head);\n\t\t\t};\n\t\t}), action(sequence([token('floor('), _additiveExpression, token(')')]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar res = state.head(props, indexes, types);\n\t\t\t\treturn Math.floor(res);\n\t\t\t};\n\t\t}), action(sequence([token('['), fieldName, token(']')]), function (state) {\n\t\t\treturn function (props, indexes) {\n\t\t\t\treturn parseFloat(props[indexes[state.head]]);\n\t\t\t};\n\t\t}), whitespaceSeparatedSequence([token('('), _additiveExpression, token(')')])]);\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\t_multiplicativeExpression = action(whitespaceSeparatedList(1, multiplicativeTerm, capture(choice([token('*'), token('/')]))), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\tvar pos = state;\n\t\t\t\tvar term = 1.0;\n\t\t\t\twhile (pos !== null) {\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\n\t\t\t\t\tif (pos.tail === null) {\n\t\t\t\t\t\treturn term;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos.tail.head === '/') {\n\t\t\t\t\t\t\tterm = 1.0 / term;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = pos.tail.tail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn term;\n\t\t\t};\n\t\t});\n\t\n\t\tmultiplicativeTerm = choice([multiplicativeTerm, action(whitespaceSeparatedSequence([token('-'), multiplicativeTerm]), function (state) {\n\t\t\treturn function (props, indexes, types) {\n\t\t\t\treturn -state.head(props, indexes, types);\n\t\t\t};\n\t\t})]);\n\t\n\t\tvar arithmeticExpression = sequence([whitespace, _additiveExpression, whitespace]);\n\t\tParsers.parseExpression = function (s) {\n\t\t\tvar result = applyParser(s, arithmeticExpression);\n\t\t\treturn result.head === s.length ? result.tail.head : null;\n\t\t\t// return result.head === s.length ? Parsers.functionFromExpression(s) : null;\n\t\t};\n\t\n\t\tvar svgPath = action(repeat(0, choice([numberLiteral, token(','), token('M'), token('C'), repeat(1, choice([token(' '), token('\\t'), token('\\r'), token('\\n')]))])), function (state) {\n\t\t\tvar coords = [];\n\t\t\twhile (state !== null) {\n\t\t\t\tcoords.push(parseFloat(state.head));\n\t\t\t\tstate = state.tail;\n\t\t\t}\n\t\t\tcoords.reverse();\n\t\t\treturn coords;\n\t\t});\n\t\n\t\tParsers.parseSVGPath = function (s) {\n\t\t\tvar result = applyParser(s, svgPath);\n\t\t\tif (result.head === s.length) {\n\t\t\t\treturn result.tail.head;\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t\n\t\t//extend L.gmx namespace\n\t\tL.gmx = L.gmx || {};\n\t\tL.gmx.Parsers = Parsers;\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t//all the methods can be called without instance itself\n\t//For example:\n\t//\n\t// var def = new Deferred();\n\t// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\n\tvar Deferred = function Deferred(cancelFunc) {\n\t    var resolveCallbacks = [],\n\t        rejectCallbacks = [],\n\t        isFulfilled = false,\n\t        isResolved = false,\n\t        fulfilledData,\n\t        onceAdded = false,\n\t        isCancelled = false;\n\t\n\t    var fulfill = this._fulfill = function (resolved /*, data*/) {\n\t        if (isFulfilled) {\n\t            return;\n\t        }\n\t        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\n\t        fulfilledData = [].slice.call(arguments, 1);\n\t        isFulfilled = true;\n\t        isResolved = resolved;\n\t\n\t        callbacks.forEach(function (callback) {\n\t            callback.apply(null, fulfilledData);\n\t        });\n\t        resolveCallbacks = rejectCallbacks = [];\n\t    };\n\t\n\t    this.resolve = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    this.reject = function () /*data*/{\n\t        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\n\t    };\n\t\n\t    var cancel = this.cancel = function () {\n\t        if (!isCancelled && !isFulfilled) {\n\t            isCancelled = true;\n\t            cancelFunc && cancelFunc();\n\t        }\n\t    };\n\t\n\t    var then = this.then = function (resolveCallback, rejectCallback) {\n\t        if (isCancelled) {\n\t            return null;\n\t        }\n\t\n\t        var userFuncDef = null;\n\t        var def = new Deferred(function () {\n\t            cancel();\n\t            userFuncDef && userFuncDef.cancel();\n\t        });\n\t\n\t        var fulfillFunc = function fulfillFunc(func, resolved) {\n\t            return function () /*data*/{\n\t                if (!func) {\n\t                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\n\t                } else {\n\t                    var res = func.apply(null, arguments);\n\t                    if (res instanceof Deferred) {\n\t                        userFuncDef = res;\n\t                        res.then(def.resolve, def.reject);\n\t                    } else {\n\t                        def.resolve(res);\n\t                    }\n\t                }\n\t            };\n\t        };\n\t\n\t        if (isFulfilled) {\n\t            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\n\t        } else {\n\t            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\n\t            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\n\t        }\n\t        return def;\n\t    };\n\t\n\t    this.once = function (onceResolveCallback) {\n\t        if (!onceAdded) {\n\t            onceAdded = true;\n\t            then(onceResolveCallback);\n\t        }\n\t    };\n\t\n\t    this.always = function (callback) {\n\t        then(callback, callback);\n\t    };\n\t\n\t    this.getFulfilledData = function () {\n\t        return fulfilledData;\n\t    };\n\t};\n\t\n\tDeferred.all = function () {\n\t    var defArray = [].slice.apply(arguments);\n\t    var resdef = new Deferred();\n\t    var left = defArray.length;\n\t    var results = new Array(defArray.length);\n\t\n\t    if (left) {\n\t        defArray.forEach(function (def, i) {\n\t            def.then(function (res) {\n\t                results[i] = res;\n\t                left--;\n\t                if (left === 0) {\n\t                    resdef.resolve.apply(resdef, results);\n\t                }\n\t            }, function () {\n\t                resdef.reject();\n\t            });\n\t        });\n\t    } else {\n\t        resdef.resolve();\n\t    }\n\t\n\t    return resdef;\n\t};\n\t\n\tL.gmx = L.gmx || {};\n\tL.gmx.Deferred = Deferred;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\n\t    var ImageRequest = function ImageRequest(id, url, options) {\n\t        this._id = id;\n\t        this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\n\t        this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\n\t        this.url = url;\n\t        this.options = options || {};\n\t    };\n\t\n\t    var GmxImageLoader = L.Class.extend({\n\t        includes: L.Mixin.Events,\n\t        statics: {\n\t            MAX_COUNT: 20 // max number of parallel requests\n\t        },\n\t\n\t        initialize: function initialize() {\n\t            this.curCount = 0; // number of currently processing requests (number of items in \"inProgress\")\n\t            this.requests = []; // not yet processed image requests\n\t            this.inProgress = {}; // hash of in progress image loadings\n\t            this.requestsCache = {}; // for requests cache by uniqueID\n\t            this.uniqueID = 0;\n\t        },\n\t\n\t        _resolveRequest: function _resolveRequest(request, image, canceled) {\n\t            var def = request.def;\n\t            if (image) {\n\t                if (!canceled && request.options.cache) {\n\t                    var url = request.url,\n\t                        cacheItem = this.requestsCache[url],\n\t                        cacheKey = request._id;\n\t                    if (!cacheItem) {\n\t                        cacheItem = this.requestsCache[url] = { image: image, requests: {} };\n\t                    }\n\t                    if (!cacheItem.requests[cacheKey]) {\n\t                        cacheItem.requests[cacheKey] = request;\n\t                    }\n\t                }\n\t                def.resolve(image);\n\t            } else if (!canceled) {\n\t                def.reject();\n\t            }\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _imageLoaded: function _imageLoaded(url, image, canceled) {\n\t            if (url in this.inProgress) {\n\t                var resolveRequest = function resolveRequest(it) {\n\t                    this._resolveRequest(it, image, canceled);\n\t                };\n\t                this.inProgress[url].requests.forEach(resolveRequest.bind(this));\n\t                --this.curCount;\n\t                delete this.inProgress[url];\n\t            }\n\t            L.gmxUtil.loaderStatus(url, true);\n\t            this.fire('imageloaded', { url: url });\n\t            this._nextLoad();\n\t        },\n\t\n\t        _nextLoad: function _nextLoad() {\n\t            //  \n\t            if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\n\t                return;\n\t            }\n\t\n\t            var request = this.requests.shift(),\n\t                url = request.url;\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                var requests = [request];\n\t                this.inProgress[url] = { requests: requests };\n\t                ++this.curCount;\n\t\n\t                for (var k = this.requests.length - 1; k >= 0; k--) {\n\t                    if (this.requests[k].url === url) {\n\t                        requests.push(this.requests[k]);\n\t                        this.requests.splice(k, 1);\n\t                    }\n\t                }\n\t\n\t                var image = this._loadImage(request);\n\t                if (!image.width) {\n\t                    L.gmxUtil.loaderStatus(url);\n\t                }\n\t\n\t                //theoretically image loading can be synchronous operation\n\t                if (this.inProgress[url]) {\n\t                    this.inProgress[url].image = image;\n\t                }\n\t            }\n\t        },\n\t\n\t        _loadImage: function _loadImage(request) {\n\t            var imageObj = new Image(),\n\t                url = request.url,\n\t                _this = this;\n\t\n\t            if (request.options.crossOrigin) {\n\t                imageObj.crossOrigin = request.options.crossOrigin;\n\t            }\n\t\n\t            imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\n\t            imageObj.onerror = function () {\n\t                _this._imageLoaded(url);\n\t            };\n\t            imageObj.src = url;\n\t\n\t            this.fire('imageloadstart', { url: url });\n\t\n\t            return imageObj;\n\t        },\n\t\n\t        _cancelRequest: function _cancelRequest(request) {\n\t            var id = request._id,\n\t                url = request.url,\n\t                i = 0,\n\t                len;\n\t            if (url in this.inProgress) {\n\t                var loadingImg = this.inProgress[url],\n\t                    requests = loadingImg.requests;\n\t\n\t                len = requests.length;\n\t                if (len === 1 && requests[0]._id === id) {\n\t                    loadingImg.image.onload = L.Util.falseFn;\n\t                    loadingImg.image.onerror = L.Util.falseFn;\n\t                    loadingImg.image.src = L.Util.emptyImageUrl;\n\t                    this._imageLoaded(url, null, true);\n\t                } else {\n\t                    for (i = 0; i < len; i++) {\n\t                        if (requests[i]._id === id) {\n\t                            requests.splice(i, 1);\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (i = 0, len = this.requests.length; i < len; i++) {\n\t                    if (this.requests[i]._id === id) {\n\t                        this.requests.splice(i, 1);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.fire('requestdone', { request: request });\n\t        },\n\t\n\t        _removeRequestFromCache: function _removeRequestFromCache(request) {\n\t            // remove request from cache\n\t            this._cancelRequest(request);\n\t            this._clearCacheItem(request.url, request._id);\n\t        },\n\t\n\t        _clearCacheItem: function _clearCacheItem(url, cacheKey) {\n\t            // remove cache item\n\t            if (this.requestsCache[url]) {\n\t                var cacheItem = this.requestsCache[url];\n\t                delete cacheItem.requests[cacheKey];\n\t                if (Object.keys(cacheItem.requests).length === 0) {\n\t                    delete this.requestsCache[url];\n\t                }\n\t            }\n\t        },\n\t        _add: function _add(atBegin, url, options) {\n\t            var id = 'id' + ++this.uniqueID,\n\t                request = new ImageRequest(id, url, options);\n\t\n\t            if (url in this.inProgress) {\n\t                this.inProgress[url].requests.push(request);\n\t            } else {\n\t                atBegin ? this.requests.unshift(request) : this.requests.push(request);\n\t                this._nextLoad();\n\t            }\n\t\n\t            this.fire('request', { request: request });\n\t\n\t            return request;\n\t        },\n\t\n\t        push: function push(url, options) {\n\t            //     \n\t            return this._add(false, url, options);\n\t        },\n\t\n\t        unshift: function unshift(url, options) {\n\t            //     \n\t            return this._add(true, url, options);\n\t        }\n\t    });\n\t\n\t    L.gmx.imageLoader = new GmxImageLoader();\n\t})();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\r\n\t* @name L.gmxUtil\r\n\t* @namespace\r\n\t*/\n\tvar gmxAPIutils = {\n\t    lastMapId: 0,\n\t\n\t    newId: function newId() {\n\t        gmxAPIutils.lastMapId += 1;\n\t        return '_' + gmxAPIutils.lastMapId;\n\t    },\n\t\n\t    uniqueGlobalName: function uniqueGlobalName(thing) {\n\t        var id = gmxAPIutils.newId();\n\t        window[id] = thing;\n\t        return id;\n\t    },\n\t\n\t    isPageHidden: function isPageHidden() {\n\t        //   \n\t        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\n\t    },\n\t\n\t    normalizeHostname: function normalizeHostname(hostName) {\n\t        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\n\t\n\t        hostName = parsedHost.host + parsedHost.directory;\n\t\n\t        if (hostName[hostName.length - 1] === '/') {\n\t            hostName = hostName.substring(0, hostName.length - 1);\n\t        }\n\t\n\t        return hostName;\n\t    },\n\t\n\t    getLayerItemFromServer: function getLayerItemFromServer(options) {\n\t        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\n\t            req = {\n\t            WrapStyle: 'func',\n\t            geometry: true,\n\t            layer: options.layerID,\n\t            query: query\n\t        };\n\t        if (options.border) {\n\t            req.border = options.border;\n\t        }\n\t        return gmxAPIutils.requestJSONP(options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx', req, options);\n\t    },\n\t\n\t    getCadastreFeatures: function getCadastreFeatures(options) {\n\t        // example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\n\t        if (options.latlng) {\n\t            var latlng = options.latlng,\n\t                req = {\n\t                WrapStyle: 'func',\n\t                text: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\n\t                tolerance: options.tolerance || 0\n\t            };\n\t            return gmxAPIutils.requestJSONP(options.url || 'http://pkk5.rosreestr.ru/api/features/', req, options);\n\t        } else {\n\t            return null;\n\t        }\n\t    },\n\t\n\t    getFormData: function getFormData(json) {\n\t        var arr = [];\n\t        for (var key in json) {\n\t            var val = json[key];\n\t            arr.push(key + '=' + ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val) : val));\n\t        }\n\t        return arr.join('&');\n\t    },\n\t\n\t    /** Sends JSONP requests\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} url - request URL\r\n\t     * @param {Object} params - request params\r\n\t     * @param {Object} [options] - additional request options\r\n\t     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n\t       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n\t     * @return {Deferred} Promise with server JSON response or with error status\r\n\t    */\n\t    requestJSONP: function requestJSONP(url, params, options) {\n\t        options = options || {};\n\t        var def = new L.gmx.Deferred();\n\t\n\t        var script = document.createElement('script');\n\t        script.setAttribute('charset', 'UTF-8');\n\t        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\n\t        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\n\t\n\t        if (callbackParamName) {\n\t            var callbackName = gmxAPIutils.uniqueGlobalName(function (obj) {\n\t                delete window[callbackName];\n\t                def.resolve(obj, options);\n\t            });\n\t\n\t            urlParams[callbackParamName] = callbackName;\n\t        }\n\t\n\t        var paramsStringItems = [];\n\t\n\t        for (var p in urlParams) {\n\t            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\n\t        }\n\t\n\t        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\n\t\n\t        script.onerror = function (e) {\n\t            def.reject(e);\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        script.onload = function () {\n\t            L.gmxUtil.loaderStatus(src, true);\n\t            script.parentNode.removeChild(script);\n\t        };\n\t        L.gmxUtil.loaderStatus(src, null, 'vector');\n\t        script.setAttribute('src', src);\n\t\n\t        document.getElementsByTagName('head').item(0).appendChild(script);\n\t        return def;\n\t    },\n\t    getXmlHttp: function getXmlHttp() {\n\t        var xmlhttp;\n\t        if (typeof XMLHttpRequest !== 'undefined') {\n\t            xmlhttp = new XMLHttpRequest();\n\t        } else {\n\t            try {\n\t                xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\n\t            } catch (e) {\n\t                try {\n\t                    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n\t                } catch (E) {\n\t                    xmlhttp = false;\n\t                }\n\t            }\n\t        }\n\t        return xmlhttp;\n\t    },\n\t    request: function request(ph) {\n\t        // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\n\t        var xhr = gmxAPIutils.getXmlHttp();\n\t        if (xhr) {\n\t            xhr.open(ph.type ? ph.type : 'GET', ph.url, ph.async || false);\n\t            if (ph.headers) {\n\t                for (var key in ph.headers) {\n\t                    xhr.setRequestHeader(key, ph.headers[key]);\n\t                }\n\t            }\n\t            var reqId = L.gmxUtil.loaderStatus();\n\t            if (ph.async) {\n\t                if (ph.withCredentials) {\n\t                    xhr.withCredentials = true;\n\t                }\n\t                xhr.onreadystatechange = function () {\n\t                    if (xhr.readyState === 4) {\n\t                        L.gmxUtil.loaderStatus(reqId, true);\n\t                        if (xhr.status === 200) {\n\t                            ph.callback(xhr.responseText);\n\t                            xhr = null;\n\t                        } else if (ph.onError) {\n\t                            ph.onError(xhr);\n\t                        }\n\t                    }\n\t                };\n\t            }\n\t            var params = null;\n\t            if (ph.params) {\n\t                params = ph.params;\n\t                var syncParams = L.gmx.gmxMapManager.getSyncParams(true);\n\t                if (syncParams) {\n\t                    params += '&' + syncParams;\n\t                }\n\t            }\n\t            xhr.send(params);\n\t            if (!ph.async && xhr.status === 200) {\n\t                ph.callback(xhr.responseText);\n\t                L.gmxUtil.loaderStatus(reqId, true);\n\t                return xhr.status;\n\t            }\n\t            return true;\n\t        }\n\t        if (ph.onError) {\n\t            ph.onError({ Error: 'bad XMLHttpRequest!' });\n\t        }\n\t        return false;\n\t    },\n\t\n\t    tileSizes: [], //    zoom\n\t    getTileNumFromLeaflet: function getTileNumFromLeaflet(tilePoint, zoom) {\n\t        if ('z' in tilePoint) {\n\t            zoom = tilePoint.z;\n\t        }\n\t        var pz = Math.pow(2, zoom),\n\t            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\n\t            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\n\t        return {\n\t            z: zoom,\n\t            x: tx % pz - pz / 2,\n\t            y: pz / 2 - 1 - ty % pz\n\t        };\n\t    },\n\t\n\t    getTilePosZoomDelta: function getTilePosZoomDelta(tilePoint, zoomFrom, zoomTo) {\n\t        //      zoom\n\t        var dz = Math.pow(2, zoomFrom - zoomTo),\n\t            size = 256 / dz,\n\t            dx = tilePoint.x % dz,\n\t            dy = tilePoint.y % dz;\n\t        return {\n\t            size: size,\n\t            zDelta: dz,\n\t            x: size * (dx < 0 ? dz + dx : dx),\n\t            y: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\n\t        };\n\t    },\n\t\n\t    geoItemBounds: function geoItemBounds(geo) {\n\t        // get item bounds array by geometry\n\t        if (!geo) {\n\t            return {\n\t                bounds: null,\n\t                boundsArr: []\n\t            };\n\t        }\n\t        var type = geo.type,\n\t            coords = geo.coordinates,\n\t            b = null,\n\t            i = 0,\n\t            len = 0,\n\t            bounds = null,\n\t            boundsArr = [];\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr1 = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    b = gmxAPIutils.bounds(coords[i][j]);\n\t                    arr1.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                }\n\t                boundsArr.push(arr1);\n\t            }\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                boundsArr.push(b);\n\t                if (i === 0) {\n\t                    bounds.extendBounds(b);\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds([coords[i]]);\n\t                bounds.extendBounds(b);\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = gmxAPIutils.bounds(coords);\n\t            //boundsArr.push(bounds);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                b = gmxAPIutils.bounds(coords[i]);\n\t                bounds.extendBounds(b);\n\t                //boundsArr.push(b);\n\t            }\n\t        }\n\t        return {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t    },\n\t\n\t    getUnFlattenGeo: function getUnFlattenGeo(geo) {\n\t        // get unFlatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            coords = geo.coordinates,\n\t            coordsOut = coords;\n\t\n\t        if (isLikePolygon) {\n\t            coordsOut = [];\n\t            var isPolygon = type === 'POLYGON' || type === 'Polygon';\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                var ring = [];\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\n\t                }\n\t                coordsOut.push(ring);\n\t            }\n\t            if (isPolygon) {\n\t                coordsOut = coordsOut[0];\n\t            }\n\t        }\n\t        return { type: type, coordinates: coordsOut };\n\t    },\n\t\n\t    unFlattenRing: function unFlattenRing(arr) {\n\t        if (typeof arr[0] !== 'number') {\n\t            return arr;\n\t        }\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            res = new Array(len / 2);\n\t\n\t        for (var i = 0; i < len; i += 2) {\n\t            res[cnt++] = [arr[i], arr[i + 1]];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    geoFlatten: function geoFlatten(geo) {\n\t        // get flatten geometry\n\t        var type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates;\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    flattenRing: function flattenRing(arr) {\n\t        var len = arr.length,\n\t            cnt = 0,\n\t            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\n\t            res = new CurArray(2 * len);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            res[cnt++] = arr[i][0];\n\t            res[cnt++] = arr[i][1];\n\t        }\n\t        return res;\n\t    },\n\t\n\t    /** Check rectangle type by coordinates\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n\t     * @return {Boolean}\r\n\t    */\n\t    isRectangle: function isRectangle(coords) {\n\t        return coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4) && (coords[0][0][0] === coords[0][1][0] || coords[0][0][1] === coords[0][1][1]) && (coords[0][1][0] === coords[0][2][0] || coords[0][1][1] === coords[0][2][1]) && (coords[0][2][0] === coords[0][3][0] || coords[0][2][1] === coords[0][3][1]) && (coords[0][3][0] === coords[0][0][0] || coords[0][3][1] === coords[0][0][1]);\n\t    },\n\t\n\t    /** Get bounds from geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n\t     * @return {Object} bounds\r\n\t    */\n\t    getGeometryBounds: function getGeometryBounds(geo) {\n\t        var pt = gmxAPIutils.geoItemBounds(geo);\n\t        return pt.bounds;\n\t    },\n\t\n\t    getMarkerPolygon: function getMarkerPolygon(bounds, dx, dy) {\n\t        var x = (bounds.min.x + bounds.max.x) / 2,\n\t            y = (bounds.min.y + bounds.max.y) / 2;\n\t        return [[x - dx, y - dy], [x - dx, y + dy], [x + dx, y + dy], [x + dx, y - dy], [x - dx, y - dy]];\n\t    },\n\t\n\t    getQuicklookPointsFromProperties: function getQuicklookPointsFromProperties(pArr, gmx) {\n\t        var indexes = gmx.tileAttributeIndexes;\n\t        var points = {\n\t            x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\n\t            y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\n\t            x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\n\t            y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\n\t            x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\n\t            y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\n\t            x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\n\t            y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\n\t        },\n\t            bounds = gmxAPIutils.bounds([[points.x1, points.y1], [points.x2, points.y2], [points.x3, points.y3], [points.x4, points.y4]]);\n\t\n\t        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\n\t            return null;\n\t        }\n\t\n\t        if (!gmx.quicklookPlatform) {\n\t            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\n\t            points.x1 = merc.x;points.y1 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\n\t            points.x2 = merc.x;points.y2 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\n\t            points.x3 = merc.x;points.y3 = merc.y;\n\t            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\n\t            points.x4 = merc.x;points.y4 = merc.y;\n\t        }\n\t\n\t        return points;\n\t    },\n\t\n\t    /** Get hash properties from array properties\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} properties in Array format\r\n\t     * @param {Object} keys indexes\r\n\t     * @return {Object} properties in Hash format\r\n\t    */\n\t    getPropertiesHash: function getPropertiesHash(arr, indexes) {\n\t        var properties = {};\n\t        for (var key in indexes) {\n\t            properties[key] = arr[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, arr, indexes) {\n\t        return key in indexes ? arr[indexes[key]] : '';\n\t    },\n\t\n\t    dec2rgba: function dec2rgba(i, a) {\n\t        // convert decimal to rgb\n\t        var r = i >> 16 & 255,\n\t            g = i >> 8 & 255,\n\t            b = i & 255;\n\t        return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\n\t    },\n\t\n\t    dec2hex: function dec2hex(i) {\n\t        // convert decimal to hex\n\t        return (i + 0x1000000).toString(16).substr(-6);\n\t    },\n\t\n\t    dec2color: function dec2color(i, a) {\n\t        // convert decimal to canvas color\n\t        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\n\t    },\n\t\n\t    oneDay: 60 * 60 * 24, //  \n\t\n\t    isTileKeysIntersects: function isTileKeysIntersects(tk1, tk2) {\n\t        //     \n\t        if (tk1.z < tk2.z) {\n\t            var t = tk1;tk1 = tk2;tk2 = t;\n\t        }\n\t\n\t        var dz = tk1.z - tk2.z;\n\t        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\n\t    },\n\t\n\t    rotatePoints: function rotatePoints(arr, angle, iconScale, center) {\n\t        // rotate -  \n\t        var out = [];\n\t        angle *= Math.PI / 180.0;\n\t        var sin = Math.sin(angle);\n\t        var cos = Math.cos(angle);\n\t        if (!iconScale) {\n\t            iconScale = 1;\n\t        }\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var x = iconScale * arr[i].x - center.x;\n\t            var y = iconScale * arr[i].y - center.y;\n\t            out.push({\n\t                'x': cos * x - sin * y + center.x,\n\t                'y': sin * x + cos * y + center.y\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t    getPatternIcon: function getPatternIcon(item, style, indexes) {\n\t        //  bitmap  pattern\n\t        if (!style.fillPattern) {\n\t            return null;\n\t        }\n\t\n\t        var notFunc = true,\n\t            pattern = style.fillPattern,\n\t            prop = item ? item.properties : null,\n\t            step = pattern.step > 0 ? pattern.step : 0,\n\t            patternDefaults = {\n\t            minWidth: 1,\n\t            maxWidth: 1000,\n\t            minStep: 0,\n\t            maxStep: 1000\n\t        };\n\t        if (pattern.patternStepFunction && prop !== null) {\n\t            step = pattern.patternStepFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (step > patternDefaults.maxStep) {\n\t            step = patternDefaults.maxStep;\n\t        } else if (step < patternDefaults.minStep) {\n\t            step = patternDefaults.minStep;\n\t        }\n\t\n\t        var size = pattern.width > 0 ? pattern.width : 8;\n\t        if (pattern.patternWidthFunction && prop !== null) {\n\t            size = pattern.patternWidthFunction(prop, indexes);\n\t            notFunc = false;\n\t        }\n\t        if (size > patternDefaults.maxWidth) {\n\t            size = patternDefaults.maxWidth;\n\t        } else if (size < patternDefaults.minWidth) {\n\t            size = patternDefaults.minWidth;\n\t        }\n\t\n\t        var op = style.fillOpacity;\n\t        if (style.opacityFunction && prop !== null) {\n\t            op = style.opacityFunction(prop, indexes) / 100;\n\t            notFunc = false;\n\t        }\n\t\n\t        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\n\t            arr = pattern.colors != null ? pattern.colors : rgb,\n\t            count = arr.length,\n\t            resColors = [],\n\t            i = 0;\n\t\n\t        for (i = 0; i < count; i++) {\n\t            var col = arr[i];\n\t            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\n\t                col = prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3];\n\t                notFunc = false;\n\t            }\n\t            resColors.push(col);\n\t        }\n\t        if (count === 0) {\n\t            resColors = [0];op = 0;count = 1;\n\t        } // pattern without colors\n\t\n\t        var delta = size + step,\n\t            allSize = delta * count,\n\t            center = 0,\n\t\n\t\n\t        //radius,\n\t        rad = 0,\n\t            hh = allSize,\n\t\n\t        //  \n\t        ww = allSize,\n\t\n\t        //  \n\t        type = pattern.style || 'horizontal',\n\t            flagRotate = false;\n\t\n\t        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\n\t            flagRotate = true;\n\t        } else if (type === 'circle') {\n\t            ww = hh = 2 * delta;\n\t            center = Math.floor(ww / 2); //  \n\t            //radius = Math.floor(size / 2);\t// \n\t            rad = 2 * Math.PI / count; //   .\n\t        } else if (type === 'vertical') {\n\t            hh = 1;\n\t        } else if (type === 'horizontal') {\n\t            ww = 1;\n\t        }\n\t        if (ww * hh > patternDefaults.maxWidth) {\n\t            console.log({ 'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big' });\n\t            return null;\n\t        }\n\t\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.clearRect(0, 0, canvas.width, canvas.height);\n\t        if (type === 'diagonal2' || type === 'vertical') {\n\t            ptx.translate(ww, 0);\n\t            ptx.rotate(Math.PI / 2);\n\t        }\n\t\n\t        for (i = 0; i < count; i++) {\n\t            ptx.beginPath();\n\t            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\n\t            ptx.fillStyle = fillStyle;\n\t\n\t            if (flagRotate) {\n\t                var x1 = i * delta;var xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t\n\t                x1 += allSize;xx1 = x1 + size;\n\t                ptx.moveTo(x1, 0);ptx.lineTo(xx1, 0);ptx.lineTo(0, xx1);ptx.lineTo(0, x1);ptx.lineTo(x1, 0);\n\t                if (type === 'cross' || type === 'cross1') {\n\t                    x1 = i * delta;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t\n\t                    x1 += allSize;xx1 = x1 + size;\n\t                    ptx.moveTo(ww, x1);ptx.lineTo(ww, xx1);ptx.lineTo(ww - xx1, 0);ptx.lineTo(ww - x1, 0);ptx.lineTo(ww, x1);\n\t                }\n\t            } else if (type === 'circle') {\n\t                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\n\t                ptx.lineTo(center, center);\n\t            } else {\n\t                ptx.fillRect(0, i * delta, ww, size);\n\t            }\n\t            ptx.closePath();\n\t            ptx.fill();\n\t        }\n\t        var canvas1 = document.createElement('canvas');\n\t        canvas1.width = ww;\n\t        canvas1.height = hh;\n\t        var ptx1 = canvas1.getContext('2d');\n\t        ptx1.drawImage(canvas, 0, 0, ww, hh);\n\t        return { 'notFunc': notFunc, 'canvas': canvas1 };\n\t    },\n\t\n\t    getSVGIcon: function getSVGIcon(options) {\n\t        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\n\t            type = options.type,\n\t            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\n\t            stroke = options.strokeStyle || '#0000ff',\n\t            strokeWidth = options.lineWidth || 2,\n\t            iconOptions = {\n\t            className: 'gmx-svg-icon'\n\t        };\n\t\n\t        if (options.className) {\n\t            iconOptions.className = options.className;\n\t        }\n\t        var size = options.iconSize;\n\t        iconOptions.iconSize = [size, size];\n\t        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\n\t\n\t        if (type === 'circle') {\n\t            if (options.fillRadialGradient) {\n\t                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\n\t                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop || [// [%, color, opacity]\n\t                [0, '#ffff00', 0.8], [1, '#ff0000', 0.8]];\n\t\n\t                for (var i = 0, len = stopColor.length; i < len; i++) {\n\t                    var it = stopColor[i];\n\t                    svg += '<stop offset=\"' + 100 * it[0] + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\n\t                }\n\t                svg += '</radialGradient></defs>';\n\t                fill = 'url(#myRadialGradient4)';\n\t                stroke = strokeWidth = null;\n\t            }\n\t            size /= 2;\n\t            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:\"' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:\"' + strokeWidth + ';';\n\t            }\n\t            svg += ';\" />';\n\t        } else if (type === 'square') {\n\t            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\n\t            if (fill) {\n\t                svg += ' fill:' + fill + ';';\n\t            }\n\t            if (stroke) {\n\t                svg += ' stroke:' + stroke + ';';\n\t            }\n\t            if (strokeWidth) {\n\t                svg += ' stroke-width:' + 2 * strokeWidth + ';';\n\t            }\n\t            svg += '\" />';\n\t        }\n\t        if (options.text) {\n\t            var text = options.text;\n\t            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\n\t            for (var key in text) {\n\t                if (key !== 'count') {\n\t                    svg += ' ' + key + '=\"' + text[key] + '\"';\n\t                }\n\t            }\n\t            svg += '>' + text.count + '</text>';\n\t        }\n\t        svg += '</g></svg>';\n\t        iconOptions.html = svg;\n\t\n\t        return new L.DivIcon(iconOptions);\n\t    },\n\t\n\t    toPixels: function toPixels(p, tpx, tpy, mInPixel) {\n\t        // get pixel point\n\t        var px1 = p[0] * mInPixel;px1 = 0.5 + px1 << 0;\n\t        var py1 = p[1] * mInPixel;py1 = 0.5 + py1 << 0;\n\t        return [px1 - tpx, tpy - py1].concat(p.slice(2));\n\t    },\n\t\n\t    getPixelPoint: function getPixelPoint(attr, coords) {\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t            style = attr.style || {},\n\t            iconScale = currentStyle.iconScale || 1,\n\t            iconCenter = currentStyle.iconCenter || false,\n\t            sx = currentStyle.sx || style.sx || 4,\n\t            sy = currentStyle.sy || style.sy || 4,\n\t            weight = currentStyle.weight || style.weight || 0,\n\t            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy;\n\t\n\t        if (!iconCenter && iconAnchor) {\n\t            px1 -= iconAnchor[0];\n\t            py1 -= iconAnchor[1];\n\t        }\n\t        sx *= iconScale;\n\t        sy *= iconScale;\n\t        sx += weight;\n\t        sy += weight;\n\t\n\t        var py1 = py - coords[1] * mInPixel,\n\t            px1 = coords[0] * mInPixel - px;\n\t\n\t        if (px1 - sx > 256) {\n\t            px1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        } else if (px1 < -sx) {\n\t            px1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\n\t        }\n\t\n\t        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0 ? null : {\n\t            sx: sx,\n\t            sy: sy,\n\t            px1: 0.5 + px1 << 0,\n\t            py1: 0.5 + py1 << 0\n\t        };\n\t    },\n\t    getImageData: function getImageData(img) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return null;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var ptx = canvas.getContext('2d');\n\t        ptx.drawImage(img, 0, 0);\n\t        return ptx.getImageData(0, 0, ww, hh).data;\n\t    },\n\t    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\n\t    isIE: function isIE(v) {\n\t        return v === gmxAPIutils.getIEversion();\n\t    },\n\t    gtIE: function gtIE(v) {\n\t        return v < gmxAPIutils.getIEversion();\n\t    },\n\t\n\t    getIEversion: function getIEversion() {\n\t        var ua = navigator.userAgent || '',\n\t            msie = ua.indexOf('MSIE ');\n\t        if (msie > 0) {\n\t            // IE 10 or older => return version number\n\t            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t        }\n\t\n\t        var trident = ua.indexOf('Trident/');\n\t        if (trident > 0) {\n\t            // IE 11 => return version number\n\t            var rv = ua.indexOf('rv:');\n\t            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t        }\n\t\n\t        var edge = ua.indexOf('Edge/');\n\t        if (edge > 0) {\n\t            // Edge (IE 12+) => return version number\n\t            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n\t        }\n\t\n\t        // other browser\n\t        return -1;\n\t    },\n\t\n\t    replaceColor: function replaceColor(img, color, fromData) {\n\t        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) {\n\t            return img;\n\t        }\n\t        var canvas = document.createElement('canvas'),\n\t            ww = img.width,\n\t            hh = img.height;\n\t\n\t        canvas.width = ww;canvas.height = hh;\n\t        var flag = false,\n\t            imageData,\n\t            ptx = canvas.getContext('2d');\n\t\n\t        if (typeof color === 'string') {\n\t            color = parseInt('0x' + color.replace(/#/, ''));\n\t        }\n\t        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\n\t            var r = color >> 16 & 255,\n\t                g = color >> 8 & 255,\n\t                b = color & 255;\n\t\n\t            if (fromData) {\n\t                imageData = ptx.createImageData(ww, hh);\n\t            } else {\n\t                ptx.drawImage(img, 0, 0);\n\t                imageData = ptx.getImageData(0, 0, ww, hh);\n\t                fromData = imageData.data;\n\t            }\n\t            var toData = imageData.data;\n\t            for (var i = 0, len = fromData.length; i < len; i += 4) {\n\t                if ((fromData[i] === 0xff || fromData[i] === 238) && fromData[i + 1] === 0 && fromData[i + 2] === 0xff) {\n\t                    toData[i] = r;\n\t                    toData[i + 1] = g;\n\t                    toData[i + 2] = b;\n\t                    toData[i + 3] = fromData[i + 3];\n\t                    flag = true;\n\t                }\n\t            }\n\t        }\n\t        if (flag) {\n\t            ptx.putImageData(imageData, 0, 0);\n\t        } else {\n\t            ptx.drawImage(img, 0, 0);\n\t        }\n\t        return canvas;\n\t    },\n\t\n\t    drawIconPath: function drawIconPath(path, attr) {\n\t        // draw iconPath in canvas\n\t        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) {\n\t            return;\n\t        }\n\t        var trFlag = false,\n\t            ctx = attr.ctx,\n\t            rad = attr.radian;\n\t\n\t        if (attr.px || attr.py) {\n\t            ctx.translate(attr.px || 0, attr.py || 0);trFlag = true;\n\t        }\n\t        if (!rad && attr.rotateRes) {\n\t            rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes);\n\t        }\n\t        if (rad) {\n\t            ctx.rotate(rad);trFlag = true;\n\t        }\n\t        ctx.moveTo(path[0], path[1]);\n\t        for (var i = 2, len = path.length; i < len; i += 2) {\n\t            ctx.lineTo(path[i], path[i + 1]);\n\t        }\n\t        if (trFlag) {\n\t            ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t        }\n\t    },\n\t\n\t    pointToCanvas: function pointToCanvas(attr) {\n\t        //   canvas\n\t        var gmx = attr.gmx,\n\t            pointAttr = attr.pointAttr,\n\t            style = attr.style || {},\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconScale = currentStyle.iconScale || 1,\n\t            image = currentStyle.image,\n\t            sx = pointAttr.sx,\n\t            sy = pointAttr.sy,\n\t            px1 = pointAttr.px1,\n\t            py1 = pointAttr.py1,\n\t            px1sx = px1,\n\t            py1sy = py1,\n\t            ctx = attr.ctx;\n\t\n\t        if (currentStyle.type === 'image') {\n\t            sx = style.sx;\n\t            sy = style.sy;\n\t            image = style.image;\n\t        }\n\t        if (currentStyle.iconCenter) {\n\t            px1sx -= sx / 2;\n\t            py1sy -= sy / 2;\n\t        } else if (style.type === 'circle') {\n\t            px1 += sx / 2;\n\t            py1 += sy / 2;\n\t        }\n\t        if (currentStyle.iconPath) {\n\t            attr.px = px1;\n\t            attr.py = py1;\n\t            attr.rotateRes = currentStyle.rotate || 0;\n\t        }\n\t        if (image) {\n\t            if ('iconColor' in currentStyle) {\n\t                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\n\t            }\n\t            style.rotateRes = currentStyle.rotate || 0;\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = currentStyle.opacity || style.opacity;\n\t            }\n\t            if (gmx.transformFlag) {\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\n\t                ctx.drawImage(image, px1, -py1, sx, sy);\n\t                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\n\t            } else {\n\t                if (iconScale !== 1) {\n\t                    sx *= iconScale;\n\t                    sy *= iconScale;\n\t                    px1 = pointAttr.px1;\n\t                    py1 = pointAttr.py1;\n\t                    px1sx = px1;\n\t                    py1sy = py1;\n\t                    if (currentStyle.iconCenter) {\n\t                        px1sx -= sx / 2;\n\t                        py1sy -= sy / 2;\n\t                    }\n\t                }\n\t                if (style.rotateRes) {\n\t                    ctx.translate(px1, py1);\n\t                    ctx.rotate(gmxAPIutils.degRad(style.rotateRes));\n\t                    ctx.translate(-px1, -py1);\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                } else {\n\t                    ctx.drawImage(image, px1sx, py1sy, sx, sy);\n\t                }\n\t            }\n\t            if ('opacity' in style) {\n\t                ctx.globalAlpha = 1;\n\t            }\n\t        } else if (style.fillColor || currentStyle.fillRadialGradient) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\n\t                var circle = style.iconSize / 2;\n\t                if (currentStyle.fillRadialGradient) {\n\t                    var rgr = currentStyle.fillRadialGradient;\n\t                    circle = rgr.r2 * iconScale;\n\t                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\n\t                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\n\t                        var arr = rgr.addColorStop[i];\n\t                        radgrad.addColorStop(arr[0], arr[1]);\n\t                    }\n\t                    ctx.fillStyle = radgrad;\n\t                }\n\t                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.fillRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.fill();\n\t        }\n\t        if (currentStyle.strokeStyle) {\n\t            ctx.beginPath();\n\t            if (currentStyle.iconPath) {\n\t                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\n\t            } else if (style.type === 'circle') {\n\t                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\n\t            } else {\n\t                ctx.strokeRect(px1sx, py1sy, sx, sy);\n\t            }\n\t            ctx.stroke();\n\t        }\n\t    },\n\t    lineToCanvasAsIcon: function lineToCanvasAsIcon(pixels, attr) {\n\t        // add line(as icon) to canvas\n\t        var len = pixels.length,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            iconPath = currentStyle.iconPath;\n\t\n\t        if (len > 0) {\n\t            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t                ctx.setLineDash([]);\n\t            }\n\t            ctx.beginPath();\n\t            for (var i = 0, p; i < len; i++) {\n\t                p = pixels[i];\n\t                gmxAPIutils.drawIconPath(iconPath, { ctx: ctx, px: p.x, py: p.y, radian: p.radian });\n\t            }\n\t            if (currentStyle.strokeStyle) {\n\t                ctx.stroke();\n\t            }\n\t            if (currentStyle.fillStyle) {\n\t                ctx.fill();\n\t            }\n\t        }\n\t    },\n\t    lineToCanvas: function lineToCanvas(attr) {\n\t        // Lines in canvas\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            item = attr.item,\n\t            currentStyle = item.currentStyle || item.parsedStyleKeys,\n\t            pixels = currentStyle.iconPath ? [] : null;\n\t\n\t        var lastX = null,\n\t            lastY = null;\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\n\t                x = p[0],\n\t                y = p[1];\n\t            if (lastX !== x || lastY !== y) {\n\t                if (pixels) {\n\t                    pixels.push({ x: x, y: y, radian: p[2] });\n\t                }\n\t                if (i === 0) {\n\t                    ctx.moveTo(x, y);\n\t                } else {\n\t                    ctx.lineTo(x, y);\n\t                }\n\t                lastX = x;lastY = y;\n\t            }\n\t        }\n\t        ctx.stroke();\n\t        return pixels;\n\t    },\n\t\n\t    getCoordsPixels: function getCoordsPixels(attr) {\n\t        var gmx = attr.gmx,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || [],\n\t            pixels = [],\n\t            hidden = [],\n\t            hiddenFlag = false,\n\t            hash = {\n\t            gmx: gmx,\n\t            tpx: attr.tpx,\n\t            tpy: attr.tpy,\n\t            coords: null,\n\t            hiddenLines: null\n\t        };\n\t        for (var j = 0, len = coords.length; j < len; j++) {\n\t            var coords1 = coords[j],\n\t                hiddenLines1 = hiddenLines[j] || [],\n\t                pixels1 = [],\n\t                hidden1 = [];\n\t            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\n\t                hash.coords = coords1[j1];\n\t                hash.hiddenLines = hiddenLines1[j1] || [];\n\t                var res = gmxAPIutils.getRingPixels(hash);\n\t                pixels1.push(res.coords);\n\t                hidden1.push(res.hidden);\n\t                if (res.hidden) {\n\t                    hiddenFlag = true;\n\t                }\n\t            }\n\t            pixels.push(pixels1);\n\t            hidden.push(hidden1);\n\t        }\n\t        return { coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom };\n\t    },\n\t\n\t    getRingPixels: function getRingPixels(attr) {\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var gmx = attr.gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            coords = attr.coords,\n\t            hiddenLines = attr.hiddenLines || null,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            lastX = null,\n\t            lastY = null,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            pixels = [],\n\t            hidden = [];\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var lineIsOnEdge = false;\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x1 = c[0] * mInPixel,\n\t                y1 = c[1] * mInPixel,\n\t                x2 = Math.round(x1 - px),\n\t                y2 = Math.round(py - y1);\n\t\n\t            if (lastX !== x2 || lastY !== y2) {\n\t                lastX = x2;lastY = y2;\n\t                if (lineIsOnEdge) {\n\t                    hidden.push(cnt);\n\t                }\n\t                pixels[cnt++] = x1;\n\t                pixels[cnt++] = y1;\n\t            }\n\t        }\n\t        return { coords: pixels, hidden: hidden.length ? hidden : null };\n\t    },\n\t\n\t    polygonToCanvas: function polygonToCanvas(attr) {\n\t        // Polygons in canvas\n\t        if (attr.coords.length === 0) {\n\t            return null;\n\t        }\n\t        var hiddenLines = attr.hiddenLines || null,\n\t            coords = attr.coords,\n\t            ctx = attr.ctx,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            cnt = 0,\n\t            cntHide = 0,\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            lastX = null,\n\t            lastY = null;\n\t\n\t        ctx.beginPath();\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                x = Math.round(c[0] - px),\n\t                y = Math.round(py - c[1]),\n\t                lineIsOnEdge = false;\n\t\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                lineIsOnEdge = true;\n\t                cntHide++;\n\t            }\n\t\n\t            if (lastX !== x || lastY !== y) {\n\t                ctx[lineIsOnEdge ? 'moveTo' : 'lineTo'](x, y);\n\t                lastX = x;lastY = y;\n\t                cnt++;\n\t            }\n\t        }\n\t        if (cnt === 1) {\n\t            ctx.lineTo(lastX + 1, lastY);\n\t        }\n\t        ctx.stroke();\n\t    },\n\t\n\t    polygonToCanvasFill: function polygonToCanvasFill(attr) {\n\t        // Polygon fill\n\t        if (attr.coords.length < 3) {\n\t            return;\n\t        }\n\t        var coords = attr.coords,\n\t            px = attr.tpx,\n\t            py = attr.tpy,\n\t            vectorSize = 1,\n\t            ctx = attr.ctx;\n\t\n\t        ctx.lineWidth = 0;\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\n\t        } else {\n\t            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\n\t        }\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\n\t        }\n\t    },\n\t\n\t    isPatternNode: function isPatternNode(it) {\n\t        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\n\t    },\n\t    labelCanvasContext: null, // 2dContext canvas for Label size\n\t    getLabelWidth: function getLabelWidth(txt, style) {\n\t        // Get label size Label\n\t        if (style) {\n\t            if (!gmxAPIutils.labelCanvasContext) {\n\t                var canvas = document.createElement('canvas');\n\t                canvas.width = canvas.height = 512;\n\t                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\n\t            }\n\t            var ptx = gmxAPIutils.labelCanvasContext;\n\t            ptx.clearRect(0, 0, 512, 512);\n\t\n\t            if (ptx.font !== style.font) {\n\t                ptx.font = style.font;\n\t            }\n\t            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\n\t            if (ptx.fillStyle !== style.fillStyle) {\n\t                ptx.fillStyle = style.fillStyle;\n\t            }\n\t            var arr = txt.split('\\n');\n\t            return arr.map(function (it) {\n\t                ptx.fillText(it, 0, 0);\n\t                return [it, ptx.measureText(it).width];\n\t            });\n\t        }\n\t        return 0;\n\t    },\n\t    setLabel: function setLabel(ctx, txt, coord, style) {\n\t        var x = coord[0],\n\t            y = coord[1];\n\t\n\t        if (ctx.shadowColor !== style.strokeStyle) {\n\t            ctx.shadowColor = style.strokeStyle;\n\t        }\n\t        if (ctx.shadowBlur !== style.shadowBlur) {\n\t            ctx.shadowBlur = style.shadowBlur;\n\t        }\n\t        if (ctx.font !== style.font) {\n\t            ctx.font = style.font;\n\t        }\n\t        if (ctx.strokeStyle !== style.strokeStyle) {\n\t            ctx.strokeStyle = style.strokeStyle;\n\t        }\n\t        if (ctx.fillStyle !== style.fillStyle) {\n\t            ctx.fillStyle = style.fillStyle;\n\t        }\n\t        ctx.strokeText(txt, x, y);\n\t        ctx.fillText(txt, x, y);\n\t    },\n\t    worldWidthMerc: 20037508,\n\t    rMajor: 6378137.000,\n\t    degRad: function degRad(ang) {\n\t        return ang * (Math.PI / 180.0);\n\t    },\n\t\n\t    distVincenty: function distVincenty(lon1, lat1, lon2, lat2) {\n\t        var p1 = {\n\t            lon: gmxAPIutils.degRad(lon1),\n\t            lat: gmxAPIutils.degRad(lat1)\n\t        },\n\t            p2 = {\n\t            lon: gmxAPIutils.degRad(lon2),\n\t            lat: gmxAPIutils.degRad(lat2)\n\t        },\n\t            a = gmxAPIutils.rMajor,\n\t            b = 6356752.3142,\n\t            f = 1 / 298.257223563; // WGS-84 ellipsiod\n\t\n\t        var L1 = p2.lon - p1.lon,\n\t            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\n\t            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\n\t            sinU1 = Math.sin(U1),\n\t            cosU1 = Math.cos(U1),\n\t            sinU2 = Math.sin(U2),\n\t            cosU2 = Math.cos(U2),\n\t            lambda = L1,\n\t            lambdaP = 2 * Math.PI,\n\t            iterLimit = 20;\n\t        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\n\t            var sinLambda = Math.sin(lambda),\n\t                cosLambda = Math.cos(lambda),\n\t                sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n\t            if (sinSigma === 0) {\n\t                return 0;\n\t            }\n\t            var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\n\t                sigma = Math.atan2(sinSigma, cosSigma),\n\t                sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\n\t                cosSqAlpha = 1 - sinAlpha * sinAlpha,\n\t                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n\t            if (isNaN(cos2SigmaM)) {\n\t                cos2SigmaM = 0;\n\t            }\n\t            var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n\t            lambdaP = lambda;\n\t            lambda = L1 + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n\t        }\n\t        if (iterLimit === 0) {\n\t            return NaN;\n\t        }\n\t\n\t        var uSq = cosSqAlpha * (a * a / (b * b) - 1),\n\t\n\t\n\t        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\n\t        A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\n\t            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\n\t            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\n\t            s = b * A * (sigma - deltaSigma);\n\t\n\t        //s = s.toFixed(3);\n\t        return s;\n\t    },\n\t\n\t    _vfi: function _vfi(fi, a, b) {\n\t        return [-Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a), Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a), -Math.sin(fi) * Math.cos(b)];\n\t    },\n\t\n\t    getCircleLatLngs: function getCircleLatLngs(latlng, r) {\n\t        // Get latlngs for circle\n\t        var x = 0,\n\t            y = 0;\n\t        if (latlng instanceof L.LatLng) {\n\t            x = latlng.lng;\n\t            y = latlng.lat;\n\t        } else if (L.Util.isArray(latlng)) {\n\t            x = latlng[1];\n\t            y = latlng[0];\n\t        } else {\n\t            return null;\n\t        }\n\t\n\t        var rad = Math.PI / 180,\n\t            a = x * rad,\n\t\n\t        //    \n\t        b = y * rad,\n\t\n\t        //    \n\t        R = gmxAPIutils.rMajor,\n\t            d = R * Math.sin(r / R),\n\t            Rd = R * Math.cos(r / R),\n\t            VR = [Rd * Math.cos(b) * Math.cos(a), Rd * Math.cos(b) * Math.sin(a), Rd * Math.sin(b)],\n\t            latlngs = [];\n\t\n\t        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\n\t            var v = gmxAPIutils._vfi(fi, a, b),\n\t                circle = [];\n\t            for (var i = 0; i < 3; i++) {\n\t                circle[i] = VR[i] + d * v[i];\n\t            }\n\t\n\t            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\n\t            if (circle[1] < 0) {\n\t                t2 = -t2;\n\t            }\n\t\n\t            if (t2 < x - 180) {\n\t                t2 += 360;\n\t            } else if (t2 > x + 180) {\n\t                t2 -= 360;\n\t            }\n\t            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\n\t        }\n\t        return latlngs;\n\t    },\n\t\n\t    /** Get point coordinates from string\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {String} text - point coordinates in following formats:\r\n\t         <br/><i>55.74312, 37.61558</i>\r\n\t         <br/><i>5544'35\" N, 3736'56\" E</i>\r\n\t         <br/><i>4187347, 7472103</i>\r\n\t         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n\t         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n\t     * @return {Array} [lat, lng] or null\r\n\t    */\n\t    parseCoordinates: function parseCoordinates(text) {\n\t        var crs = null,\n\t            regex = /\\(EPSG:(\\d+)\\)/g,\n\t            t = regex.exec(text);\n\t\n\t        if (t) {\n\t            crs = t[1];\n\t            text = text.replace(regex, '');\n\t        }\n\t\n\t        if (text.match(/[qrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\n\t            return null;\n\t        }\n\t\n\t        //there should be a separator in the string (exclude strings like \"11E11\")\n\t        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\n\t            return null;\n\t        }\n\t\n\t        if (text.indexOf(' ') !== -1) {\n\t            text = text.replace(/,/g, '.');\n\t        }\n\t        var results = [];\n\t        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\n\t        t = regex.exec(text);\n\t        while (t) {\n\t            results.push(t[1]);\n\t            t = regex.exec(text);\n\t        }\n\t        if (results.length < 2) {\n\t            return null;\n\t        }\n\t        var ii = Math.floor(results.length / 2),\n\t            y = 0,\n\t            mul = 1,\n\t            i;\n\t        for (i = 0; i < ii; i++) {\n\t            y += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t        var x = 0;\n\t        mul = 1;\n\t        for (i = ii; i < results.length; i++) {\n\t            x += parseFloat(results[i]) * mul;\n\t            mul /= 60;\n\t        }\n\t\n\t        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\n\t            t = x;\n\t            x = y;\n\t            y = t;\n\t        }\n\t\n\t        var pos;\n\t        if (crs === '3857') {\n\t            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\n\t            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\n\t            x = pos.lng;\n\t            y = pos.lat;\n\t        }\n\t\n\t        if (text.indexOf('W') !== -1) {\n\t            x = -x;\n\t        }\n\t\n\t        if (text.indexOf('S') !== -1) {\n\t            y = -y;\n\t        }\n\t        return [y, x];\n\t    },\n\t\n\t    pad2: function pad2(t) {\n\t        return t >= 0 && t < 10 ? '0' + t : '' + t;\n\t    },\n\t\n\t    trunc: function trunc(x) {\n\t        return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\n\t    },\n\t\n\t    formatDegrees: function formatDegrees(angle, format) {\n\t        angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\n\t        var a1 = Math.floor(angle),\n\t            a2 = Math.floor(60 * (angle - a1)),\n\t            a3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\n\t            st = gmxAPIutils.pad2(a1) + '';\n\t\n\t        if (format === undefined) {\n\t            format = 2;\n\t        }\n\t        if (format > 0) {\n\t            st += gmxAPIutils.pad2(a2) + '\\'';\n\t        }\n\t        if (format > 1) {\n\t            st += gmxAPIutils.pad2(a3) + '\"';\n\t        }\n\t        return st;\n\t    },\n\t\n\t    /** Get point coordinates in string format with degrees\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format with degrees\r\n\t    */\n\t    latLonFormatCoordinates: function latLonFormatCoordinates(x, y) {\n\t        x %= 360;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        } else if (x < -180) {\n\t            x += 360;\n\t        }\n\t        return gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t\n\t    formatCoordinates: function formatCoordinates(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates(x, y);\n\t    },\n\t\n\t    /** Get point coordinates in string format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} lng - point longitude\r\n\t     * @param {Number} lat - point latitude\r\n\t     * @return {String} point coordinates in string format\r\n\t    */\n\t    latLonFormatCoordinates2: function latLonFormatCoordinates2(x, y) {\n\t        return gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') + gmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\n\t    },\n\t    formatCoordinates2: function formatCoordinates2(x, y) {\n\t        return gmxAPIutils.latLonFormatCoordinates2(x, y);\n\t    },\n\t\n\t    getPixelScale: function getPixelScale(zoom) {\n\t        return 256 / gmxAPIutils.tileSizes[zoom];\n\t    },\n\t\n\t    forEachPoint: function forEachPoint(coords, callback) {\n\t        if (!coords || coords.length === 0) {\n\t            return [];\n\t        }\n\t        var i,\n\t            len,\n\t            ret = [];\n\t        if (!coords[0].length) {\n\t            if (coords.length === 2) {\n\t                return callback(coords);\n\t            } else {\n\t                for (i = 0, len = coords.length / 2; i < len; i++) {\n\t                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\n\t                }\n\t            }\n\t        } else {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                if (typeof coords[i] !== 'string') {\n\t                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    },\n\t    /*\r\n\t    \tgetQuicklookPoints: function(coord) { //  4   \r\n\t    \t\tvar d1 = Number.MAX_VALUE;\r\n\t    \t\tvar d2 = Number.MAX_VALUE;\r\n\t    \t\tvar d3 = Number.MAX_VALUE;\r\n\t    \t\tvar d4 = Number.MAX_VALUE;\r\n\t    \t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t    \t\tthis.forEachPoint(coord, function(p) {\r\n\t    \t\t\tvar x = p[0];\r\n\t    \t\t\tvar y = p[1];\r\n\t    \t\t\tif ((x - y) < d1) {\r\n\t    \t\t\t\td1 = x - y;\r\n\t    \t\t\t\tx1 = p[0];\r\n\t    \t\t\t\ty1 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x - y) < d2) {\r\n\t    \t\t\t\td2 = -x - y;\r\n\t    \t\t\t\tx2 = p[0];\r\n\t    \t\t\t\ty2 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((-x + y) < d3) {\r\n\t    \t\t\t\td3 = -x + y;\r\n\t    \t\t\t\tx3 = p[0];\r\n\t    \t\t\t\ty3 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t\tif ((x + y) < d4) {\r\n\t    \t\t\t\td4 = x + y;\r\n\t    \t\t\t\tx4 = p[0];\r\n\t    \t\t\t\ty4 = p[1];\r\n\t    \t\t\t}\r\n\t    \t\t});\r\n\t    \t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t    \t},\r\n\t    */\n\t    getItemCenter: function getItemCenter(item, geoItems) {\n\t        var bounds = item.bounds,\n\t            min = bounds.min,\n\t            max = bounds.max,\n\t            type = item.type,\n\t            isPoint = type === 'POINT' || type === 'MULTIPOINT',\n\t            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t\n\t        if (type === 'MULTIPOLYGON') {\n\t            return center;\n\t        } else if (type === 'POLYGON') {\n\t            for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                var it = geoItems[i],\n\t                    geom = it.geo,\n\t                    coords = geom.coordinates,\n\t                    dataOption = it.dataOption,\n\t                    bbox = dataOption.bounds;\n\t\n\t                if (bbox.contains(center)) {\n\t                    if (geom.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                    }\n\t                    for (var j = 0, len1 = coords.length; j < len1; j++) {\n\t                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\n\t                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\n\t                            if (pt) {\n\t                                return pt.max.center;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        } else if (type === 'POINT' || type === 'MULTIPOINT') {\n\t            return center;\n\t        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\n\t            return center;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    getHSegmentsInPolygon: function getHSegmentsInPolygon(y, poly) {\n\t        var s = [],\n\t            i,\n\t            len,\n\t            out,\n\t            vectorSize = 1,\n\t            p1 = poly[0];\n\t\n\t        if (typeof poly[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [poly[0], poly[1]];\n\t        }\n\t        var isGt1 = y > p1[1];\n\t        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\n\t                isGt2 = y > p2[1];\n\t            if (isGt1 !== isGt2) {\n\t                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\n\t            }\n\t            p1 = p2;\n\t            isGt1 = isGt2;\n\t        }\n\t        len = s.length;\n\t        if (len) {\n\t            s = s.sort();\n\t            var max = 0,\n\t                index = -1;\n\t            for (i = 1; i < len; i += 2) {\n\t                var j = i - 1,\n\t                    d = Math.abs(s[i] - s[j]);\n\t                if (d > max) {\n\t                    max = d;\n\t                    index = j;\n\t                }\n\t            }\n\t            out = {\n\t                y: y,\n\t                segArr: s,\n\t                max: {\n\t                    width: max,\n\t                    center: [(s[index] + s[index + 1]) / 2, y]\n\t                }\n\t            };\n\t        }\n\t        return out;\n\t    },\n\t\n\t    isPointInPolygonArr: function isPointInPolygonArr(chkPoint, coords) {\n\t        //        \n\t        var isIn = false,\n\t            x = chkPoint[0],\n\t            y = chkPoint[1],\n\t            vectorSize = 1,\n\t            p1 = coords[0];\n\t\n\t        if (typeof coords[0] === 'number') {\n\t            vectorSize = 2;\n\t            p1 = [coords[0], coords[1]];\n\t        }\n\t\n\t        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\n\t            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\n\t                xmin = Math.min(p1[0], p2[0]),\n\t                xmax = Math.max(p1[0], p2[0]),\n\t                ymax = Math.max(p1[1], p2[1]);\n\t            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\n\t                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\n\t                if (p1[1] === p2[1] || y <= xinters) {\n\t                    isIn = !isIn;\n\t                }\n\t            }\n\t            p1 = p2;\n\t        }\n\t        return isIn;\n\t    },\n\t\n\t    /** Is point in polygon with holes\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {chkPoint} chkPoint - point in [x, y] format\r\n\t     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if polygon contain chkPoint\r\n\t    */\n\t    isPointInPolygonWithHoles: function isPointInPolygonWithHoles(chkPoint, coords) {\n\t        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) {\n\t            return false;\n\t        }\n\t        for (var j = 1, len = coords.length; j < len; j++) {\n\t            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /** Is polygon clockwise\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {ring} ring - ring from geoJSON coordinates data format\r\n\t     * @return {Boolean} true if ring is clockwise\r\n\t    */\n\t    isClockwise: function isClockwise(ring) {\n\t        var area = 0;\n\t        for (var i = 0, j, len = ring.length; i < len; i++) {\n\t            j = (i + 1) % len;\n\t            area += ring[i][0] * ring[j][1];\n\t            area -= ring[j][0] * ring[i][1];\n\t        }\n\t        return area < 0;\n\t    },\n\t\n\t    isPointInPolyLine: function isPointInPolyLine(chkPoint, lineHeight, coords, hiddenLines) {\n\t        //  (  )   \n\t        var dx = chkPoint[0],\n\t            dy = chkPoint[1],\n\t            nullPoint = { x: dx, y: dy },\n\t            minx = dx - lineHeight,\n\t            maxx = dx + lineHeight,\n\t            miny = dy - lineHeight,\n\t            maxy = dy + lineHeight,\n\t            cntHide = 0;\n\t\n\t        lineHeight *= lineHeight;\n\t        for (var i = 1, len = coords.length; i < len; i++) {\n\t            if (hiddenLines && i === hiddenLines[cntHide]) {\n\t                cntHide++;\n\t            } else {\n\t                var p1 = coords[i - 1],\n\t                    p2 = coords[i],\n\t                    x1 = p1[0],\n\t                    y1 = p1[1],\n\t                    x2 = p2[0],\n\t                    y2 = p2[1];\n\t\n\t                if (!(Math.max(x1, x2) < minx || Math.min(x1, x2) > maxx || Math.max(y1, y2) < miny || Math.min(y1, y2) > maxy)) {\n\t                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, { x: x1, y: y1 }, { x: x2, y: y2 }, true);\n\t                    if (sqDist < lineHeight) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    isPointInLines: function isPointInLines(attr) {\n\t        var arr = attr.coords,\n\t            point = attr.point,\n\t            delta = attr.delta,\n\t            boundsArr = attr.boundsArr,\n\t            hidden = attr.hidden;\n\t        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\n\t            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\n\t            if (flag && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /** Get length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} latlngs array\r\n\t     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n\t     * @return {Number} length\r\n\t    */\n\t    getLength: function getLength(latlngs, isMerc) {\n\t        var length = 0;\n\t        if (latlngs && latlngs.length) {\n\t            var lng = false,\n\t                lat = false;\n\t\n\t            isMerc = isMerc === undefined || isMerc;\n\t            latlngs.forEach(function (latlng) {\n\t                if (L.Util.isArray(latlng)) {\n\t                    if (L.Util.isArray(latlng[0])) {\n\t                        length += gmxAPIutils.getLength(latlng, isMerc);\n\t                        return length;\n\t                    } else if (isMerc) {\n\t                        // From Mercator array\n\t                        latlng = L.Projection.Mercator.unproject({ x: latlng[0], y: latlng[1] });\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\n\t                }\n\t                lng = latlng.lng;\n\t                lat = latlng.lat;\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get prettify length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area\r\n\t     * @param {String} type: ('km', 'm', 'nm')\r\n\t     * @return {String} prettify length\r\n\t    */\n\t    prettifyDistance: function prettifyDistance(length, type) {\n\t        var km = ' ' + L.gmxLocale.getText('units.km');\n\t        if (type === 'nm') {\n\t            return Math.round(0.539956803 * length) / 1000 + ' ' + L.gmxLocale.getText('units.nm');\n\t        } else if (type === 'km') {\n\t            return Math.round(length) / 1000 + km;\n\t        } else if (length < 2000 || type === 'm') {\n\t            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\n\t        } else if (length < 200000) {\n\t            return Math.round(length / 10) / 100 + km;\n\t        }\n\t        return Math.round(length / 1000) + km;\n\t    },\n\t\n\t    /** Get geoJSON length\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} length\r\n\t    */\n\t    geoJSONGetLength: function geoJSONGetLength(geoJSON) {\n\t        var out = 0,\n\t            i,\n\t            j,\n\t            len,\n\t            len1,\n\t            coords;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\n\t        }if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'LineString') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingLength(coords[i]);\n\t            }\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                for (j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    out += gmxAPIutils.getRingLength(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getRingLength: function getRingLength(coords) {\n\t        var length = 0;\n\t        if (coords && coords.length) {\n\t            var lng = false,\n\t                lat = false;\n\t            coords.forEach(function (lnglat) {\n\t                if (L.Util.isArray(lnglat)) {\n\t                    if (lnglat.length > 2) {\n\t                        length += gmxAPIutils.getRingLength(lnglat);\n\t                        return length;\n\t                    }\n\t                }\n\t                if (lng !== false && lat !== false) {\n\t                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\n\t                }\n\t                lng = lnglat[0];\n\t                lat = lnglat[1];\n\t            });\n\t        }\n\t        return length;\n\t    },\n\t\n\t    /** Get geoJSON area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoJSONGetArea: function geoJSONGetArea(geoJSON) {\n\t        var out = 0;\n\t\n\t        if (geoJSON.type === 'GeometryCollection') {\n\t            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\n\t        }if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\n\t            var coords = geoJSON.coordinates;\n\t            if (geoJSON.type === 'Polygon') {\n\t                coords = [coords];\n\t            }\n\t            for (var i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.getRingArea(coords[i][0]);\n\t                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\n\t                    out -= gmxAPIutils.getRingArea(coords[i][j]);\n\t                }\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    geoJSONGetLatLng: function geoJSONGetLatLng(geoJSON) {\n\t        if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\n\t        } else if (geoJSON.type === 'Point') {\n\t            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\n\t        } else {\n\t            throw new Error('cannot get ' + geoJSON.type + ' latLng');\n\t        }\n\t    },\n\t\n\t    getRingArea: function getRingArea(coords) {\n\t        var area = 0;\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = coords[i],\n\t                p2 = coords[ipp];\n\t            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\n\t        }\n\t        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t        return out;\n\t    },\n\t\n\t    /** Get area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} L.latLng array\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    getArea: function getArea(arr) {\n\t        var area = 0;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            var ipp = i === len - 1 ? 0 : i + 1,\n\t                p1 = arr[i],\n\t                p2 = arr[ipp];\n\t            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\n\t        }\n\t        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\n\t    },\n\t\n\t    /** Get prettified size of area\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Number} area in square meters\r\n\t     * @param {String} type: ('km2', 'ha', 'm2')\r\n\t     * @return {String} prettified area\r\n\t    */\n\t    prettifyArea: function prettifyArea(area, type) {\n\t        var km2 = ' ' + L.gmxLocale.getText('units.km2');\n\t\n\t        if (type === 'km2') {\n\t            return '' + Math.round(area / 100) / 10000 + km2;\n\t        } else if (type === 'ha') {\n\t            return '' + Math.round(area / 100) / 100 + ' ' + L.gmxLocale.getText('units.ha');\n\t        } else if (area < 100000 || type === 'm2') {\n\t            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\n\t        } else if (area < 3000000) {\n\t            return ('' + Math.round(area / 1000) / 1000).replace('.', ',') + km2;\n\t        } else if (area < 30000000) {\n\t            return ('' + Math.round(area / 10000) / 100).replace('.', ',') + km2;\n\t        } else if (area < 300000000) {\n\t            return ('' + Math.round(area / 100000) / 10).replace('.', ',') + km2;\n\t        }\n\t        return Math.round(area / 1000000) + km2;\n\t    },\n\t\n\t    geoLength: function geoLength(geom) {\n\t        var ret = 0,\n\t            type = geom.type;\n\t        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoLength({ type: 'LINESTRING', coordinates: geom.coordinates[i] });\n\t            }\n\t            return ret;\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            ret = gmxAPIutils.getLength(geom.coordinates);\n\t        }\n\t        return ret;\n\t    },\n\t\n\t    /** Converts Geomixer geometry to geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - Geomixer geometry\r\n\t     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n\t     * @return {Object} geoJSON geometry\r\n\t    */\n\t    geometryToGeoJSON: function geometryToGeoJSON(geom, mercFlag) {\n\t        if (!geom) {\n\t            return null;\n\t        }\n\t\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    convertGeometry: function convertGeometry(geom, fromMerc) {\n\t        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon' : geom.type === 'POLYGON' ? 'Polygon' : geom.type === 'MULTILINESTRING' ? 'MultiLineString' : geom.type === 'LINESTRING' ? 'LineString' : geom.type === 'MULTIPOINT' ? 'MultiPoint' : geom.type === 'POINT' ? 'Point' : geom.type,\n\t            coords = geom.coordinates;\n\t        if (fromMerc) {\n\t            coords = gmxAPIutils.coordsFromMercator(type, coords);\n\t        } else {\n\t            coords = gmxAPIutils.coordsToMercator(type, coords);\n\t        }\n\t        return {\n\t            type: geom.type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    /** Converts GeoJSON object into GeoMixer format\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry - GeoJSON object\r\n\t     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n\t     * @return {Object} Geometry in GeoMixer format\r\n\t    */\n\t    geoJSONtoGeometry: function geoJSONtoGeometry(geoJSON, mercFlag) {\n\t        if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        } else if (geoJSON.type === 'Feature') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\n\t        } else if (geoJSON.type === 'FeatureCollection') {\n\t            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\n\t        }\n\t\n\t        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON' : geoJSON.type === 'Polygon' ? 'POLYGON' : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING' : geoJSON.type === 'LineString' ? 'LINESTRING' : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT' : geoJSON.type === 'Point' ? 'POINT' : geoJSON.type,\n\t            coords = geoJSON.coordinates;\n\t        if (mercFlag) {\n\t            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\n\t        }\n\t        return {\n\t            type: type,\n\t            coordinates: coords\n\t        };\n\t    },\n\t\n\t    _coordsConvert: function _coordsConvert(type, coords, toMerc) {\n\t        var i,\n\t            len,\n\t            p,\n\t            resCoords = [];\n\t        if (type === 'Point') {\n\t            if (toMerc) {\n\t                p = L.Projection.Mercator.project({ lat: coords[1], lng: coords[0] });\n\t                resCoords = [p.x, p.y];\n\t            } else {\n\t                p = L.Projection.Mercator.unproject({ y: coords[1], x: coords[0] });\n\t                resCoords = [p.lng, p.lat];\n\t            }\n\t        } else if (type === 'LineString' || type === 'MultiPoint') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'Polygon' || type === 'MultiLineString') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\n\t            }\n\t        } else if (type === 'MultiPolygon') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\n\t            }\n\t        }\n\t        return resCoords;\n\t    },\n\t\n\t    coordsFromMercator: function coordsFromMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, false);\n\t    },\n\t\n\t    coordsToMercator: function coordsToMercator(type, coords) {\n\t        return gmxAPIutils._coordsConvert(type, coords, true);\n\t    },\n\t\n\t    transformGeometry: function transformGeometry(geom, callback) {\n\t        return !geom ? geom : {\n\t            type: geom.type,\n\t            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function (p) {\n\t                return callback(p);\n\t            })\n\t        };\n\t    },\n\t\n\t    /** Get area for geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geometry\r\n\t     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n\t     * @return {Number} area in square meters\r\n\t    */\n\t    geoArea: function geoArea(geom, isMerc) {\n\t        var i,\n\t            len,\n\t            ret = 0,\n\t            type = geom.type || '';\n\t        isMerc = isMerc === undefined || isMerc;\n\t        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\n\t            for (i = 0, len = geom.coordinates.length; i < len; i++) {\n\t                ret += gmxAPIutils.geoArea({ type: 'POLYGON', coordinates: geom.coordinates[i] }, isMerc);\n\t            }\n\t            return ret;\n\t        } else if (type === 'POLYGON' || type === 'Polygon') {\n\t            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\n\t            for (i = 1, len = geom.coordinates.length; i < len; i++) {\n\t                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\n\t            }\n\t            return ret;\n\t        } else if (geom.length) {\n\t            var latlngs = [],\n\t                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\n\t\n\t            for (i = 0, len = geom.length; i < len; i += vectorSize) {\n\t                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\n\t                latlngs.push(isMerc ? L.Projection.Mercator.unproject({ y: p[1], x: p[0] }) : { lat: p[1], lng: p[0] });\n\t            }\n\t            return gmxAPIutils.getArea(latlngs);\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    /** Get summary for geoJSON geometry\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Object} geoJSON geometry\r\n\t     * @param {Object} unitOptions {\r\n\t     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n\t     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n\t     *               }\r\n\t     * @return {String} Summary string for geometry\r\n\t    */\n\t    getGeoJSONSummary: function getGeoJSONSummary(geom, unitOptions) {\n\t        var type = geom.type,\n\t            units = unitOptions || {},\n\t            out = 0,\n\t            i,\n\t            len,\n\t            coords;\n\t        if (type === 'Point') {\n\t            coords = geom.coordinates;\n\t            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\n\t        } else if (type === 'Polygon') {\n\t            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\n\t        } else if (type === 'MultiPolygon') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoArea({ type: 'Polygon', coordinates: coords[i] }, false);\n\t            }\n\t            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\n\t        } else if (type === 'LineString') {\n\t            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\n\t        } else if (type === 'MultiLineString') {\n\t            coords = geom.coordinates;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                out += gmxAPIutils.geoJSONGetLength({ type: 'LineString', coordinates: coords[i] });\n\t            }\n\t            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for point\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {latlng} point\r\n\t     * @param {num} format number:\r\n\t     *         0: 6252'30.68\" N, 2248'27.42\" E\r\n\t     *         1: 62.875188 N, 22.807617 E\r\n\t     *         2: 2538932, 9031643 (EPSG:3395)\r\n\t     *         3: 2538932, 9069712 (EPSG:3857)\r\n\t     * @return {String} Summary string for LatLng point\r\n\t    */\n\t    getCoordinatesString: function getCoordinatesString(latlng, num) {\n\t        var x = latlng.lng,\n\t            y = latlng.lat,\n\t            formats = ['', '', ' (EPSG:3395)', ' (EPSG:3857)'],\n\t            len = formats.length,\n\t            merc,\n\t            out = '';\n\t        num = num || 0;\n\t        if (x > 180) {\n\t            x -= 360;\n\t        }\n\t        if (x < -180) {\n\t            x += 360;\n\t        }\n\t        if (num % len === 0) {\n\t            out = gmxAPIutils.formatCoordinates2(x, y);\n\t        } else if (num % len === 1) {\n\t            out = gmxAPIutils.formatCoordinates(x, y);\n\t        } else if (num % len === 2) {\n\t            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\n\t        } else {\n\t            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\n\t            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    /** Get summary for geometries array\r\n\t     * @memberof L.gmxUtil\r\n\t     * @param {Array} geometries array in Geomixer format\r\n\t     * @param {Object} units Options for length and area\r\n\t     * @return {String} Summary string for geometries array\r\n\t    */\n\t    getGeometriesSummary: function getGeometriesSummary(arr, unitOptions) {\n\t        var out = '',\n\t            type = '',\n\t            res = 0;\n\t        if (!unitOptions) {\n\t            unitOptions = {};\n\t        }\n\t        if (arr) {\n\t            arr.forEach(function (geom) {\n\t                if (geom) {\n\t                    type = geom.type.toUpperCase();\n\t                    if (type.indexOf('POINT') !== -1) {\n\t                        var latlng = L.Projection.Mercator.unproject({ y: geom.coordinates[1], x: geom.coordinates[0] });\n\t                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: ' + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\n\t                    } else if (type.indexOf('LINESTRING') !== -1) {\n\t                        res += gmxAPIutils.geoLength(geom);\n\t                    } else if (type.indexOf('POLYGON') !== -1) {\n\t                        res += gmxAPIutils.geoArea(geom);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        if (!out) {\n\t            if (type.indexOf('LINESTRING') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: ' + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\n\t            } else if (type.indexOf('POLYGON') !== -1) {\n\t                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: ' + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getGeometrySummary: function getGeometrySummary(geom, unitOptions) {\n\t        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\n\t    },\n\t\n\t    chkOnEdge: function chkOnEdge(p1, p2, ext) {\n\t        //   \n\t        if (p1[0] < ext.min.x && p2[0] < ext.min.x || p1[0] > ext.max.x && p2[0] > ext.max.x) {\n\t            return true;\n\t        }\n\t        if (p1[1] < ext.min.y && p2[1] < ext.min.y || p1[1] > ext.max.y && p2[1] > ext.max.y) {\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getHidden: function getHidden(coords, tb) {\n\t        //     \n\t        var hiddenLines = [],\n\t            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\n\t            prev = null;\n\t        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\n\t            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\n\t            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\n\t                hiddenLines.push(i);\n\t            }\n\t            prev = p;\n\t        }\n\t        return hiddenLines;\n\t    },\n\t\n\t    getNormalizeBounds: function getNormalizeBounds(screenBounds, mercDeltaY) {\n\t        // get bounds array from -180 180 lng\n\t        var northWest = screenBounds.getNorthWest(),\n\t            southEast = screenBounds.getSouthEast(),\n\t            minX = northWest.lng,\n\t            maxX = southEast.lng,\n\t            w = (maxX - minX) / 2,\n\t            minX1 = null,\n\t            maxX1 = null,\n\t            out = [];\n\t\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = { x: minX, y: southEast.lat },\n\t            m2 = { x: maxX, y: northWest.lat };\n\t\n\t        if (mercDeltaY !== undefined) {\n\t            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\n\t            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\n\t            m1.y -= mercDeltaY;\n\t            m2.y -= mercDeltaY;\n\t        }\n\t        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\n\t\n\t        if (minX1) {\n\t            var m11 = { x: minX1, y: southEast.lat },\n\t                m12 = { x: maxX1, y: northWest.lat };\n\t            if (mercDeltaY !== undefined) {\n\t                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\n\t                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\n\t                m11.y -= mercDeltaY;\n\t                m12.y -= mercDeltaY;\n\t            }\n\t            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\n\t        }\n\t        return out;\n\t    },\n\t\n\t    toPrecision: function toPrecision(x, prec) {\n\t        var zn = Math.pow(10, prec ? prec : 4);\n\t        return Math.round(zn * x) / zn;\n\t    },\n\t\n\t    getTileBounds: function getTileBounds(x, y, z) {\n\t        //x, y, z - GeoMixer tile coordinates\n\t        var tileSize = gmxAPIutils.tileSizes[z],\n\t            minx = x * tileSize,\n\t            miny = y * tileSize;\n\t        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\n\t    },\n\t\n\t    parseTemplate: function parseTemplate(str, properties) {\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = key in properties ? properties[key] : '';\n\t\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    getDefaultBalloonTemplate: function getDefaultBalloonTemplate(properties, tileAttributeTypes) {\n\t        var str = '';\n\t        for (var key in properties) {\n\t            if (!tileAttributeTypes || key in tileAttributeTypes) {\n\t                str += '<b>' + key + ':</b> [' + key + ']<br />';\n\t            }\n\t        }\n\t        str += '<br />[SUMMARY]<br />';\n\t        return str;\n\t    },\n\t\n\t    parseBalloonTemplate: function parseBalloonTemplate(str, options) {\n\t        var properties = options.properties;\n\t\n\t        if (!str) {\n\t            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\n\t        }\n\t        var matches = str.match(/\\[([^\\]]+)\\]/ig);\n\t        if (matches) {\n\t            var tileAttributeTypes = options.tileAttributeTypes,\n\t                unitOptions = options.unitOptions,\n\t                geometries = options.geometries;\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var key1 = matches[i],\n\t                    key = key1.substr(1, key1.length - 2),\n\t                    res = '';\n\t\n\t                if (key in properties) {\n\t                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\n\t                } else if (key === 'SUMMARY') {\n\t                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                str = str.replace(key1, res);\n\t            }\n\t        }\n\t        return str;\n\t    },\n\t\n\t    styleKeys: {\n\t        marker: {\n\t            server: ['image', 'angle', 'scale', 'minScale', 'maxScale', 'size', 'circle', 'center', 'color'],\n\t            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\n\t        },\n\t        outline: {\n\t            server: ['color', 'opacity', 'thickness', 'dashes'],\n\t            client: ['color', 'opacity', 'weight', 'dashArray']\n\t        },\n\t        fill: {\n\t            server: ['color', 'opacity', 'image', 'pattern', 'radialGradient', 'linearGradient'],\n\t            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\n\t        },\n\t        label: {\n\t            server: ['text', 'field', 'template', 'color', 'haloColor', 'size', 'spacing', 'align'],\n\t            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\n\t        }\n\t    },\n\t    styleFuncKeys: {\n\t        iconSize: 'iconSizeFunction',\n\t        iconAngle: 'rotateFunction',\n\t        iconScale: 'scaleFunction',\n\t        iconColor: 'iconColorFunction',\n\t        opacity: 'opacityFunction',\n\t        fillOpacity: 'fillOpacityFunction',\n\t        color: 'colorFunction',\n\t        fillColor: 'fillColorFunction'\n\t    },\n\t    styleFuncError: {\n\t        iconSize: function iconSize() {\n\t            return 8;\n\t        },\n\t        iconAngle: function iconAngle() {\n\t            return 0;\n\t        },\n\t        iconScale: function iconScale() {\n\t            return 1;\n\t        },\n\t        iconColor: function iconColor() {\n\t            return 0xFF;\n\t        },\n\t        opacity: function opacity() {\n\t            return 1;\n\t        },\n\t        fillOpacity: function fillOpacity() {\n\t            return 0.5;\n\t        },\n\t        color: function color() {\n\t            return 0xFF;\n\t        },\n\t        fillColor: function fillColor() {\n\t            return 0xFF;\n\t        }\n\t    },\n\t    defaultStyles: {\n\t        MinZoom: 1,\n\t        MaxZoom: 21,\n\t        Filter: '',\n\t        Balloon: '',\n\t        DisableBalloonOnMouseMove: true,\n\t        DisableBalloonOnClick: false,\n\t        RenderStyle: {\n\t            point: { // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\n\t                color: 0xFF,\n\t                weight: 1,\n\t                iconSize: 8\n\t            },\n\t            linestring: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            },\n\t            polygon: { // old = {outline: {color: 255, thickness: 1}},\n\t                color: 0xFF,\n\t                weight: 1\n\t            }\n\t        }\n\t    },\n\t\n\t    getDefaultStyle: function getDefaultStyle(type) {\n\t        var from = gmxAPIutils.defaultStyles,\n\t            out = L.extend({}, from);\n\t        out.RenderStyle = from.RenderStyle[type];\n\t        return out;\n\t    },\n\t\n\t    toServerStyle: function toServerStyle(style) {\n\t        // Style leaflet->Scanex\n\t        var out = {};\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (var i = 0, len = keys.client.length; i < len; i++) {\n\t                var key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    if (!out[key]) {\n\t                        out[key] = {};\n\t                    }\n\t                    var zn = style[key1];\n\t                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\n\t                        zn *= 100;\n\t                    }\n\t                    out[key][keys.server[i]] = zn;\n\t                }\n\t            }\n\t        }\n\t        if ('iconAnchor' in style) {\n\t            if (!out.marker) {\n\t                out.marker = {};\n\t            }\n\t            out.marker.dx = -style.iconAnchor[0];\n\t            out.marker.dy = -style.iconAnchor[1];\n\t        }\n\t        return out;\n\t    },\n\t\n\t    fromServerStyle: function fromServerStyle(style) {\n\t        // Style Scanex->leaflet\n\t        var st,\n\t            i,\n\t            len,\n\t            key1,\n\t            out = {\n\t            type: '' // 'polygon', 'line', 'circle', 'square', 'image'\n\t        };\n\t\n\t        for (var key in gmxAPIutils.styleKeys) {\n\t            var keys = gmxAPIutils.styleKeys[key];\n\t            for (i = 0, len = keys.client.length; i < len; i++) {\n\t                key1 = keys.client[i];\n\t                if (key1 in style) {\n\t                    out[key1] = style[key1];\n\t                }\n\t            }\n\t            st = style[key];\n\t            if (st && (typeof st === 'undefined' ? 'undefined' : _typeof(st)) === 'object') {\n\t                for (i = 0, len = keys.server.length; i < len; i++) {\n\t                    key1 = keys.server[i];\n\t                    if (key1 in st) {\n\t                        var newKey = keys.client[i],\n\t                            zn = st[key1];\n\t                        if (typeof zn === 'string') {\n\t                            if (gmxAPIutils.styleFuncKeys[newKey]) {\n\t                                if (zn.match(/[^\\d\\.]/) === null) {\n\t                                    zn = Number(zn);\n\t                                } else {\n\t                                    var func = L.gmx.Parsers.parseExpression(zn);\n\t                                    if (func === null) {\n\t                                        zn = gmxAPIutils.styleFuncError[newKey]();\n\t                                    } else {\n\t                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\n\t                                    }\n\t                                }\n\t                            }\n\t                        } else if (key1 === 'opacity') {\n\t                            zn /= 100;\n\t                        }\n\t                        out[newKey] = zn;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (style.marker) {\n\t            st = style.marker;\n\t            if ('dx' in st || 'dy' in st) {\n\t                var dx = st.dx || 0,\n\t                    dy = st.dy || 0;\n\t                out.iconAnchor = [-dx, -dy]; // For leaflet type iconAnchor\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getUnixTimeFromStr: function getUnixTimeFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        return Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\n\t    },\n\t\n\t    getDateFromStr: function getDateFromStr(st) {\n\t        var arr = L.Util.trim(st).split(' ');\n\t        arr = arr[0].split('.');\n\t\n\t        if (arr[2].length === 4) {\n\t            arr = arr.reverse();\n\t        }\n\t        var dt = new Date(arr[0], arr[1] - 1, arr[2]);\n\t        return dt;\n\t    },\n\t\n\t    getUTCdate: function getUTCdate(utime) {\n\t        var dt = new Date(utime * 1000);\n\t\n\t        return [dt.getUTCFullYear(), gmxAPIutils.pad2(dt.getUTCMonth() + 1), gmxAPIutils.pad2(dt.getUTCDate())].join('.');\n\t    },\n\t\n\t    getUTCtime: function getUTCtime(utime) {\n\t        var h = Math.floor(utime / 3600),\n\t            m = Math.floor((utime - h * 3600) / 60),\n\t            s = Math.floor(utime - h * 3600 - m * 60);\n\t\n\t        return [\n\t        //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\n\t        gmxAPIutils.pad2(h), gmxAPIutils.pad2(m), gmxAPIutils.pad2(s)].join(':');\n\t    },\n\t\n\t    getUTCdateTime: function getUTCdateTime(utime) {\n\t        var time = utime % (3600 * 24);\n\t\n\t        if (time) {\n\t            return [gmxAPIutils.getUTCdate(utime), gmxAPIutils.getUTCtime(utime % (3600 * 24))].join(' ');\n\t        } else {\n\t            return gmxAPIutils.getUTCdate(utime);\n\t        }\n\t    },\n\t\n\t    attrToString: function attrToString(type, value) {\n\t        if (type === 'date') {\n\t            return value ? L.gmxUtil.getUTCdate(value) : value;\n\t        } else if (type === 'time') {\n\t            return value ? L.gmxUtil.getUTCtime(value) : value;\n\t        } else if (type === 'datetime') {\n\t            return value ? L.gmxUtil.getUTCdateTime(value) : value;\n\t        } else {\n\t            return value;\n\t        }\n\t    },\n\t\n\t    getTileAttributes: function getTileAttributes(prop) {\n\t        var tileAttributeIndexes = {},\n\t            tileAttributeTypes = {};\n\t        if (prop.attributes) {\n\t            var attrs = prop.attributes,\n\t                attrTypes = prop.attrTypes || null;\n\t            if (prop.identityField) {\n\t                tileAttributeIndexes[prop.identityField] = 0;\n\t            }\n\t            for (var a = 0; a < attrs.length; a++) {\n\t                var key = attrs[a];\n\t                tileAttributeIndexes[key] = a + 1;\n\t                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\n\t            }\n\t        }\n\t        return {\n\t            tileAttributeTypes: tileAttributeTypes,\n\t            tileAttributeIndexes: tileAttributeIndexes\n\t        };\n\t    }\n\t};\n\t\n\tgmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0); // 111319.5;\n\tgmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI; // 6335440.712613423;\n\t\n\t(function () {\n\t    //pre-calculate tile sizes\n\t    for (var z = 0; z < 30; z++) {\n\t        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\n\t    }\n\t})();\n\t\n\tgmxAPIutils.Bounds = function (arr) {\n\t    this.min = {\n\t        x: Number.MAX_VALUE,\n\t        y: Number.MAX_VALUE\n\t    };\n\t    this.max = {\n\t        x: -Number.MAX_VALUE,\n\t        y: -Number.MAX_VALUE\n\t    };\n\t    this.extendArray(arr);\n\t};\n\tgmxAPIutils.Bounds.prototype = {\n\t    extend: function extend(x, y) {\n\t        if (x < this.min.x) {\n\t            this.min.x = x;\n\t        }\n\t        if (x > this.max.x) {\n\t            this.max.x = x;\n\t        }\n\t        if (y < this.min.y) {\n\t            this.min.y = y;\n\t        }\n\t        if (y > this.max.y) {\n\t            this.max.y = y;\n\t        }\n\t        return this;\n\t    },\n\t    extendBounds: function extendBounds(bounds) {\n\t        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\n\t    },\n\t    extendArray: function extendArray(arr) {\n\t        if (!arr || !arr.length) {\n\t            return this;\n\t        }\n\t        var i, len;\n\t        if (typeof arr[0] === 'number') {\n\t            for (i = 0, len = arr.length; i < len; i += 2) {\n\t                this.extend(arr[i], arr[i + 1]);\n\t            }\n\t        } else {\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                this.extend(arr[i][0], arr[i][1]);\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t    addBuffer: function addBuffer(dxmin, dymin, dxmax, dymax) {\n\t        this.min.x -= dxmin;\n\t        this.min.y -= dymin || dxmin;\n\t        this.max.x += dxmax || dxmin;\n\t        this.max.y += dymax || dymin || dxmin;\n\t        return this;\n\t    },\n\t    contains: function contains(point) {\n\t        // ([x, y]) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = point[0],\n\t            y = point[1];\n\t        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\n\t    },\n\t    getCenter: function getCenter() {\n\t        var min = this.min,\n\t            max = this.max;\n\t        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\n\t    },\n\t    addOffset: function addOffset(offset) {\n\t        this.min.x += offset[0];this.max.x += offset[0];\n\t        this.min.y += offset[1];this.max.y += offset[1];\n\t        return this;\n\t    },\n\t    intersects: function intersects(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\n\t    },\n\t    intersectsWithDelta: function intersectsWithDelta(bounds, dx, dy) {\n\t        // (Bounds, dx, dy) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            x = dx || 0,\n\t            y = dy || 0,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\n\t    },\n\t    isEqual: function isEqual(bounds) {\n\t        // (Bounds) -> Boolean\n\t        var min = this.min,\n\t            max = this.max,\n\t            min2 = bounds.min,\n\t            max2 = bounds.max;\n\t        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\n\t    },\n\t    isNodeIntersect: function isNodeIntersect(coords) {\n\t        for (var i = 0, len = coords.length; i < len; i++) {\n\t            if (this.contains(coords[i])) {\n\t                return {\n\t                    num: i,\n\t                    point: coords[i]\n\t                };\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t    clipPolygon: function clipPolygon(coords) {\n\t        // (coords) -> clip coords\n\t        var min = this.min,\n\t            max = this.max,\n\t            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\n\t            cp1,\n\t            cp2,\n\t            s,\n\t            e,\n\t            inside = function inside(p) {\n\t            return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\n\t        },\n\t            intersection = function intersection() {\n\t            var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\n\t                dp = [s[0] - e[0], s[1] - e[1]],\n\t                n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n\t                n2 = s[0] * e[1] - s[1] * e[0],\n\t                n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n\t            return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\n\t        };\n\t\n\t        var outputList = coords;\n\t        cp1 = clip[3];\n\t        for (var j = 0; j < 4; j++) {\n\t            cp2 = clip[j];\n\t            var inputList = outputList,\n\t                len = inputList.length;\n\t            outputList = [];\n\t            s = inputList[len - 1]; //last on the input list\n\t            for (var i = 0; i < len; i++) {\n\t                e = inputList[i];\n\t                if (inside(e)) {\n\t                    if (!inside(s)) {\n\t                        outputList.push(intersection());\n\t                    }\n\t                    outputList.push(e);\n\t                } else if (inside(s)) {\n\t                    outputList.push(intersection());\n\t                }\n\t                s = e;\n\t            }\n\t            cp1 = cp2;\n\t        }\n\t        return outputList;\n\t    },\n\t    clipPolyLine: function clipPolyLine(coords, angleFlag, delta) {\n\t        // (coords) -> clip coords\n\t        delta = delta || 0;\n\t        var min = this.min,\n\t            max = this.max,\n\t            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\n\t            bitCode = function bitCode(p) {\n\t            var code = 0;\n\t\n\t            if (p[0] < bbox[0]) code |= 1; // left\n\t            else if (p[0] > bbox[2]) code |= 2; // right\n\t\n\t            if (p[1] < bbox[1]) code |= 4; // bottom\n\t            else if (p[1] > bbox[3]) code |= 8; // top\n\t\n\t            return code;\n\t        },\n\t            getAngle = function getAngle(a, b) {\n\t            return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\n\t        },\n\t            intersect = function intersect(a, b, edge) {\n\t            return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\n\t            edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\n\t            edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\n\t            edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\n\t            null;\n\t        },\n\t            result = [],\n\t            len = coords.length,\n\t            codeA = bitCode(coords[0], bbox),\n\t            part = [],\n\t            i,\n\t            a,\n\t            b,\n\t            c,\n\t            codeB,\n\t            lastCode;\n\t\n\t        for (i = 1; i < len; i++) {\n\t            a = coords[i - 1];\n\t            b = coords[i];\n\t            if (a[0] === b[0] && a[1] === b[1]) {\n\t                continue;\n\t            }\n\t            codeB = lastCode = bitCode(b, bbox);\n\t\n\t            while (true) {\n\t\n\t                if (!(codeA | codeB)) {\n\t                    // accept\n\t                    if (angleFlag) {\n\t                        a[2] = getAngle(a, b);\n\t                        c = coords[i + 1];\n\t                        b[2] = c ? getAngle(b, c) : a[2];\n\t                    }\n\t                    part.push(a);\n\t\n\t                    if (codeB !== lastCode) {\n\t                        // segment went outside\n\t                        part.push(b);\n\t\n\t                        if (i < len - 1) {\n\t                            // start a new line\n\t                            result.push(part);\n\t                            part = [];\n\t                        }\n\t                    } else if (i === len - 1) {\n\t                        part.push(b);\n\t                    }\n\t                    break;\n\t                } else if (codeA & codeB) {\n\t                    // trivial reject\n\t                    break;\n\t                } else if (codeA) {\n\t                    // a outside, intersect with clip edge\n\t                    a = intersect(a, b, codeA, bbox);\n\t                    codeA = bitCode(a, bbox);\n\t                } else {\n\t                    // b outside\n\t                    b = intersect(a, b, codeB, bbox);\n\t                    codeB = bitCode(b, bbox);\n\t                }\n\t            }\n\t\n\t            codeA = lastCode;\n\t        }\n\t\n\t        if (part.length) result.push(part);\n\t\n\t        return result;\n\t    }\n\t};\n\t\n\tgmxAPIutils.bounds = function (arr) {\n\t    return new gmxAPIutils.Bounds(arr);\n\t};\n\t\n\t//  API     \n\tgmxAPIutils.parseUri = function (str) {\n\t    var o = gmxAPIutils.parseUri.options,\n\t        m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\n\t        uri = {},\n\t        i = 14;\n\t\n\t    while (i--) {\n\t        uri[o.key[i]] = m[i] || '';\n\t    }\n\t\n\t    uri[o.q.name] = {};\n\t    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n\t        if ($1) {\n\t            uri[o.q.name][$1] = $2;\n\t        }\n\t    });\n\t\n\t    uri.hostOnly = uri.host;\n\t    uri.host = uri.authority; // HACK\n\t\n\t    return uri;\n\t};\n\t\n\tgmxAPIutils.parseUri.options = {\n\t    strictMode: false,\n\t    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n\t    q: {\n\t        name: 'queryKey',\n\t        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n\t    },\n\t    parser: {\n\t        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n\t        loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n\t    }\n\t};\n\t\n\tif (!L.gmxUtil) {\n\t    L.gmxUtil = {};\n\t}\n\t\n\t//public interface\n\tL.extend(L.gmxUtil, {\n\t    newId: gmxAPIutils.newId,\n\t    loaderStatus: function loaderStatus() {},\n\t    isIE9: gmxAPIutils.isIE(9),\n\t    isIE10: gmxAPIutils.isIE(10),\n\t    isIE11: gmxAPIutils.isIE(11),\n\t    gtIE11: gmxAPIutils.gtIE(11),\n\t    getFormData: gmxAPIutils.getFormData,\n\t    requestJSONP: gmxAPIutils.requestJSONP,\n\t    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\n\t    request: gmxAPIutils.request,\n\t    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\n\t    fromServerStyle: gmxAPIutils.fromServerStyle,\n\t    toServerStyle: gmxAPIutils.toServerStyle,\n\t    getDefaultStyle: gmxAPIutils.getDefaultStyle,\n\t    bounds: gmxAPIutils.bounds,\n\t    getGeometryBounds: gmxAPIutils.getGeometryBounds,\n\t    tileSizes: gmxAPIutils.tileSizes,\n\t    getDateFromStr: gmxAPIutils.getDateFromStr,\n\t    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\n\t    getUTCdate: gmxAPIutils.getUTCdate,\n\t    getUTCtime: gmxAPIutils.getUTCtime,\n\t    getUTCdateTime: gmxAPIutils.getUTCdateTime,\n\t    attrToString: gmxAPIutils.attrToString,\n\t    getTileAttributes: gmxAPIutils.getTileAttributes,\n\t    formatCoordinates: function formatCoordinates(latlng, type) {\n\t        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\n\t    },\n\t    formatDegrees: gmxAPIutils.formatDegrees,\n\t    pad2: gmxAPIutils.pad2,\n\t    dec2hex: gmxAPIutils.dec2hex,\n\t    dec2rgba: gmxAPIutils.dec2rgba,\n\t    trunc: gmxAPIutils.trunc,\n\t    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\n\t    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\n\t    getLength: gmxAPIutils.getLength,\n\t    geoLength: gmxAPIutils.geoLength,\n\t    prettifyDistance: gmxAPIutils.prettifyDistance,\n\t    getArea: gmxAPIutils.getArea,\n\t    prettifyArea: gmxAPIutils.prettifyArea,\n\t    geoArea: gmxAPIutils.geoArea,\n\t    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\n\t    getSVGIcon: gmxAPIutils.getSVGIcon,\n\t    getCoordinatesString: gmxAPIutils.getCoordinatesString,\n\t    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\n\t    getGeometrySummary: gmxAPIutils.getGeometrySummary,\n\t    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\n\t    getPropertiesHash: gmxAPIutils.getPropertiesHash,\n\t    distVincenty: gmxAPIutils.distVincenty,\n\t    parseCoordinates: gmxAPIutils.parseCoordinates,\n\t    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\n\t    convertGeometry: gmxAPIutils.convertGeometry,\n\t    transformGeometry: gmxAPIutils.transformGeometry,\n\t    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\n\t    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\n\t    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\n\t    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\n\t    parseUri: gmxAPIutils.parseUri,\n\t    isRectangle: gmxAPIutils.isRectangle,\n\t    isClockwise: gmxAPIutils.isClockwise,\n\t    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\n\t    getPatternIcon: gmxAPIutils.getPatternIcon,\n\t    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\n\t    normalizeHostname: gmxAPIutils.normalizeHostname,\n\t    getTileBounds: gmxAPIutils.getTileBounds,\n\t    parseTemplate: gmxAPIutils.parseTemplate\n\t});\n\t\n\t(function () {\n\t    var requests = {};\n\t    var lastRequestId = 0;\n\t\n\t    var processMessage = function processMessage(e) {\n\t\n\t        if (!(e.origin in requests)) {\n\t            return;\n\t        }\n\t\n\t        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\n\t        try {\n\t            var dataObj = JSON.parse(dataStr);\n\t        } catch (ev) {\n\t            console.log({ Status: 'error', ErrorInfo: { ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr } });\n\t        }\n\t        var request = requests[e.origin][dataObj.CallbackName];\n\t        if (!request) {\n\t            return; // message   \n\t        }\n\t\n\t        delete requests[e.origin][dataObj.CallbackName];\n\t        delete dataObj.CallbackName;\n\t\n\t        if (request.iframe.parentNode) {\n\t            request.iframe.parentNode.removeChild(request.iframe);\n\t        }\n\t        if ('callback' in request) {\n\t            request.callback(dataObj);\n\t        }\n\t    };\n\t\n\t    L.DomEvent.on(window, 'message', processMessage);\n\t\n\t    function createPostIframe2(id, callback, url) {\n\t        var uniqueId = 'gmxAPIutils_id' + lastRequestId++,\n\t            iframe = L.DomUtil.create('iframe');\n\t\n\t        iframe.style.display = 'none';\n\t        iframe.setAttribute('id', id);\n\t        iframe.setAttribute('name', id); /*eslint-disable no-script-url */\n\t        iframe.src = 'javascript:true'; /*eslint-enable */\n\t        iframe.callbackName = uniqueId;\n\t\n\t        var parsedURL = gmxAPIutils.parseUri(url);\n\t        var origin = (parsedURL.protocol ? parsedURL.protocol + ':' : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\n\t\n\t        requests[origin] = requests[origin] || {};\n\t        requests[origin][uniqueId] = { callback: callback, iframe: iframe };\n\t\n\t        return iframe;\n\t    }\n\t\n\t    // namespace\n\t    gmxAPIutils.createPostIframe2 = createPostIframe2;\n\t})();\n\t\n\t//  POST \n\t(function () {\n\t    /**   POST \r\n\t    * @namespace L.gmxUtil\r\n\t       * @ignore\r\n\t    * @function\r\n\t    *\r\n\t    * @param url {string} - URL \r\n\t    * @param params {object} -  -\r\n\t    * @param callback {function} - callback,       .   - -  \r\n\t    * @param baseForm {DOMElement} -   . ,      .\r\n\t    *                                     ,         .\r\n\t    */\n\t    function sendCrossDomainPostRequest(url, params, callback, baseForm) {\n\t        var form,\n\t            id = '$$iframe_' + gmxAPIutils.newId();\n\t\n\t        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\n\t            originalFormAction;\n\t\n\t        if (baseForm) {\n\t            form = baseForm;\n\t            originalFormAction = form.getAttribute('action');\n\t            form.setAttribute('action', url);\n\t            form.target = id;\n\t        } else if (L.Browser.ielt9) {\n\t            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\n\t            form = document.createElement(str);\n\t        } else {\n\t            form = document.createElement('form');\n\t            form.style.display = 'none';\n\t            form.setAttribute('enctype', 'multipart/form-data');\n\t            form.target = id;\n\t            form.setAttribute('method', 'POST');\n\t            form.setAttribute('action', url);\n\t            form.id = id;\n\t        }\n\t\n\t        var hiddenParamsDiv = document.createElement('div');\n\t        hiddenParamsDiv.style.display = 'none';\n\t\n\t        if (params.WrapStyle === 'window') {\n\t            params.WrapStyle = 'message';\n\t        }\n\t\n\t        if (params.WrapStyle === 'message') {\n\t            params.CallbackName = iframe.callbackName;\n\t        }\n\t\n\t        for (var paramName in params) {\n\t            var input = document.createElement('input');\n\t            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\n\t            input.setAttribute('type', 'hidden');\n\t            input.setAttribute('name', paramName);\n\t            input.setAttribute('value', value);\n\t            hiddenParamsDiv.appendChild(input);\n\t        }\n\t\n\t        form.appendChild(hiddenParamsDiv);\n\t\n\t        if (!baseForm) {\n\t            document.body.appendChild(form);\n\t        }\n\t        document.body.appendChild(iframe);\n\t\n\t        form.submit();\n\t\n\t        if (baseForm) {\n\t            form.removeChild(hiddenParamsDiv);\n\t            if (originalFormAction !== null) {\n\t                form.setAttribute('action', originalFormAction);\n\t            } else {\n\t                form.removeAttribute('action');\n\t            }\n\t        } else {\n\t            form.parentNode.removeChild(form);\n\t        }\n\t    }\n\t    // namespace\n\t    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\n\t})();\n\texports.gmxAPIutils = gmxAPIutils;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\n\t    styleCanvasKeysLen = styleCanvasKeys.length;\n\t\n\tvar setCanvasStyle = function setCanvasStyle(prop, indexes, ctx, style) {\n\t    for (var i = 0; i < styleCanvasKeysLen; i++) {\n\t        var key = styleCanvasKeys[i],\n\t            valKey = style[key];\n\t        if (valKey !== ctx[key]) {\n\t            ctx[key] = valKey;\n\t        }\n\t    }\n\t    if (style.dashArray) {\n\t        var dashes = style.dashArray,\n\t            dashOffset = style.dashOffset || 0;\n\t        if ('setLineDash' in ctx) {\n\t            ctx.setLineDash(dashes);\n\t            if (ctx.lineDashOffset !== dashOffset) {\n\t                ctx.lineDashOffset = dashOffset;\n\t            }\n\t        }\n\t    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\n\t        ctx.setLineDash([]);\n\t    }\n\t    if (ctx.lineCap !== 'round') {\n\t        ctx.lineCap = 'round';\n\t    }\n\t    if (ctx.lineJoin !== 'round') {\n\t        ctx.lineJoin = 'round';\n\t    }\n\t\n\t    if (style.canvasPattern) {\n\t        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\n\t    } else if (style.fillLinearGradient) {\n\t        var rgr = style.fillLinearGradient,\n\t            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\n\t            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\n\t        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\n\t            var arr1 = rgr.addColorStop[j],\n\t                arrFunc = rgr.addColorStopFunctions[j],\n\t                p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0],\n\t                p2 = arr1.length < 3 ? 100 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2],\n\t                p1 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\n\t            lineargrad.addColorStop(p0, p1);\n\t        }\n\t        ctx.fillStyle = style.fillStyle = lineargrad;\n\t    }\n\t};\n\t\n\t/*\r\n\tgeoItem\r\n\t     properties:  (   )\r\n\t     dataOption:   \r\n\titem\r\n\t     skipRasters:  \r\n\t     currentStyle:  canvas  \r\n\t     parsedStyleKeys:   \r\n\toptions\r\n\t     ctx: canvas context\r\n\t     tbounds: tile bounds\r\n\t     tpx: X  \r\n\t     tpy: Y  \r\n\t     gmx:   layer._gmx\r\n\t        gmx.currentZoom\r\n\t        gmx.lastHover\r\n\t        gmx.tileAttributeIndexes\r\n\t     bgImage:   background\r\n\t     rasters:     background\r\n\tcurrentStyle\r\n\t     \r\n\tstyle\r\n\t       \r\n\t    style.image -  type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n\t*/\n\tL.gmxUtil.drawGeoItem = function (geoItem, item, options, currentStyle, style) {\n\t    var propsArr = geoItem.properties,\n\t        idr = propsArr[0],\n\t        i,\n\t        len,\n\t        j,\n\t        len1,\n\t        gmx = options.gmx,\n\t        ctx = options.ctx,\n\t        geom = propsArr[propsArr.length - 1],\n\t        coords = null,\n\t        dataOption = geoItem.dataOption,\n\t        rasters = options.rasters || {},\n\t        tbounds = options.tbounds;\n\t\n\t    item.currentStyle = L.extend({}, currentStyle);\n\t    if (style) {\n\t        if (gmx.styleHook) {\n\t            if (!geoItem.styleExtend) {\n\t                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\n\t            }\n\t            if (geoItem.styleExtend) {\n\t                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\n\t            } else {\n\t                return false;\n\t            }\n\t        }\n\t        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\n\t    } else {\n\t        style = {};\n\t    }\n\t\n\t    var geoType = geom.type,\n\t        dattr = {\n\t        gmx: gmx,\n\t        item: item,\n\t        style: style,\n\t        styleExtend: geoItem.styleExtend || {},\n\t        ctx: ctx,\n\t        tpx: options.tpx,\n\t        tpy: options.tpy\n\t    };\n\t    if (geoType === 'POINT') {\n\t        dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, geom.coordinates);\n\t        if (!dattr.pointAttr) {\n\t            return false;\n\t        } // point not in canvas tile\n\t    }\n\t    if (geoType === 'POINT' || geoType === 'MULTIPOINT') {\n\t        //   \n\t        coords = geom.coordinates;\n\t        if ('iconColor' in style && style.image) {\n\t            if (style.lastImage !== style.image) {\n\t                style.lastImage = style.image;\n\t                style.lastImageData = _Utils.gmxAPIutils.getImageData(style.image);\n\t            }\n\t            dattr.imageData = style.lastImageData;\n\t        }\n\t\n\t        if (geoType === 'MULTIPOINT') {\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                dattr.coords = coords[i];\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            dattr.coords = coords;\n\t            _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t        }\n\t    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\n\t        if (style.image) {\n\t            // set MULTIPOLYGON as marker\n\t            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\n\t            dattr.pointAttr = _Utils.gmxAPIutils.getPixelPoint(dattr, dattr.coords);\n\t            if (dattr.pointAttr) {\n\t                _Utils.gmxAPIutils.pointToCanvas(dattr);\n\t            }\n\t        } else {\n\t            coords = geom.coordinates;\n\t            if (geoType === 'POLYGON') {\n\t                coords = [coords];\n\t            }\n\t\n\t            var hiddenLines = dataOption.hiddenLines || [],\n\t                pixelsMap = dataOption.pixels,\n\t                flagPixels = true;\n\t\n\t            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\n\t                pixelsMap = dataOption.pixels = _Utils.gmxAPIutils.getCoordsPixels({\n\t                    gmx: gmx,\n\t                    coords: coords,\n\t                    tpx: options.tpx,\n\t                    tpy: options.tpy,\n\t                    hiddenLines: hiddenLines\n\t                });\n\t            }\n\t\n\t            var coordsToCanvas = function coordsToCanvas(func, flagFill) {\n\t                coords = pixelsMap.coords;\n\t                hiddenLines = pixelsMap.hidden || [];\n\t                dattr.flagPixels = flagPixels;\n\t                for (i = 0, len = coords.length; i < len; i++) {\n\t                    var coords1 = coords[i];\n\t                    var hiddenLines1 = hiddenLines[i] || [];\n\t                    ctx.beginPath();\n\t                    for (j = 0, len1 = coords1.length; j < len1; j++) {\n\t                        dattr.coords = coords1[j];\n\t                        dattr.hiddenLines = hiddenLines1[j] || [];\n\t                        func(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    if (flagFill) {\n\t                        ctx.fill();\n\t                    }\n\t                }\n\t            };\n\t            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\n\t                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\n\t            if (strokeStyle && lineWidth) {\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvas);\n\t            }\n\t            if (options.bgImage) {\n\t                dattr.bgImage = options.bgImage;\n\t            } else if (rasters[idr]) {\n\t                dattr.bgImage = rasters[idr];\n\t            }\n\t            if (dattr.styleExtend.skipRasters || item.skipRasters) {\n\t                delete dattr.bgImage;\n\t            }\n\t            if (style.imagePattern) {\n\t                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\n\t            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                if (_Utils.gmxAPIutils.isPatternNode(dattr.bgImage)) {\n\t                    if ('rasterOpacity' in gmx) {\n\t                        ctx.globalAlpha = gmx.rasterOpacity;\n\t                    }\n\t                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\n\t                    style.bgImage = true;\n\t                }\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t                ctx.globalAlpha = 1;\n\t            }\n\t            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\n\t                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\n\t                coordsToCanvas(_Utils.gmxAPIutils.polygonToCanvasFill, true);\n\t            }\n\t        }\n\t    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\n\t        coords = geom.coordinates;\n\t        if (geoType === 'LINESTRING') {\n\t            coords = [coords];\n\t        }\n\t        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\n\t        for (i = 0, len = coords.length; i < len; i++) {\n\t            var arr = tbounds.clipPolyLine(coords[i], true, size);\n\t            for (j = 0, len1 = arr.length; j < len1; j++) {\n\t                dattr.coords = arr[j];\n\t                var pixels = _Utils.gmxAPIutils.lineToCanvas(dattr);\n\t                if (pixels) {\n\t                    ctx.save();\n\t                    _Utils.gmxAPIutils.lineToCanvasAsIcon(pixels, dattr);\n\t                    ctx.restore();\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return true;\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n\t*/\n\tvar gmxSessionManager = {\n\t    APIKEY_PARAM: 'key',\n\t    SCRIPT_REGEXP: [/\\bleaflet-geomixer(-\\w*)?\\.js\\b/, /\\bgeomixer(-\\w*)?\\.js\\b/],\n\t    _scriptSearched: false,\n\t    _scriptAPIKey: null,\n\t    _searchScriptAPIKey: function _searchScriptAPIKey() {\n\t        var _this = this;\n\t        if (this._scriptSearched) {\n\t            return this._scriptAPIKey;\n\t        }\n\t\n\t        var scripts = document.getElementsByTagName('script');\n\t        for (var i = 0; i < scripts.length; i++) {\n\t            var src = scripts[i].getAttribute('src'),\n\t                arr = this.SCRIPT_REGEXP;\n\t            for (var j = 0, len = arr.length; j < len; j++) {\n\t                if (arr[j].exec(src)) {\n\t                    var query = src.split('?')[1];\n\t\n\t                    if (query) {\n\t                        var params = query.split('&');\n\t                        for (var p = 0; p < params.length; p++) {\n\t                            var parsedParam = params[p].split('=');\n\t                            if (parsedParam[0] === _this.APIKEY_PARAM) {\n\t                                _this._scriptAPIKey = parsedParam[1];\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t            if (_this._scriptAPIKey) {\n\t                break;\n\t            }\n\t        }\n\t        this._scriptSearched = true;\n\t        return this._scriptAPIKey;\n\t    },\n\t\n\t    //we will search apiKey in script tags iff apiKey parameter is undefined.\n\t    //if it is defined as falsy (null, '', etc), we won't send any requests to server\n\t    requestSessionKey: function requestSessionKey(serverHost, apiKey) {\n\t        var keys = this._sessionKeys;\n\t\n\t        if (!(serverHost in keys)) {\n\t            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\n\t            keys[serverHost] = new L.gmx.Deferred();\n\t            if (apiKey) {\n\t                gmxAPIutils.requestJSONP('http://' + serverHost + '/ApiKey.ashx', {\n\t                    WrapStyle: 'func',\n\t                    Key: apiKey\n\t                }).then(function (response) {\n\t                    if (response && response.Status === 'ok') {\n\t                        keys[serverHost].resolve(response.Result.Key);\n\t                    } else {\n\t                        keys[serverHost].reject();\n\t                    }\n\t                }, keys[serverHost].reject);\n\t            } else {\n\t                keys[serverHost].resolve('');\n\t            }\n\t        }\n\t        return keys[serverHost];\n\t    },\n\t\n\t    //get already received session key\n\t    getSessionKey: function getSessionKey(serverHost) {\n\t        var keyPromise = this._sessionKeys[serverHost];\n\t\n\t        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\n\t    },\n\t    _sessionKeys: {} //deferred for each host\n\t};\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxSessionManager = gmxSessionManager;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxMapManager = {\n\t    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\n\t    getMap: function getMap(serverHost, apiKey, mapName, skipTiles) {\n\t        var maps = this._maps;\n\t        if (!maps[serverHost] || !maps[serverHost][mapName]) {\n\t            var def = new L.gmx.Deferred();\n\t            maps[serverHost] = maps[serverHost] || {};\n\t            maps[serverHost][mapName] = { promise: def };\n\t\n\t            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function (sessionKey) {\n\t                _Utils.gmxAPIutils.requestJSONP('http://' + serverHost + '/TileSender.ashx', {\n\t                    WrapStyle: 'func',\n\t                    skipTiles: skipTiles || 'None', // All, NotVisible, None\n\t                    key: sessionKey,\n\t                    MapName: mapName,\n\t                    ModeKey: 'map'\n\t                }).then(function (json) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        json.Result.properties.hostName = serverHost;\n\t                        def.resolve(json.Result);\n\t                    } else {\n\t                        def.reject(json);\n\t                    }\n\t                }, def.reject);\n\t            }, def.reject);\n\t        }\n\t        return maps[serverHost][mapName].promise;\n\t    },\n\t\n\t    syncParams: {},\n\t    //      \n\t    setSyncParams: function setSyncParams(hash) {\n\t        this.syncParams = hash;\n\t    },\n\t    getSyncParams: function getSyncParams(stringFlag) {\n\t        var res = this.syncParams;\n\t        if (stringFlag) {\n\t            var arr = [];\n\t            for (var key in res) {\n\t                arr.push(key + '=' + res[key]);\n\t            }\n\t            res = arr.join('&');\n\t        }\n\t        return res;\n\t    },\n\t\n\t    //we will (lazy) create index by layer name to speed up multiple function calls\n\t    findLayerInfo: function findLayerInfo(serverHost, mapID, layerID) {\n\t        var hostMaps = this._maps[serverHost],\n\t            mapInfo = hostMaps && hostMaps[mapID];\n\t\n\t        if (!mapInfo) {\n\t            return null;\n\t        }\n\t\n\t        if (mapInfo.layers) {\n\t            return mapInfo.layers[layerID];\n\t        }\n\t\n\t        var serverData = mapInfo.promise.getFulfilledData();\n\t\n\t        if (!serverData) {\n\t            return null;\n\t        }\n\t\n\t        mapInfo.layers = {};\n\t\n\t        //create index by layer name\n\t        gmxMapManager.iterateLayers(serverData[0], function (layerInfo) {\n\t            mapInfo.layers[layerInfo.properties.name] = layerInfo;\n\t        });\n\t\n\t        return mapInfo.layers[layerID];\n\t    },\n\t    iterateLayers: function iterateLayers(treeInfo, callback) {\n\t        var iterate = function iterate(arr) {\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var layer = arr[i];\n\t\n\t                if (layer.type === 'group') {\n\t                    iterate(layer.content.children);\n\t                } else if (layer.type === 'layer') {\n\t                    callback(layer.content);\n\t                }\n\t            }\n\t        };\n\t\n\t        treeInfo && iterate(treeInfo.children);\n\t    },\n\t    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\n\t}; /** Asynchronously request information about map given server host and map name\r\n\t   */\n\t\n\t\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxMapManager = gmxMapManager;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//Helper class, that represents layers of single Geomixer's map\n\t//Creates layers from given map description\n\tvar gmxMap = L.Class.extend({\n\t\tincludes: L.Mixin.Events,\n\t\n\t\tinitialize: function initialize(mapInfo, commonLayerOptions) {\n\t\t\tthis.layers = [];\n\t\t\tthis.layersByTitle = {};\n\t\t\tthis.layersByID = {};\n\t\t\tthis.dataManagers = {};\n\t\n\t\t\tvar _this = this;\n\t\n\t\t\tthis.properties = L.extend({}, mapInfo.properties);\n\t\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\n\t\t\tthis.rawTree = mapInfo;\n\t\n\t\t\tthis.layersCreated = new L.gmx.Deferred();\n\t\n\t\t\tvar missingLayerTypes = {},\n\t\t\t    dataSources = {};\n\t\n\t\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function (layerInfo) {\n\t\t\t\tvar props = layerInfo.properties,\n\t\t\t\t    meta = props.MetaProperties || {},\n\t\t\t\t    options = {\n\t\t\t\t\tmapID: mapInfo.properties.name,\n\t\t\t\t\tlayerID: props.name\n\t\t\t\t};\n\t\n\t\t\t\tprops.hostName = mapInfo.properties.hostName;\n\t\n\t\t\t\tvar type = props.ContentID || props.type,\n\t\t\t\t    layerOptions = L.extend(options, commonLayerOptions);\n\t\n\t\t\t\tif (props.dataSource || 'parentLayer' in meta) {\n\t\t\t\t\t// Set dataSource layer\n\t\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\n\t\t\t\t\tif ('parentLayer' in meta) {\n\t\t\t\t\t\t// todo     \n\t\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\n\t\t\t\t\t}\n\t\t\t\t\tdataSources[options.layerID] = {\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t};\n\t\t\t\t} else if (type in L.gmx._layerClasses) {\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\n\t\t\t\t} else {\n\t\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\n\t\t\t\t\tmissingLayerTypes[type].push({\n\t\t\t\t\t\tinfo: layerInfo,\n\t\t\t\t\t\toptions: layerOptions\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t//load missing layer types\n\t\t\tvar loaders = [];\n\t\t\tfor (var type in missingLayerTypes) {\n\t\t\t\tloaders.push(L.gmx._loadLayerClass(type).then( /*eslint-disable no-loop-func */function (type) {\n\t\t\t\t\t/*eslint-enable */\n\t\t\t\t\tvar it = missingLayerTypes[type];\n\t\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\n\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\n\t\t\t\t\t}\n\t\t\t\t}.bind(null, type)));\n\t\t\t}\n\t\t\tvar hosts = {},\n\t\t\t    host,\n\t\t\t    id,\n\t\t\t    it;\n\t\t\tfor (id in dataSources) {\n\t\t\t\tit = dataSources[id];\n\t\t\t\tvar opt = it.options,\n\t\t\t\t    pId = opt.parentLayer,\n\t\t\t\t    pLayer = this.layersByID[pId];\n\t\t\t\tif (pLayer) {\n\t\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\n\t\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);\n\t\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\n\t\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\n\t\t\t\t} else {\n\t\t\t\t\thost = opt.hostName;\n\t\t\t\t\tif (!hosts[host]) {\n\t\t\t\t\t\thosts[host] = {};\n\t\t\t\t\t}\n\t\t\t\t\tif (!hosts[host][pId]) {\n\t\t\t\t\t\thosts[host][pId] = [];\n\t\t\t\t\t}\n\t\t\t\t\thosts[host][pId].push(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (host in hosts) {\n\t\t\t\tvar arr = [],\n\t\t\t\t    prefix = 'http://' + host;\n\t\t\t\tfor (id in hosts[host]) {\n\t\t\t\t\tarr.push({ Layer: id });\n\t\t\t\t}\n\t\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx', {\n\t\t\t\t\tWrapStyle: 'func',\n\t\t\t\t\tLayers: JSON.stringify(arr)\n\t\t\t\t}, {\n\t\t\t\t\tids: hosts[host]\n\t\t\t\t}).then(function (json, opt) {\n\t\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\n\t\t\t\t\t\tjson.Result.forEach(function (it) {\n\t\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\n\t\t\t\t\t\t\t    props = it.properties,\n\t\t\t\t\t\t\t    pId = props.name;\n\t\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\tvar pt = dataSources[id];\n\t\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\n\t\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\n\t\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\n\t\t\t\t\t\tif (opt && opt.ids) {\n\t\t\t\t\t\t\tfor (var pId in opt.ids) {\n\t\t\t\t\t\t\t\topt.ids[pId].forEach(function (id) {\n\t\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\n\t\t},\n\t\n\t\taddDataManager: function addDataManager(it) {\n\t\t\tvar pid = it.properties.name;\n\t\t\tif (!this.dataManagers[pid]) {\n\t\t\t\tthis.dataManagers[pid] = new DataManager(it.properties);\n\t\t\t}\n\t\t\treturn this.dataManagers[pid];\n\t\t},\n\t\tgetDataManager: function getDataManager(id) {\n\t\t\treturn this.dataManagers[id];\n\t\t},\n\t\n\t\taddLayer: function addLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tthis.layers.push(layer);\n\t\t\tthis.layersByTitle[props.title] = layer;\n\t\t\tthis.layersByID[props.name] = layer;\n\t\t\tthis.fire('layeradd', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\tremoveLayer: function removeLayer(layer) {\n\t\t\tvar props = layer.getGmxProperties();\n\t\n\t\t\tfor (var i = 0; i < this.layers.length; i++) {\n\t\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\n\t\t\t\t\tthis.layers.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tdelete this.layersByTitle[props.title];\n\t\t\tdelete this.layersByID[props.name];\n\t\t\tthis.fire('layerremove', { layer: layer });\n\t\n\t\t\treturn this;\n\t\t},\n\t\n\t\taddLayersToMap: function addLayersToMap(leafletMap) {\n\t\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\n\t\t\t\tvar layer = this.layers[l];\n\t\t\t\tif (layer.getGmxProperties().visible) {\n\t\t\t\t\tleafletMap.addLayer(layer);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t});\n\tL.gmx = L.gmx || {};\n\tL.gmx.gmxMap = gmxMap;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * gmxEventsManager - handlers manager\r\n\t */\n\tvar GmxEventsManager = L.Handler.extend({\n\t    options: {},\n\t\n\t    initialize: function initialize(map) {\n\t        this._map = map;\n\t        this._layers = {};\n\t        this._lastLayer = null;\n\t        this._lastId = null;\n\t        var _this = this;\n\t        this._drawstart = null;\n\t        this._lastCursor = '';\n\t\n\t        var isDrawing = function isDrawing() {\n\t            if (_this._drawstart) {\n\t                return true;\n\t            } else if (_this._drawstart === null) {\n\t                if (map.gmxControlsManager) {\n\t                    var drawingControl = map.gmxControlsManager.get('drawing');\n\t                    if (drawingControl) {\n\t                        drawingControl.on('activechange', function (ev) {\n\t                            _this._drawstart = ev.activeIcon;\n\t                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\n\t                        });\n\t                    }\n\t                }\n\t                _this._drawstart = false;\n\t            }\n\t            return false;\n\t        };\n\t\n\t        var getDomIndex = function getDomIndex(layer) {\n\t            var container = layer._container;\n\t            if (container) {\n\t                var arr = container.parentNode.childNodes;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    if (container === arr[i]) {\n\t                        return i;\n\t                    }\n\t                }\n\t            }\n\t            return 0;\n\t        };\n\t\n\t        var skipNodeName = {\n\t            IMG: true,\n\t            DIV: true,\n\t            path: true\n\t        };\n\t\n\t        var clearLastHover = function clearLastHover() {\n\t            if (_this._lastLayer) {\n\t                _this._lastLayer.gmxEventCheck({ type: 'mousemove' }, true);\n\t                _this._lastLayer = null;\n\t            }\n\t        };\n\t\n\t        var eventCheck = function eventCheck(ev) {\n\t            var type = ev.type,\n\t                map = _this._map,\n\t                skipNode = false;\n\t            if (ev.originalEvent) {\n\t                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\n\t                var target = ev.originalEvent.target;\n\t                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\n\t            }\n\t            if (map._animatingZoom || isDrawing() || skipNode || type === 'click' && map._skipClick || // from drawing\n\t            type === 'mousemove' && map.gmxMouseDown) {\n\t                clearLastHover();\n\t                map._skipClick = false;\n\t                return;\n\t            }\n\t            if (ev.layerPoint) {\n\t                map._gmxMouseLatLng = ev.latlng;\n\t                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\n\t            }\n\t\n\t            var arr = Object.keys(_this._layers).sort(function (a, b) {\n\t                var la = map._layers[a],\n\t                    lb = map._layers[b];\n\t                if (la && lb) {\n\t                    var oa = la.options,\n\t                        ob = lb.options,\n\t                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\n\t                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\n\t                        delta = zb - za;\n\t                    return delta ? delta : _this._layers[b] - _this._layers[a];\n\t                }\n\t                return 0;\n\t            });\n\t\n\t            var layer,\n\t                foundLayer = null,\n\t                cursor = '';\n\t\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var id = arr[i];\n\t                layer = map._layers[id];\n\t                if (layer && layer._map && !layer._animating && layer.options.clickable) {\n\t                    if (layer.gmxEventCheck(ev)) {\n\t                        if (layer.hasEventListeners('mouseover')) {\n\t                            cursor = 'pointer';\n\t                        }\n\t                        foundLayer = layer;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            if (_this._lastCursor !== cursor && !isDrawing()) {\n\t                map._container.style.cursor = cursor;\n\t            }\n\t            _this._lastCursor = cursor;\n\t\n\t            if (type !== 'zoomend') {\n\t                if (foundLayer) {\n\t                    if (_this._lastLayer !== foundLayer) {\n\t                        clearLastHover();\n\t                    }\n\t                    _this._lastLayer = foundLayer;\n\t                } else {\n\t                    clearLastHover();\n\t                }\n\t            }\n\t        };\n\t\n\t        map.on({\n\t            zoomend: function zoomend() {\n\t                if (map._gmxMouseLatLng) {\n\t                    setTimeout(function () {\n\t                        eventCheck({ type: 'mousemove', latlng: map._gmxMouseLatLng });\n\t                    }, 0);\n\t                }\n\t            },\n\t            click: eventCheck,\n\t            dblclick: eventCheck,\n\t            mousedown: eventCheck,\n\t            mouseup: eventCheck,\n\t            mousemove: eventCheck,\n\t            contextmenu: eventCheck,\n\t            layeradd: function layeradd(ev) {\n\t                var layer = ev.layer;\n\t                if ('gmxEventCheck' in layer && layer.options.clickable) {\n\t                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\n\t                }\n\t            },\n\t            layerremove: function layerremove(ev) {\n\t                var id = ev.layer._leaflet_id;\n\t                delete _this._layers[id];\n\t                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\n\t                    _this._lastLayer = null;\n\t                    _this._lastId = 0;\n\t                }\n\t            }\n\t        }, this);\n\t    }\n\t});\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if handler has already been initialized.\n\t    if (!this._gmxEventsManager) {\n\t        this._gmxEventsManager = new GmxEventsManager(this);\n\t        this.isGmxDrawing = function () {\n\t            return this._gmxEventsManager._drawstart;\n\t        };\n\t\n\t        this.on('remove', function () {\n\t            if (this._gmxEventsManager) {\n\t                this._gmxEventsManager.removeHooks();\n\t            }\n\t        });\n\t    }\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var DEFAULT_LANGUAGE = 'rus',\n\t        _setKeyText = function _setKeyText(lang, key, item, hash) {\n\t        if (!hash[lang]) {\n\t            hash[lang] = {};\n\t        }\n\t        hash[lang][key] = item;\n\t    };\n\t    L.gmxLocale = {\n\t\n\t        setLanguage: function setLanguage(lang) {\n\t            this._language = lang;\n\t        },\n\t\n\t        getLanguage: function getLanguage() {\n\t            return window.language || this._language || DEFAULT_LANGUAGE;\n\t        }\n\t    };\n\t\n\t    L.gmxLocaleMixin = {\n\t        addText: function addText() {\n\t            var lang = arguments[0],\n\t                newHash = arguments[1];\n\t            if (arguments.length === 1) {\n\t                newHash = lang;\n\t                lang = null;\n\t            }\n\t            for (var k in newHash) {\n\t                if (lang === null) {\n\t                    for (var k1 in newHash[k]) {\n\t                        _setKeyText(k, k1, newHash[k][k1], this);\n\t                    }\n\t                } else {\n\t                    _setKeyText(lang, k, newHash[k], this);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getText: function getText(key) {\n\t            var lang = L.gmxLocale.getLanguage(),\n\t                locale = this[lang] || {};\n\t\n\t            var keyArr = key ? key.split(/\\./) : [];\n\t            for (var i = 0, len = keyArr.length; i < len; i++) {\n\t                if (!locale) {\n\t                    break;\n\t                }\n\t                locale = locale[keyArr[i]];\n\t            }\n\t            return locale;\n\t        }\n\t    };\n\t    L.extend(L.gmxLocale, L.gmxLocaleMixin);\n\t})();\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    rus: {\n\t        Coordinates: '',\n\t        Length: '',\n\t        nodeLength: '  ',\n\t        edgeLength: ' ',\n\t        Area: '',\n\t        Perimeter: '',\n\t        units: {\n\t            m: '',\n\t            nm: '.',\n\t            km: '',\n\t            m2: '. ',\n\t            km2: '. ',\n\t            ha: '',\n\t            m2html: '<sup>2',\n\t            km2html: '<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.extend(L.gmxLocale, {\n\t    eng: {\n\t        Coordinates: 'Coordinates',\n\t        Length: 'Length',\n\t        nodeLength: 'From start point',\n\t        edgeLength: 'Segment length',\n\t        Area: 'Area',\n\t        Perimeter: 'Perimeter',\n\t        units: {\n\t            m: 'm',\n\t            nm: 'nmi',\n\t            km: 'km',\n\t            m2: 'sq. m',\n\t            km2: 'sq. km',\n\t            ha: 'ha',\n\t            m2html: 'm<sup>2',\n\t            km2html: 'km<sup>2'\n\t        }\n\t    }\n\t});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.gmxVectorTileLoader = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar gmxVectorTileLoader = {\n\t    _loadedTiles: {},\n\t    _getKey: function _getKey(ti) {\n\t        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\n\t    },\n\t    load: function load(tileSenderPrefix, tileInfo) {\n\t        var key = gmxVectorTileLoader._getKey(tileInfo);\n\t\n\t        if (!this._loadedTiles[key]) {\n\t            var def = new L.gmx.Deferred();\n\t            this._loadedTiles[key] = def;\n\t\n\t            var requestParams = {\n\t                ModeKey: 'tile',\n\t                r: 'j',\n\t                LayerName: tileInfo.layerID,\n\t                z: tileInfo.z,\n\t                x: tileInfo.x,\n\t                y: tileInfo.y,\n\t                v: tileInfo.v\n\t            };\n\t\n\t            if (tileInfo.d !== -1) {\n\t                requestParams.Level = tileInfo.d;\n\t                requestParams.Span = tileInfo.s;\n\t            }\n\t\n\t            _Utils.gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, { callbackParamName: null }).then(null, function () {\n\t                def.reject();\n\t            });\n\t        }\n\t\n\t        return this._loadedTiles[key];\n\t    }\n\t};\n\t\n\twindow.gmxAPI = window.gmxAPI || {};\n\twindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function (data) {\n\t    var key = gmxVectorTileLoader._getKey({\n\t        layerID: data.LayerName,\n\t        x: data.x,\n\t        y: data.y,\n\t        z: data.z,\n\t        d: data.level,\n\t        s: data.span,\n\t        v: data.v\n\t    });\n\t\n\t    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\n\t};\n\texports.gmxVectorTileLoader = gmxVectorTileLoader;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.VectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t//Single vector tile, received from GeoMixer server\n\t//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\n\t//      - {Object[]} data - information about vector objects in tile\n\t//      - {Number[4]} [bbox] - optional bbox of objects in tile\n\t//  options:\n\t//      x, y, z, v, s, d: GeoMixer vector tile point\n\t//      dateZero: zero Date for temporal layers\n\t//      isGeneralized: flag for generalized tile\n\tvar VectorTile = function VectorTile(dataProvider, options) {\n\t    this.dataProvider = dataProvider;\n\t    this.loadDef = new L.gmx.Deferred();\n\t    this.data = null;\n\t    this.dataOptions = null;\n\t\n\t    this.x = options.x;\n\t    this.y = options.y;\n\t    this.z = options.z;\n\t    this.v = options.v;\n\t    this.s = options.s || -1;\n\t    this.d = options.d || -1;\n\t    this.isGeneralized = options.isGeneralized;\n\t    this.isFlatten = options.isFlatten;\n\t    this.bounds = _Utils.gmxAPIutils.getTileBounds(this.x, this.y, this.z);\n\t    this.gmxTilePoint = { x: this.x, y: this.y, z: this.z, s: this.s, d: this.d };\n\t    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\n\t\n\t    if (this.s >= 0 && options.dateZero) {\n\t        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * _Utils.gmxAPIutils.oneDay * 1000);\n\t    }\n\t\n\t    this.state = 'notLoaded'; //notLoaded, loading, loaded\n\t};\n\t\n\tVectorTile.prototype = {\n\t    addData: function addData(data, keys) {\n\t\n\t        if (keys) {\n\t            this.removeData(keys, true);\n\t        }\n\t\n\t        var len = data.length,\n\t            dataOptions = new Array(len),\n\t            dataBounds = _Utils.gmxAPIutils.bounds();\n\t        for (var i = 0; i < len; i++) {\n\t            var dataOption = this._parseItem(data[i]);\n\t            dataOptions[i] = dataOption;\n\t            dataBounds.extendBounds(dataOption.bounds);\n\t        }\n\t\n\t        if (!this.data) {\n\t            this.data = data;\n\t            this.dataOptions = dataOptions;\n\t        } else {\n\t            this.data = this.data.concat(data);\n\t            this.dataOptions = this.dataOptions.concat(dataOptions);\n\t        }\n\t\n\t        this.state = 'loaded';\n\t\n\t        this.loadDef.resolve(this.data);\n\t        return dataBounds;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\n\t            if (keys[arr[i][0]]) {\n\t                arr.splice(i, 1);\n\t                if (this.dataOptions) {\n\t                    this.dataOptions.splice(i, 1);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    load: function load() {\n\t        if (this.state === 'notLoaded') {\n\t            this.state = 'loading';\n\t            var _this = this;\n\t            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function (data, bbox) {\n\t                _this.bbox = bbox;\n\t                _this.addData(data);\n\t            });\n\t        }\n\t\n\t        return this.loadDef;\n\t    },\n\t\n\t    clear: function clear() {\n\t        this.state = 'notLoaded';\n\t        this.data = null;\n\t        this.dataOptions = null;\n\t\n\t        this.loadDef = new L.gmx.Deferred();\n\t    },\n\t\n\t    _parseItem: function _parseItem(it) {\n\t        var len = it.length,\n\t            i;\n\t\n\t        // TODO: old properties null = ''\n\t        for (i = 0; i < len; i++) {\n\t            if (it[i] === null) {\n\t                it[i] = '';\n\t            }\n\t        }\n\t\n\t        var geo = it[len - 1],\n\t            needFlatten = this.isFlatten,\n\t            type = geo.type,\n\t            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\n\t            isPolygon = type === 'POLYGON' || type === 'Polygon',\n\t            coords = geo.coordinates,\n\t            hiddenLines = [],\n\t            bounds = null,\n\t            boundsArr = [];\n\t\n\t        if (isLikePolygon) {\n\t            if (isPolygon) {\n\t                coords = [coords];\n\t            }\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            var edgeBounds = _Utils.gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\n\t                hiddenFlag = false;\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                var arr = [],\n\t                    hiddenLines1 = [];\n\t\n\t                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\n\t                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\n\t                        coords[i][j] = _Utils.gmxAPIutils.flattenRing(coords[i][j]);\n\t                    }\n\t                    var b = _Utils.gmxAPIutils.bounds(coords[i][j]);\n\t                    arr.push(b);\n\t                    if (j === 0) {\n\t                        bounds.extendBounds(b);\n\t                    }\n\t                    // EdgeLines calc\n\t                    var edgeArr = _Utils.gmxAPIutils.getHidden(coords[i][j], edgeBounds);\n\t                    hiddenLines1.push(edgeArr);\n\t                    if (edgeArr.length) {\n\t                        hiddenFlag = true;\n\t                    }\n\t                }\n\t                boundsArr.push(arr);\n\t                hiddenLines.push(hiddenLines1);\n\t            }\n\t            if (!hiddenFlag) {\n\t                hiddenLines = null;\n\t            }\n\t            if (isPolygon) {\n\t                boundsArr = boundsArr[0];\n\t            }\n\t        } else if (type === 'POINT' || type === 'Point') {\n\t            bounds = _Utils.gmxAPIutils.bounds([coords]);\n\t        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds([coords[i]]));\n\t            }\n\t        } else if (type === 'LINESTRING' || type === 'LineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds(coords);\n\t        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\n\t            bounds = _Utils.gmxAPIutils.bounds();\n\t            for (i = 0, len = coords.length; i < len; i++) {\n\t                bounds.extendBounds(_Utils.gmxAPIutils.bounds(coords[i]));\n\t            }\n\t        }\n\t        var dataOption = {\n\t            bounds: bounds,\n\t            boundsArr: boundsArr\n\t        };\n\t        if (hiddenLines) {\n\t            dataOption.hiddenLines = hiddenLines;\n\t        }\n\t        return dataOption;\n\t    }\n\t};\n\t//class methods\n\t\n\tVectorTile.makeTileKey = function (x, y, z, v, s, d) {\n\t    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\n\t};\n\t\n\tVectorTile.createTileKey = function (opt) {\n\t    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\n\t};\n\t\n\tVectorTile.parseTileKey = function (gmxTileKey) {\n\t    var p = gmxTileKey.split('_').map(function (it) {\n\t        return Number(it);\n\t    });\n\t    return { z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5] };\n\t};\n\t\n\tVectorTile.boundsFromTileKey = function (gmxTileKey) {\n\t    var p = VectorTile.parseTileKey(gmxTileKey);\n\t    return _Utils.gmxAPIutils.getTileBounds(p.x, p.y, p.z);\n\t};\n\texports.VectorTile = VectorTile;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar Observer = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    /* options : {\r\n\t            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n\t                                        // `update` - send only changed data\r\n\t            callback: Func,             // will be called when layer's data for this observer is changed\r\n\t            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n\t            bbox: bbox,                 // bbox to observe on Mercator\r\n\t            filters: [String]           // filter keys array\r\n\t            active: [Boolean=true]      // is this observer active\r\n\t            targetZoom: [Number]        // for zoom generalized type default(null)\r\n\t        }\r\n\t    */\n\t    initialize: function initialize(options) {\n\t        this.type = options.type || 'update';\n\t        this._callback = options.callback;\n\t        this._items = null;\n\t        this.bbox = options.bbox; // set bbox by Mercator bounds\n\t        this.filters = options.filters || [];\n\t        this.targetZoom = options.targetZoom || null;\n\t        this.active = 'active' in options ? options.active : true;\n\t\n\t        if (options.bounds) {\n\t            // set bbox by LatLngBounds\n\t            this.setBounds(options.bounds);\n\t        }\n\t\n\t        var w = _Utils.gmxAPIutils.worldWidthMerc,\n\t            dx;\n\t        if (!this.bbox) {\n\t            this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t            this.world = true;\n\t        } else if (this.bbox.max.x > w) {\n\t            dx = this.bbox.max.x - w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\n\t        } else if (this.bbox.min.x < -w) {\n\t            dx = this.bbox.min.x + w;\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\n\t        }\n\t\n\t        if (options.dateInterval) {\n\t            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\n\t        }\n\t    },\n\t\n\t    hasFilter: function hasFilter(filterName) {\n\t        for (var i = 0, len = this.filters.length; i < len; i++) {\n\t            if (this.filters[i] === filterName) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    activate: function activate() {\n\t        if (!this.active) {\n\t            this.active = true;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    deactivate: function deactivate() {\n\t        if (this.active) {\n\t            this.active = false;\n\t            this.fire('activate');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    toggleActive: function toggleActive(isActive) {\n\t        return isActive ? this.activate() : this.deactivate();\n\t    },\n\t\n\t    isActive: function isActive() {\n\t        return this.active;\n\t    },\n\t\n\t    updateData: function updateData(data) {\n\t        var len = data.length,\n\t            out = { count: len };\n\t\n\t        if (this.type === 'update') {\n\t            //calculate difference with previous data\n\t            if (!this._items) {\n\t                this._items = {};\n\t            }\n\t            var prevItems = this._items,\n\t                newItems = {},\n\t                added = [],\n\t                removed = [],\n\t                key;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                var it = data[i];\n\t\n\t                key = it.id + '_' + it.tileKey;\n\t\n\t                newItems[key] = it;\n\t\n\t                if (!prevItems[key]) {\n\t                    added.push(it);\n\t                }\n\t            }\n\t\n\t            for (key in prevItems) {\n\t                if (!newItems[key]) {\n\t                    removed.push(prevItems[key]);\n\t                }\n\t            }\n\t\n\t            if (added.length) {\n\t                out.added = added;\n\t            }\n\t            if (removed.length) {\n\t                out.removed = removed;\n\t            }\n\t\n\t            this._items = newItems;\n\t        } else {\n\t            out.added = data;\n\t        }\n\t        this._callback(out);\n\t        out = null;\n\t        data = null;\n\t\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(keys) {\n\t        if (this.type !== 'update' || !this._items) {\n\t            return this;\n\t        }\n\t\n\t        var items = this._items,\n\t            removed = [];\n\t\n\t        for (var id in keys) {\n\t            if (items[id]) {\n\t                removed.push(items[id]);\n\t                delete items[id];\n\t            }\n\t        }\n\t\n\t        if (removed.length) {\n\t            this._callback({ removed: removed });\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    /*setFilter: function (func) {\r\n\t        this._filters.userFilter = func;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },\r\n\t      removeFilter: function () {\r\n\t        delete this._filters.userFilter;\r\n\t        this.fire('update');\r\n\t        return this;\r\n\t    },*/\n\t\n\t    setBounds: function setBounds(bounds) {\n\t        var w;\n\t        if (!bounds) {\n\t            if (!this.world) {\n\t                w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                this.bbox = _Utils.gmxAPIutils.bounds([[-w, -w], [w, w]]);\n\t                this.bbox1 = null;\n\t                this.world = true;\n\t                this.fire('update');\n\t            }\n\t            return this;\n\t        }\n\t\n\t        var min = bounds.min,\n\t            max = bounds.max;\n\t        if (!min || !max) {\n\t            var latLngBounds = L.latLngBounds(bounds),\n\t                sw = latLngBounds.getSouthWest(),\n\t                ne = latLngBounds.getNorthEast();\n\t            min = { x: sw.lng, y: sw.lat };\n\t            max = { x: ne.lng, y: ne.lat };\n\t        }\n\t        var minX = min.x,\n\t            maxX = max.x,\n\t            minY = min.y,\n\t            maxY = max.y,\n\t            minX1 = null,\n\t            maxX1 = null;\n\t\n\t        this.world = false;\n\t        w = (maxX - minX) / 2;\n\t        if (w >= 180) {\n\t            minX = -180;maxX = 180;\n\t            this.world = true;\n\t        } else if (maxX > 180 || minX < -180) {\n\t            var center = (maxX + minX) / 2 % 360;\n\t            if (center > 180) {\n\t                center -= 360;\n\t            } else if (center < -180) {\n\t                center += 360;\n\t            }\n\t            minX = center - w;maxX = center + w;\n\t            if (minX < -180) {\n\t                minX1 = minX + 360;maxX1 = 180;minX = -180;\n\t            } else if (maxX > 180) {\n\t                minX1 = -180;maxX1 = maxX - 360;maxX = 180;\n\t            }\n\t        }\n\t        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        this.bbox1 = null;\n\t        if (minX1) {\n\t            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\n\t            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\n\t            this.bbox1 = _Utils.gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\n\t        }\n\t\n\t        this.fire('update');\n\t        return this;\n\t    },\n\t\n\t    intersects: function intersects(bounds) {\n\t        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\n\t    },\n\t\n\t    intersectsWithTile: function intersectsWithTile(tile) {\n\t        if (this.targetZoom) {\n\t            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\n\t            if (tile.isGeneralized && tile.z !== z || tile.z > z) {\n\t                return false;\n\t            }\n\t        }\n\t        var di = this.dateInterval;\n\t        return this.intersects(tile.bounds) && (!tile.beginDate || di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate);\n\t    },\n\t\n\t    _setDateInterval: function _setDateInterval(beginDate, endDate) {\n\t        if (beginDate && endDate) {\n\t            // var beginValue = beginDate.valueOf(),\n\t            // endValue = endDate.valueOf();\n\t            this.dateInterval = {\n\t                beginDate: beginDate,\n\t                endDate: endDate\n\t            };\n\t        } else {\n\t            this.dateInterval = null;\n\t        }\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var isValid = beginDate && endDate;\n\t\n\t        if (!this.dateInterval !== !isValid || isValid && (this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() || this.dateInterval.endDate.valueOf() !== endDate.valueOf())) {\n\t            this._setDateInterval(beginDate, endDate);\n\t            this.fire('update', { temporalFilter: true });\n\t        }\n\t        return this;\n\t    }\n\t}); //Single observer with vector data\n\t\n\tL.gmx.observer = function (options) {\n\t    return new Observer(options);\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    //tree for fast tiles selection inside temporal interval\n\t    //  options:\n\t    //      TemporalTiles: tilePoints array\n\t    //      TemporalVers: tiles version array\n\t    //      TemporalPeriods: periods\n\t    //      ZeroDate: start Date\n\t    var TilesTree = function TilesTree(options) {\n\t        var _rootNodes = [],\n\t            tiles = options.TemporalTiles || [],\n\t            vers = options.TemporalVers || [],\n\t            periods = options.TemporalPeriods || [],\n\t            maxPeriod = periods[periods.length - 1],\n\t            smin = Number.MAX_VALUE,\n\t            arr = options.ZeroDate.split('.'),\n\t            zn = new Date(arr.length > 2 ? arr[2] : 2008, arr.length > 1 ? arr[1] - 1 : 0, arr.length > 0 ? arr[0] : 1),\n\t            dateZero = new Date(zn.getTime() - zn.getTimezoneOffset() * 60000),\n\t            zeroUT = dateZero.getTime() / 1000;\n\t\n\t        this.dateZero = dateZero;\n\t\n\t        var addTile = function addTile(node, tile, key) {\n\t            var d = node.d;\n\t            if (tile.d === periods[d]) {\n\t                node.count++;\n\t                node.tiles.push(key);\n\t                return;\n\t            }\n\t\n\t            var pd = periods[d - 1],\n\t                childrenCount = periods[d] / pd;\n\t\n\t            if (!('children' in node)) {\n\t                node.children = new Array(childrenCount);\n\t            }\n\t\n\t            var sChild = Math.floor(tile.s * tile.d / pd),\n\t                ds = sChild - node.s * childrenCount;\n\t\n\t            if (!node.children[ds]) {\n\t                var pdOneDay = pd * gmxAPIutils.oneDay,\n\t                    t1 = sChild * pdOneDay + zeroUT;\n\t                node.children[ds] = {\n\t                    d: d - 1,\n\t                    s: sChild,\n\t                    t1: t1,\n\t                    t2: t1 + pdOneDay,\n\t                    count: 0,\n\t                    children: [],\n\t                    tiles: []\n\t                };\n\t            }\n\t\n\t            addTile(node.children[ds], tile, key);\n\t        };\n\t\n\t        var dmax = periods.length - 1,\n\t            dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\n\t            i,\n\t            len;\n\t\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var s = Number(arr[1]),\n\t                d = Number(arr[0]);\n\t\n\t            if (d === maxPeriod) {\n\t                smin = Math.min(smin, s);\n\t            }\n\t        }\n\t        for (i = 0, len = tiles.length; i < len; i++) {\n\t            arr = tiles[i];\n\t            var t = {\n\t                x: Number(arr[2]),\n\t                y: Number(arr[3]),\n\t                z: Number(arr[4]),\n\t                v: Number(vers[i]),\n\t                s: Number(arr[1]),\n\t                d: Number(arr[0])\n\t            };\n\t            if (t.d < 0) {\n\t                continue;\n\t            }\n\t\n\t            var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\n\t                cs = ds + smin;\n\t\n\t            _rootNodes[ds] = _rootNodes[ds] || {\n\t                d: dmax,\n\t                s: cs,\n\t                t1: cs * dmaxOneDay + zeroUT,\n\t                t2: (cs + 1) * dmaxOneDay + zeroUT,\n\t                count: 0,\n\t                tiles: []\n\t            };\n\t            var key = VectorTile.createTileKey(t);\n\t\n\t            addTile(_rootNodes[ds], t, key);\n\t        }\n\t        tiles = vers = null;\n\t\n\t        //options: bounds (in mercator projection)\n\t        this.selectTiles = function (t1, t2, options) {\n\t\n\t            options = options || {};\n\t\n\t            var t1Val = t1.valueOf() / 1000,\n\t                t2Val = t2.valueOf() / 1000;\n\t\n\t            // We will restrict tile levels by the nearest two levels to target date interval length\n\t            // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\n\t            var minLevel = 0,\n\t                dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\n\t\n\t            for (var i = 0; i < periods.length; i++) {\n\t                if (periods[i] > dateIntervalLength) {\n\t                    minLevel = Math.max(0, i - 1);\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (periods[periods.length - 1] <= dateIntervalLength) {\n\t                minLevel = periods.length - 1;\n\t            }\n\t\n\t            var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\n\t\n\t            var getCountOfIntersected = function getCountOfIntersected(tileBounds, bounds) {\n\t                var count = 0;\n\t                for (var t = 0; t < tileBounds.length; t++) {\n\t                    if (tileBounds[t].intersects(bounds)) {\n\t                        count++;\n\t                    }\n\t                }\n\t\n\t                return count;\n\t            };\n\t\n\t            // --------------------\n\t            var selectTilesForNode = function selectTilesForNode(node, t1, t2) {\n\t                if (t1 >= node.t2 || t2 <= node.t1) {\n\t                    return { count: 0, tiles: [], nodes: [] };\n\t                }\n\t\n\t                if (options.bounds && !node.tileBounds) {\n\t                    node.tileBounds = node.tiles.map(function (it) {\n\t                        return VectorTile.boundsFromTileKey(it);\n\t                    });\n\t                }\n\t\n\t                if (node.d === minLevel) {\n\t                    var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: count,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t\n\t                var childrenCount = 0,\n\t\n\t                //number of tiles if we use shorter intervals\n\t                childrenRes = [],\n\t                    len = node.children ? node.children.length : 0,\n\t                    ds;\n\t\n\t                for (ds = 0; ds < len; ds++) {\n\t                    if (node.children[ds]) {\n\t                        childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\n\t                    } else {\n\t                        childrenRes[ds] = { count: 0, tiles: [], nodes: [] };\n\t                    }\n\t                    childrenCount += childrenRes[ds].count;\n\t                }\n\t\n\t                var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\n\t\n\t                if (node.d > maxLevel || childrenCount < intersectCount) {\n\t                    var resTilesArr = [],\n\t                        resNodesArr = [];\n\t                    for (ds = 0; ds < childrenRes.length; ds++) {\n\t                        resNodesArr.push(childrenRes[ds].nodes);\n\t                        resTilesArr.push(childrenRes[ds].tiles);\n\t                    }\n\t\n\t                    return {\n\t                        tiles: [].concat.apply([], resTilesArr),\n\t                        count: childrenCount,\n\t                        nodes: [].concat.apply([], resNodesArr)\n\t                    };\n\t                } else {\n\t                    return {\n\t                        tiles: node.tiles,\n\t                        count: intersectCount,\n\t                        nodes: [node]\n\t                    };\n\t                }\n\t            };\n\t\n\t            var resTiles = [];\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                if (_rootNodes[ds]) {\n\t                    var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\n\t                    if (nodeSelection.tiles.length) {\n\t                        resTiles = resTiles.concat(nodeSelection.tiles);\n\t                    }\n\t                }\n\t            }\n\t\n\t            var resTilesHash = {};\n\t            for (var t = 0; t < resTiles.length; t++) {\n\t                resTilesHash[resTiles[t]] = true;\n\t            }\n\t\n\t            return { tiles: resTilesHash };\n\t        };\n\t\n\t        this.getNode = function (d, s) {\n\t            if (d < 0 || s < 0) {\n\t                return null;\n\t            }\n\t\n\t            var findNode = function findNode(node, d, s) {\n\t                if (!node) {\n\t                    return null;\n\t                }\n\t\n\t                if (periods[node.d] === d) {\n\t                    return node.s === s ? node : null;\n\t                }\n\t\n\t                var childrenCount = periods[node.d] / periods[node.d - 1];\n\t                var sChild = Math.floor(s * d / periods[node.d - 1]);\n\t                var ds = sChild - node.s * childrenCount;\n\t\n\t                return node.children[ds] ? findNode(node.children[ds], d, s) : null;\n\t            };\n\t\n\t            for (var ds = 0; ds < _rootNodes.length; ds++) {\n\t                var node = findNode(_rootNodes[ds], d, s);\n\t                if (node) {\n\t                    return node;\n\t                }\n\t            }\n\t\n\t            return null;\n\t        };\n\t    };\n\t    L.gmx.tilesTree = function (options) {\n\t        return new TilesTree(options);\n\t    };\n\t})();\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _VectorTile = __webpack_require__(14);\n\t\n\tvar _VectorTileLoader = __webpack_require__(13);\n\t\n\tvar ObserverTileLoader = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t    initialize: function initialize(dataManager) {\n\t        this._dataManager = dataManager;\n\t        this._observerData = {};\n\t        this._tileData = {};\n\t    },\n\t\n\t    addObserver: function addObserver(observer) {\n\t        this._observerData[observer.id] = {\n\t            observer: observer,\n\t            tiles: {},\n\t            leftToLoad: 0,\n\t            loadingState: false //are we loading any tiles for this observer?\n\t        };\n\t\n\t        observer.on('update', this._updateObserver.bind(this, observer));\n\t\n\t        this._updateObserver(observer);\n\t\n\t        return this;\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        var obsTiles = this._observerData[id].tiles;\n\t\n\t        for (var tileId in obsTiles) {\n\t            delete this._tileData[tileId].observers[id];\n\t        }\n\t\n\t        delete this._observerData[id];\n\t\n\t        return this;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\n\t        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\n\t\n\t        var tileObservers = {};\n\t\n\t        for (var key in this._observerData) {\n\t            var obsInfo = this._observerData[key];\n\t\n\t            if (obsInfo.observer.intersectsWithTile(tile)) {\n\t                obsInfo.tiles[tile.vectorTileKey] = true;\n\t                obsInfo.leftToLoad += leftToLoadDelta;\n\t                tileObservers[key] = true;\n\t            }\n\t        }\n\t\n\t        this._tileData[tile.vectorTileKey] = {\n\t            observers: tileObservers,\n\t            tile: tile\n\t        };\n\t\n\t        return this;\n\t    },\n\t\n\t    removeTile: function removeTile(tileId) {\n\t        var tileData = this._tileData[tileId],\n\t            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\n\t\n\t        for (var id in tileData.observers) {\n\t            var observerData = this._observerData[id];\n\t            observerData.leftToLoad -= leftToLoadDelta;\n\t            delete observerData.tiles[tileId];\n\t        }\n\t\n\t        delete this._tileData[tileId];\n\t\n\t        return this;\n\t    },\n\t\n\t    startLoadTiles: function startLoadTiles(observer) {\n\t\n\t        //force active tile list update\n\t        this._dataManager._getActiveTileKeys();\n\t\n\t        var obsData = this._observerData[observer.id];\n\t        if (obsData.leftToLoad === 0) {\n\t            this.fire('observertileload', { observer: observer });\n\t            return this;\n\t        }\n\t\n\t        if (!obsData.loadingState) {\n\t            obsData.loadingState = true;\n\t            observer.fire('startLoadingTiles');\n\t        }\n\t\n\t        for (var tileId in obsData.tiles) {\n\t            this._tileData[tileId].tile.load();\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getTileObservers: function getTileObservers(tileId) {\n\t        return this._tileData[tileId].observers;\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerData[observer.id].loadingState;\n\t    },\n\t\n\t    _updateObserver: function _updateObserver(observer) {\n\t        var obsData = this._observerData[observer.id],\n\t            newObserverTiles = {},\n\t            leftToLoad = 0,\n\t            key;\n\t\n\t        for (key in this._tileData) {\n\t            var tile = this._tileData[key].tile;\n\t            if (observer.intersectsWithTile(tile)) {\n\t                newObserverTiles[key] = true;\n\t                if (tile.state !== 'loaded') {\n\t                    leftToLoad++;\n\t                }\n\t                this._tileData[key].observers[observer.id] = true;\n\t            }\n\t        }\n\t\n\t        for (key in obsData.tiles) {\n\t            if (!(key in newObserverTiles)) {\n\t                delete this._tileData[key].observers[observer.id];\n\t            }\n\t        }\n\t\n\t        obsData.tiles = newObserverTiles;\n\t        obsData.leftToLoad = leftToLoad;\n\t    },\n\t\n\t    _tileLoadedCallback: function _tileLoadedCallback(tile) {\n\t        this.fire('tileload', { tile: tile });\n\t\n\t        if (!(tile.vectorTileKey in this._tileData)) {\n\t            return;\n\t        }\n\t\n\t        var tileObservers = this._tileData[tile.vectorTileKey].observers;\n\t        for (var id in tileObservers) {\n\t            var obsData = this._observerData[id];\n\t            obsData.leftToLoad--;\n\t\n\t            if (obsData.leftToLoad === 0) {\n\t                if (obsData.loadingState) {\n\t                    obsData.loadingState = false;\n\t                    obsData.observer.fire('stopLoadingTiles');\n\t                }\n\t                this.fire('observertileload', { observer: obsData.observer });\n\t            }\n\t        }\n\t    }\n\t});\n\t\n\tvar DataManager = L.Class.extend({\n\t    includes: L.Mixin.Events,\n\t\n\t    options: {\n\t        name: null, // layer ID\n\t        identityField: '', // attribute name for identity items\n\t        attributes: [], // attributes names\n\t        attrTypes: [], // attributes types\n\t        tiles: null, // tiles array for nontemporal data\n\t        tilesVers: null, // tiles version array for nontemporal data\n\t        LayerVersion: -1, // layer version\n\t        GeoProcessing: null, // processing data\n\t        Temporal: false, // only for temporal data\n\t        TemporalColumnName: '', // temporal attribute name\n\t        ZeroDate: '01.01.2008', // 0 date string\n\t        TemporalPeriods: [], // temporal periods\n\t        TemporalTiles: [], // temporal tiles array\n\t        TemporalVers: [], // temporal version array\n\t        hostName: 'maps.kosmosnimki.ru', // default hostName\n\t        sessionKey: '', // session key\n\t        isGeneralized: false, // flag for use generalized tiles\n\t        isFlatten: false // flag for flatten geometry\n\t    },\n\t\n\t    setOptions: function setOptions(options) {\n\t        this._clearProcessing();\n\t        if (options.GeoProcessing) {\n\t            this.processingTile = this.addData([]);\n\t            this._chkProcessing(options.GeoProcessing);\n\t        }\n\t        L.setOptions(this, options);\n\t        this.optionsLink = options;\n\t\n\t        this._isTemporalLayer = this.options.Temporal;\n\t\n\t        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\n\t        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\n\t        var hostName = this.options.hostName,\n\t            sessionKey = this.options.sessionKey;\n\t        if (!sessionKey) {\n\t            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\n\t        }\n\t        this.tileSenderPrefix = 'http://' + hostName + '/' + 'TileSender.ashx?WrapStyle=None' + '&key=' + encodeURIComponent(sessionKey);\n\t\n\t        this._needCheckActiveTiles = true;\n\t    },\n\t\n\t    _vectorTileDataProviderLoad: function _vectorTileDataProviderLoad(x, y, z, v, s, d, callback) {\n\t        var _this = this;\n\t        _VectorTileLoader.gmxVectorTileLoader.load(_this.tileSenderPrefix, { x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name }).then(callback, function () {\n\t            console.log('Error loading vector tile');\n\t            callback([]);\n\t            _this.fire('chkLayerUpdate', { dataProvider: _this }); //TODO: do we really need event here?\n\t        });\n\t    },\n\t\n\t    initialize: function initialize(options, clearVersion) {\n\t        this._tilesTree = null;\n\t        this._activeTileKeys = {};\n\t        this._endDate = null;\n\t        this._beginDate = null;\n\t\n\t        this._tiles = {};\n\t        this._filters = {};\n\t        this._freeSubscrID = 0;\n\t        this._items = {};\n\t        this._observers = {};\n\t\n\t        this._needCheckDateInterval = false;\n\t        this._needCheckActiveTiles = true;\n\t\n\t        var _this = this;\n\t        this._vectorTileDataProvider = {\n\t            load: this._vectorTileDataProviderLoad.bind(this)\n\t        };\n\t\n\t        this._observerTileLoader = new ObserverTileLoader(this);\n\t        this._observerTileLoader.on('tileload', function (event) {\n\t            var tile = event.tile;\n\t            _this._updateItemsFromTile(tile);\n\t\n\t            if (_this._tilesTree) {\n\t                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\n\t                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\n\t            }\n\t        });\n\t\n\t        this._observerTileLoader.on('observertileload', function (event) {\n\t            var observer = event.observer;\n\t            if (observer.isActive()) {\n\t                observer.needRefresh = false;\n\t                observer.updateData(_this.getItems(observer.id));\n\t            }\n\t        });\n\t        this.setOptions(options);\n\t        if (clearVersion) {\n\t            this.options.LayerVersion = -1;\n\t        }\n\t        if (this._isTemporalLayer) {\n\t            this.addFilter('TemporalFilter', function (item, tile, observer) {\n\t                var unixTimeStamp = item.options.unixTimeStamp,\n\t                    dates = observer.dateInterval;\n\t                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\n\t            });\n\t        }\n\t    },\n\t\n\t    _getActiveTileKeys: function _getActiveTileKeys() {\n\t\n\t        this._chkMaxDateInterval();\n\t        if (!this._needCheckActiveTiles) {\n\t            return this._activeTileKeys;\n\t        }\n\t\n\t        this._needCheckActiveTiles = false;\n\t\n\t        if (this._isTemporalLayer) {\n\t            var newTileKeys = {};\n\t            if (this._beginDate && this._endDate) {\n\t                if (!this._tilesTree) {\n\t                    this.initTilesTree();\n\t                }\n\t\n\t                /*var commonBounds = L.gmxUtil.bounds();\r\n\t                for (var obs in this._observers) {\r\n\t                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n\t                }*/\n\t\n\t                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\n\t            }\n\t            this._updateActiveTilesList(newTileKeys);\n\t        } else {\n\t            this.initTilesList();\n\t        }\n\t\n\t        return this._activeTileKeys;\n\t    },\n\t\n\t    _getObserversByFilterName: function _getObserversByFilterName(filterName) {\n\t        var oKeys = {};\n\t        for (var id in this._observers) {\n\t            if (this._observers[id].hasFilter(filterName)) {\n\t                oKeys[id] = true;\n\t            }\n\t        }\n\t        return oKeys;\n\t    },\n\t\n\t    addFilter: function addFilter(filterName, filterFunc) {\n\t        this._filters[filterName] = filterFunc;\n\t        this._triggerObservers(this._getObserversByFilterName(filterName));\n\t    },\n\t\n\t    removeFilter: function removeFilter(filterName) {\n\t        if (this._filters[filterName]) {\n\t            var oKeys = this._getObserversByFilterName(filterName);\n\t            delete this._filters[filterName];\n\t            this._triggerObservers(oKeys);\n\t        }\n\t    },\n\t\n\t    getItems: function getItems(oId) {\n\t        var resItems = [],\n\t            observer = this._observers[oId];\n\t\n\t        if (!observer) {\n\t            return [];\n\t        }\n\t\n\t        //add internal filters\n\t        var filters = observer.filters.concat('processingFilter');\n\t        this._isTemporalLayer && filters.push('TemporalFilter');\n\t\n\t        filters = filters.filter(function (filter) {\n\t            return filter in this._filters;\n\t        }.bind(this));\n\t\n\t        var _this = this,\n\t            putData = function putData(tile) {\n\t            var data = tile.data;\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var dataOption = tile.dataOptions[i];\n\t                if (!observer.intersects(dataOption.bounds)) {\n\t                    continue;\n\t                }\n\t\n\t                var it = data[i],\n\t                    id = it[0],\n\t                    item = _this.getItem(id);\n\t\n\t                var geom = it[it.length - 1],\n\t                    isFiltered = false;\n\t\n\t                for (var f = 0; f < filters.length; f++) {\n\t                    var filterFunc = _this._filters[filters[f]];\n\t                    if (!filterFunc(item, tile, observer, geom, dataOption)) {\n\t                        isFiltered = true;\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (!isFiltered) {\n\t                    resItems.push({\n\t                        id: id,\n\t                        properties: it,\n\t                        item: item,\n\t                        dataOption: dataOption,\n\t                        tileKey: tile.vectorTileKey\n\t                    });\n\t                }\n\t            }\n\t        };\n\t        var activeTileKeys = this._getActiveTileKeys();\n\t        for (var tkey in activeTileKeys) {\n\t            var tile = _this._tiles[tkey].tile;\n\t            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\n\t                putData(tile);\n\t            }\n\t        }\n\t\n\t        return resItems;\n\t    },\n\t\n\t    _updateItemsFromTile: function _updateItemsFromTile(tile) {\n\t        var vectorTileKey = tile.vectorTileKey,\n\t            data = tile.data || [],\n\t            len = data.length,\n\t            geomIndex = data[0] && data[0].length - 1;\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            var it = data[i],\n\t                geom = it[geomIndex],\n\t                id = it[0],\n\t                item = this._items[id];\n\t            if (item) {\n\t                if (!item.processing) {\n\t                    item.properties = it;\n\t                    if (item.type.indexOf('MULTI') === -1) {\n\t                        item.type = 'MULTI' + item.type;\n\t                    }\n\t                } else {\n\t                    tile.data[i] = item.properties;\n\t                }\n\t                delete item.bounds;\n\t                item.currentFilter = null;\n\t            } else {\n\t                item = {\n\t                    id: id,\n\t                    type: geom.type,\n\t                    properties: it,\n\t                    options: {\n\t                        fromTiles: {}\n\t                    }\n\t                };\n\t                this._items[id] = item;\n\t            }\n\t            item.options.fromTiles[vectorTileKey] = i;\n\t            if (tile.isGeneralized) {\n\t                item.options.isGeneralized = true;\n\t            }\n\t\n\t            if (this.options.TemporalColumnName) {\n\t                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\n\t                item.options.unixTimeStamp = zn * 1000;\n\t            }\n\t        }\n\t        return len;\n\t    },\n\t\n\t    getMaxDateInterval: function getMaxDateInterval() {\n\t        this._chkMaxDateInterval();\n\t        return {\n\t            beginDate: this._beginDate,\n\t            endDate: this._endDate\n\t        };\n\t    },\n\t\n\t    _chkMaxDateInterval: function _chkMaxDateInterval() {\n\t        if (this._isTemporalLayer && this._needCheckDateInterval) {\n\t            this._needCheckDateInterval = false;\n\t            var observers = this._observers,\n\t                newBeginDate = null,\n\t                newEndDate = null;\n\t            for (var oId in observers) {\n\t                var observer = observers[oId],\n\t                    dateInterval = observer.dateInterval;\n\t\n\t                if (!dateInterval) {\n\t                    continue;\n\t                }\n\t\n\t                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\n\t                    newBeginDate = dateInterval.beginDate;\n\t                }\n\t\n\t                if (!newEndDate || dateInterval.endDate > newEndDate) {\n\t                    newEndDate = dateInterval.endDate;\n\t                }\n\t            }\n\t            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\n\t                this._beginDate = newBeginDate;\n\t                this._endDate = newEndDate;\n\t                this._needCheckActiveTiles = true;\n\t            }\n\t        }\n\t    },\n\t\n\t    addObserver: function addObserver(options, id) {\n\t        id = id || 's' + ++this._freeSubscrID;\n\t        var _this = this,\n\t            observer = L.gmx.observer(options);\n\t\n\t        observer.id = id;\n\t        observer.needRefresh = true;\n\t        this._observerTileLoader.addObserver(observer);\n\t\n\t        observer.on('update', function (ev) {\n\t            observer.needRefresh = true;\n\t            if (ev.temporalFilter) {\n\t                _this._needCheckDateInterval = true;\n\t            }\n\t\n\t            _this._waitCheckObservers();\n\t        }).on('activate', function () {\n\t            _this.fire('observeractivate');\n\t            _this.checkObserver(observer);\n\t        });\n\t\n\t        _this._needCheckDateInterval = true;\n\t        this._observers[id] = observer;\n\t        this._waitCheckObservers();\n\t\n\t        if (observer.isActive()) {\n\t            this.fire('observeractivate');\n\t        }\n\t\n\t        return observer;\n\t    },\n\t\n\t    getActiveObserversCount: function getActiveObserversCount() {\n\t        var count = 0;\n\t        for (var k in this._observers) {\n\t            if (this._observers[k].isActive()) {\n\t                count++;\n\t            }\n\t        }\n\t        return count;\n\t    },\n\t\n\t    getObserver: function getObserver(id) {\n\t        return this._observers[id];\n\t    },\n\t\n\t    removeObserver: function removeObserver(id) {\n\t        if (this._observers[id]) {\n\t            this._observerTileLoader.removeObserver(id);\n\t            var isActive = this._observers[id].isActive();\n\t\n\t            delete this._observers[id];\n\t\n\t            if (isActive) {\n\t                this.fire('observeractivate');\n\t            }\n\t        }\n\t    },\n\t\n\t    getObserverLoadingState: function getObserverLoadingState(observer) {\n\t        return this._observerTileLoader.getObserverLoadingState(observer);\n\t    },\n\t\n\t    getItemsBounds: function getItemsBounds() {\n\t        if (!this._itemsBounds) {\n\t            this._itemsBounds = _Utils.gmxAPIutils.bounds();\n\t            for (var id in this._items) {\n\t                var item = this.getItem(id);\n\t                this._itemsBounds.extendBounds(item.bounds);\n\t            }\n\t        }\n\t        return this._itemsBounds;\n\t    },\n\t\n\t    //combine and return all parts of geometry\n\t    getItem: function getItem(id) {\n\t        var item = this._items[id];\n\t        if (item && !item.bounds) {\n\t            var fromTiles = item.options.fromTiles,\n\t                arr = [];\n\t            for (var key in fromTiles) {\n\t                // get full object bounds\n\t                if (this._tiles[key]) {\n\t                    var num = fromTiles[key],\n\t                        tile = this._tiles[key].tile;\n\t                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\n\t                        arr.push(tile.dataOptions[num].bounds);\n\t                    } else {\n\t                        delete fromTiles[key];\n\t                    }\n\t                }\n\t            }\n\t            if (arr.length === 1) {\n\t                item.bounds = arr[0];\n\t            } else {\n\t                item.bounds = _Utils.gmxAPIutils.bounds();\n\t                var w = _Utils.gmxAPIutils.worldWidthMerc;\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var it = arr[i];\n\t                    if (item.bounds.max.x - it.min.x > w) {\n\t                        it = _Utils.gmxAPIutils.bounds([[it.min.x + 2 * w, it.min.y], [it.max.x + 2 * w, it.max.y]]);\n\t                    }\n\t                    item.bounds.extendBounds(it);\n\t                }\n\t            }\n\t        }\n\t        return item;\n\t    },\n\t\n\t    getItemMembers: function getItemMembers(id) {\n\t        var fromTiles = this._items[id].options.fromTiles,\n\t            members = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key]) {\n\t                var tile = this._tiles[key].tile;\n\t                if (tile.data) {\n\t                    var objIndex = fromTiles[key],\n\t                        props = tile.data[objIndex],\n\t                        dataOption = tile.dataOptions[objIndex],\n\t                        bbox = dataOption.bounds;\n\t\n\t                    members.push({\n\t                        geo: props[props.length - 1],\n\t                        width: bbox.max.x - bbox.min.x,\n\t                        dataOption: dataOption\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        return members.sort(function (a, b) {\n\t            return b.width - a.width;\n\t        });\n\t    },\n\t\n\t    getItemGeometries: function getItemGeometries(id) {\n\t        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\n\t            geomItems = [];\n\t        for (var key in fromTiles) {\n\t            if (this._tiles[key] && this._tiles[key].tile.data) {\n\t                var tileData = this._tiles[key].tile.data,\n\t                    props = tileData[fromTiles[key]];\n\t\n\t                geomItems.push(_Utils.gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\n\t            }\n\t        }\n\t        return geomItems;\n\t    },\n\t\n\t    addTile: function addTile(tile) {\n\t        this._tiles[tile.vectorTileKey] = { tile: tile };\n\t        this._getActiveTileKeys()[tile.vectorTileKey] = true;\n\t        this._observerTileLoader.addTile(tile);\n\t        this.checkObservers();\n\t    },\n\t\n\t    checkObserver: function checkObserver(observer) {\n\t        if (observer.needRefresh && observer.isActive()) {\n\t            this._observerTileLoader.startLoadTiles(observer);\n\t        }\n\t    },\n\t\n\t    checkObservers: function checkObservers() {\n\t        var observers = this._observers;\n\t        for (var id in this._observers) {\n\t            this.checkObserver(observers[id]);\n\t        }\n\t    },\n\t\n\t    _waitCheckObservers: function _waitCheckObservers() {\n\t        //TODO: refactor\n\t        if (this._checkObserversTimer) {\n\t            clearTimeout(this._checkObserversTimer);\n\t        }\n\t\n\t        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\n\t    },\n\t\n\t    _triggerObservers: function _triggerObservers(oKeys) {\n\t        var keys = oKeys || this._observers;\n\t\n\t        for (var id in keys) {\n\t            if (this._observers[id]) {\n\t                this._observers[id].needRefresh = true;\n\t            }\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    _removeDataFromObservers: function _removeDataFromObservers(data) {\n\t        var keys = this._observers;\n\t        for (var id in keys) {\n\t            this._observers[id].removeData(data);\n\t        }\n\t        this._waitCheckObservers();\n\t    },\n\t\n\t    preloadTiles: function preloadTiles(dateBegin, dateEnd, bounds) {\n\t        var tileKeys = {};\n\t        if (this._isTemporalLayer) {\n\t            if (!this._tilesTree) {\n\t                this.initTilesTree();\n\t            }\n\t            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\n\t        } else {\n\t            this._needCheckActiveTiles = true;\n\t            tileKeys = this._getActiveTileKeys();\n\t        }\n\t\n\t        var loadingDefs = [];\n\t        for (var key in tileKeys) {\n\t            var tile = this._getVectorTile(key, true).tile;\n\t\n\t            if (tile.state !== 'notLoaded') {\n\t                continue;\n\t            }\n\t\n\t            if (bounds && !bounds.intersects(tile.bounds)) {\n\t                continue;\n\t            }\n\t\n\t            var loadDef = tile.load();\n\t            loadingDefs.push(loadDef);\n\t        }\n\t\n\t        return Deferred.all.apply(null, loadingDefs);\n\t    },\n\t\n\t    _updateActiveTilesList: function _updateActiveTilesList(newTilesList) {\n\t\n\t        if (this._tileFilteringHook) {\n\t            var filteredTilesList = {};\n\t            for (var tk in newTilesList) {\n\t                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\n\t                    filteredTilesList[tk] = true;\n\t                }\n\t            }\n\t            newTilesList = filteredTilesList;\n\t        }\n\t\n\t        var oldTilesList = this._activeTileKeys || {};\n\t\n\t        var observersToUpdate = {},\n\t            _this = this,\n\t            key;\n\t\n\t        if (this.processingTile) {\n\t            newTilesList[this.processingTile.vectorTileKey] = true;\n\t        }\n\t        if (this._rasterVectorTile) {\n\t            key = this._rasterVectorTile.vectorTileKey;\n\t            newTilesList[key] = true;\n\t            this._tiles[key] = { tile: this._rasterVectorTile };\n\t        }\n\t\n\t        var checkSubscription = function checkSubscription(vKey) {\n\t            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\n\t            for (var sid in observerIds) {\n\t                observersToUpdate[sid] = true;\n\t            }\n\t        };\n\t\n\t        for (key in newTilesList) {\n\t            if (!oldTilesList[key]) {\n\t                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\n\t                checkSubscription(key);\n\t            }\n\t        }\n\t\n\t        for (key in oldTilesList) {\n\t            if (!newTilesList[key]) {\n\t                checkSubscription(key);\n\t                this._observerTileLoader.removeTile(key);\n\t            }\n\t        }\n\t\n\t        this._activeTileKeys = newTilesList;\n\t\n\t        this._triggerObservers(observersToUpdate);\n\t    },\n\t\n\t    _propertiesToArray: function _propertiesToArray(it) {\n\t        var prop = it.properties,\n\t            indexes = this.tileAttributeIndexes,\n\t            arr = [];\n\t\n\t        for (var key in indexes) {\n\t            arr[indexes[key]] = prop[key];\n\t        }arr[arr.length] = it.geometry;\n\t        arr[0] = it.id;\n\t        return arr;\n\t    },\n\t\n\t    _clearProcessing: function _clearProcessing() {\n\t        if (this.processingTile) {\n\t            var _items = this._items,\n\t                tile = this.processingTile,\n\t                vKey = tile.vectorTileKey,\n\t                data = tile.data || [];\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i][0];\n\t                if (_items[id]) {\n\t                    var item = _items[id];\n\t                    item.processing = null;\n\t                    item.currentFilter = null;\n\t                    delete item.options.fromTiles[vKey];\n\t                    delete item.fromServerProps;\n\t                    delete item.geometry;\n\t                }\n\t            }\n\t            tile.clear();\n\t        }\n\t    },\n\t\n\t    _chkProcessing: function _chkProcessing(processing) {\n\t        var _items = this._items,\n\t            needProcessingFilter = false,\n\t            skip = {},\n\t            id,\n\t            i,\n\t            len,\n\t            it,\n\t            data;\n\t\n\t        if (processing) {\n\t            if (processing.Deleted) {\n\t                for (i = 0, len = processing.Deleted.length; i < len; i++) {\n\t                    id = processing.Deleted[i];\n\t                    skip[id] = true;\n\t                    if (_items[id]) {\n\t                        _items[id].processing = true;\n\t                        _items[id].currentFilter = null;\n\t                    }\n\t                    if (len > 0) {\n\t                        needProcessingFilter = true;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var out = {};\n\t            if (processing.Inserted) {\n\t                for (i = 0, len = processing.Inserted.length; i < len; i++) {\n\t                    it = processing.Inserted[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (processing.Updated) {\n\t                for (i = 0, len = processing.Updated.length; i < len; i++) {\n\t                    it = processing.Updated[i];\n\t                    if (!skip[it[0]]) {\n\t                        out[it[0]] = it;\n\t                    }\n\t                }\n\t                if (!needProcessingFilter && len > 0) {\n\t                    needProcessingFilter = true;\n\t                }\n\t            }\n\t\n\t            data = [];\n\t            for (id in out) {\n\t                if (this._items[id]) {\n\t                    this._items[id].properties = out[id];\n\t                    this._items[id].processing = true;\n\t                    this._items[id].currentFilter = null;\n\t                }\n\t                data.push(out[id]);\n\t            }\n\t\n\t            if (data.length > 0) {\n\t                this.processingTile = this.addData(data);\n\t            }\n\t        }\n\t        if (needProcessingFilter) {\n\t            this.addFilter('processingFilter', function (item, tile) {\n\t                return tile.z === 0 || !item.processing;\n\t            });\n\t        } else {\n\t            this.removeFilter('processingFilter');\n\t        }\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            this._resetTilesTree();\n\t        }\n\t    },\n\t\n\t    _resetTilesTree: function _resetTilesTree() {\n\t        this._tilesTree = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    updateVersion: function updateVersion(options) {\n\t        if (options) {\n\t            this.setOptions(options);\n\t        }\n\t        this._resetTilesTree();\n\t        // this.fire('versionchange');\n\t    },\n\t\n\t    _getDataKeys: function _getDataKeys(data) {\n\t        var chkKeys = {};\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            chkKeys[data[i][0]] = true;\n\t        }\n\t        return chkKeys;\n\t    },\n\t\n\t    _getProcessingTile: function _getProcessingTile() {\n\t        if (!this.processingTile) {\n\t            var x = -0.5,\n\t                y = -0.5,\n\t                z = 0,\n\t                v = 0,\n\t                s = -1,\n\t                d = -1,\n\t                isFlatten = this.options.isFlatten;\n\t\n\t            this.processingTile = new _VectorTile.VectorTile({ load: function load(x, y, z, v, s, d, callback) {\n\t                    callback([]);\n\t                } }, { x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten });\n\t\n\t            this.addTile(this.processingTile);\n\t        }\n\t        return this.processingTile;\n\t    },\n\t\n\t    addData: function addData(data) {\n\t        if (!data) {\n\t            data = [];\n\t        }\n\t        var vTile = this._getProcessingTile(),\n\t            chkKeys = this._getDataKeys(data),\n\t            dataBounds = vTile.addData(data, chkKeys);\n\t\n\t        if (this._itemsBounds) {\n\t            this._itemsBounds.extendBounds(dataBounds);\n\t        }\n\t        this._updateItemsFromTile(vTile);\n\t        this._triggerObservers();\n\t        return vTile;\n\t    },\n\t\n\t    removeData: function removeData(data) {\n\t        this._itemsBounds = null;\n\t        var vTile = this.processingTile;\n\t        if (vTile) {\n\t            var chkKeys = {};\n\t\n\t            if (!data || !data.length) {\n\t                return vTile;\n\t            }\n\t\n\t            for (var i = 0, len = data.length; i < len; i++) {\n\t                var id = data[i];\n\t                chkKeys[id] = true;\n\t                delete this._items[id];\n\t            }\n\t            this._removeDataFromObservers(chkKeys);\n\t            vTile.removeData(chkKeys, true);\n\t            this._updateItemsFromTile(vTile);\n\t\n\t            this._triggerObservers();\n\t        }\n\t\n\t        return vTile;\n\t    },\n\t\n\t    initTilesTree: function initTilesTree() {\n\t        this._tilesTree = L.gmx.tilesTree(this.options);\n\t        this.options.TemporalTiles = this.options.TemporalVers = null;\n\t\n\t        if ('TemporalTiles' in this.optionsLink) {\n\t            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\n\t        }\n\t        this.dateZero = this._tilesTree.dateZero;\n\t        if (this.processingTile) {\n\t            this._tiles[this.processingTile.vectorTileKey] = {\n\t                tile: this.processingTile\n\t            };\n\t        }\n\t    },\n\t\n\t    _getVectorTile: function _getVectorTile(vKey, createFlag) {\n\t        if (!this._tiles[vKey] && createFlag) {\n\t            var info = _VectorTile.VectorTile.parseTileKey(vKey);\n\t            info.dateZero = this.dateZero;\n\t            this._addVectorTile(info);\n\t        }\n\t        return this._tiles[vKey];\n\t    },\n\t\n\t    _addVectorTile: function _addVectorTile(info) {\n\t        info.isFlatten = this.options.isFlatten;\n\t        var tile = new _VectorTile.VectorTile(this._vectorTileDataProvider, info),\n\t            vKey = tile.vectorTileKey;\n\t\n\t        this._tiles[vKey] = { tile: tile };\n\t        return vKey;\n\t    },\n\t\n\t    _getGeneralizedTileKeys: function _getGeneralizedTileKeys(vTilePoint) {\n\t        var dz = vTilePoint.z % 2 ? 1 : 2,\n\t            pz = Math.pow(2, dz),\n\t            z = vTilePoint.z - dz,\n\t            x = Math.floor(vTilePoint.x / pz),\n\t            y = Math.floor(vTilePoint.y / pz),\n\t            temp = { v: vTilePoint.v, s: -1, d: -1, isGeneralized: true },\n\t            keys = {};\n\t\n\t        while (z > 1) {\n\t            var gKey = [z, x, y].join('_');\n\t            keys[gKey] = L.extend({}, temp, { x: x, y: y, z: z });\n\t            z -= 2;\n\t            x = Math.floor(x / 4);\n\t            y = Math.floor(y / 4);\n\t        }\n\t        return keys;\n\t    },\n\t\n\t    initTilesList: function initTilesList() {\n\t        // For non temporal layers we create all Vector tiles\n\t        var newActiveTileKeys = {};\n\t        if (this.options.tiles) {\n\t            var arr = this.options.tiles || [],\n\t                vers = this.options.tilesVers,\n\t                generalizedKeys = this.options.isGeneralized ? {} : null,\n\t                newTiles = {},\n\t                gKey,\n\t                tKey,\n\t                info,\n\t                tHash;\n\t\n\t            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\n\t                info = {\n\t                    x: Number(arr[i]),\n\t                    y: Number(arr[i + 1]),\n\t                    z: Number(arr[i + 2]),\n\t                    v: Number(vers[cnt]),\n\t                    s: -1,\n\t                    d: -1\n\t                };\n\t\n\t                tHash = this._getVectorTile(_VectorTile.VectorTile.createTileKey(info), true);\n\t                tKey = tHash.tile.vectorTileKey;\n\t                newTiles[tKey] = tHash;\n\t                newActiveTileKeys[tKey] = true;\n\t                if (generalizedKeys) {\n\t                    var gKeys = this._getGeneralizedTileKeys(info);\n\t                    for (gKey in gKeys) {\n\t                        var gPoint = gKeys[gKey];\n\t                        if (generalizedKeys[gKey]) {\n\t                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\n\t                        } else {\n\t                            generalizedKeys[gKey] = gPoint;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if (generalizedKeys) {\n\t                for (gKey in generalizedKeys) {\n\t                    info = generalizedKeys[gKey];\n\t                    tKey = _VectorTile.VectorTile.createTileKey(info);\n\t                    if (!newTiles[tKey]) {\n\t                        if (!this._tiles[tKey]) {\n\t                            this._addVectorTile(info);\n\t                        }\n\t                        newTiles[tKey] = this._tiles[tKey];\n\t                        newActiveTileKeys[tKey] = true;\n\t                    }\n\t                }\n\t            }\n\t            this._tiles = newTiles;\n\t            if (this.processingTile) {\n\t                this._tiles[this.processingTile.vectorTileKey] = {\n\t                    tile: this.processingTile\n\t                };\n\t            }\n\t        }\n\t        this._updateActiveTilesList(newActiveTileKeys);\n\t    },\n\t\n\t    //Tile filtering hook filters out active vector tiles.\n\t    //Can be used to prevent loading data from some spatial-temporal region\n\t    setTileFilteringHook: function setTileFilteringHook(filteringHook) {\n\t        this._tileFilteringHook = filteringHook;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    },\n\t\n\t    removeTileFilteringHook: function removeTileFilteringHook() {\n\t        this._tileFilteringHook = null;\n\t        this._needCheckActiveTiles = true;\n\t        this._getActiveTileKeys(); //force list update\n\t    }\n\t\n\t});\n\tL.gmx = L.gmx || {};\n\tL.gmx.DataManager = DataManager;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar _StyleManager = __webpack_require__(19);\n\t\n\tvar _ScreenVectorTile = __webpack_require__(20);\n\t\n\tL.gmx.VectorLayer = L.TileLayer.Canvas.extend({\n\t    options: {\n\t        openPopups: [],\n\t        minZoom: 1,\n\t        zIndexOffset: 0,\n\t        isGeneralized: true,\n\t        isFlatten: false,\n\t        useWebGL: false,\n\t        clickable: true\n\t    },\n\t\n\t    initialize: function initialize(options) {\n\t        options = L.setOptions(this, options);\n\t\n\t        this.initPromise = new L.gmx.Deferred();\n\t\n\t        this._drawQueue = [];\n\t        this._drawQueueHash = {};\n\t\n\t        this._drawInProgress = {};\n\t\n\t        this._anyDrawings = false; //are we drawing something?\n\t        this.repaintObservers = {}; // external observers like screen\n\t\n\t        var _this = this;\n\t\n\t        this._gmx = {\n\t            hostName: _Utils.gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\n\t            mapName: options.mapID,\n\t            useWebGL: options.useWebGL,\n\t            layerID: options.layerID,\n\t            beginDate: options.beginDate,\n\t            endDate: options.endDate,\n\t            sortItems: options.sortItems || null,\n\t            styles: options.styles || [],\n\t            tileSubscriptions: {},\n\t            _tilesToLoad: 0,\n\t            shiftXlayer: 0,\n\t            shiftYlayer: 0,\n\t            renderHooks: [],\n\t            preRenderHooks: [],\n\t            _needPopups: {}\n\t        };\n\t        if (options.crossOrigin) {\n\t            this._gmx.crossOrigin = options.crossOrigin;\n\t        }\n\t\n\t        this.on('tileunload', function (e) {\n\t            _this._clearTileSubscription(e.tile.zKey);\n\t        });\n\t    },\n\t\n\t    // extended from L.TileLayer.Canvas\n\t    _removeTile: function _removeTile(zKey) {\n\t        var tileLink = this._tiles[zKey];\n\t        if (tileLink) {\n\t            var tile = tileLink.el;\n\t            if (tile && tile.parentNode) {\n\t                tile.parentNode.removeChild(tile);\n\t            }\n\t\n\t            delete this._tiles[zKey];\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\n\t            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\n\t        }\n\t        var gmx = this._gmx;\n\t\n\t        gmx.shiftY = 0;\n\t        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\n\t        gmx.currentZoom = map.getZoom();\n\t        gmx.styleManager.initStyles();\n\t\n\t        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\n\t\n\t        map.on('zoomstart', this._zoomStart, this);\n\t        map.on('zoomend', this._zoomEnd, this);\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.on('moveend', this._moveEnd, this);\n\t        }\n\t        if (this.options.clickable === false) {\n\t            this._container.style.pointerEvents = 'none';\n\t        }\n\t        if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        this.on('stylechange', this._onStyleChange, this);\n\t        this.on('versionchange', this._onVersionChange, this);\n\t\n\t        // this._zIndexOffsetCheck();\n\t        L.gmx.layersVersion.add(this);\n\t        this.fire('add');\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._container) {\n\t            this._container.parentNode.removeChild(this._container);\n\t        }\n\t\n\t        map.off({\n\t            'viewreset': this._reset,\n\t            'moveend': this._update\n\t        }, this);\n\t\n\t        if (this._animated) {\n\t            map.off({\n\t                'zoomanim': this._animateZoom,\n\t                'zoomend': this._endZoomAnim\n\t            }, this);\n\t        }\n\t\n\t        if (!this.options.updateWhenIdle) {\n\t            map.off('move', this._limitedUpdate, this);\n\t        }\n\t        this._container = null;\n\t        this._map = null;\n\t\n\t        this._clearAllSubscriptions();\n\t        map.off('zoomstart', this._zoomStart, this);\n\t        map.off('zoomend', this._zoomEnd, this);\n\t        this.off('stylechange', this._onStyleChange, this);\n\t\n\t        var gmx = this._gmx;\n\t\n\t        delete gmx.map;\n\t        if (gmx.properties.type === 'Vector') {\n\t            map.off('moveend', this._moveEnd, this);\n\t        }\n\t        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\n\t            L.gmx.layersVersion.remove(this);\n\t        }\n\t        this.fire('remove');\n\t    },\n\t\n\t    _initContainer: function _initContainer() {\n\t        L.TileLayer.Canvas.prototype._initContainer.call(this);\n\t        this._prpZoomData();\n\t        this.setZIndexOffset();\n\t    },\n\t\n\t    _updateZIndex: function _updateZIndex() {\n\t        if (this._container) {\n\t            var options = this.options,\n\t                zIndex = options.zIndex || 0,\n\t                zIndexOffset = options.zIndexOffset || 0;\n\t\n\t            this._container.style.zIndex = zIndexOffset + zIndex;\n\t        }\n\t    },\n\t\n\t    _update: function _update() {\n\t        if (!this._map || this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\n\t        ) {\n\t                this._clearAllSubscriptions();\n\t                return;\n\t            }\n\t        this._gmx.styleManager.deferred.then(this.__update.bind(this));\n\t    },\n\t\n\t    _addTile: function _addTile(tilePoint) {\n\t        var myLayer = this,\n\t            zoom = this._map._zoom,\n\t            gmx = this._gmx;\n\t\n\t        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\n\t            this._tileLoaded();\n\t            return;\n\t        }\n\t\n\t        var zKey = this._tileCoordsToKey(tilePoint, zoom);\n\t        if (!gmx.tileSubscriptions[zKey]) {\n\t            gmx._tilesToLoad++;\n\t            var isDrawnFirstTime = false,\n\t                gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\n\t                done = function done() {\n\t                if (!isDrawnFirstTime) {\n\t                    gmx._tilesToLoad--;\n\t                    myLayer._tileLoaded();\n\t                    isDrawnFirstTime = true;\n\t                }\n\t            },\n\t                attr = {\n\t                type: 'resend',\n\t                active: false,\n\t                bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                callback: function callback(data) {\n\t                    myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\n\t                }\n\t            };\n\t            if (this.options.isGeneralized) {\n\t                attr.targetZoom = zoom;\n\t            }\n\t            if (gmx.layerType === 'VectorTemporal') {\n\t                attr.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t\n\t            var observer = gmx.dataManager.addObserver(attr, zKey);\n\t            observer.on('activate', function () {\n\t                //if observer is deactivated before drawing,\n\t                //we can consider corresponding tile as already drawn\n\t                if (!observer.isActive()) {\n\t                    done();\n\t                }\n\t            });\n\t\n\t            observer.on('startLoadingTiles', this._chkDrawingState, this);\n\t\n\t            gmx.tileSubscriptions[zKey] = {\n\t                z: zoom,\n\t                x: tilePoint.x,\n\t                y: tilePoint.y,\n\t                px: 256 * gmxTilePoint.x,\n\t                py: 256 * (1 + gmxTilePoint.y)\n\t            };\n\t            observer.activate();\n\t        }\n\t    },\n\t\n\t    _chkDrawingState: function _chkDrawingState() {\n\t        var gmx = this._gmx,\n\t            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\n\t\n\t        if (!isDrawing) {\n\t            for (var key in gmx.tileSubscriptions) {\n\t                var observer = gmx.dataManager.getObserver(key);\n\t                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\n\t                    isDrawing = true;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (!isDrawing && this._anyDrawings) {\n\t            this.fire('doneDraw');\n\t        } else if (isDrawing && !this._anyDrawings) {\n\t            this.fire('startDraw');\n\t        }\n\t\n\t        this._anyDrawings = isDrawing;\n\t    },\n\t\n\t    _getLoadedTilesPercentage: function _getLoadedTilesPercentage(container) {\n\t        if (!container) {\n\t            return 0;\n\t        }\n\t        var len = 0,\n\t            count = 0;\n\t        var arr = ['img', 'canvas'];\n\t        for (var key in arr) {\n\t            var tiles = container.getElementsByTagName(arr[key]);\n\t            if (tiles && tiles.length > 0) {\n\t                len += tiles.length;\n\t                for (var i = 0, len1 = tiles.length; i < len1; i++) {\n\t                    if (tiles[i]._tileComplete) {\n\t                        count++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (len < 1) {\n\t            return 0;\n\t        }\n\t        return count / len;\n\t    },\n\t\n\t    _tileLoaded: function _tileLoaded() {\n\t        if (this._animated) {\n\t            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\n\t        }\n\t        if (this._gmx._tilesToLoad === 0) {\n\t            this.fire('load');\n\t\n\t            if (this._animated) {\n\t                // clear scaled tiles after all new tiles are loaded (for performance)\n\t                this._setClearBgBuffer(0);\n\t            }\n\t        }\n\t    },\n\t\n\t    _tileOnLoad: function _tileOnLoad(tile) {\n\t        if (tile) {\n\t            L.DomUtil.addClass(tile, 'leaflet-tile-loaded');\n\t        }\n\t        this._tileLoaded();\n\t    },\n\t\n\t    _tileOnError: function _tileOnError() {},\n\t\n\t    tileDrawn: function tileDrawn(tile) {\n\t        this._tileOnLoad(tile);\n\t    },\n\t\n\t    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\n\t    // converts tile coordinates to key for the tile cache\n\t    _tileCoordsToKey: function _tileCoordsToKey(coords, zoom) {\n\t        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\n\t    },\n\t\n\t    _getTiledPixelBounds: function _getTiledPixelBounds(center) {\n\t        var map = this._map,\n\t            gmx = this._gmx,\n\t            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\n\t            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\n\t            halfSize = map.getSize().divideBy(2);\n\t\n\t        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n\t    },\n\t\n\t    _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {\n\t        var tileSize = this.options.tileSize;\n\t        return new L.Bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._round());\n\t    },\n\t\n\t    // original for L.gmx.VectorLayer\n\t\n\t    //public interface\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var gmx = this._gmx;\n\t\n\t        gmx.properties = ph.properties;\n\t        gmx.geometry = ph.geometry;\n\t\n\t        if (gmx.properties._initDone) {\n\t            // need delete tiles key\n\t            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\n\t        }\n\t        gmx.properties._initDone = true;\n\t\n\t        if (!gmx.geometry) {\n\t            var worldSize = _Utils.gmxAPIutils.tileSizes[1];\n\t            gmx.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        // Original properties from the server.\n\t        // Descendant classes can override this property\n\t        // Not so good solution, but it works\n\t        gmx.rawProperties = ph.rawProperties || ph.properties;\n\t\n\t        this._updateProperties(ph.properties);\n\t\n\t        ph.properties.isGeneralized = this.options.isGeneralized;\n\t        ph.properties.isFlatten = this.options.isFlatten;\n\t\n\t        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\n\t\n\t        if (this.options.parentOptions) {\n\t            if (!ph.properties.styles) {\n\t                ph.properties.styles = this.options.parentOptions.styles;\n\t            }\n\t            gmx.dataManager.on('versionchange', this._onVersionChange, this);\n\t        }\n\t\n\t        gmx.styleManager = new _StyleManager.StyleManager(gmx);\n\t        this.options.minZoom = gmx.styleManager.minZoom;\n\t        this.options.maxZoom = gmx.styleManager.maxZoom;\n\t\n\t        gmx.dataManager.on('observeractivate', function () {\n\t            if (gmx.dataManager.getActiveObserversCount()) {\n\t                L.gmx.layersVersion.add(this);\n\t            } else {\n\t                L.gmx.layersVersion.remove(this);\n\t            }\n\t        }, this);\n\t\n\t        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\n\t            this.options.chkUpdate = true; //Check updates for vector layers by default\n\t        }\n\t        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\n\t            this._objectsReorderInit(this);\n\t        }\n\t\n\t        if (gmx.clusters) {\n\t            this.bindClusters(JSON.parse(gmx.clusters));\n\t        }\n\t        if (gmx.filter) {\n\t            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (func) {\n\t                gmx.dataManager.addFilter('userFilter_' + gmx.layerID, function (item) {\n\t                    return gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\n\t                }.bind(this));\n\t            }\n\t        }\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\n\t        }\n\t\n\t        this.initPromise.resolve();\n\t        return this;\n\t    },\n\t\n\t    getDataManager: function getDataManager() {\n\t        return this._gmx.dataManager;\n\t    },\n\t\n\t    enableGeneralization: function enableGeneralization() {\n\t        if (!this.options.isGeneralized) {\n\t            this.options.isGeneralized = true;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.enableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    disableGeneralization: function disableGeneralization() {\n\t        if (this.options.isGeneralized) {\n\t            this.options.isGeneralized = false;\n\t            if (this._gmx.dataManager) {\n\t                this._clearAllSubscriptions();\n\t                this._gmx.dataManager.disableGeneralization();\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    setRasterOpacity: function setRasterOpacity(opacity) {\n\t        var _this = this;\n\t        if (this._gmx.rasterOpacity !== opacity) {\n\t            this._gmx.rasterOpacity = opacity;\n\t            this.initPromise.then(function () {\n\t                _this.repaint();\n\t            });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        return this._gmx.styleManager.getStyles();\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        this._gmx.styleManager.getIcons(callback);\n\t        return this;\n\t    },\n\t\n\t    setStyles: function setStyles(styles) {\n\t        var _this = this;\n\t\n\t        this.initPromise.then(function () {\n\t            _this._gmx.styleManager.clearStyles();\n\t            if (styles) {\n\t                styles.forEach(function (it, i) {\n\t                    _this.setStyle(it, i, true);\n\t                });\n\t            } else {\n\t                _this.fire('stylechange');\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    getStyle: function getStyle(num) {\n\t        return this.getStyles()[num];\n\t    },\n\t\n\t    setStyle: function setStyle(style, num, createFlag) {\n\t        var _this = this,\n\t            gmx = this._gmx;\n\t        this.initPromise.then(function () {\n\t            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\n\t                _this.fire('stylechange', { num: num || 0 });\n\t            });\n\t        });\n\t        return this;\n\t    },\n\t\n\t    setStyleHook: function setStyleHook(func) {\n\t        this._gmx.styleHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeStyleHook: function removeStyleHook() {\n\t        this._gmx.styleHook = null;\n\t        return this;\n\t    },\n\t\n\t    setRasterHook: function setRasterHook(func) {\n\t        this._gmx.rasterProcessingHook = func;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    removeRasterHook: function removeRasterHook() {\n\t        this._gmx.rasterProcessingHook = null;\n\t        this.repaint();\n\t        return this;\n\t    },\n\t\n\t    setFilter: function setFilter(func) {\n\t        var gmx = this._gmx;\n\t        gmx.dataManager.addFilter('userFilter', function (item) {\n\t            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\n\t        }.bind(this));\n\t        return this;\n\t    },\n\t\n\t    removeFilter: function removeFilter() {\n\t        this._gmx.dataManager.removeFilter('userFilter');\n\t        return this;\n\t    },\n\t\n\t    setDateInterval: function setDateInterval(beginDate, endDate) {\n\t        var gmx = this._gmx;\n\t\n\t        if (gmx.dateBegin && gmx.dateEnd) {\n\t            beginDate = gmx.dateBegin;\n\t            endDate = gmx.dateEnd;\n\t        }\n\t\n\t        //check that something changed\n\t        if (!gmx.beginDate !== !beginDate || !gmx.endDate !== !endDate || beginDate && gmx.beginDate.valueOf() !== beginDate.valueOf() || endDate && gmx.endDate.valueOf() !== endDate.valueOf()) {\n\t            if (gmx.rawProperties.maxShownPeriod && beginDate) {\n\t                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\n\t                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\n\t            }\n\t\n\t            gmx.beginDate = beginDate;\n\t            gmx.endDate = endDate;\n\t\n\t            var observer = null,\n\t                dataManager = gmx.dataManager;\n\t            for (var key in gmx.tileSubscriptions) {\n\t                observer = dataManager.getObserver(key);\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            observer = dataManager.getObserver('_Labels');\n\t            if (observer) {\n\t                observer.setDateInterval(beginDate, endDate);\n\t            }\n\t            if (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\n\t                gmx.properties.LayerVersion = -1;\n\t                dataManager.setOptions({ LayerVersion: -1 });\n\t                if (this._map) {\n\t                    L.gmx.layersVersion.now();\n\t                }\n\t            }\n\t            this.fire('dateIntervalChanged');\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    getDateInterval: function getDateInterval() {\n\t        return {\n\t            beginDate: this._gmx.beginDate,\n\t            endDate: this._gmx.endDate\n\t        };\n\t    },\n\t\n\t    addObserver: function addObserver(options) {\n\t        return this._gmx.dataManager.addObserver(options);\n\t    },\n\t\n\t    removeObserver: function removeObserver(observer) {\n\t        return this._gmx.dataManager.removeObserver(observer.id);\n\t    },\n\t\n\t    setPositionOffset: function setPositionOffset(dx, dy) {\n\t        var gmx = this._gmx;\n\t        gmx.shiftXlayer = dx;\n\t        gmx.shiftYlayer = dy;\n\t        this._update();\n\t        return this;\n\t    },\n\t\n\t    getPositionOffset: function getPositionOffset() {\n\t        var gmx = this._gmx;\n\t        return { shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer };\n\t    },\n\t\n\t    setZIndexOffset: function setZIndexOffset(offset) {\n\t        if (arguments.length) {\n\t            this.options.zIndexOffset = offset;\n\t        }\n\t        this._updateZIndex();\n\t        return this;\n\t    },\n\t\n\t    repaint: function repaint(zKeys) {\n\t        if (this._map) {\n\t            if (!zKeys) {\n\t                zKeys = {};\n\t                for (var key in this._gmx.tileSubscriptions) {\n\t                    zKeys[key] = true;\n\t                }\n\t                L.extend(zKeys, this.repaintObservers);\n\t            }\n\t            this._gmx.dataManager._triggerObservers(zKeys);\n\t        }\n\t    },\n\t\n\t    redrawItem: function redrawItem(id) {\n\t        if (this._map) {\n\t            var item = this._gmx.dataManager.getItem(id),\n\t                gmxTiles = this._getTilesByBounds(item.bounds);\n\t\n\t            this.repaint(gmxTiles);\n\t        }\n\t    },\n\t\n\t    gmxGetCanvasTile: function gmxGetCanvasTile(tilePoint) {\n\t        var zKey = this._tileCoordsToKey(tilePoint);\n\t\n\t        if (zKey in this._tiles) {\n\t            return this._tiles[zKey];\n\t        }\n\t        // save tile in cache\n\t        var tile = this._getTile();\n\t        this._tiles[zKey] = {\n\t            el: tile,\n\t            coords: tilePoint,\n\t            current: true\n\t        };\n\t\n\t        // tile._zKey = zKey;\n\t        tile._zoom = this._map._zoom;\n\t        tile._tileComplete = true;\n\t        tile._tilePoint = tilePoint;\n\t        this.tileDrawn(tile);\n\t        return this._tiles[zKey];\n\t    },\n\t\n\t    appendTileToContainer: function appendTileToContainer(tile) {\n\t        this._tileContainer.appendChild(tile);\n\t        var tilePos = this._getTilePos(tile._tilePoint);\n\t        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\n\t    },\n\t\n\t    addData: function addData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.addData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removeData: function removeData(data, options) {\n\t        if (!this._gmx.mapName) {\n\t            // client side layer\n\t            this._gmx.dataManager.removeData(data, options);\n\t            this.repaint();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    getStylesByProperties: function getStylesByProperties(propArray, zoom) {\n\t        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\n\t    },\n\t\n\t    getItemStyle: function getItemStyle(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        return gmx.styleManager.getObjStyle(item);\n\t    },\n\t\n\t    getTileAttributeTypes: function getTileAttributeTypes() {\n\t        return this._gmx.tileAttributeTypes;\n\t    },\n\t\n\t    getTileAttributeIndexes: function getTileAttributeIndexes() {\n\t        return this._gmx.tileAttributeIndexes;\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id),\n\t            styles = this.getStyles(),\n\t            out = '';\n\t\n\t        if (item && styles[item.currentFilter]) {\n\t            var propsArr = item.properties;\n\t            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\n\t                properties: this.getItemProperties(propsArr),\n\t                geometries: [propsArr[propsArr.length - 1]],\n\t                tileAttributeTypes: gmx.tileAttributeTypes,\n\t                unitOptions: this._map ? this._map.options : {}\n\t            });\n\t        }\n\t        return out;\n\t    },\n\t\n\t    getItemProperties: function getItemProperties(propArray) {\n\t        var properties = {},\n\t            indexes = this._gmx.tileAttributeIndexes;\n\t        for (var key in indexes) {\n\t            properties[key] = propArray[indexes[key]];\n\t        }\n\t        return properties;\n\t    },\n\t\n\t    addPreRenderHook: function addPreRenderHook(renderHook) {\n\t        this._gmx.preRenderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removePreRenderHook: function removePreRenderHook(hook) {\n\t        var arr = this._gmx.preRenderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    addRenderHook: function addRenderHook(renderHook) {\n\t        this._gmx.renderHooks.push(renderHook);\n\t        this.repaint();\n\t    },\n\t\n\t    removeRenderHook: function removeRenderHook(hook) {\n\t        var arr = this._gmx.renderHooks;\n\t        for (var i = 0, len = arr.length; i < len; i++) {\n\t            if (arr[i] === hook) {\n\t                arr.splice(i, 1);\n\t                this.repaint();\n\t                break;\n\t            }\n\t        }\n\t    },\n\t\n\t    //get original properties from the server\n\t    getGmxProperties: function getGmxProperties() {\n\t        return this._gmx.rawProperties;\n\t    },\n\t\n\t    //returns L.LatLngBounds\n\t    getBounds: function getBounds() {\n\t        var proj = L.Projection.Mercator,\n\t            gmxBounds = this._gmx.layerID ? _Utils.gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\n\t\n\t        if (gmxBounds) {\n\t            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\n\t        } else {\n\t            return new L.LatLngBounds();\n\t        }\n\t    },\n\t\n\t    getGeometry: function getGeometry() {\n\t        if (!this._gmx.latLngGeometry) {\n\t            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\n\t        }\n\t\n\t        return this._gmx.latLngGeometry;\n\t    },\n\t\n\t    // internal methods\n\t    _clearTileSubscription: function _clearTileSubscription(zKey) {\n\t        var gmx = this._gmx;\n\t\n\t        if (zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            delete gmx.tileSubscriptions[zKey];\n\t            this._removeTile(zKey);\n\t\n\t            if (this._anyDrawings) {\n\t                this._chkDrawingState();\n\t            }\n\t        }\n\t\n\t        if (zKey in this._drawQueueHash) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t    },\n\t\n\t    _clearAllSubscriptions: function _clearAllSubscriptions() {\n\t        while (this._drawQueue.length) {\n\t            this._drawQueue[0].def.cancel();\n\t        }\n\t\n\t        var gmx = this._gmx;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.screenTile) {\n\t                subscription.screenTile.destructor();\n\t            }\n\t            var observer = gmx.dataManager.getObserver(zKey);\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            gmx.dataManager.removeObserver(zKey);\n\t            delete gmx.tileSubscriptions[zKey];\n\t            delete this._tiles[zKey];\n\t        }\n\t\n\t        if (this._anyDrawings) {\n\t            this._chkDrawingState();\n\t        }\n\t\n\t        gmx._tilesToLoad = 0;\n\t    },\n\t\n\t    _zoomStart: function _zoomStart() {\n\t        this._gmx.zoomstart = true;\n\t    },\n\t\n\t    _zoomEnd: function _zoomEnd() {\n\t        this._gmx.zoomstart = false;\n\t        this.setCurrentZoom(this._map);\n\t        // this._zIndexOffsetCheck();\n\t    },\n\t\n\t    _moveEnd: function _moveEnd() {\n\t        if ('dataManager' in this._gmx) {\n\t            this._gmx.dataManager.fire('moveend');\n\t        }\n\t    },\n\t\n\t    _onStyleChange: function _onStyleChange() {\n\t        var gmx = this._gmx;\n\t        if (!gmx.balloonEnable && this._popup) {\n\t            this.unbindPopup();\n\t        } else if (gmx.balloonEnable && !this._popup) {\n\t            this.bindPopup('');\n\t        }\n\t        if (this._map) {\n\t            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\n\t                this.options.minZoom = gmx.styleManager.minZoom;\n\t                this.options.maxZoom = gmx.styleManager.maxZoom;\n\t                this._map._updateZoomLevels();\n\t            }\n\t            if (gmx.labelsLayer) {\n\t                this._map._labelsLayer.add(this);\n\t            } else if (!gmx.labelsLayer) {\n\t                this._map._labelsLayer.remove(this);\n\t            }\n\t            if (Object.keys(gmx.tileSubscriptions).length > 0) {\n\t                for (var key in gmx.tileSubscriptions) {\n\t                    // recheck bbox on screen observers\n\t                    var observer = gmx.dataManager.getObserver(key),\n\t                        parsedKey = gmx.tileSubscriptions[key],\n\t                        gmxTilePoint = _Utils.gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\n\t                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\n\t                    if (!observer.bbox.isEqual(bbox)) {\n\t                        var proj = L.Projection.Mercator;\n\t                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\n\t                    }\n\t                }\n\t            } else {\n\t                this.redraw();\n\t            }\n\t        }\n\t    },\n\t\n\t    _removeInProgressDrawing: function _removeInProgressDrawing(zKey) {\n\t        delete this._drawInProgress[zKey];\n\t        this._chkDrawingState();\n\t    },\n\t\n\t    _drawTileAsync: function _drawTileAsync(tilePoint, zoom, data) {\n\t        var queue = this._drawQueue,\n\t            isEmpty = queue.length === 0,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            _this = this;\n\t\n\t        if (this._drawQueueHash[zKey]) {\n\t            this._drawQueueHash[zKey].cancel();\n\t        }\n\t\n\t        var drawNextTile = function drawNextTile() {\n\t            _this._chkDrawingState();\n\t\n\t            if (!queue.length) {\n\t                return;\n\t            }\n\t\n\t            var queueItem = queue.shift();\n\t            delete _this._drawQueueHash[queueItem.zKey];\n\t            if (_this._map && queueItem.z === _this._map._zoom) {\n\t                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\n\t\n\t                _this._drawInProgress[queueItem.zKey] = true;\n\t\n\t                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\n\t\n\t                queueItem.drawDef.then(queueItem.def.resolve.bind(queueItem.def, queueItem.data), queueItem.def.reject);\n\t            } else {\n\t                queueItem.def.reject();\n\t            }\n\t            setTimeout(drawNextTile, 0);\n\t        };\n\t\n\t        var gtp = _Utils.gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\n\t        var queueItem = { gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data };\n\t        var def = queueItem.def = new L.gmx.Deferred(function () {\n\t            queueItem.drawDef && queueItem.drawDef.cancel();\n\t\n\t            _this._removeInProgressDrawing(zKey);\n\t\n\t            delete _this._drawQueueHash[zKey];\n\t            for (var i = queue.length - 1; i >= 0; i--) {\n\t                var elem = queue[i];\n\t                if (elem.zKey === zKey) {\n\t                    queue.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t        queue.push(queueItem);\n\t\n\t        this._drawQueueHash[zKey] = def;\n\t\n\t        if (isEmpty) {\n\t            setTimeout(drawNextTile, 0);\n\t        }\n\t\n\t        return def;\n\t    },\n\t\n\t    _updateShiftY: function _updateShiftY() {\n\t        var gmx = this._gmx,\n\t            map = this._map,\n\t            deltaY = 0;\n\t\n\t        if (map) {\n\t            var pos = map.getCenter();\n\t            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\n\t        }\n\t\n\t        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\n\t        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\n\t        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY); //  \n\t\n\t        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\n\t    },\n\t\n\t    _prpZoomData: function _prpZoomData() {\n\t        this.setCurrentZoom(this._map);\n\t        // this.repaint();\n\t    },\n\t\n\t    setCurrentZoom: function setCurrentZoom(map) {\n\t        var gmx = this._gmx;\n\t        gmx.currentZoom = map._zoom;\n\t        gmx.tileSize = _Utils.gmxAPIutils.tileSizes[gmx.currentZoom];\n\t        gmx.mInPixel = 256 / gmx.tileSize;\n\t    },\n\t\n\t    // _zIndexOffsetCheck: function() {\n\t    // var gmx = this._gmx;\n\t    // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\n\t    // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\n\t    // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\n\t    // if (zIndexOffset !== this.options.zIndexOffset) {\n\t    // this.setZIndexOffset(zIndexOffset);\n\t    // }\n\t    // }\n\t    // },\n\t\n\t    _setClearBgBuffer: function _setClearBgBuffer(zd) {\n\t        if (this._clearBgBufferTimer) {\n\t            clearTimeout(this._clearBgBufferTimer);\n\t        }\n\t        var _this = this;\n\t        this._clearBgBufferTimer = setTimeout(function () {\n\t            if (_this._bgBuffer) {\n\t                _this._clearBgBuffer();\n\t            }\n\t        }, zd || 0);\n\t    },\n\t\n\t    _getNeedPopups: function _getNeedPopups() {\n\t        var out = {},\n\t            openPopups = this.options.openPopups;\n\t        for (var i = 0, len = openPopups.length; i < len; i++) {\n\t            out[openPopups[i]] = false;\n\t        }\n\t        return out;\n\t    },\n\t\n\t    __update: function __update() {\n\t        var map = this._map;\n\t        if (!map) {\n\t            return;\n\t        }\n\t        var zoom = map.getZoom(),\n\t            center = map.getCenter();\n\t\n\t        if (this._gmx.applyShift) {\n\t            this._updateShiftY();\n\t        }\n\t        this._tileZoom = zoom;\n\t        if (this.options.openPopups.length) {\n\t            this._gmx._needPopups = this._getNeedPopups();\n\t            this.options.openPopups = [];\n\t        }\n\t\n\t        var pixelBounds = this._getTiledPixelBounds(center),\n\t            tileRange = this._pxBoundsToTileRange(pixelBounds),\n\t            limit = this._getWrapTileNum();\n\t\n\t        if (tileRange.min.y < 0) {\n\t            tileRange.min.y = 0;\n\t        }\n\t        if (tileRange.max.y >= limit.y) {\n\t            tileRange.max.y = limit.y - 1;\n\t        }\n\t\n\t        this._chkTileSubscriptions(zoom, tileRange);\n\t\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            this._setClearBgBuffer(500);\n\t            return;\n\t        }\n\t\n\t        // create a queue of coordinates to load tiles from\n\t        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n\t            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n\t                var coords = new L.Point(i, j);\n\t                coords.z = this._tileZoom;\n\t\n\t                if (!this._tiles[this._tileCoordsToKey(coords)]) {\n\t                    this._addTile(coords);\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkTileSubscriptions: function _chkTileSubscriptions(zoom, tileRange) {\n\t        //L.TileVector will remove all tiles from other zooms.\n\t        //But it will not remove subscriptions without tiles - we should do it ourself\n\t        var gmx = this._gmx,\n\t            min = tileRange.min,\n\t            max = tileRange.max;\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey];\n\t            if (subscription.z !== zoom || subscription.x < min.x || subscription.x > max.x || subscription.y < min.y || subscription.y > max.y) {\n\t                this._clearTileSubscription(zKey);\n\t            }\n\t        }\n\t    },\n\t\n\t    _getScreenTile: function _getScreenTile(tilePoint, zoom) {\n\t        var gmx = this._gmx,\n\t            zKey = this._tileCoordsToKey(tilePoint, zoom),\n\t            subscription = gmx.tileSubscriptions[zKey],\n\t            screenTile = null;\n\t        if (subscription) {\n\t            if (subscription.screenTile) {\n\t                screenTile = subscription.screenTile;\n\t            } else {\n\t                subscription.screenTile = screenTile = new _ScreenVectorTile.ScreenVectorTile(this, tilePoint, zoom);\n\t            }\n\t        }\n\t        return screenTile;\n\t    },\n\t\n\t    _gmxDrawTile: function _gmxDrawTile(tilePoint, zoom, data) {\n\t        var gmx = this._gmx,\n\t            cancelled = false,\n\t            screenTileDrawPromise = null,\n\t            def = new L.gmx.Deferred(function () {\n\t            cancelled = true;\n\t            screenTileDrawPromise && screenTileDrawPromise.cancel();\n\t        });\n\t\n\t        if (!this._map) {\n\t            def.reject();\n\t            return def;\n\t        }\n\t        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\n\t        if (screenTile) {\n\t            gmx.styleManager.deferred.then(function () {\n\t                if (!cancelled) {\n\t                    screenTileDrawPromise = screenTile.drawTile(data);\n\t                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\n\t                }\n\t            });\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _getTilesByBounds: function _getTilesByBounds(bounds) {\n\t        //   gmxTiles  bounds\n\t        var gmx = this._gmx,\n\t            zoom = this._map._zoom,\n\t            shiftX = gmx.shiftX || 0,\n\t\n\t        //  \n\t        shiftY = gmx.shiftY || 0,\n\t\n\t        //   + OSM\n\t        minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\n\t            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\n\t            screenBounds = this._map.getBounds(),\n\t            sw = screenBounds.getSouthWest(),\n\t            ne = screenBounds.getNorthEast(),\n\t            dx = 0;\n\t\n\t        if (ne.lng - sw.lng < 360) {\n\t            if (maxLatLng.lng < sw.lng) {\n\t                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\n\t            } else if (minLatLng.lng > ne.lng) {\n\t                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\n\t            }\n\t        }\n\t        minLatLng.lng += dx;\n\t        maxLatLng.lng += dx;\n\t\n\t        var pixelBounds = this._map.getPixelBounds(),\n\t            minPoint = this._map.project(minLatLng),\n\t            maxPoint = this._map.project(maxLatLng);\n\t\n\t        var minY, maxY, minX, maxX;\n\t        if (pixelBounds) {\n\t            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\n\t            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\n\t            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\n\t            minX = Math.floor((minX + shiftX) / 256);\n\t            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\n\t            maxX = Math.floor((maxX + shiftX) / 256);\n\t        } else {\n\t            minY = Math.floor((maxPoint.y + shiftY) / 256);\n\t            maxY = Math.floor((minPoint.y + shiftY) / 256);\n\t            minX = Math.floor((minPoint.x + shiftX) / 256);\n\t            maxX = Math.floor((maxPoint.x + shiftX) / 256);\n\t        }\n\t        var gmxTiles = {};\n\t        for (var x = minX; x <= maxX; x++) {\n\t            for (var y = minY; y <= maxY; y++) {\n\t                var zKey = this._tileCoordsToKey({ x: x, y: y }, zoom);\n\t                gmxTiles[zKey] = true;\n\t            }\n\t        }\n\t        return gmxTiles;\n\t    },\n\t\n\t    _updateProperties: function _updateProperties(prop) {\n\t        var gmx = this._gmx,\n\t            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\n\t\n\t        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\n\t\n\t        if (this.options.parentOptions) {\n\t            prop = this.options.parentOptions;\n\t        }\n\t\n\t        gmx.identityField = prop.identityField; // ogc_fid\n\t        gmx.GeometryType = (prop.GeometryType || '').toLowerCase(); //     \n\t        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1; // . zoom  \n\t        gmx.minZoomQuicklooks = gmx.minZoomRasters; //   minZoom     \n\t\n\t        var type = prop.type || 'Vector';\n\t        if (prop.Temporal) {\n\t            type += 'Temporal';\n\t        }\n\t        gmx.layerType = type; // VectorTemporal Vector\n\t        gmx.items = {};\n\t\n\t        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\n\t        if (gmx.dataManager) {\n\t            gmx.dataManager.setOptions(prop);\n\t        }\n\t        if ('ZIndexField' in prop) {\n\t            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\n\t                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField]; // sort field index\n\t            }\n\t        }\n\t        if (this._objectsReorder) {\n\t            this._objectsReorder.initialize();\n\t        }\n\t\n\t        // if ('clusters' in prop) {\n\t        // gmx.clusters = prop.clusters;\n\t        // }\n\t\n\t        gmx.filter = prop.filter; // for dataSource attr\n\t        gmx.dateBegin = prop.dateBegin;\n\t        gmx.dateEnd = prop.dateEnd;\n\t        gmx.dataSource = prop.dataSource;\n\t        if ('MetaProperties' in gmx.rawProperties) {\n\t            var meta = gmx.rawProperties.MetaProperties;\n\t            if ('parentLayer' in meta) {\n\t                //  \t\t// todo     \n\t                gmx.dataSource = meta.parentLayer.Value || '';\n\t            }\n\t            if ('filter' in meta) {\n\t                //  \n\t                gmx.filter = meta.filter.Value || '';\n\t            }\n\t            if ('dateBegin' in meta) {\n\t                //    \n\t                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\n\t            }\n\t            if ('dateEnd' in meta) {\n\t                //    \n\t                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\n\t            }\n\t            if ('shiftX' in meta || 'shiftY' in meta) {\n\t                //   \n\t                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\n\t                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\n\t            }\n\t            if ('shiftXfield' in meta || 'shiftYfield' in meta) {\n\t                //     \n\t                if (meta.shiftXfield) {\n\t                    gmx.shiftXfield = meta.shiftXfield.Value;\n\t                }\n\t                if (meta.shiftYfield) {\n\t                    gmx.shiftYfield = meta.shiftYfield.Value;\n\t                }\n\t            }\n\t            if ('quicklookPlatform' in meta) {\n\t                //  \n\t                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\n\t                if (gmx.quicklookPlatform === 'image') {\n\t                    delete gmx.quicklookPlatform;\n\t                }\n\t            }\n\t            if ('quicklookX1' in meta) {\n\t                gmx.quicklookX1 = meta.quicklookX1.Value;\n\t            }\n\t            if ('quicklookY1' in meta) {\n\t                gmx.quicklookY1 = meta.quicklookY1.Value;\n\t            }\n\t            if ('quicklookX2' in meta) {\n\t                gmx.quicklookX2 = meta.quicklookX2.Value;\n\t            }\n\t            if ('quicklookY2' in meta) {\n\t                gmx.quicklookY2 = meta.quicklookY2.Value;\n\t            }\n\t            if ('quicklookX3' in meta) {\n\t                gmx.quicklookX3 = meta.quicklookX3.Value;\n\t            }\n\t            if ('quicklookY3' in meta) {\n\t                gmx.quicklookY3 = meta.quicklookY3.Value;\n\t            }\n\t            if ('quicklookX4' in meta) {\n\t                gmx.quicklookX4 = meta.quicklookX4.Value;\n\t            }\n\t            if ('quicklookY4' in meta) {\n\t                gmx.quicklookY4 = meta.quicklookY4.Value;\n\t            }\n\t\n\t            if ('multiFilters' in meta) {\n\t                //      \n\t                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\n\t            }\n\t            if ('isGeneralized' in meta) {\n\t                // Set generalization\n\t                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\n\t            }\n\t            if ('isFlatten' in meta) {\n\t                // Set flatten geometry\n\t                this.options.isFlatten = meta.isFlatten.Value !== 'false';\n\t            }\n\t        }\n\t        if (prop.Temporal) {\n\t            // Clear generalization flag for Temporal layers\n\t            this.options.isGeneralized = false;\n\t        }\n\t\n\t        if (prop.IsRasterCatalog) {\n\t            gmx.IsRasterCatalog = prop.IsRasterCatalog;\n\t            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\n\t            if (layerLink) {\n\t                gmx.rasterBGfunc = function (x, y, z, item) {\n\t                    var properties = item.properties;\n\t                    return 'http://' + gmx.hostName + '/TileSender.ashx?ModeKey=tile' + '&x=' + x + '&y=' + y + '&z=' + z + '&LayerName=' + properties[layerLink] + '&key=' + encodeURIComponent(gmx.sessionKey);\n\t                };\n\t            }\n\t        }\n\t        if (prop.Quicklook) {\n\t            var quicklookParams;\n\t\n\t            //       ,    JSON'\n\t            if (prop.Quicklook[0] === '{') {\n\t                quicklookParams = JSON.parse(prop.Quicklook);\n\t            } else {\n\t                quicklookParams = {\n\t                    minZoom: gmx.minZoomRasters,\n\t                    template: prop.Quicklook\n\t                };\n\t            }\n\t\n\t            if ('X1' in quicklookParams) {\n\t                gmx.quicklookX1 = quicklookParams.X1;\n\t            }\n\t            if ('Y1' in quicklookParams) {\n\t                gmx.quicklookY1 = quicklookParams.Y1;\n\t            }\n\t            if ('X2' in quicklookParams) {\n\t                gmx.quicklookX2 = quicklookParams.X2;\n\t            }\n\t            if ('Y2' in quicklookParams) {\n\t                gmx.quicklookY2 = quicklookParams.Y2;\n\t            }\n\t            if ('X3' in quicklookParams) {\n\t                gmx.quicklookX3 = quicklookParams.X3;\n\t            }\n\t            if ('Y3' in quicklookParams) {\n\t                gmx.quicklookY3 = quicklookParams.Y3;\n\t            }\n\t            if ('X4' in quicklookParams) {\n\t                gmx.quicklookX4 = quicklookParams.X4;\n\t            }\n\t            if ('Y4' in quicklookParams) {\n\t                gmx.quicklookY4 = quicklookParams.Y4;\n\t            }\n\t\n\t            var template = gmx.Quicklook = quicklookParams.template;\n\t            if ('minZoom' in quicklookParams) {\n\t                gmx.minZoomQuicklooks = quicklookParams.minZoom;\n\t            }\n\t            gmx.quicklookBGfunc = function (item) {\n\t                var url = template,\n\t                    reg = /\\[([^\\]]+)\\]/,\n\t                    matches = reg.exec(url);\n\t                while (matches && matches.length > 1) {\n\t                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\n\t                    matches = reg.exec(url);\n\t                }\n\t                return url;\n\t            };\n\t            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\n\t        }\n\t        this.options.attribution = prop.Copyright || '';\n\t    },\n\t\n\t    _onVersionChange: function _onVersionChange() {\n\t        this._updateProperties(this._gmx.rawProperties);\n\t    },\n\t\n\t    getViewRasters: function getViewRasters() {\n\t        var gmx = this._gmx,\n\t            hash = {},\n\t            out = [];\n\t\n\t        for (var zKey in gmx.tileSubscriptions) {\n\t            var subscription = gmx.tileSubscriptions[zKey],\n\t                screenTile = subscription.screenTile;\n\t            if (screenTile) {\n\t                screenTile.itemsView.forEach(function (it) {\n\t                    hash[it.id] = true;\n\t                });\n\t            }\n\t        }\n\t        for (var id in hash) {\n\t            out.push(id);\n\t        }\n\t\n\t        return out;\n\t    },\n\t\n\t    getPropItem: function getPropItem(key, propArr) {\n\t        return _Utils.gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\n\t    }\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.StyleManager = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tvar StyleManager = function StyleManager(gmx) {\n\t    this.gmx = gmx;\n\t    this.deferred = new L.gmx.Deferred();\n\t\n\t    this._maxVersion = 0;\n\t    this._maxStyleSize = 0;\n\t    this._styles = [];\n\t    this._deferredIcons = [];\n\t    this._parserFunctions = {};\n\t    this._serverStylesParsed = false;\n\t\n\t    var minZoom = Infinity,\n\t        maxZoom = -Infinity,\n\t        arr = gmx.properties.styles || [];\n\t\n\t    for (var i = 0, len = arr.length; i < len; i++) {\n\t        var st = arr[i];\n\t        minZoom = Math.min(minZoom, st.MinZoom);\n\t        maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t    }\n\t    this.minZoom = minZoom === Infinity ? 0 : minZoom;\n\t    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\n\t};\n\tStyleManager.prototype = {\n\t    _getMaxStyleSize: function _getMaxStyleSize(zoom) {\n\t        // estimete style size for arbitrary object\n\t        var maxSize = 0;\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom > style.MaxZoom || zoom < style.MinZoom) {\n\t                continue;\n\t            }\n\t            var RenderStyle = style.RenderStyle;\n\t            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\n\t            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\n\t                maxSize = StyleManager.MAX_STYLE_SIZE;\n\t                break;\n\t            }\n\t            var maxShift = 0;\n\t            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\n\t                maxShift = Math.max(Math.abs(RenderStyle.iconAnchor[0]), Math.abs(RenderStyle.iconAnchor[1]));\n\t            }\n\t            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\n\t        }\n\t        return maxSize;\n\t    },\n\t\n\t    getStyleBounds: function getStyleBounds(gmxTilePoint) {\n\t        if (!gmxTilePoint) {\n\t            return _Utils.gmxAPIutils.bounds();\n\t        }\n\t\n\t        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\n\t\n\t        var mercSize = 2 * this._maxStyleSize * _Utils.gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\n\t        return _Utils.gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\n\t    },\n\t\n\t    //is any style is visible at given zoom?\n\t    isVisibleAtZoom: function isVisibleAtZoom(zoom) {\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = this._styles[i];\n\t            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t\n\t    getIcons: function getIcons(callback) {\n\t        var _this = this;\n\t        this.deferred.then(function () {\n\t            var out = [];\n\t            for (var i = 0, len = _this._styles.length; i < len; i++) {\n\t                var style = _this._styles[i],\n\t                    pt = {};\n\t                if (style.RenderStyle) {\n\t                    pt.RenderStyle = { image: style.RenderStyle.image };\n\t                }\n\t                if (style.HoverStyle) {\n\t                    pt.HoverStyle = { image: style.HoverStyle.image };\n\t                }\n\t                out.push(pt);\n\t            }\n\t            if (callback) {\n\t                callback(out);\n\t            }\n\t        });\n\t        this.initStyles();\n\t    },\n\t\n\t    _chkReady: function _chkReady() {\n\t        if (this._needLoadIcons < 1) {\n\t            var _this = this;\n\t            if (this.gmx.dataManager) {\n\t                this.gmx.dataManager.addFilter('styleFilter', function (it) {\n\t                    return _this._chkStyleFilter(it);\n\t                });\n\t            }\n\t            this.deferred.resolve();\n\t        }\n\t    },\n\t\n\t    initStyles: function initStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\n\t            this._getImageSize(this._deferredIcons[i]);\n\t        }\n\t        this._deferredIcons = [];\n\t        this._chkReady();\n\t        return this.deferred;\n\t    },\n\t\n\t    getStyles: function getStyles() {\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        var out = [];\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var style = L.extend({}, this._styles[i]);\n\t            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\n\t            if (style.HoverStyle) {\n\t                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\n\t            }\n\t            delete style.filterFunction;\n\t            delete style.version;\n\t            delete style.common;\n\t            delete style.type;\n\t            out.push(style);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    clearStyles: function clearStyles() {\n\t        this._styles = [];\n\t        this.gmx.balloonEnable = false;\n\t        this.gmx.labelsLayer = false;\n\t    },\n\t\n\t    _changeStylesVersion: function _changeStylesVersion() {\n\t        var _this = this;\n\t        this._styles.map(function (it) {\n\t            it.version = ++_this._maxVersion;\n\t        });\n\t    },\n\t\n\t    setStyle: function setStyle(st, num, createFlag) {\n\t        num = num || 0;\n\t        if (num < this._styles.length || createFlag) {\n\t            var style = this._styles[num];\n\t            if (!style) {\n\t                style = this._prepareItem({});\n\t                this._styles[num] = style;\n\t            }\n\t            this.deferred = new L.gmx.Deferred();\n\t            style.version = ++this._maxVersion;\n\t            if ('Filter' in st) {\n\t                style.Filter = st.Filter;\n\t                var type = _typeof(st.Filter);\n\t                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"')) : type === 'function' ? style.Filter : null;\n\t\n\t                this._changeStylesVersion();\n\t            }\n\t            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\n\t                var key = StyleManager.DEFAULT_KEYS[i];\n\t                if (key in st) {\n\t                    style[key] = st[key];\n\t                }\n\t            }\n\t            if (st.RenderStyle) {\n\t                style.RenderStyle = this._parseStyle(st.RenderStyle);\n\t            }\n\t            if (st.HoverStyle) {\n\t                style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle);\n\t            }\n\t            this._checkStyles();\n\t        }\n\t        return this.initStyles();\n\t    },\n\t\n\t    getItemBalloon: function getItemBalloon(id) {\n\t        var item = this.gmx.dataManager.getItem(id),\n\t            currentFilter = item ? item.currentFilter : 0,\n\t            style = this._styles[currentFilter];\n\t        return style ? {\n\t            DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\n\t            DisableBalloonOnClick: style.DisableBalloonOnClick || false,\n\t            templateBalloon: style.Balloon || null,\n\t            isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\n\t        } : null;\n\t    },\n\t\n\t    // apply styleHook func\n\t    // applyStyleHook: function(item, hoverFlag) {\n\t    // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\n\t    // },\n\t\n\t    getObjStyle: function getObjStyle(item) {\n\t        this._chkStyleFilter(item);\n\t        var style = this._styles[item.currentFilter],\n\t            version;\n\t\n\t        if (!style) {\n\t            return null;\n\t        }\n\t        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\n\t            if (style.HoverStyle) {\n\t                version = style.HoverStyle.version || -1;\n\t                if (version !== item.styleVersion) {\n\t                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\n\t                }\n\t                return style.HoverStyle;\n\t            } else {\n\t                delete item.parsedStyleHover;\n\t            }\n\t            return null;\n\t        }\n\t        version = style.version || -1;\n\t        if (version !== item.styleVersion) {\n\t            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\n\t        }\n\t        return style.RenderStyle;\n\t    },\n\t\n\t    _needLoadIcons: 0,\n\t    _getImageSize: function _getImageSize(pt) {\n\t        // check image size\n\t        var url = pt.iconUrl || pt.fillIconUrl,\n\t            opt = pt.iconAngle || pt.iconScale ? { crossOrigin: 'anonymous' } : {},\n\t            _this = this;\n\t\n\t        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t            opt = {}; // skip bug in IE11\n\t        }\n\t        opt.layerID = this.gmx.layerID;\n\t        ++this._needLoadIcons;\n\t        L.gmx.imageLoader.unshift(url, opt).def.then(function (it) {\n\t            pt.version = ++_this._maxVersion;\n\t            if (pt.fillIconUrl) {\n\t                pt.imagePattern = it;\n\t            } else {\n\t                var w = it.width,\n\t                    h = it.height;\n\t                if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\n\t                    // skip bug in IE11\n\t                    document.body.appendChild(it);\n\t                    w = it.offsetWidth;\n\t                    h = it.offsetHeight;\n\t                    document.body.removeChild(it);\n\t                }\n\t                pt.sx = w;\n\t                pt.sy = h;\n\t                pt.image = it;\n\t                var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\n\t                if (!pt.scaleFunction && !pt.rotateFunction) {\n\t                    if (pt.iconScale || pt.iconScale === 1) {\n\t                        maxSize *= pt.iconScale;\n\t                    }\n\t                    pt.common = true;\n\t                }\n\t                pt.maxSize = Number(maxSize.toFixed());\n\t            }\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t        }, function () {\n\t            pt.version = ++_this._maxVersion;\n\t            pt.sx = 1;\n\t            pt.sy = 0;\n\t            pt.image = null;\n\t            _this._needLoadIcons--;\n\t            _this._chkReady();\n\t            console.log({ url: url, func: '_getImageSize', Error: 'image not found' });\n\t        });\n\t    },\n\t\n\t    getCurrentFilters: function getCurrentFilters(propArray, zoom) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            types = gmx.tileAttributeTypes,\n\t            z = zoom || 1,\n\t            out = [];\n\t\n\t        if (!this._serverStylesParsed) {\n\t            this._parseServerStyles();\n\t        }\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t            if (z > st.MaxZoom || z < st.MinZoom || st.filterFunction && !st.filterFunction(propArray, indexes, types)) {\n\t                continue;\n\t            }\n\t            out.push(i);\n\t            if (!gmx.multiFilters) {\n\t                break;\n\t            }\n\t        }\n\t        return out;\n\t    },\n\t\n\t    _chkStyleFilter: function _chkStyleFilter(item) {\n\t        var gmx = this.gmx,\n\t            zoom = gmx.currentZoom,\n\t            fnum = gmx.multiFilters ? -1 : item.currentFilter,\n\t            curr = this._styles[fnum],\n\t            needParse = !curr || curr.version !== item.styleVersion;\n\t\n\t        if (needParse || item._lastZoom !== zoom) {\n\t            item.currentFilter = -1;\n\t            item.multiFilters = [];\n\t            var filters = this.getCurrentFilters(item.properties, zoom);\n\t            for (var i = 0, len = filters.length; i < len; i++) {\n\t                var num = filters[i],\n\t                    st = this._styles[num];\n\t                item.hoverDiff = st.hoverDiff;\n\t                item.currentFilter = num;\n\t                if (needParse || fnum !== num) {\n\t                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\n\t                        parsedHover = null;\n\t\n\t                    item.parsedStyleKeys = parsed;\n\t                    if (st.HoverStyle) {\n\t                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\n\t                        item.parsedStyleHover = parsedHover;\n\t                    }\n\t                    if (gmx.multiFilters) {\n\t                        item.multiFilters.push({\n\t                            style: st.RenderStyle,\n\t                            styleHover: st.HoverStyle,\n\t                            parsedStyle: parsed,\n\t                            parsedStyleHover: parsedHover\n\t                        });\n\t                    }\n\t                }\n\t                item.styleVersion = st.version;\n\t                if (!gmx.multiFilters) {\n\t                    break;\n\t                }\n\t            }\n\t            item._lastZoom = zoom;\n\t        }\n\t        if (this._styles[item.currentFilter]) {\n\t            return true;\n\t        } else {\n\t            item.currentFilter = -1;\n\t            return false;\n\t        }\n\t    },\n\t\n\t    _parseServerStyles: function _parseServerStyles() {\n\t        var gmx = this.gmx,\n\t            props = gmx.properties,\n\t            arr = props.styles || [{ MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE }],\n\t            len = Math.max(arr.length, gmx.styles.length);\n\t\n\t        for (var i = 0; i < len; i++) {\n\t            if (!this._styles[i]) {\n\t                var gmxStyle = gmx.styles[i] || arr[i];\n\t                if (!gmxStyle.RenderStyle) {\n\t                    gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE;\n\t                }\n\t                if (gmxStyle.HoverStyle === undefined) {\n\t                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\n\t                    if (hoveredStyle.outline) {\n\t                        hoveredStyle.outline.thickness += 1;\n\t                    }\n\t                    gmxStyle.HoverStyle = hoveredStyle;\n\t                } else if (gmxStyle.HoverStyle === null) {\n\t                    delete gmxStyle.HoverStyle;\n\t                }\n\t                var pt = this._prepareItem(gmxStyle);\n\t                this._styles.push(pt);\n\t                if (this._isLabel(pt.RenderStyle)) {\n\t                    gmx.labelsLayer = true;\n\t                }\n\t            }\n\t        }\n\t        this._checkStyles();\n\t        this._serverStylesParsed = true;\n\t    },\n\t\n\t    _checkStyles: function _checkStyles() {\n\t        var minZoom = Infinity,\n\t            maxZoom = -Infinity,\n\t            balloonEnable = false,\n\t            labelsLayer = false;\n\t\n\t        for (var i = 0, len = this._styles.length; i < len; i++) {\n\t            var st = this._styles[i];\n\t\n\t            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\n\t            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\n\t            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\n\t                balloonEnable = true;\n\t                st.BalloonEnable = true;\n\t            }\n\t            st.hoverDiff = null;\n\t            st.common = {};\n\t            if (st.RenderStyle) {\n\t                if (!labelsLayer) {\n\t                    if (this._isLabel(st.RenderStyle)) {\n\t                        labelsLayer = true;\n\t                    }\n\t                }\n\t                if (st.RenderStyle.common) {\n\t                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\n\t                }\n\t                if (st.HoverStyle) {\n\t                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\n\t                }\n\t            }\n\t            if (st.HoverStyle && st.HoverStyle.common) {\n\t                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\n\t            }\n\t            minZoom = Math.min(minZoom, st.MinZoom);\n\t            maxZoom = Math.max(maxZoom, st.MaxZoom);\n\t        }\n\t        if (this.minZoom !== Infinity) {\n\t            this.minZoom = minZoom;\n\t        }\n\t        if (this.maxZoom !== -Infinity) {\n\t            this.maxZoom = maxZoom;\n\t        }\n\t        this.gmx.balloonEnable = balloonEnable;\n\t        this.gmx.labelsLayer = labelsLayer;\n\t    },\n\t\n\t    _parseStyle: function _parseStyle(st, renderStyle) {\n\t        if (st) {\n\t            st.common = true;\n\t            for (var key in st) {\n\t                if (_Utils.gmxAPIutils.styleFuncKeys[key]) {\n\t                    var fkey = _Utils.gmxAPIutils.styleFuncKeys[key],\n\t                        val = st[key];\n\t                    if (typeof val === 'string') {\n\t                        st.common = false;\n\t                        if (renderStyle && renderStyle[key] === val) {\n\t                            st[fkey] = renderStyle[fkey];\n\t                        } else {\n\t                            if (!this._parserFunctions[val]) {\n\t                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\n\t                            }\n\t                            st[fkey] = this._parserFunctions[val];\n\t                        }\n\t                    } else if (typeof val === 'function') {\n\t                        st.common = false;\n\t                        st[fkey] = val;\n\t                    }\n\t                }\n\t            }\n\t\n\t            var type = '';\n\t            if ('iconUrl' in st) {\n\t                type = 'image';\n\t                if (st.iconUrl) {\n\t                    st.maxSize = 256;\n\t                    this._deferredIcons.push(st);\n\t                }\n\t            } else if (st.fillIconUrl) {\n\t                type = 'square';\n\t                this._deferredIcons.push(st);\n\t            } else if (st.fillPattern) {\n\t                type = 'square';\n\t                st.common = StyleManager.parsePattern(st.fillPattern);\n\t                st.canvasPattern = _Utils.gmxAPIutils.getPatternIcon(null, st);\n\t            } else if (st.iconCircle) {\n\t                type = 'circle';\n\t                if (!('iconSize' in st)) {\n\t                    st.iconSize = 4;\n\t                }\n\t            } else if (st.iconPath) {\n\t                type = 'iconPath';\n\t                var iconSize = 0,\n\t                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\n\t                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function (it, i) {\n\t                    var z = arr[i] || it;\n\t                    iconSize = Math.max(iconSize, z);\n\t                    return z;\n\t                });\n\t                st.iconSize = 2 * iconSize;\n\t            } else if (st.fillRadialGradient) {\n\t                type = 'circle';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\n\t                if (size === null) {\n\t                    st.common = false;\n\t                } else {\n\t                    st.iconSize = size;\n\t                }\n\t            } else if (st.fillLinearGradient) {\n\t                type = 'square';\n\t                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\n\t            } else if (st.iconSize) {\n\t                type = 'square';\n\t                if (!('iconCenter' in st)) {\n\t                    st.iconCenter = true;\n\t                }\n\t            }\n\t            st.type = type;\n\t            if (st.common && !st.maxSize) {\n\t                st.maxSize = st.iconSize || 0;\n\t                st.maxSize += st.weight ? st.weight : 0;\n\t                if ('iconScale' in st) {\n\t                    st.maxSize *= st.iconScale;\n\t                }\n\t            }\n\t        }\n\t        return st;\n\t    },\n\t\n\t    _prepareItem: function _prepareItem(style) {\n\t        // Style Scanex->leaflet\n\t        var pt = {\n\t            MinZoom: style.MinZoom || 0,\n\t            MaxZoom: style.MaxZoom || 18,\n\t            Filter: style.Filter || null,\n\t            Balloon: style.Balloon || '',\n\t            RenderStyle: style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {},\n\t            version: ++this._maxVersion\n\t        };\n\t        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\n\t        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\n\t        if (style.HoverStyle) {\n\t            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\n\t        }\n\t\n\t        if ('Filter' in style) {\n\t            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\n\t            if (ph) {\n\t                pt.filterFunction = ph;\n\t            }\n\t        }\n\t        return pt;\n\t    },\n\t\n\t    _isLabel: function _isLabel(st) {\n\t        var indexes = this.gmx.tileAttributeIndexes;\n\t        return st && (st.labelTemplate || st.labelField && st.labelField in indexes);\n\t    },\n\t\n\t    _itemStyleParser: function _itemStyleParser(item, pt) {\n\t        pt = pt || {};\n\t        var out = {},\n\t            arr,\n\t            i,\n\t            len,\n\t            indexes = this.gmx.tileAttributeIndexes,\n\t            prop = item.properties || {},\n\t            itemType = item.type,\n\t            type = pt.type,\n\t            color = 'color' in pt ? pt.color : 255,\n\t            opacity = 'opacity' in pt ? pt.opacity : 1;\n\t\n\t        out.sx = pt.sx;\n\t        out.sy = pt.sy;\n\t        if (pt.maxSize) {\n\t            out.maxSize = pt.maxSize;\n\t        }\n\t        if (pt.iconAngle) {\n\t            var rotateRes = pt.iconAngle || 0;\n\t            if (rotateRes && typeof rotateRes === 'string') {\n\t                rotateRes = pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0;\n\t            }\n\t            out.rotate = rotateRes || 0;\n\t        }\n\t        if ('iconColor' in pt) {\n\t            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\n\t        }\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if (type === 'image') {\n\t            out.type = type;\n\t            if (pt.iconUrl) {\n\t                out.iconUrl = pt.iconUrl;\n\t            }\n\t            if (pt.image) {\n\t                out.image = pt.image;\n\t            }\n\t        } else if (pt.fillRadialGradient) {\n\t            var rgr = pt.fillRadialGradient,\n\t                r1 = rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1,\n\t                r2 = rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2,\n\t                x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\n\t                y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\n\t                x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\n\t                y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2;\n\t            if (rgr.r2max) {\n\t                r2 = Math.min(r2, rgr.r2max);\n\t            }\n\t            var colorStop = [];\n\t            len = rgr.addColorStop.length;\n\t            if (!rgr.addColorStopFunctions) {\n\t                rgr.addColorStopFunctions = new Array(len);\n\t            }\n\t            for (i = 0; i < len; i++) {\n\t                arr = rgr.addColorStop[i];\n\t                var arrFunc = rgr.addColorStopFunctions[i] || [],\n\t                    p0 = arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0],\n\t                    p3 = arr[3];\n\t                if (arr.length < 4) {\n\t                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\n\t                    p3 = _Utils.gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\n\t                }\n\t                colorStop.push([p0, p3]);\n\t            }\n\t            out.maxSize = out.sx = out.sy = out.iconSize = r2;\n\t            out.fillRadialGradient = {\n\t                x1: x1, y1: y1, r1: r1, x2: x2, y2: y2, r2: r2,\n\t                addColorStop: colorStop\n\t            };\n\t            out._radialGradientParsed = {\n\t                create: [x1, y1, r1, x2, y2, r2],\n\t                colorStop: colorStop\n\t            };\n\t        } else if (pt.fillLinearGradient) {\n\t            out.fillLinearGradient = pt.fillLinearGradient;\n\t        } else {\n\t            if (pt.fillPattern) {\n\t                out.canvasPattern = pt.canvasPattern ? pt.canvasPattern : _Utils.gmxAPIutils.getPatternIcon(item, pt, indexes);\n\t            }\n\t\n\t            if (type === 'iconPath') {\n\t                out.type = type;\n\t                out.iconPath = pt.iconPath;\n\t            }\n\t\n\t            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\n\t                type = 'polygon';\n\t            }\n\t            if (pt.iconSize) {\n\t                var iconSize = 'sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize;\n\t                out.sx = out.sy = iconSize;\n\t                // iconSize += pt.weight ? pt.weight : 0;\n\t                out.iconSize = iconSize;\n\t                if ('iconScale' in pt) {\n\t                    out.iconSize *= pt.iconScale;\n\t                }\n\t                out.maxSize = iconSize;\n\t            }\n\t            out.stroke = true;\n\t            if ('colorFunction' in pt || 'opacityFunction' in pt) {\n\t                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\n\t                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\n\t            }\n\t            out.strokeStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            out.lineWidth = 'weight' in pt ? pt.weight : 1;\n\t        }\n\t\n\t        if ('iconScale' in pt) {\n\t            out.iconScale = 'scaleFunction' in pt ? pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1 : pt.iconScale;\n\t        }\n\t        if ('iconAnchor' in pt) {\n\t            out.iconAnchor = pt.iconAnchor;\n\t        }\n\t        if ('iconCenter' in pt) {\n\t            out.iconCenter = pt.iconCenter;\n\t        }\n\t\n\t        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\n\t            out.type = type;\n\t            var fop = pt.fillOpacity,\n\t                fc = pt.fillColor,\n\t                fcDec = typeof fc === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\n\t\n\t            if ('fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, 1);\n\t            }\n\t            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\n\t                color = 'fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255;\n\t                opacity = 'fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1;\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(color, opacity);\n\t            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\n\t                out.fillStyle = _Utils.gmxAPIutils.dec2color(fcDec, fop);\n\t            }\n\t        }\n\t\n\t        if ('dashArray' in pt) {\n\t            out.dashArray = pt.dashArray;\n\t        }\n\t        if ('dashOffset' in pt) {\n\t            out.dashOffset = pt.dashOffset;\n\t        }\n\t\n\t        if (this.gmx.labelsLayer) {\n\t            arr = _Utils.gmxAPIutils.styleKeys.label.client;\n\t            for (i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i];\n\t                if (it in pt) {\n\t                    if (it === 'labelField') {\n\t                        if (!indexes[pt[it]]) {\n\t                            continue;\n\t                        }\n\t                    } else if (it === 'labelTemplate') {\n\t                        var properties = _Utils.gmxAPIutils.getPropertiesHash(prop, indexes);\n\t                        out.labelText = _Utils.gmxAPIutils.parseTemplate(pt[it], properties);\n\t                    }\n\t                    out[it] = pt[it];\n\t                }\n\t            }\n\t            if ('labelAnchor' in pt) {\n\t                out.labelAnchor = pt.labelAnchor;\n\t            }\n\t        }\n\t        return out;\n\t    }\n\t};\n\tStyleManager.MAX_STYLE_SIZE = 256;\n\t//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\n\tStyleManager.DEFAULT_STYLE = { outline: { color: 255, thickness: 1 }, marker: { size: 8 } };\n\tStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\n\tStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10]; // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\n\t\n\tStyleManager.parsePattern = function (pattern) {\n\t    var common = true,\n\t        parsers = L.gmx.Parsers;\n\t    if ('step' in pattern && typeof pattern.step === 'string') {\n\t        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\n\t        common = false;\n\t    }\n\t    if ('width' in pattern && typeof pattern.width === 'string') {\n\t        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\n\t        common = false;\n\t    }\n\t    if ('colors' in pattern) {\n\t        var arr = [];\n\t        for (var i = 0, len = pattern.colors.length; i < len; i++) {\n\t            var rt = pattern.colors[i];\n\t            if (typeof rt === 'string') {\n\t                arr.push(parsers.parseExpression(rt));\n\t                common = false;\n\t            } else {\n\t                arr.push(null);\n\t            }\n\t        }\n\t        pattern.patternColorsFunction = arr;\n\t    }\n\t    return common;\n\t};\n\t\n\tStyleManager.getStyleKeys = function (style) {\n\t    var out = {};\n\t    for (var key in _Utils.gmxAPIutils.styleKeys) {\n\t        var keys = _Utils.gmxAPIutils.styleKeys[key];\n\t        for (var i = 0, len = keys.client.length; i < len; i++) {\n\t            var key1 = keys.client[i];\n\t            if (key1 in style) {\n\t                if (style[key1] !== undefined) {\n\t                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\n\t                }\n\t                if (key1 === 'fillPattern') {\n\t                    delete out[key1].patternColorsFunction;\n\t                } else if (key1 === 'fillLinearGradient') {\n\t                    delete out[key1].addColorStopFunctions;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if ('iconAnchor' in style) {\n\t        out.iconAnchor = style.iconAnchor;\n\t    }\n\t    if ('labelAnchor' in style) {\n\t        out.labelAnchor = style.labelAnchor;\n\t    }\n\t    return out;\n\t};\n\t\n\tStyleManager.checkDiff = function (st, st1) {\n\t    for (var key in st) {\n\t        if (st[key] !== st1[key]) {\n\t            return key;\n\t        }\n\t    }\n\t    return null;\n\t};\n\t\n\tStyleManager.parseRadialGradient = function (rg) {\n\t    //\tx1,y1,r1       ;\n\t    //\tx2,y2,r2       .\n\t    //\taddColorStop -     [[position, color]...]\n\t    //\t\tposition     .      0.0 ()  1.0 ();\n\t    //\t\tcolor     .\n\t    //\t\topacity  \n\t    //\t\tcanvasStyleColor      canvas\n\t    var common = true,\n\t        parsers = L.gmx.Parsers,\n\t        i = 0,\n\t        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (!rg[it]) {\n\t            rg[it] = 0;\n\t        }\n\t        if (typeof rg[it] === 'string') {\n\t            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\n\t            common = false;\n\t        }\n\t    }\n\t\n\t    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\n\t    rg.addColorStopFunctions = [];\n\t    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\n\t        arr = rg.addColorStop[i];\n\t        var resFunc = [typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null];\n\t        rg.addColorStopFunctions.push(resFunc);\n\t        if (resFunc[1] === null && resFunc[2] === null) {\n\t            arr[3] = _Utils.gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\n\t        } else {\n\t            common = false;\n\t        }\n\t    }\n\t    if ('r2Function' in rg) {\n\t        common = false;\n\t    }\n\t    return common ? Math.max(rg.r1, rg.r2) : null;\n\t};\n\t\n\tStyleManager.parseLinearGradient = function (lg) {\n\t    var common = true;\n\t    //\tx1,y1    \n\t    //\tx2,y2    \n\t    //\taddColorStop -     [[position, color]...]\n\t    //\t\tposition     .      0.0 ()  1.0 ();\n\t    //\t\tcolor     .\n\t    //\t\topacity  \n\t    var i = 0,\n\t        parsers = L.gmx.Parsers,\n\t        arr = ['x1', 'y1', 'x2', 'y2'],\n\t        def = [0, 0, 0, 256],\n\t        len = arr.length;\n\t    for (i = 0; i < len; i++) {\n\t        var it = arr[i];\n\t        if (it in lg) {\n\t            if (typeof lg[it] === 'string') {\n\t                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\n\t                common = false;\n\t            }\n\t        } else {\n\t            lg[it] = def[i];\n\t        }\n\t    }\n\t\n\t    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\n\t    lg.addColorStopFunctions = [];\n\t    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\n\t        arr = lg.addColorStop[i];\n\t        lg.addColorStopFunctions.push([typeof arr[0] === 'string' ? parsers.parseExpression(arr[0]) : null, typeof arr[1] === 'string' ? parsers.parseExpression(arr[1]) : null, typeof arr[2] === 'string' ? parsers.parseExpression(arr[2]) : null]);\n\t    }\n\t    return common;\n\t};\n\texports.StyleManager = StyleManager;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ScreenVectorTile = undefined;\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t// Single tile on screen with vector data\n\tfunction ScreenVectorTile(layer, tilePoint, zoom) {\n\t    this.layer = layer;\n\t    this.tilePoint = tilePoint;\n\t    this.zoom = zoom;\n\t    this.gmx = layer._gmx;\n\t    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\n\t    var utils = _Utils.gmxAPIutils;\n\t    this.worldWidthMerc = utils.worldWidthMerc;\n\t    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\n\t    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\n\t    this.tpx = 256 * gmxTilePoint.x;\n\t    this.tpy = 256 * (1 + gmxTilePoint.y);\n\t    this.gmxTilePoint = gmxTilePoint;\n\t\n\t    this.showRaster = zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx || zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx;\n\t    this.rasters = {}; //combined and processed canvases for each vector item in tile\n\t    this.rasterRequests = {}; // all cached raster requests\n\t    this.itemsView = []; // items on screen tile + todo: without not visible\n\t    this._uniqueID = 0; // draw attempt id\n\t    this.gmx.badTiles = this.gmx.badTiles || {};\n\t}\n\t\n\tScreenVectorTile.prototype = {\n\t\n\t    //return promise, which resolves with object {gtp, image}\n\t    _loadTileRecursive: function _loadTileRecursive(gtp, urlFunction) {\n\t        var gmx = this.gmx,\n\t            _this = this,\n\t            requestPromise = null,\n\t            currentUrl,\n\t            def = new L.gmx.Deferred(function () {\n\t            if (requestPromise) {\n\t                //don't store cancelled requests in request cache\n\t                delete _this.rasterRequests[currentUrl];\n\t                requestPromise.cancel();\n\t            }\n\t        });\n\t\n\t        var tryLoad = function tryLoad(gtp, crossOrigin) {\n\t            var rUrl = urlFunction(gtp);\n\t\n\t            var tryHigherLevelTile = function tryHigherLevelTile() {\n\t                if (gtp.z > 1) {\n\t                    tryLoad({\n\t                        x: Math.floor(gtp.x / 2),\n\t                        y: Math.floor(gtp.y / 2),\n\t                        z: gtp.z - 1\n\t                    }, ''); // 'anonymous' 'use-credentials'\n\t                } else {\n\t                    def.reject();\n\t                }\n\t            };\n\t\n\t            if (gmx.badTiles[rUrl] || gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z) {\n\t                tryHigherLevelTile();\n\t                return;\n\t            }\n\t            var request = _this.rasterRequests[rUrl];\n\t            if (!request) {\n\t                if (gmx.rasterProcessingHook) {\n\t                    crossOrigin = 'anonymous';\n\t                }\n\t                request = L.gmx.imageLoader.push(rUrl, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    zoom: _this.zoom,\n\t                    cache: true,\n\t                    crossOrigin: crossOrigin || ''\n\t                });\n\t                _this.rasterRequests[rUrl] = request;\n\t            } else {\n\t                request.options.tileRastersId = _this._uniqueID;\n\t            }\n\t            currentUrl = rUrl;\n\t            requestPromise = request.def;\n\t\n\t            requestPromise.then(function (imageObj) {\n\t                def.resolve({ gtp: gtp, image: imageObj });\n\t            }, function () {\n\t                gmx.badTiles[rUrl] = true;\n\t                tryHigherLevelTile();\n\t            });\n\t        };\n\t\n\t        tryLoad(gtp);\n\t        return def;\n\t    },\n\t\n\t    _rasterHook: function _rasterHook(attr) {\n\t        var source = attr.sourceTilePoint || attr.destinationTilePoint,\n\t            info = {\n\t            geoItem: attr.geoItem,\n\t            destination: {\n\t                z: attr.destinationTilePoint.z,\n\t                x: attr.destinationTilePoint.x,\n\t                y: attr.destinationTilePoint.y\n\t            },\n\t            source: {\n\t                z: source.z,\n\t                x: source.x,\n\t                y: source.y\n\t            }\n\t        };\n\t        if (attr.url) {\n\t            info.quicklook = attr.url;\n\t        }\n\t        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(attr.res, attr.image, attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256, attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256, info);\n\t    },\n\t\n\t    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\n\t    _defaultRasterHook: function _defaultRasterHook(res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\n\t        var ptx = res.getContext('2d');\n\t        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\n\t    },\n\t\n\t    // get pixels parameters for shifted object\n\t    _getShiftPixels: function _getShiftPixels(it) {\n\t        var w = it.dx + (it.dx < 0 ? 256 : 0),\n\t            h = it.dy + (it.dy < 0 ? 256 : 0),\n\t            sx = 0,\n\t            sw = 256 - w,\n\t            dx = w,\n\t            dw = sw;\n\t        if (it.tx > it.x) {\n\t            sx = sw;sw = w;dx = 0;dw = sw;\n\t        }\n\t        if (sx === 256 || sw < 1) {\n\t            return null;\n\t        }\n\t\n\t        var sy = h,\n\t            sh = 256 - h,\n\t            dy = 0,\n\t            dh = sh;\n\t        if (it.ty > it.y) {\n\t            sy = 0;dy = sh;sh = h;dh = sh;\n\t        }\n\t        if (sy === 256 || sh < 1) {\n\t            return null;\n\t        }\n\t\n\t        return {\n\t            sx: sx, sy: sy, sw: sw, sh: sh,\n\t            dx: dx, dy: dy, dw: dw, dh: dh\n\t        };\n\t    },\n\t\n\t    // get tiles parameters for shifted object\n\t    _getShiftTilesArray: function _getShiftTilesArray(bounds, shiftX, shiftY) {\n\t        var mInPixel = this.gmx.mInPixel,\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            px = shiftX * mInPixel,\n\t            py = shiftY * mInPixel,\n\t            deltaX = Math.floor(0.5 + px % 256),\n\t\n\t        // shift on tile in pixel\n\t        deltaY = Math.floor(0.5 + py % 256),\n\t            tileSize = 256 / mInPixel,\n\t            tminX = gmxTilePoint.x - shiftX / tileSize,\n\t\n\t        // by screen tile\n\t        tminY = gmxTilePoint.y - shiftY / tileSize,\n\t            rminX = Math.floor(tminX),\n\t            rmaxX = rminX + (tminX === rminX ? 0 : 1),\n\t            rminY = Math.floor(tminY),\n\t            rmaxY = rminY + (tminY === rminY ? 0 : 1),\n\t            minX = Math.floor((bounds.min.x - shiftX) / tileSize),\n\t\n\t        // by geometry bounds\n\t        maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\n\t            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\n\t            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\n\t\n\t        if (rminX < minX) {\n\t            rminX = minX;\n\t        }\n\t        if (rmaxX > maxX) {\n\t            rmaxX = maxX;\n\t        }\n\t        if (rminY < minY) {\n\t            rminY = minY;\n\t        }\n\t        if (rmaxY > maxY) {\n\t            rmaxY = maxY;\n\t        }\n\t\n\t        var arr = [];\n\t        for (var j = rminY; j <= rmaxY; j++) {\n\t            for (var i = rminX; i <= rmaxX; i++) {\n\t                arr.push({\n\t                    z: gmxTilePoint.z,\n\t                    x: i,\n\t                    y: j,\n\t                    dx: deltaX,\n\t                    dy: deltaY,\n\t                    tx: tminX,\n\t                    ty: tminY\n\t                });\n\t            }\n\t        }\n\t        return arr;\n\t    },\n\t\n\t    // Loads missing rasters for single item and combines them in canvas.\n\t    // Stores resulting canvas in this.rasters\n\t    _getItemRasters: function _getItemRasters(geo) {\n\t        var properties = geo.properties,\n\t            idr = properties[0],\n\t            _this = this,\n\t            gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            rasters = this.rasters,\n\t            mainRasterLoader = null,\n\t            recursiveLoaders,\n\t            shiftX = Number(gmx.shiftXfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\n\t            shiftY = Number(gmx.shiftYfield ? _Utils.gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\n\t            isShift = shiftX || shiftY,\n\t            urlBG = _Utils.gmxAPIutils.getPropItem('urlBG', properties, indexes),\n\t            url = '',\n\t            itemImageProcessingHook = null,\n\t            isTiles = false,\n\t            item = gmx.dataManager.getItem(idr),\n\t            gmxTilePoint = this.gmxTilePoint,\n\t            resCanvas = null,\n\t            imageItem = null;\n\t\n\t        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || _Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\n\t            isTiles = true; // Raster Layer\n\t        } else if (gmx.quicklookBGfunc) {\n\t            url = gmx.quicklookBGfunc(item); // Quicklook\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        } else if (urlBG) {\n\t            url = urlBG; // Image urlBG from properties\n\t            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\n\t        }\n\t        if (isTiles) {\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                recursiveLoaders.forEach(function (it) {\n\t                    it.cancel();\n\t                });\n\t                recursiveLoaders = null;\n\t            });\n\t        } else {\n\t            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey; //  for browser cache from another tabs\n\t            var request = this.rasterRequests[url];\n\t            if (!request) {\n\t                request = L.gmx.imageLoader.push(url, {\n\t                    tileRastersId: _this._uniqueID,\n\t                    crossOrigin: gmx.crossOrigin || 'anonymous'\n\t                });\n\t                this.rasterRequests[url] = request;\n\t            } else {\n\t                request.options.tileRastersId = this._uniqueID;\n\t            }\n\t\n\t            // in fact, we want to return request.def, but need to do additional action during cancellation.\n\t            // so, we consctruct new promise and add pipe it with request.def\n\t            mainRasterLoader = new L.gmx.Deferred(function () {\n\t                //don't cache cancelled requests\n\t                delete _this.rasterRequests[url];\n\t                request.def.cancel();\n\t            });\n\t            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\n\t        }\n\t        var itemRasterPromise = new L.gmx.Deferred(function () {\n\t            if (mainRasterLoader) {\n\t                mainRasterLoader.cancel();\n\t                mainRasterLoader = null;\n\t            }\n\t        });\n\t\n\t        if (isTiles) {\n\t            var dataOption = geo.dataOption || {},\n\t                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\n\t                cnt = tileToLoadPoints.length,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (cnt < 1) {\n\t                    mainRasterLoader.resolve();\n\t                }\n\t            },\n\t                skipRasterFunc = function skipRasterFunc() {\n\t                cnt--;\n\t                chkReadyRasters();\n\t            },\n\t                urlFunction = function urlFunction(gtp) {\n\t                return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\n\t            },\n\t                onLoadFunction = function onLoadFunction(gtp, p, img) {\n\t                item.skipRasters = false;\n\t                var isImage = true;\n\t\n\t                if (itemImageProcessingHook) {\n\t                    img = itemImageProcessingHook(img, {\n\t                        gmx: gmx,\n\t                        geoItem: geo,\n\t                        item: item,\n\t                        gmxTilePoint: gtp\n\t                    });\n\t                    isImage = false;\n\t                }\n\t\n\t                var info = {\n\t                    geoItem: geo,\n\t                    image: img,\n\t                    destinationTilePoint: gmxTilePoint,\n\t                    sourceTilePoint: gtp,\n\t                    sx: 0, sy: 0, sw: 256, sh: 256,\n\t                    dx: 0, dy: 0, dw: 256, dh: 256\n\t                };\n\t\n\t                if (isShift) {\n\t                    var pos = _this._getShiftPixels(p);\n\t                    if (pos === null) {\n\t                        skipRasterFunc();\n\t                        return;\n\t                    }\n\t                    L.extend(info, pos);\n\t                    isImage = false;\n\t                }\n\t\n\t                if (gtp.z !== gmxTilePoint.z) {\n\t                    var posInfo = _Utils.gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\n\t                    if (posInfo.size < 1 / 256) {\n\t                        //  1px\n\t                        chkReadyRasters();\n\t                        return;\n\t                    }\n\t                    isImage = false;\n\t                    info.sx = Math.floor(posInfo.x);\n\t                    info.sy = Math.floor(posInfo.y);\n\t                    info.sw = info.sh = posInfo.size;\n\t                    if (isShift) {\n\t                        var sw = Math.floor(info.dw / posInfo.zDelta);\n\t                        info.sx = (info.dx === 0 ? info.sw : 256) - sw;\n\t                        info.sw = sw;\n\t\n\t                        var sh = Math.floor(info.dh / posInfo.zDelta);\n\t                        info.sy = (info.dy === 0 ? info.sh : 256) - sh;\n\t                        info.sh = sh;\n\t                    }\n\t                }\n\t                if (isImage && !gmx.rasterProcessingHook) {\n\t                    cnt--;\n\t                    resCanvas = img;\n\t                    chkReadyRasters();\n\t                } else {\n\t                    if (!resCanvas) {\n\t                        resCanvas = document.createElement('canvas');\n\t                        resCanvas.width = resCanvas.height = 256;\n\t                    }\n\t                    info.res = resCanvas;\n\t                    var hookResult = _this._rasterHook(info),\n\t                        then = function then() {\n\t                        cnt--;\n\t                        p.resImage = resCanvas;\n\t                        chkReadyRasters();\n\t                    };\n\t\n\t                    if (hookResult) {\n\t                        if (hookResult instanceof L.gmx.Deferred) {\n\t                            hookResult.then(then);\n\t                        }\n\t                    } else if (hookResult === null) {\n\t                        item.skipRasters = true;\n\t                        skipRasterFunc();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                }\n\t            };\n\t            recursiveLoaders = tileToLoadPoints.map(function (it) {\n\t                var loader = _this._loadTileRecursive(it, urlFunction);\n\t                loader.then(function (loadResult) {\n\t                    onLoadFunction(loadResult.gtp, it, loadResult.image);\n\t                }, skipRasterFunc);\n\t                return loader;\n\t            });\n\t\n\t            mainRasterLoader.then(function () {\n\t                rasters[idr] = resCanvas;\n\t                itemRasterPromise.resolve();\n\t            });\n\t        } else {\n\t            // for quicklook\n\t            item.skipRasters = false;\n\t            var imageLoaded = function imageLoaded(img) {\n\t                var imgAttr = {\n\t                    gmx: gmx,\n\t                    geoItem: geo,\n\t                    item: item,\n\t                    gmxTilePoint: gmxTilePoint\n\t                };\n\t                if (!resCanvas) {\n\t                    resCanvas = document.createElement('canvas');\n\t                    resCanvas.width = resCanvas.height = 256;\n\t                }\n\t                var prepareItem = function prepareItem(imageElement) {\n\t                    var promise = _this._rasterHook({\n\t                        geoItem: geo,\n\t                        res: resCanvas,\n\t                        image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\n\t                        destinationTilePoint: gmxTilePoint,\n\t                        url: url\n\t                    }),\n\t                        then = function then() {\n\t                        rasters[idr] = resCanvas;\n\t                        itemRasterPromise.resolve();\n\t                    };\n\t                    if (promise) {\n\t                        if (promise instanceof L.gmx.Deferred) {\n\t                            promise.then(then);\n\t                        }\n\t                    } else if (promise === null) {\n\t                        item.skipRasters = true;\n\t                        itemRasterPromise.resolve();\n\t                    } else {\n\t                        then();\n\t                    }\n\t                };\n\t                prepareItem(img);\n\t                delete _this.rasterRequests[url];\n\t            };\n\t            if (imageItem) {\n\t                imageLoaded(imageItem);\n\t            } else {\n\t                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\n\t            }\n\t        }\n\t        itemRasterPromise.always(function () {\n\t            mainRasterLoader = null;\n\t            if (recursiveLoaders) {\n\t                recursiveLoaders = null;\n\t            }\n\t        });\n\t        return itemRasterPromise;\n\t    },\n\t\n\t    _getVisibleItems: function _getVisibleItems(geoItems) {\n\t        if (geoItems.length < 2) {\n\t            this.itemsView = geoItems;\n\t            return geoItems;\n\t        }\n\t        if (!_Utils.gmxAPIutils._tileCanvas) {\n\t            _Utils.gmxAPIutils._tileCanvas = document.createElement('canvas');\n\t            _Utils.gmxAPIutils._tileCanvas.width = _Utils.gmxAPIutils._tileCanvas.height = 256;\n\t        }\n\t        var i,\n\t            len,\n\t            gmx = this.gmx,\n\t            dm = gmx.dataManager,\n\t            canvas = _Utils.gmxAPIutils._tileCanvas,\n\t            ctx = canvas.getContext('2d'),\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.imageSmoothingEnabled = false;\n\t        for (i = 0, len = geoItems.length; i < len; i++) {\n\t            ctx.fillStyle = _Utils.gmxAPIutils.dec2rgba(i + 1, 1);\n\t            var geoItem = geoItems[i];\n\t            L.gmxUtil.drawGeoItem(geoItem, dm.getItem(geoItem.properties[0]), dattr, { fillStyle: ctx.fillStyle });\n\t        }\n\t        var items = {},\n\t            data = ctx.getImageData(0, 0, 256, 256).data;\n\t\n\t        for (i = 0, len = data.length; i < len; i += 4) {\n\t            if (data[i + 3] === 255) {\n\t                var color = data[i + 2];\n\t                if (data[i + 1]) {\n\t                    color += data[i + 1] << 8;\n\t                }\n\t                if (data[i]) {\n\t                    color += data[i] << 16;\n\t                }\n\t                if (color) {\n\t                    items[color] = true;\n\t                }\n\t            }\n\t        }\n\t        var out = [];\n\t        for (var num in items) {\n\t            var it = geoItems[Number(num) - 1];\n\t            if (it) {\n\t                out.push(it);\n\t            }\n\t        }\n\t        this.itemsView = out;\n\t        return out;\n\t    },\n\t\n\t    _getNeedRasterItems: function _getNeedRasterItems(geoItems) {\n\t        var gmx = this.gmx,\n\t            indexes = gmx.tileAttributeIndexes,\n\t            tbounds = this.tbounds,\n\t            out = [];\n\t        for (var i = 0, len = geoItems.length; i < len; i++) {\n\t            var geo = geoItems[i],\n\t                properties = geo.properties,\n\t                idr = properties[0],\n\t                dataOption = geo.dataOption || {},\n\t                skipRasters = false;\n\t\n\t            if (gmx.quicklookBGfunc && !_Utils.gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\n\t                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) {\n\t                    continue;\n\t                }\n\t                var platform = _Utils.gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\n\t                if ((!platform || platform === 'imageMercator') && !_Utils.gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)) {\n\t                    continue;\n\t                }\n\t            }\n\t\n\t            if (gmx.styleHook) {\n\t                geo.styleExtend = gmx.styleHook(gmx.dataManager.getItem(idr), gmx.lastHover && idr === gmx.lastHover.id);\n\t                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\n\t            }\n\t            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\n\t                out.push(geo);\n\t            }\n\t        }\n\t        return this._getVisibleItems(out);\n\t    },\n\t\n\t    _getTileRasters: function _getTileRasters(geoItems) {\n\t        //load all missing rasters for items we are going to render\n\t        var itemPromises = [],\n\t            def = new L.gmx.Deferred(function () {\n\t            itemPromises.forEach(function (promise) {\n\t                promise.cancel();\n\t            });\n\t            itemPromises = null;\n\t        }),\n\t            itemRasters = this._getNeedRasterItems(geoItems),\n\t            needLoadRasters = itemRasters.length;\n\t\n\t        if (needLoadRasters) {\n\t            var _this = this,\n\t                chkReadyRasters = function chkReadyRasters() {\n\t                if (needLoadRasters < 1) {\n\t                    def.resolve();\n\t                }\n\t            };\n\t            itemRasters.forEach(function (geo) {\n\t                var itemRasterPromise = _this._getItemRasters(geo);\n\t                itemRasterPromise.then(function () {\n\t                    needLoadRasters--;\n\t                    chkReadyRasters();\n\t                });\n\t                itemPromises.push(itemRasterPromise);\n\t            });\n\t        } else {\n\t            def.resolve();\n\t        }\n\t        return def;\n\t    },\n\t\n\t    _chkItems: function _chkItems(data) {\n\t        var layer = this.layer;\n\t        if (!layer._map) {\n\t            return null;\n\t        }\n\t        var items = data && data.added && data.added.length ? data.added : null;\n\t\n\t        if (!items) {\n\t            var tLink = layer._tiles[this.zKey];\n\t            if (tLink && tLink.el) {\n\t                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\n\t            }\n\t            return null;\n\t        }\n\t        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\n\t    },\n\t\n\t    _cancelRastersPromise: function _cancelRastersPromise() {\n\t        if (this.rastersPromise) {\n\t            this.rastersPromise.cancel();\n\t            this.rastersPromise = null;\n\t        }\n\t    },\n\t\n\t    drawTile: function drawTile(data) {\n\t        var drawPromise = this.currentDrawPromise,\n\t            _this = this;\n\t\n\t        this._uniqueID++; // count draw attempt\n\t\n\t        if (drawPromise) {\n\t            this._cancelRastersPromise();\n\t            if (this._preRenderPromise) {\n\t                this._preRenderPromise.cancel(); // cancel preRenderHooks chain if exists\n\t            }\n\t            if (this._renderPromise) {\n\t                this._renderPromise.cancel(); // cancel renderHooks chain if exists\n\t            }\n\t            drawPromise.reject();\n\t        }\n\t        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\n\t        drawPromise.always(function () {\n\t            _this._drawDone();\n\t            _this.currentDrawPromise = null;\n\t            _this.rastersPromise = null;\n\t            _this._preRenderPromise = null;\n\t            _this._renderPromise = null;\n\t        });\n\t\n\t        this.currentDrawPromise = drawPromise;\n\t\n\t        var geoItems = this._chkItems(data);\n\t        if (!geoItems) {\n\t            drawPromise.resolve();\n\t            return drawPromise;\n\t        }\n\t        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\n\t            tile = tileLink.el,\n\t            ctx = tile.getContext('2d'),\n\t            gmx = this.gmx,\n\t            dattr = {\n\t            tbounds: this.tbounds,\n\t            rasters: this.rasters,\n\t            gmx: gmx,\n\t            tpx: this.tpx,\n\t            tpy: this.tpy,\n\t            ctx: ctx\n\t        };\n\t        tile.zKey = tileLink.el._zKey = this.zKey;\n\t\n\t        var doDraw = function doDraw() {\n\t            ctx.clearRect(0, 0, 256, 256);\n\t            var hookInfo = {\n\t                tpx: _this.tpx,\n\t                tpy: _this.tpy,\n\t                x: _this.tilePoint.x,\n\t                y: _this.tilePoint.y,\n\t                z: _this.zoom\n\t            },\n\t                bgImage = null;\n\t\n\t            _this._preRenderPromise = new L.gmx.Deferred();\n\t            _this._preRenderPromise.resolve(bgImage);\n\t\n\t            gmx.preRenderHooks.forEach(function (f) {\n\t                _this._preRenderPromise = _this._preRenderPromise.then(function (hookBgImage) {\n\t\n\t                    //in-place modifications are possible\n\t                    bgImage = hookBgImage || bgImage;\n\t\n\t                    if (!bgImage) {\n\t                        bgImage = document.createElement('canvas');\n\t                        bgImage.width = bgImage.height = 256;\n\t                    }\n\t                    return f(bgImage, hookInfo);\n\t                });\n\t            });\n\t            _this._preRenderPromise.then(function (hookBgImage) {\n\t                bgImage = hookBgImage || bgImage;\n\t                if (bgImage) {\n\t                    dattr.bgImage = bgImage;\n\t                }\n\t                //ctx.save();\n\t                for (var i = 0, len = geoItems.length; i < len; i++) {\n\t                    var geoItem = geoItems[i],\n\t                        id = geoItem.id,\n\t                        item = gmx.dataManager.getItem(id);\n\t                    if (item) {\n\t                        // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\n\t                        var style = gmx.styleManager.getObjStyle(item),\n\t                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\n\t\n\t                        if (gmx.multiFilters) {\n\t                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                                var it = item.multiFilters[j];\n\t                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\n\t                            }\n\t                        } else {\n\t                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\n\t                        }\n\t                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\n\t                            gmx._needPopups[id] = true;\n\t                        }\n\t                    }\n\t                }\n\t                //ctx.restore();\n\t                _this.rasters = {}; // clear rasters\n\t                if (_this.layer._map && !tile.parentNode) {\n\t                    _this.layer.appendTileToContainer(tile);\n\t                }\n\t                //async chain\n\t                _this._renderPromise = new L.gmx.Deferred();\n\t                _this._renderPromise.resolve(tile);\n\t                gmx.renderHooks.forEach(function (f) {\n\t                    _this._renderPromise = _this._renderPromise.then(function (hookTile) {\n\t                        tile = hookTile || tile;\n\t                        return f(tile, hookInfo);\n\t                    });\n\t                });\n\t                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\n\t            }, drawPromise.reject);\n\t        };\n\t\n\t        if (this.showRaster) {\n\t            this.rastersPromise = this._getTileRasters(geoItems);\n\t            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\n\t        } else {\n\t            doDraw();\n\t        }\n\t\n\t        return drawPromise;\n\t    },\n\t\n\t    destructor: function destructor() {\n\t        this._cancelRastersPromise();\n\t        this._clearCache();\n\t\n\t        this.currentDrawPromise && this.currentDrawPromise.reject();\n\t    },\n\t\n\t    _drawDone: function _drawDone() {\n\t        for (var url in this.rasterRequests) {\n\t            var req = this.rasterRequests[url];\n\t            if (this._uniqueID !== req.options.tileRastersId) {\n\t                req.remove();\n\t                delete this.rasterRequests[url];\n\t            }\n\t        }\n\t        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\n\t    },\n\t\n\t    _clearCache: function _clearCache() {\n\t        for (var url in this.rasterRequests) {\n\t            this.rasterRequests[url].remove();\n\t        }\n\t        this.rasterRequests = {};\n\t    }\n\t};\n\texports.ScreenVectorTile = ScreenVectorTile;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\r\n\t * ObjectsReorder  - Reorder objects in Gemixer layer\r\n\t */\n\t(function () {\n\t\n\t    var MAX = 1000000,\n\t        ObjectsReorder = function ObjectsReorder(layer) {\n\t        this.all = {};\n\t        this.userSetSortFunc = false; // user sort func flag\n\t        this.sortFunc = null;\n\t        this.count = 0;\n\t        this.disabled = false;\n\t        this.layer = layer;\n\t        layer.on('add', this.onAdd, this);\n\t        layer.on('remove', this.onRemove, this);\n\t    };\n\t    ObjectsReorder.prototype = {\n\t        addToReorder: function addToReorder(id, bottomFlag) {\n\t            ++this.count;\n\t            this.all[id] = bottomFlag ? -this.count : this.count;\n\t        },\n\t        clickFunc: function clickFunc(ev) {\n\t            if (!this.disabled) {\n\t                var id = ev.gmx.id;\n\t                this.addToReorder(id, ev.originalEvent.ctrlKey);\n\t                this.layer.redrawItem(id);\n\t            }\n\t        },\n\t        sortItems: function sortItems(a, b) {\n\t            // layer context\n\t            var reorder = this._objectsReorder;\n\t            if (reorder.count > 0) {\n\t                var ap = reorder.all[a.id],\n\t                    bp = reorder.all[b.id];\n\t\n\t                if (ap || bp) {\n\t                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\n\t                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\n\t                    return ap - bp;\n\t                }\n\t            }\n\t            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\n\t        },\n\t        resetSortFunc: function resetSortFunc() {\n\t            var layer = this.layer,\n\t                gmx = layer._gmx,\n\t                zIndexField = gmx.zIndexField;\n\t            gmx.sortItems = this.sortItems;\n\t            this.sortFunc = zIndexField && !this.userSetSortFunc ? function (a, b) {\n\t                // layer context\n\t                var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\n\t                return res ? res : a.id - b.id;\n\t            } : function (a, b) {\n\t                return a.id - b.id;\n\t            };\n\t        },\n\t        initialize: function initialize() {\n\t            var gmx = this.layer._gmx;\n\t            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\n\t                this.resetSortFunc();\n\t            }\n\t        },\n\t        onAdd: function onAdd() {\n\t            this.initialize();\n\t            this.layer.on('click', this.clickFunc, this);\n\t        },\n\t        onRemove: function onRemove() {\n\t            this.layer.off('click', this.clickFunc, this);\n\t        }\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t        _objectsReorder: null,\n\t\n\t        _objectsReorderInit: function _objectsReorderInit() {\n\t            if (!this._objectsReorder) {\n\t                this._objectsReorder = new ObjectsReorder(this);\n\t            }\n\t        },\n\t\n\t        getReorderArrays: function getReorderArrays() {\n\t            var out = { top: [], bottom: [] };\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder,\n\t                    arr = Object.keys(reorder.all).sort(function (a, b) {\n\t                    return reorder.all[a] - reorder.all[b];\n\t                });\n\t\n\t                for (var i = 0, len = arr.length; i < len; i++) {\n\t                    var id = arr[i];\n\t                    if (reorder.all[id] > 0) {\n\t                        out.top.push(id);\n\t                    } else {\n\t                        out.bottom.push(id);\n\t                    }\n\t                }\n\t            }\n\t            return out;\n\t        },\n\t\n\t        bringToTopItem: function bringToTopItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        bringToBottomItem: function bringToBottomItem(id) {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.addToReorder(id, true);\n\t            this.redrawItem(id);\n\t            return this;\n\t        },\n\t\n\t        clearReorderArrays: function clearReorderArrays() {\n\t            if (this._objectsReorder) {\n\t                var reorder = this._objectsReorder;\n\t                reorder.all = {};\n\t                reorder.count = 0;\n\t                this.repaint();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        setReorderArrays: function setReorderArrays(top, bottom) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.all = {};\n\t            reorder.count = 0;\n\t            bottom.forEach(function (id) {\n\t                reorder.addToReorder(id, true);\n\t            });\n\t            top.forEach(function (id) {\n\t                reorder.addToReorder(id);\n\t            });\n\t            this.repaint();\n\t            return this;\n\t        },\n\t\n\t        getSortedItems: function getSortedItems(arr) {\n\t            this._objectsReorderInit();\n\t            return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\n\t        },\n\t\n\t        setSortFunc: function setSortFunc(func) {\n\t            this._objectsReorderInit();\n\t            var reorder = this._objectsReorder;\n\t            reorder.sortFunc = func;\n\t            reorder.userSetSortFunc = func ? true : false;\n\t            this._gmx.sortItems = reorder.sortItems;\n\t            this.repaint();\n\t            return this;\n\t        },\n\t        disableFlip: function disableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = true;\n\t            return this;\n\t        },\n\t        enableFlip: function enableFlip() {\n\t            this._objectsReorderInit();\n\t            this._objectsReorder.disabled = false;\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.VectorLayer.include({\n\t    bindPopup: function bindPopup(content, options) {\n\t        var popupOptions = L.extend({ maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID }, options);\n\t\n\t        if (this._popup) {\n\t            this.unbindPopup();\n\t        }\n\t        if (content instanceof L.Popup) {\n\t            this._popup = content;\n\t        } else {\n\t            if (!this._popup || options) {\n\t                this._popup = new L.Popup(popupOptions);\n\t            }\n\t            this._popup.setContent(content);\n\t        }\n\t        this._popup._initContent = content;\n\t        this._popup._state = '';\n\t\n\t        if (!this._popupHandlersAdded) {\n\t            this.on('click', this._openClickPopup, this).on('mousemove', this._movePopup, this).on('mouseover', this._overPopup, this).on('mouseout', this._outPopup, this).on('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupHandlersAdded = true;\n\t        }\n\t        if (popupOptions && popupOptions.popupopen) {\n\t            this._popupopen = popupOptions.popupopen;\n\t        }\n\t\n\t        this._popup.updateLayout = this._popup._updateLayout;\n\t\n\t        return this;\n\t    },\n\t\n\t    unbindPopup: function unbindPopup() {\n\t        if (this._popup) {\n\t            this._popup = null;\n\t            this.off('click', this._openClickPopup, this).off('mousemove', this._movePopup, this).off('mouseover', this._overPopup, this).off('mouseout', this._outPopup, this).off('doneDraw', this._chkNeedOpenPopup, this);\n\t\n\t            this._popupopen = null;\n\t            this._popupHandlersAdded = false;\n\t        }\n\t        this._gmx.balloonEnable = false;\n\t        return this;\n\t    },\n\t\n\t    _chkNeedOpenPopup: function _chkNeedOpenPopup() {\n\t        for (var id in this._gmx._needPopups) {\n\t            if (this._gmx._needPopups[id]) {\n\t                this.addPopup(id);\n\t                delete this._gmx._needPopups[id];\n\t            }\n\t        }\n\t    },\n\t\n\t    disablePopup: function disablePopup() {\n\t        this._popupDisabled = true;\n\t        return this;\n\t    },\n\t\n\t    enablePopup: function enablePopup() {\n\t        this._popupDisabled = false;\n\t        return this;\n\t    },\n\t\n\t    openPopup: function openPopup(latlng, options) {\n\t\n\t        if (this._popup) {\n\t            // open the popup from one of the path's points if not specified\n\t            latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];\n\t\n\t            options = options || {};\n\t            options.latlng = latlng;\n\t            this._openPopup(options);\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    closePopup: function closePopup() {\n\t        if (this._popup) {\n\t            this._popup._close();\n\t            this.fire('popupclose', { popup: this._popup });\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _movePopup: function _movePopup(options) {\n\t        if (this._popup._state === 'mouseover') {\n\t            var id = this._popup.options._gmxID || -1;\n\t            if (id !== options.gmx.id) {\n\t                this._setPopupContent(options);\n\t            }\n\t            this._popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _overPopup: function _overPopup(options) {\n\t        var _popup = this._popup;\n\t        if (!_popup._map) {\n\t            this._openPopup(options);\n\t        } else {\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: this._setPopupContent(options, _popup)\n\t            });\n\t        }\n\t        if (_popup._state === 'mouseover') {\n\t            _popup.setLatLng(options.latlng);\n\t        }\n\t    },\n\t\n\t    _outPopup: function _outPopup(ev) {\n\t        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\n\t            this.closePopup();\n\t        }\n\t    },\n\t\n\t    _callBalloonHook: function _callBalloonHook(props, div) {\n\t\n\t        var spans = div.getElementsByTagName('span'),\n\t            hooksCount = {},\n\t            key,\n\t            i,\n\t            len;\n\t        for (key in this._balloonHook) {\n\t            // collect hook counts\n\t            var hookID = this._balloonHook[key].hookID;\n\t            hooksCount[key] = 0;\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                if (spans[i].id === hookID) {\n\t                    hooksCount[key]++;\n\t                }\n\t            }\n\t        }\n\t\n\t        for (key in this._balloonHook) {\n\t            var hook = this._balloonHook[key],\n\t                fid = hook.hookID,\n\t                notFound = true;\n\t\n\t            for (i = 0, len = spans.length; i < len; i++) {\n\t                var node = spans[i];\n\t                if (node.id === fid) {\n\t                    notFound = false;\n\t                    node.id += '_' + i;\n\t                    hook.callback(props, div, node, hooksCount);\n\t                }\n\t            }\n\t            if (notFound) {\n\t                hook.callback(props, div, null, hooksCount);\n\t            }\n\t        }\n\t    },\n\t\n\t    _setPopupContent: function _setPopupContent(options, _popup) {\n\t        if (!_popup) {\n\t            _popup = this._popup;\n\t        }\n\t        var gmx = options.gmx || {},\n\t            balloonData = gmx.balloonData || {},\n\t            properties = L.extend({}, gmx.properties),\n\t            target = gmx.target || {},\n\t            geometry = target.geometry || {},\n\t            offset = target.offset,\n\t            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\n\t            type = options.type,\n\t            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\n\t            outItem = {\n\t            id: gmx.id,\n\t            type: type,\n\t            nodePoint: gmx.nodePoint,\n\t            latlng: options.latlng,\n\t            properties: properties,\n\t            templateBalloon: templateBalloon\n\t        };\n\t\n\t        if (geometry.type === 'POINT') {\n\t            var coord = geometry.coordinates;\n\t            outItem.latlng = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t        }\n\t        if (offset) {\n\t            var protoOffset = L.Popup.prototype.options.offset;\n\t            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\n\t        }\n\t\n\t        if (this._popupopen) {\n\t            this._popupopen({\n\t                popup: _popup,\n\t                latlng: outItem.latlng,\n\t                layerPoint: options.layerPoint,\n\t                contentNode: _popup._contentNode,\n\t                containerPoint: options.containerPoint,\n\t                originalEvent: options.originalEvent,\n\t                gmx: outItem\n\t            });\n\t        } else if (!(templateBalloon instanceof L.Popup)) {\n\t            if (!(templateBalloon instanceof HTMLElement)) {\n\t                var geometries,\n\t                    summary = '',\n\t                    unitOptions = this._map ? this._map.options : {};\n\t\n\t                if (!skipSummary) {\n\t                    geometries = target.geometry ? [target.geometry] : gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || [];\n\t                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\n\t                }\n\t                if (this._balloonHook) {\n\t                    if (!templateBalloon) {\n\t                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\n\t                    }\n\t                    for (var key in this._balloonHook) {\n\t                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\n\t                    }\n\t                }\n\t                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: this._gmx.tileAttributeTypes,\n\t                    unitOptions: unitOptions,\n\t                    summary: summary,\n\t                    geometries: geometries\n\t                });\n\t            }\n\t\n\t            var contentDiv = L.DomUtil.create('div', '');\n\t            contentDiv.innerHTML = templateBalloon;\n\t            _popup.setContent(contentDiv);\n\t            if (this._balloonHook) {\n\t                this._callBalloonHook(gmx.properties, _popup.getContent());\n\t            }\n\t            //outItem.templateBalloon = templateBalloon;\n\t        }\n\t        _popup.options._gmxID = gmx.id;\n\t        return outItem;\n\t    },\n\t\n\t    _openClickPopup: function _openClickPopup(options) {\n\t        var originalEvent = options.originalEvent || {},\n\t            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                gmx = options.gmx,\n\t                balloonData = gmx.balloonData,\n\t                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\n\t                item = gmx.target;\n\t\n\t            if (flag && item.options.isGeneralized && !item.geometry) {\n\t                var layerProp = gmx.layer.getGmxProperties();\n\t                gmxAPIutils.getLayerItemFromServer({\n\t                    options: options,\n\t                    layerID: layerProp.name,\n\t                    value: item.id,\n\t                    field: layerProp.identityField\n\t                }).then(function (json, params) {\n\t                    if (json && json.Status === 'ok' && json.Result) {\n\t                        var pArr = json.Result.values[0];\n\t                        params.options.gmx.target.fromServerProps = pArr;\n\t                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\n\t                        this._openPopup(params.options);\n\t                    }\n\t                }.bind(this));\n\t            } else {\n\t                this._openPopup(options);\n\t            }\n\t        }\n\t    },\n\t\n\t    _openPopup: function _openPopup(options, notSkip) {\n\t        var map = this._map,\n\t            originalEvent = options.originalEvent || {},\n\t            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\n\t\n\t        if (!skip) {\n\t            var type = options.type,\n\t                _popup = this._popup,\n\t                gmx = options.gmx || {},\n\t                balloonData = gmx.balloonData || {};\n\t\n\t            if (type === 'click') {\n\t                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) {\n\t                    return;\n\t                }\n\t\n\t                if (!('_gmxPopups' in map)) {\n\t                    map._gmxPopups = [];\n\t                }\n\t                if (!('maxPopupCount' in map.options)) {\n\t                    map.options.maxPopupCount = 1;\n\t                }\n\t                if (!this._gmx._gmxPopupsInit) {\n\t                    this._gmx._gmxPopupsInit = true;\n\t                    map.on({\n\t                        layerremove: function layerremove(ev) {\n\t                            if (ev.layer instanceof L.Popup) {\n\t                                this._clearPopup(ev.layer);\n\t                            } else if (ev.layer === this) {\n\t                                if (map._gmxPopups) {\n\t                                    var layerId = this._gmx.layerID;\n\t                                    map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                                        if (c._map) {\n\t                                            if (c.options.layerId === layerId) {\n\t                                                c._map.removeLayer(c);\n\t                                            } else {\n\t                                                p.push(c);\n\t                                            }\n\t                                        }\n\t                                        return p;\n\t                                    }, []);\n\t                                }\n\t                                this.closePopup();\n\t                            }\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                this._clearPopup(gmx.id);\n\t                var opt = this._popup ? this._popup.options : { maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID };\n\t                _popup = new L.Popup(L.extend({}, opt, { closeOnClick: map.options.maxPopupCount === 1, autoPan: true }));\n\t            } else if (type === 'mouseover') {\n\t                if (balloonData.DisableBalloonOnMouseMove) {\n\t                    _popup._state = '';\n\t                    return;\n\t                }\n\t                _popup.options.autoPan = false;\n\t            } else {\n\t                return;\n\t            }\n\t            _popup.options.objectId = gmx.id;\n\t            _popup._state = type;\n\t            var outItem = this._setPopupContent(options, _popup);\n\t            _popup.setLatLng(outItem.latlng);\n\t\n\t            this.fire('popupopen', {\n\t                popup: _popup,\n\t                gmx: outItem\n\t            });\n\t            if (type === 'click') {\n\t                if (map._gmxPopups.length >= map.options.maxPopupCount) {\n\t                    map.removeLayer(map._gmxPopups.shift());\n\t                }\n\t                map._gmxPopups.push(_popup);\n\t            }\n\t            _popup.addTo(map); // this._map.openPopup(_popup);\n\t\n\t            if (_popup._closeButton) {\n\t                var closeStyle = _popup._closeButton.style;\n\t                if (type === 'mouseover' && closeStyle !== 'hidden') {\n\t                    closeStyle.visibility = 'hidden';\n\t                    _popup._container.style.marginBottom = '7px';\n\t                    _popup._container.style.pointerEvents = 'none';\n\t                } else if (type === 'click' && closeStyle !== 'inherit') {\n\t                    closeStyle.visibility = 'inherit';\n\t                    _popup._container.style.marginBottom = '';\n\t                    _popup._container.style.pointerEvents = '';\n\t                }\n\t            }\n\t        }\n\t    },\n\t\n\t    _clearPopup: function _clearPopup(item /* <L.Popup> or objectId */) {\n\t        var map = this._map;\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID,\n\t                flagPopup = item instanceof L.Popup;\n\t            map._gmxPopups = map._gmxPopups.reduce(function (p, c) {\n\t                if (c._map) {\n\t                    if (flagPopup && c === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else if (c.options.layerId === layerId && c.options.objectId === item) {\n\t                        c._map.removeLayer(c);\n\t                    } else {\n\t                        p.push(c);\n\t                    }\n\t                }\n\t                return p;\n\t            }, []);\n\t        }\n\t    },\n\t\n\t    getPopups: function getPopups(flag) {\n\t        var map = this._map,\n\t            out = [];\n\t        if (map && map._gmxPopups) {\n\t            var layerId = this._gmx.layerID;\n\t            map._gmxPopups.reduce(function (p, c) {\n\t                if (c.options.layerId === layerId) {\n\t                    p.push(flag ? c : c.options.objectId);\n\t                }\n\t                return p;\n\t            }, out);\n\t        }\n\t        return out;\n\t    },\n\t\n\t    addPopup: function addPopup(id) {\n\t        var gmx = this._gmx,\n\t            item = gmx.dataManager.getItem(id);\n\t        if (!item || !this._map) {\n\t            gmx._needPopups[id] = false;\n\t        } else {\n\t            var center = item.bounds.getCenter(),\n\t                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\n\t            this._openPopup({\n\t                type: 'click',\n\t                latlng: latlng,\n\t                gmx: this.getHoverOption(item)\n\t            }, true);\n\t            delete gmx._needPopups[id];\n\t        }\n\t        return this;\n\t    },\n\t\n\t    addPopupHook: function addPopupHook(key, callback) {\n\t        if (!this._balloonHook) {\n\t            this._balloonHook = {};\n\t        }\n\t        if (!this._balloonHook[key]) {\n\t            var hookID = '_' + L.stamp({});\n\t            this._balloonHook[key] = {\n\t                key: key,\n\t                hookID: hookID,\n\t                resStr: '<span id=\"' + hookID + '\"></span>',\n\t                callback: callback\n\t            };\n\t        }\n\t        return this;\n\t    },\n\t\n\t    removePopupHook: function removePopupHook(key) {\n\t        if (this._balloonHook) {\n\t            delete this._balloonHook[key];\n\t        }\n\t        return this;\n\t    }\n\t});\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx.VectorLayer.include({\n\t    _gmxFirstObjectsByPoint: function _gmxFirstObjectsByPoint(geoItems, mercPoint, bounds) {\n\t        //      mouseClick\n\t        var gmx = this._gmx,\n\t            mInPixel = gmx.mInPixel,\n\t            j,\n\t            len;\n\t\n\t        for (var i = geoItems.length - 1; i >= 0; i--) {\n\t            var geoItem = geoItems[i].properties,\n\t                idr = geoItem[0],\n\t                dataOption = geoItems[i].dataOption || {},\n\t                item = gmx.dataManager.getItem(idr),\n\t                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\n\t                iconScale = currentStyle.iconScale || 1,\n\t                iconCenter = currentStyle.iconCenter,\n\t                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\n\t                parsedStyle = gmx.styleManager.getObjStyle(item),\n\t                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\n\t                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\n\t                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\n\t                offset = [iconScale * sx / 2, iconScale * sy / 2],\n\t                point = mercPoint,\n\t                geom = geoItem[geoItem.length - 1],\n\t                type = geom.type;\n\t\n\t            if (type === 'POINT' && parsedStyle.type === 'circle') {\n\t                offset[0] *= 2;\n\t                offset[1] *= 2;\n\t            }\n\t            var radius = offset[0],\n\t                objBounds = _Utils.gmxAPIutils.bounds().extendBounds(dataOption.bounds).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t            if (iconAnchor) {\n\t                offset = [iconAnchor[0] - offset[0], iconAnchor[1] - offset[1]];\n\t                point = [mercPoint[0] + offset[0] / mInPixel, mercPoint[1] - offset[1] / mInPixel];\n\t            }\n\t            if (!objBounds.contains(point)) {\n\t                continue;\n\t            }\n\t\n\t            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\n\t                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\n\t                chktype = type,\n\t                hiddenLines = dataOption.hiddenLines || [],\n\t                boundsArr = dataOption.boundsArr,\n\t                coords = geom.coordinates,\n\t                nodePoint = null,\n\t                ph = {\n\t                point: mercPoint,\n\t                bounds: bounds,\n\t                coords: coords,\n\t                boundsArr: boundsArr\n\t            };\n\t\n\t            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\n\t                if (marker) {\n\t                    chktype = 'POINT';\n\t                } else if (!fill) {\n\t                    if (type === 'POLYGON') {\n\t                        chktype = 'MULTILINESTRING';\n\t                        hiddenLines = hiddenLines[0];\n\t                    } else {\n\t                        chktype = 'LIKEMULTILINESTRING';\n\t                    }\n\t                    ph.hidden = hiddenLines;\n\t                }\n\t            }\n\t\n\t            if (chktype === 'LINESTRING') {\n\t                if (!_Utils.gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\n\t                    nodePoint = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'LIKEMULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                var flag = false;\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    ph.coords = coords[j];\n\t                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\n\t                    ph.boundsArr = boundsArr[j];\n\t                    if (_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                        flag = true;\n\t                        break;\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'MULTILINESTRING') {\n\t                ph.delta = lineWidth / mInPixel;\n\t                ph.hidden = hiddenLines;\n\t                if (!_Utils.gmxAPIutils.isPointInLines(ph)) {\n\t                    var pBounds = _Utils.gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\n\t                    for (j = 0, len = coords.length; j < len; j++) {\n\t                        nodePoint = pBounds.isNodeIntersect(coords[j]);\n\t                        if (nodePoint !== null) {\n\t                            nodePoint.ring = j;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (nodePoint === null) {\n\t                        continue;\n\t                    }\n\t                }\n\t            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\n\t                var chkPoint = mercPoint;\n\t                flag = false;\n\t                if (chktype === 'POLYGON') {\n\t                    coords = [geom.coordinates];\n\t                    boundsArr = [dataOption.boundsArr];\n\t                }\n\t                for (j = 0, len = coords.length; j < len; j++) {\n\t                    var arr = coords[j],\n\t                        bbox = boundsArr[j];\n\t                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\n\t                        var b = bbox[j1];\n\t                        if (b.intersects(bounds)) {\n\t                            if (_Utils.gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\n\t                                flag = j1 === 0 ? true : false;\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                if (!flag) {\n\t                    continue;\n\t                }\n\t            } else if (chktype === 'POINT') {\n\t                if (parsedStyle.type === 'circle') {\n\t                    var x = (coords[0] - point[0]) * mInPixel,\n\t                        y = (coords[1] - point[1]) * mInPixel;\n\t                    if (x * x + y * y > radius * radius) {\n\t                        continue;\n\t                    }\n\t                }\n\t            }\n\t            if (!this.isPointInClipPolygons(mercPoint)) {\n\t                continue;\n\t            }\n\t\n\t            return {\n\t                id: idr,\n\t                properties: item.properties,\n\t                geometry: geom,\n\t                bounds: item.bounds,\n\t                nodePoint: nodePoint,\n\t                offset: iconAnchor ? offset : null,\n\t                parsedStyle: parsedStyle\n\t            };\n\t        }\n\t        return null;\n\t    },\n\t\n\t    gmxEventCheck: function gmxEventCheck(ev, skipOver) {\n\t        if (!this._map) {\n\t            return 0;\n\t        }\n\t        var layer = this,\n\t            gmx = layer._gmx,\n\t            type = ev.type,\n\t            lastHover = gmx.lastHover,\n\t            chkHover = function chkHover(evType) {\n\t            if (lastHover && type === 'mousemove') {\n\t                if (evType && layer.hasEventListeners(evType)) {\n\t                    ev.gmx = lastHover;\n\t                    layer.fire(evType, ev);\n\t                }\n\t                if (lastHover.hoverDiff) {\n\t                    layer.redrawItem(lastHover.id);\n\t                }\n\t            }\n\t        };\n\t\n\t        var zoom = this._map.getZoom();\n\t        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n\t            skipOver = true;\n\t        }\n\t        if (skipOver) {\n\t            if (lastHover) {\n\t                lastHover.prevId = null;\n\t            }\n\t            chkHover('mouseout');\n\t            gmx.lastHover = null;\n\t        } else if (this.hasEventListeners('mouseover') || this.hasEventListeners('mouseout') || this.hasEventListeners(type) || type === 'mousemove' && gmx.properties.fromType !== 'Raster') {\n\t\n\t            var lng = ev.latlng.lng % 360,\n\t                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : lng > 180 ? -360 : 0)),\n\t                point = L.Projection.Mercator.project(latlng)._subtract({ x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0 }),\n\t                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\n\t                mercatorPoint = [point.x, point.y];\n\t\n\t            // observer   ,      \n\t            var observerOptions = {\n\t                type: 'resend',\n\t                bbox: _Utils.gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\n\t                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\n\t                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\n\t                active: false //  ,       \n\t            };\n\t            if (this.options.isGeneralized) {\n\t                observerOptions.targetZoom = zoom;\n\t            }\n\t\n\t            gmx.dataManager.addObserver(observerOptions, 'hover');\n\t\n\t            var geoItems = gmx.dataManager.getItems('hover');\n\t\n\t            gmx.dataManager.removeObserver('hover');\n\t\n\t            if (geoItems && geoItems.length) {\n\t                if (geoItems.length > 1 && gmx.sortItems) {\n\t                    geoItems = this.getSortedItems(geoItems);\n\t                }\n\t\n\t                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\n\t                if (target) {\n\t                    var idr = target.id,\n\t                        item = gmx.dataManager.getItem(idr),\n\t                        prevId = lastHover ? lastHover.id : null,\n\t                        changed = !lastHover || lastHover.id !== idr;\n\t                    if (type === 'mousemove' && lastHover) {\n\t                        if (!changed) {\n\t                            ev.gmx = lastHover;\n\t                            this.fire(type, ev);\n\t                            return idr;\n\t                        }\n\t                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\n\t                        gmx.lastHover = null;\n\t                    }\n\t\n\t                    ev.gmx = L.extend(this.getHoverOption(item), {\n\t                        targets: geoItems,\n\t                        nodePoint: target.nodePoint,\n\t                        prevId: prevId,\n\t                        hoverDiff: item.hoverDiff\n\t                    });\n\t                    if (this.hasEventListeners(type)) {\n\t                        this.fire(type, ev);\n\t                    }\n\t                    if (type === 'mousemove' && changed) {\n\t                        lastHover = gmx.lastHover = ev.gmx;\n\t                        chkHover('mouseover');\n\t                        gmx.lastMouseover = gmx.lastHover;\n\t                    }\n\t                    this._map.doubleClickZoom.disable();\n\t                    return idr;\n\t                }\n\t            }\n\t        }\n\t        if (this._map) {\n\t            this._map.doubleClickZoom.enable();\n\t        }\n\t        return 0;\n\t    },\n\t\n\t    getHoverOption: function getHoverOption(item) {\n\t        return {\n\t            layer: this,\n\t            target: item,\n\t            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\n\t            properties: this.getItemProperties(item.properties),\n\t            currentFilter: item.currentFilter || 0,\n\t            id: item.id\n\t        };\n\t    }\n\t});\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\t(function () {\n\t    var delay = 20000,\n\t        layers = {},\n\t        dataManagersLinks = {},\n\t        script = '/Layer/CheckVersion.ashx',\n\t        intervalID = null,\n\t        timeoutID = null,\n\t        lastLayersStr = '';\n\t\n\t    var isExistsTiles = function isExistsTiles(prop) {\n\t        var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\n\t        return tilesKey in prop;\n\t    };\n\t    var getParams = function getParams(prop, dm, layerDateInterval) {\n\t        var pt = {\n\t            Name: prop.name,\n\t            Version: isExistsTiles(prop) ? prop.LayerVersion : -1\n\t        };\n\t        if (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\n\t            var maxDateInterval = dm.getMaxDateInterval(),\n\t                beginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\n\t                endDate = maxDateInterval.endDate || layerDateInterval.endDate;\n\t            if (beginDate) {\n\t                pt.dateBegin = Math.floor(beginDate.getTime() / 1000);\n\t            }\n\t            if (endDate) {\n\t                pt.dateEnd = Math.floor(endDate.getTime() / 1000);\n\t            }\n\t        }\n\t        return pt;\n\t    };\n\t    var getRequestParams = function getRequestParams(layer) {\n\t        var hosts = {},\n\t            prop,\n\t            hostName,\n\t            dm,\n\t            layerDateInterval;\n\t        if (layer) {\n\t            if (layer instanceof L.gmx.DataManager) {\n\t                dm = layer;\n\t                prop = dm.options;\n\t            } else {\n\t                prop = layer._gmx.properties;\n\t                dm = layer._gmx.dataManager;\n\t                layerDateInterval = layer._gmx;\n\t            }\n\t            hostName = prop.hostName || layer._gmx.hostName;\n\t            hosts[hostName] = [getParams(prop, dm, layerDateInterval)];\n\t        } else {\n\t            var skipItems = {};\n\t            for (var id in layers) {\n\t                var obj = layers[id],\n\t                    isDataManager = obj instanceof L.gmx.DataManager;\n\t                if (obj.options.chkUpdate || isDataManager) {\n\t                    dm = isDataManager ? obj : obj._gmx.dataManager;\n\t                    prop = isDataManager ? obj.options : obj._gmx.properties;\n\t                    layerDateInterval = isDataManager ? obj : obj._gmx;\n\t                    hostName = prop.hostName || obj._gmx.hostName;\n\t                    var pt = getParams(prop, dm, layerDateInterval),\n\t                        key = pt.Name + pt.Version;\n\t                    if (!skipItems[key]) {\n\t                        if (hosts[hostName]) {\n\t                            hosts[hostName].push(pt);\n\t                        } else {\n\t                            hosts[hostName] = [pt];\n\t                        }\n\t                    }\n\t                    skipItems[key] = true;\n\t                }\n\t            }\n\t        }\n\t        return hosts;\n\t    };\n\t\n\t    var chkVersion = function chkVersion(layer, callback) {\n\t        var processResponse = function processResponse(res) {\n\t            if (res && res.Status === 'ok' && res.Result) {\n\t                for (var i = 0, len = res.Result.length; i < len; i++) {\n\t                    var item = res.Result[i],\n\t                        id = item.properties.name;\n\t\n\t                    if (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) {\n\t                        layer.updateVersion(item);\n\t                    }\n\t                    for (var key in layers) {\n\t                        var curLayer = layers[key];\n\t                        if (layer && layer === curLayer) {\n\t                            continue;\n\t                        }\n\t                        if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\n\t                            // \n\t                            curLayer.updateVersion(item);\n\t                        } else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\n\t                            //  \n\t                            curLayer.updateVersion(item.properties);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            lastLayersStr = '';\n\t            if (callback) {\n\t                callback(res);\n\t            }\n\t        };\n\t\n\t        if (document.body && !_Utils.gmxAPIutils.isPageHidden()) {\n\t            var hosts = getRequestParams(layer),\n\t                chkHost = function chkHost(hostName) {\n\t                var url = 'http://' + hostName + script,\n\t                    layersStr = JSON.stringify(hosts[hostName]);\n\t\n\t                if (lastLayersStr !== layersStr) {\n\t                    lastLayersStr = layersStr;\n\t                    if ('FormData' in window) {\n\t                        _Utils.gmxAPIutils.request({\n\t                            url: url,\n\t                            async: true,\n\t                            headers: {\n\t                                'Content-type': 'application/x-www-form-urlencoded'\n\t                            },\n\t                            type: 'POST',\n\t                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\n\t                            withCredentials: true,\n\t                            callback: function callback(response) {\n\t                                processResponse(JSON.parse(response));\n\t                            },\n\t                            onError: function onError(response) {\n\t                                console.log('Error: LayerVersion ', response);\n\t                            }\n\t                        });\n\t                    } else {\n\t                        _Utils.gmxAPIutils.sendCrossDomainPostRequest(url, {\n\t                            WrapStyle: 'message',\n\t                            layers: layersStr\n\t                        }, processResponse);\n\t                    }\n\t                    var timeStamp = Date.now();\n\t                    for (var key in layers) {\n\t                        var it = layers[key];\n\t                        var options = it._gmx || it.options;\n\t                        if (options.hostName === hostName) {\n\t                            options._stampVersionRequest = timeStamp;\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t            for (var hostName in hosts) {\n\t                chkHost(hostName);\n\t            }\n\t        }\n\t    };\n\t\n\t    var layersVersion = {\n\t\n\t        addDataManager: function addDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t            dataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\n\t            layers[id] = dataManager;\n\t        },\n\t\n\t        removeDataManager: function removeDataManager(dataManager) {\n\t            var id = dataManager.options.name;\n\t            if (id in layers) {\n\t                dataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\n\t                delete layers[id];\n\t            }\n\t        },\n\t\n\t        remove: function remove(layer) {\n\t            delete layers[layer._leaflet_id];\n\t            var _gmx = layer._gmx,\n\t                pOptions = layer.options.parentOptions;\n\t            if (pOptions) {\n\t                var pId = pOptions.name;\n\t                if (dataManagersLinks[pId]) {\n\t                    delete dataManagersLinks[pId][_gmx.properties.name];\n\t                    if (!Object.keys(dataManagersLinks[pId]).length) {\n\t                        layersVersion.removeDataManager(_gmx.dataManager);\n\t                        delete dataManagersLinks[pId];\n\t                    }\n\t                }\n\t            } else {\n\t                _gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\n\t            }\n\t        },\n\t\n\t        add: function add(layer) {\n\t            var id = layer._leaflet_id;\n\t            if (id in layers) {\n\t                return;\n\t            }\n\t\n\t            var _gmx = layer._gmx,\n\t                prop = _gmx.properties;\n\t            if ('LayerVersion' in prop) {\n\t                layers[id] = layer;\n\t                _gmx._chkVersion = function () {\n\t                    chkVersion(layer);\n\t                };\n\t                _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\n\t                var pOptions = layer.options.parentOptions;\n\t                if (pOptions) {\n\t                    var pId = pOptions.name;\n\t                    layersVersion.addDataManager(_gmx.dataManager);\n\t                    if (!dataManagersLinks[pId]) {\n\t                        dataManagersLinks[pId] = {};\n\t                    }\n\t                    dataManagersLinks[pId][prop.name] = layer;\n\t                }\n\t\n\t                layersVersion.start();\n\t                if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\n\t                    layersVersion.now();\n\t                }\n\t            }\n\t        },\n\t\n\t        chkVersion: chkVersion,\n\t\n\t        now: function now() {\n\t            if (timeoutID) {\n\t                clearTimeout(timeoutID);\n\t            }\n\t            timeoutID = setTimeout(chkVersion, 0);\n\t        },\n\t\n\t        stop: function stop() {\n\t            if (intervalID) {\n\t                clearInterval(intervalID);\n\t            }\n\t            intervalID = null;\n\t        },\n\t\n\t        start: function start(msec) {\n\t            if (msec) {\n\t                delay = msec;\n\t            }\n\t            layersVersion.stop();\n\t            intervalID = setInterval(chkVersion, delay);\n\t        }\n\t    };\n\t\n\t    if (!L.gmx) {\n\t        L.gmx = {};\n\t    }\n\t    L.gmx.layersVersion = layersVersion;\n\t\n\t    L.gmx.VectorLayer.include({\n\t        updateVersion: function updateVersion(layerDescription) {\n\t            if (layerDescription) {\n\t                var gmx = this._gmx;\n\t                if (layerDescription.geometry) {\n\t                    gmx.geometry = layerDescription.geometry;\n\t                }\n\t                if (layerDescription.properties) {\n\t                    L.extend(gmx.properties, layerDescription.properties);\n\t                    gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\n\t                    gmx.rawProperties = gmx.properties;\n\t                    this.fire('versionchange');\n\t                    if (!gmx.dataSource) {\n\t                        gmx.dataManager.updateVersion(gmx.rawProperties);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t//Raster layer is just vector layer with the single object and special background tiles\n\tL.gmx.RasterLayer = L.gmx.VectorLayer.extend({\n\t    options: {\n\t        isGeneralized: false,\n\t        zIndexOffset: 0\n\t        //clickable: false\n\t    },\n\t    initFromDescription: function initFromDescription(ph) {\n\t        var props = ph.properties,\n\t            styles = props.styles[0] || { MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21 },\n\t            vectorProperties = {\n\t            type: 'Vector',\n\t            fromType: props.type,\n\t            identityField: 'ogc_fid',\n\t            GeometryType: 'POLYGON',\n\t            IsRasterCatalog: true,\n\t            Copyright: props.Copyright || '',\n\t            RCMinZoomForRasters: styles.MinZoom,\n\t            visible: props.visible,\n\t            styles: [{\n\t                DisableBalloonOnClick: true,\n\t                MinZoom: styles.MinZoom,\n\t                MaxZoom: styles.MaxZoom,\n\t                RenderStyle: { outline: { thickness: 0 }, fill: { opacity: 100 } },\n\t                HoverStyle: null\n\t            }]\n\t        },\n\t            gmx = this._gmx,\n\t            worldSize = gmxAPIutils.tileSizes[1];\n\t\n\t        if (props.MaxZoom) {\n\t            gmx.maxNativeZoom = props.MaxZoom;\n\t        }\n\t        if (!ph.geometry) {\n\t            ph.geometry = {\n\t                type: 'POLYGON',\n\t                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\n\t            };\n\t        }\n\t\n\t        L.gmx.VectorLayer.prototype.initFromDescription.call(this, { geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties });\n\t\n\t        gmx.rasterBGfunc = function (x, y, z) {\n\t            return 'http://' + gmx.hostName + '/' + 'TileSender.ashx?ModeKey=tile' + '&key=' + encodeURIComponent(gmx.sessionKey) + '&LayerName=' + gmx.layerID + '&z=' + z + '&x=' + x + '&y=' + y;\n\t        };\n\t\n\t        var vectorDataProvider = { load: function load(x, y, z, v, s, d, callback) {\n\t                var objects = [[777, ph.geometry]],\n\t                    itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\n\t                    bounds = itemBounds.bounds;\n\t\n\t                if (bounds.max.x > worldSize) {\n\t                    // for old layers geometry\n\t                    var ww2 = 2 * worldSize,\n\t                        id = 777,\n\t                        coords = ph.geometry.coordinates,\n\t                        bboxArr = itemBounds.boundsArr;\n\t\n\t                    objects = [];\n\t                    if (ph.geometry.type === 'POLYGON') {\n\t                        coords = [coords];\n\t                        bboxArr = [bboxArr];\n\t                    }\n\t\n\t                    for (var i = 0, len = coords.length; i < len; i++) {\n\t                        var it = coords[i],\n\t                            bbox = bboxArr[i][0],\n\t                            arr = it;\n\t                        objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        if (bbox.max.x > worldSize) {\n\t                            arr = [];\n\t                            for (var j = 0, len1 = it.length; j < len1; j++) {\n\t                                var it1 = it[j];\n\t                                for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\n\t                                    var it2 = it1[j1];\n\t                                    arr1.push([it2[0] - ww2, it2[1]]);\n\t                                }\n\t                                arr.push(arr1);\n\t                            }\n\t                            objects.push([id++, { type: 'POLYGON', coordinates: arr }]);\n\t                        }\n\t                    }\n\t                }\n\t                callback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\n\t            } };\n\t        gmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, { x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2 });\n\t        gmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\n\t\n\t        return this;\n\t    },\n\t\n\t    setZoomBounds: function setZoomBounds(minZoom, maxZoom) {\n\t        var styles = this.getStyles().slice(0);\n\t        styles[0] = L.extend({}, styles[0]);\n\t        styles[0].MinZoom = minZoom;\n\t        styles[0].MaxZoom = maxZoom;\n\t        this.setStyles(styles);\n\t    }\n\t});\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.LabelsLayer = L.Class.extend({\n\t\n\t    options: {\n\t        pane: 'overlayPane'\n\t    },\n\t\n\t    initialize: function initialize(map, options) {\n\t        L.setOptions(this, options);\n\t        this._observers = {};\n\t        this._styleManagers = {};\n\t        this._labels = {};\n\t        var _this = this;\n\t\n\t        this.bbox = _Utils.gmxAPIutils.bounds();\n\t\n\t        var chkData = function chkData(data, layer) {\n\t            if (!data.added && !data.removed) {\n\t                return;\n\t            }\n\t\n\t            var opt = layer.options,\n\t                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\n\t                layerId = '_' + layer._leaflet_id,\n\t                gmx = layer._gmx,\n\t                labels = {};\n\t\n\t            for (var i = 0, len = added.length; i < len; i++) {\n\t                var item = added[i].item,\n\t                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\n\t                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\n\t\n\t                if (gmx.styleHook) {\n\t                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\n\t                    if (styleExtend) {\n\t                        currentStyle = L.extend({}, currentStyle, styleExtend);\n\t                    } else {\n\t                        continue;\n\t                    }\n\t                }\n\t                if (item.multiFilters) {\n\t                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\n\t                        var st = item.multiFilters[j].parsedStyle;\n\t                        if ('labelField' in st || 'labelText' in st) {\n\t                            currentStyle = st;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                var style = gmx.styleManager.getObjStyle(item) || {},\n\t                    labelText = currentStyle.labelText || style.labelText,\n\t                    labelField = currentStyle.labelField || style.labelField,\n\t                    fieldType = gmx.tileAttributeTypes[labelField],\n\t                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\n\t\n\t                if (style.labelTemplate) {\n\t                    var reg = /\\[([^\\]]*)\\]/g,\n\t                        match;\n\t                    txt = style.labelTemplate;\n\t\n\t                    while (match = reg.exec(style.labelTemplate)) {\n\t                        if (match.length === 2) {\n\t                            labelField = match[1];\n\t                            fieldType = gmx.tileAttributeTypes[labelField];\n\t                            var val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\n\t                            txt = txt.replace(match[0], val);\n\t                        }\n\t                    }\n\t                }\n\t                if (txt || txt === 0) {\n\t                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\n\t                        id = '_' + item.id,\n\t                        changed = true,\n\t                        width = 0,\n\t                        arrTxtWidth,\n\t                        options = item.options,\n\t                        labelStyle = {\n\t                        font: fontSize + 'px \"Arial\"',\n\t                        labelHaloColor: 'labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : 'labelHaloColor' in style ? style.labelHaloColor : 0xffffff,\n\t                        labelColor: currentStyle.labelColor || style.labelColor,\n\t                        labelAlign: currentStyle.labelAlign || style.labelAlign,\n\t                        labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\n\t                        labelFontSize: fontSize\n\t                    };\n\t                    if (options) {\n\t                        if (!('center' in options)) {\n\t                            var center = _Utils.gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\n\t                            if (!center) {\n\t                                continue;\n\t                            }\n\t                            options.center = center;\n\t                        }\n\t                        if (options.label) {\n\t                            width = options.label.width;\n\t                            arrTxtWidth = options.label.arrTxtWidth;\n\t                            var pstyle = options.label.style;\n\t                            changed = options.label.txt !== txt || pstyle.labelHaloColor !== labelStyle.labelHaloColor || pstyle.labelColor !== labelStyle.labelColor || pstyle.labelAlign !== labelStyle.labelAlign || pstyle.labelAnchor !== labelStyle.labelAnchor || pstyle.labelFontSize !== labelStyle.labelFontSize;\n\t                        }\n\t                    }\n\t                    if (changed) {\n\t                        width = 0;\n\t                        arrTxtWidth = _Utils.gmxAPIutils.getLabelWidth(txt, labelStyle);\n\t                        if (arrTxtWidth) {\n\t                            arrTxtWidth.forEach(function (it) {\n\t                                width = Math.max(width, it[1]);\n\t                            });\n\t                        }\n\t\n\t                        if (!width) {\n\t                            delete labels[id];\n\t                            continue;\n\t                        }\n\t                        width += 4;\n\t                        item.options.labelStyle = null;\n\t                    }\n\t                    options.label = {\n\t                        isPoint: isPoint,\n\t                        width: width,\n\t                        sx: style.sx || 0,\n\t                        txt: txt,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        style: labelStyle\n\t                    };\n\t                    labels[id] = item;\n\t                }\n\t            }\n\t            _this._labels[layerId] = labels;\n\t        };\n\t\n\t        var addObserver = function addObserver(layer) {\n\t            var gmx = layer._gmx,\n\t                filters = ['styleFilter', 'userFilter'],\n\t                options = {\n\t                type: 'resend',\n\t                bbox: _this.bbox,\n\t                filters: filters,\n\t                callback: function callback(data) {\n\t                    chkData(data, layer);\n\t                    _this.redraw();\n\t                }\n\t            };\n\t            if (gmx.beginDate && gmx.endDate) {\n\t                options.dateInterval = [gmx.beginDate, gmx.endDate];\n\t            }\n\t            return gmx.dataManager.addObserver(options, '_Labels');\n\t        };\n\t        this.add = function (layer) {\n\t            var id = layer._leaflet_id,\n\t                gmx = layer._gmx;\n\t\n\t            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\n\t                gmx.styleManager.deferred.then(function () {\n\t                    var observer = addObserver(layer),\n\t                        _zoom = _this._map._zoom;\n\t                    if (layer.options.isGeneralized) {\n\t                        observer.targetZoom = _zoom; //need update to current zoom\n\t                    }\n\t                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\n\t                        observer.deactivate();\n\t                    }\n\t                    _this._observers[id] = observer;\n\t                    _this._styleManagers[id] = gmx.styleManager;\n\t\n\t                    _this._labels['_' + id] = {};\n\t                    _this._updateBbox();\n\t                });\n\t            }\n\t        };\n\t        this.remove = function (layer) {\n\t            var id = layer._leaflet_id;\n\t            if (_this._observers[id]) {\n\t                var gmx = layer._gmx,\n\t                    dataManager = gmx.dataManager;\n\t                dataManager.removeObserver(_this._observers[id].id);\n\t                delete _this._observers[id];\n\t                delete _this._styleManagers[id];\n\t                delete _this._labels['_' + id];\n\t                _this.redraw();\n\t            }\n\t        };\n\t        this._layeradd = function (ev) {\n\t            _this.add(ev.layer);\n\t        };\n\t        this._layerremove = function (ev) {\n\t            _this.remove(ev.layer);\n\t        };\n\t    },\n\t\n\t    redraw: function redraw() {\n\t        if (!this._frame && !this._map._animating) {\n\t            this._frame = L.Util.requestAnimFrame(this._redraw, this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    _addToPane: function _addToPane() {\n\t        var pane = this._map.getPanes()[this.options.pane];\n\t        if (pane) {\n\t            pane.insertBefore(this._canvas, pane.firstChild);\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t        this._map = map;\n\t\n\t        if (!this._canvas) {\n\t            this._initCanvas();\n\t        }\n\t        // this._addToPane();\n\t\n\t        map.on('moveend', this._reset, this);\n\t        map.on({\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        });\n\t        if (map.options.zoomAnimation && L.Browser.any3d) {\n\t            map.on('zoomanim', this._animateZoom, this);\n\t        }\n\t\n\t        this._reset();\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t        if (this._canvas.parentNode) {\n\t            this._canvas.parentNode.removeChild(this._canvas);\n\t        }\n\t\n\t        map.off('moveend', this._reset, this);\n\t        map.off('layeradd', this._layeradd);\n\t        map.off('layerremove', this._layerremove);\n\t\n\t        if (map.options.zoomAnimation) {\n\t            map.off('zoomanim', this._animateZoom, this);\n\t        }\n\t    },\n\t\n\t    addTo: function addTo(map) {\n\t        map.addLayer(this);\n\t        return this;\n\t    },\n\t\n\t    _initCanvas: function _initCanvas() {\n\t        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\n\t            size = this._map.getSize();\n\t        canvas.width = size.x;canvas.height = size.y;\n\t        canvas.style.pointerEvents = 'none';\n\t        this._canvas = canvas;\n\t\n\t        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\n\t        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        var _map = this._map,\n\t            screenBounds = _map.getBounds(),\n\t            southWest = screenBounds.getSouthWest(),\n\t            northEast = screenBounds.getNorthEast(),\n\t            m1 = L.Projection.Mercator.project(southWest),\n\t            m2 = L.Projection.Mercator.project(northEast),\n\t            _zoom = _map.getZoom();\n\t\n\t        this.mInPixel = _Utils.gmxAPIutils.getPixelScale(_zoom);\n\t        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (observer.targetZoom) {\n\t                observer.targetZoom = _zoom;\n\t            }\n\t            observer.setBounds({\n\t                min: { x: southWest.lng, y: southWest.lat },\n\t                max: { x: northEast.lng, y: northEast.lat }\n\t            });\n\t        }\n\t    },\n\t\n\t    _reset: function _reset() {\n\t        this._updateBbox();\n\t        for (var id in this._observers) {\n\t            var observer = this._observers[id];\n\t            if (!observer.isActive() && this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())) {\n\t                observer.activate();\n\t            }\n\t            observer.fire('update');\n\t        }\n\t    },\n\t\n\t    _redraw: function _redraw() {\n\t        var out = [],\n\t            _map = this._map,\n\t            mapSize = _map.getSize(),\n\t            _canvas = this._canvas,\n\t            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\n\t            topLeft = _map.containerPointToLayerPoint(offset);\n\t\n\t        _canvas.width = mapSize.x;_canvas.height = mapSize.y;\n\t        L.DomUtil.setPosition(_canvas, topLeft);\n\t\n\t        var w2 = 2 * this.mInPixel * _Utils.gmxAPIutils.worldWidthMerc,\n\t            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\n\t            ctx = _canvas.getContext('2d'),\n\t            i,\n\t            len,\n\t            it;\n\t\n\t        for (var layerId in this._labels) {\n\t            var labels = this._labels[layerId];\n\t            for (var id in labels) {\n\t                it = labels[id];\n\t                var options = it.options,\n\t                    label = options.label,\n\t                    style = label.style,\n\t                    labelAlign = style.labelAlign || 'center',\n\t                    arrTxtWidth = label.arrTxtWidth,\n\t                    count = arrTxtWidth.length || 1,\n\t                    width = label.width,\n\t                    width2 = width / 2,\n\t                    size = style.labelFontSize || 12,\n\t                    size2 = size / 2,\n\t                    center = options.center,\n\t                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\n\t                    isFiltered = false;\n\t\n\t                if (label.isPoint) {\n\t                    var delta = label.sx;\n\t                    if (labelAlign === 'left') {\n\t                        pos[0] += width2 + delta;\n\t                    } else if (labelAlign === 'right') {\n\t                        pos[0] -= width + delta;\n\t                    }\n\t                }\n\t                pos[0] -= width2 + this._ctxShift[0];\n\t                pos[1] = -size2 - pos[1] + this._ctxShift[1];\n\t                size2 *= count;\n\t                if (style.labelAnchor) {\n\t                    pos[0] += style.labelAnchor[0];\n\t                    pos[1] += style.labelAnchor[1];\n\t                }\n\t\n\t                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\n\t                    var coord = [Math.floor(tx), Math.floor(pos[1])],\n\t                        bbox = _Utils.gmxAPIutils.bounds([[coord[0] - width2, coord[1] - size2], [coord[0] + width2, coord[1] + size2]]);\n\t                    for (i = 0, len = out.length; i < len; i++) {\n\t                        if (bbox.intersects(out[i].bbox)) {\n\t                            isFiltered = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (isFiltered) {\n\t                        continue;\n\t                    }\n\t\n\t                    if (!options.labelStyle) {\n\t                        options.labelStyle = {\n\t                            font: size + 'px \"Arial\"',\n\t                            fillStyle: _Utils.gmxAPIutils.dec2color(style.labelColor || 0, 1),\n\t                            shadowBlur: 4\n\t                        };\n\t                        if (style.labelHaloColor !== -1) {\n\t                            options.labelStyle.strokeStyle = options.labelStyle.shadowColor = _Utils.gmxAPIutils.dec2color(style.labelHaloColor, 1);\n\t                        }\n\t                    }\n\t                    out.push({\n\t                        arr: it.properties,\n\t                        bbox: bbox,\n\t                        arrTxtWidth: arrTxtWidth,\n\t                        width2: labelAlign === 'center' ? width2 : 0,\n\t                        txt: label.txt,\n\t                        style: options.labelStyle,\n\t                        size: size,\n\t                        coord: coord\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        if (out.length) {\n\t            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\n\t            for (i = 0, len = out.length; i < len; i++) {\n\t                it = out[i];\n\t                it.arrTxtWidth.forEach(function (pt, nm) {\n\t                    var coord = [it.coord[0] + it.width2 - pt[1] / 2, it.coord[1] + nm * it.size];\n\t                    _Utils.gmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\n\t                });\n\t            }\n\t            if (!_canvas.parentNode) {\n\t                this._addToPane();\n\t            }\n\t        } else if (_canvas.parentNode) {\n\t            _canvas.parentNode.removeChild(_canvas);\n\t        }\n\t\n\t        this._frame = null;\n\t    },\n\t\n\t    _animateZoom: function _animateZoom(e) {\n\t        var scale = this._map.getZoomScale(e.zoom),\n\t            pixelBoundsMin = this._map.getPixelBounds().min;\n\t\n\t        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\n\t        if (pixelBoundsMin.y < 0) {\n\t            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\n\t        }\n\t\n\t        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\n\t    }\n\t}); /*\r\n\t     (c) 2014, Sergey Alekseev\r\n\t     Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n\t    */\n\t\n\t\n\tL.labelsLayer = function (map, options) {\n\t    return new L.LabelsLayer(map, options);\n\t};\n\t\n\tL.Map.addInitHook(function () {\n\t    // Check to see if Labels has already been initialized.\n\t    if (!this._labelsLayer) {\n\t        this._labelsLayer = new L.LabelsLayer(this);\n\t        this._labelsLayer.addTo(this);\n\t    }\n\t});\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var isBoundsIntersects = function isBoundsIntersects(bounds, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].intersects(bounds)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    var isObserverIntersects = function isObserverIntersects(observer, clipPolygons) {\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (observer.intersects(bbox[j1])) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var _isPointInClipPolygons = function _isPointInClipPolygons(chkPoint, clipPolygons) {\n\t        if (!clipPolygons || Object.keys(clipPolygons).length === 0) {\n\t            return true;\n\t        }\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var it = arr[i],\n\t                    type = it.geometry.type,\n\t                    boundsArr = it.boundsArr;\n\t                for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\n\t                    var bbox = boundsArr[j];\n\t                    if (type === 'Polygon') {\n\t                        bbox = [bbox];\n\t                    }\n\t                    for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\n\t                        if (bbox[j1].contains(chkPoint)) {\n\t                            var coords = it.geometry.coordinates,\n\t                                isIn = false;\n\t                            if (type === 'Polygon') {\n\t                                coords = [coords];\n\t                            }\n\t                            for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\n\t                                if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\n\t                                    isIn = true;\n\t                                    break;\n\t                                }\n\t                            }\n\t                            if (isIn) {\n\t                                return true;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    var getClipPolygonItem = function getClipPolygonItem(geo) {\n\t        var geometry = gmxAPIutils.convertGeometry(geo),\n\t            bboxArr = gmxAPIutils.geoItemBounds(geometry);\n\t        bboxArr.geometry = geometry;\n\t        return bboxArr;\n\t    };\n\t\n\t    var clipTileByPolygon = function clipTileByPolygon(dattr) {\n\t        var canvas = document.createElement('canvas');\n\t        canvas.width = canvas.height = 256;\n\t        var ctx = canvas.getContext('2d'),\n\t            clipPolygons = dattr.clipPolygons;\n\t\n\t        dattr.ctx = ctx;\n\t        ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\n\t\n\t        for (var key in clipPolygons) {\n\t            var arr = clipPolygons[key];\n\t            for (var i = 0, len = arr.length; i < len; i++) {\n\t                var geo = arr[i].geometry,\n\t                    coords = geo.coordinates;\n\t                if (geo.type === 'Polygon') {\n\t                    coords = [coords];\n\t                }\n\t                for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\n\t                    var coords1 = coords[i1];\n\t                    ctx.beginPath();\n\t                    for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\n\t                        dattr.coords = coords1[j1];\n\t                        var pixels = gmxAPIutils.getRingPixels(dattr);\n\t                        dattr.coords = pixels.coords;\n\t                        gmxAPIutils.polygonToCanvasFill(dattr);\n\t                    }\n\t                    ctx.closePath();\n\t                    ctx.fill();\n\t                }\n\t            }\n\t        }\n\t        ctx = dattr.tile.getContext('2d');\n\t        ctx.clearRect(0, 0, 256, 256);\n\t        ctx.drawImage(canvas, 0, 0);\n\t    };\n\t\n\t    L.gmx.VectorLayer.include({\n\t\n\t        isPointInClipPolygons: function isPointInClipPolygons(point) {\n\t            // point [x, y] in Mercator\n\t            return _isPointInClipPolygons(point, this._gmx._clipPolygons);\n\t        },\n\t\n\t        addClipPolygon: function addClipPolygon(polygon) {\n\t            // (L.Polygon) or (L.GeoJSON with Polygons)\n\t            var item = [],\n\t                i,\n\t                len;\n\t\n\t            if ('coordinates' in polygon && 'type' in polygon) {\n\t                item.push(getClipPolygonItem(polygon));\n\t            } else if (polygon instanceof L.Polygon) {\n\t                item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\n\t            } else if (polygon instanceof L.GeoJSON) {\n\t                var layers = polygon.getLayers();\n\t                for (i = 0, len = layers.length; i < len; i++) {\n\t                    var layer = layers[i];\n\t                    if (layer instanceof L.Polygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    } else if (layer instanceof L.MultiPolygon && layer.feature) {\n\t                        item.push(getClipPolygonItem(layer.feature.geometry));\n\t                    }\n\t                }\n\t            }\n\t            if (item.length) {\n\t                var gmx = this._gmx,\n\t                    dataManager = gmx.dataManager,\n\t                    _this = this,\n\t                    id = L.stamp(polygon);\n\t\n\t                if (!this._gmx._clipPolygons) {\n\t                    this._gmx._clipPolygons = {};\n\t                }\n\t                this._gmx._clipPolygons[id] = item;\n\t                dataManager.setTileFilteringHook(function (tile) {\n\t                    return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipFilter', function (item, tile, observer) {\n\t                    return isObserverIntersects(observer, _this._gmx._clipPolygons);\n\t                });\n\t\n\t                dataManager.addFilter('clipPointsFilter', function (item) {\n\t                    if (item.type === 'POINT') {\n\t                        var propArr = item.properties,\n\t                            geom = propArr[propArr.length - 1];\n\t                        return _isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\n\t                    }\n\t                    return true;\n\t                });\n\t                if (Object.keys(this._gmx._clipPolygons).length === 1) {\n\t                    gmx.renderHooks.unshift(function (tile, hookInfo) {\n\t                        if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\n\t                            clipTileByPolygon({\n\t                                tile: tile,\n\t                                tpx: hookInfo.tpx,\n\t                                tpy: hookInfo.tpy,\n\t                                gmx: { mInPixel: gmx.mInPixel },\n\t                                clipPolygons: _this._gmx._clipPolygons\n\t                            });\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        removeClipPolygon: function removeClipPolygon(polygon) {\n\t            var id = L.stamp(polygon);\n\t            if (this._gmx._clipPolygons) {\n\t                delete this._gmx._clipPolygons[id];\n\t                if (Object.keys(this._gmx._clipPolygons).length === 0) {\n\t                    this._gmx.dataManager.removeTileFilteringHook();\n\t                    this._gmx.dataManager.removeFilter('clipFilter');\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.gmxImageTransform = function (img, hash) {\n\t    var gmx = hash.gmx,\n\t        gmxTilePoint = hash.gmxTilePoint,\n\t        mInPixel = gmx.mInPixel,\n\t        geoItem = hash.geoItem,\n\t        properties = geoItem.properties,\n\t        dataOption = geoItem.dataOption || {},\n\t\n\t\n\t    // geom = properties[properties.length - 1],\n\t    // coord = geom.coordinates[0],\n\t    indexes = gmx.tileAttributeIndexes,\n\t        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\n\t        points = {};\n\t\n\t    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\n\t    if (quicklookPlatform === 'LANDSAT8') {\n\t        points.x1 = dataOption.bounds.min.x;points.y1 = dataOption.bounds.max.y;\n\t        points.x2 = dataOption.bounds.max.x;points.y2 = dataOption.bounds.max.y;\n\t        points.x3 = dataOption.bounds.max.x;points.y3 = dataOption.bounds.min.y;\n\t        points.x4 = dataOption.bounds.min.x;points.y4 = dataOption.bounds.min.y;\n\t    } else {\n\t        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\n\t    }\n\t\n\t    var x1 = mInPixel * points.x1,\n\t        y1 = mInPixel * points.y1,\n\t        x2 = mInPixel * points.x2,\n\t        y2 = mInPixel * points.y2,\n\t        x3 = mInPixel * points.x3,\n\t        y3 = mInPixel * points.y3,\n\t        x4 = mInPixel * points.x4,\n\t        y4 = mInPixel * points.y4,\n\t        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\n\t        ww = Math.round(boundsP.max.x - boundsP.min.x),\n\t        hh = Math.round(boundsP.max.y - boundsP.min.y),\n\t        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\n\t        itbounds = geoItem.item.bounds,\n\t        wMerc = gmxAPIutils.worldWidthMerc,\n\t        tpx = gmxTilePoint.x;\n\t\n\t    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\n\t        // For points intersects 180 deg\n\t        tpx += Math.round(wMerc * mInPixel / 128);\n\t    }\n\t    var dx = boundsP.min.x - 256 * tpx;\n\t\n\t    x1 -= boundsP.min.x;y1 = boundsP.max.y - y1;\n\t    x2 -= boundsP.min.x;y2 = boundsP.max.y - y2;\n\t    x3 -= boundsP.min.x;y3 = boundsP.max.y - y3;\n\t    x4 -= boundsP.min.x;y4 = boundsP.max.y - y4;\n\t\n\t    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\n\t\n\t    if (!gmx.ProjectiveImage) {\n\t        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\n\t    }\n\t    var pt = gmx.ProjectiveImage.getCanvas({\n\t        imageObj: img,\n\t        points: shiftPoints,\n\t        wView: ww,\n\t        hView: hh,\n\t        deltaX: dx,\n\t        deltaY: dy\n\t    });\n\t    return pt.canvas;\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    var ProjectiveImageWebGL = L.Class.extend({\n\t        options: {\n\t            antialias: true,\n\t            depth: false,\n\t            preserveDrawingBuffer: true,\n\t            shaderVS: 'attribute vec2 aVertCoord;\\\r\n\t            uniform mat4 uTransformMatrix;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            void main(void) {\\\r\n\t                vTextureCoord = aVertCoord;\\\r\n\t                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n\t            }\\\r\n\t        ',\n\t            shaderFS: 'precision mediump float;\\\r\n\t            varying vec2 vTextureCoord;\\\r\n\t            uniform sampler2D uSampler;\\\r\n\t            void main(void) {\\\r\n\t                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n\t            }\\\r\n\t        '\n\t        },\n\t\n\t        setOptions: function setOptions(options) {\n\t            L.setOptions(this, options);\n\t        },\n\t\n\t        initialize: function initialize(options) {\n\t            this.setOptions(options);\n\t\n\t            var canvas = document.createElement('canvas'),\n\t                glOpts = {\n\t                antialias: this.options.antialias,\n\t                depth: this.options.depth,\n\t                preserveDrawingBuffer: this.options.preserveDrawingBuffer\n\t            },\n\t                gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\n\t            if (!gl) {\n\t                return;\n\t            }\n\t            var glResources = this._setupGlContext(gl);\n\t            if (!glResources) {\n\t                return;\n\t            }\n\t\n\t            canvas.width = canvas.height = 256;\n\t            glResources.canvas = canvas;\n\t\n\t            this.glResources = glResources;\n\t            this.canvas = canvas;\n\t            this.gl = gl;\n\t        },\n\t\n\t        _getShader: function _getShader(type, source, gl) {\n\t            var shader = gl.createShader(type);\n\t\n\t            gl.shaderSource(shader, source);\n\t            gl.compileShader(shader);\n\t\n\t            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t                gl.deleteShader(shader);\n\t                return null;\n\t            }\n\t            return shader;\n\t        },\n\t\n\t        _setupGlContext: function _setupGlContext(gl) {\n\t            // Store return values here\n\t            var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\n\t                fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\n\t\n\t            if (vertexShader && fragmentShader) {\n\t                // Compile the program\n\t                var shaderProgram = gl.createProgram();\n\t                gl.attachShader(shaderProgram, vertexShader);\n\t                gl.attachShader(shaderProgram, fragmentShader);\n\t                gl.linkProgram(shaderProgram);\n\t\n\t                if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n\t                    // Find and set up the uniforms and attributes\n\t                    gl.useProgram(shaderProgram);\n\t                    this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n\t                    var vertexBuffer = gl.createBuffer(),\n\t\n\t                    // Create a buffer to hold the vertices\n\t                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\n\t                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n\t                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\n\t\n\t                    // draw the triangles\n\t                    gl.enableVertexAttribArray(vertAttrib);\n\t                    gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\n\t                    return {\n\t                        transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\n\t                        samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\n\t                        screenTexture: gl.createTexture() // Create a texture to use for the screen image\n\t                    };\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        _bindTexture: function _bindTexture(gl, image, texture) {\n\t            gl.bindTexture(gl.TEXTURE_2D, texture);\n\t            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\t\n\t            // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t            // Prevents s-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t            // Prevents t-coordinate wrapping (repeating).\n\t            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t            gl.bindTexture(gl.TEXTURE_2D, null);\n\t        },\n\t\n\t        getCanvas: function getCanvas(attr) {\n\t            var p = attr.points,\n\t                deltaX = attr.deltaX,\n\t                deltaY = attr.deltaY,\n\t                dstPoints = new Float32Array([(p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128, (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128, (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128, (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128]);\n\t\n\t            var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\n\t                gl = this.gl,\n\t                glResources = this.glResources;\n\t\n\t            this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\n\t\n\t            gl.viewport(0, 0, 256, 256);\n\t            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // set background to full transparency\n\t\n\t            gl.uniformMatrix4fv(glResources.transMatUniform, false, [v[0], v[3], 0, v[6], v[1], v[4], 0, v[7], 0, 0, 1, 0, v[2], v[5], 0, 1]);\n\t\n\t            gl.activeTexture(gl.TEXTURE0);\n\t            gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\n\t            gl.uniform1i(glResources.samplerUniform, 0);\n\t\n\t            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\t            return this;\n\t        }\n\t    });\n\t\n\t    function adj(m) {\n\t        // Compute the adjugate of m\n\t        return [m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4], m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5], m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]];\n\t    }\n\t\n\t    function multmm(a, b) {\n\t        // multiply two matrices\n\t        var c = Array(9);\n\t        for (var i = 0; i !== 3; ++i) {\n\t            for (var j = 0; j !== 3; ++j) {\n\t                var cij = 0;\n\t                for (var k = 0; k !== 3; ++k) {\n\t                    cij += a[3 * i + k] * b[3 * k + j];\n\t                }\n\t                c[3 * i + j] = cij;\n\t            }\n\t        }\n\t        return c;\n\t    }\n\t\n\t    function multmv(m, v) {\n\t        // multiply matrix and vector\n\t        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n\t    }\n\t\n\t    function basisToPoints(p) {\n\t        var m = [p[0], p[2], p[4], p[1], p[3], p[5], 1, 1, 1];\n\t        var v = multmv(adj(m), [p[6], p[7], 1]);\n\t        return multmm(m, [v[0], 0, 0, 0, v[1], 0, 0, 0, v[2]]);\n\t    }\n\t\n\t    ProjectiveImageWebGL.Utils = {\n\t        general2DProjection: function general2DProjection(from, to) {\n\t            var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\n\t            if (arr[8]) {\n\t                for (var i = 0; i !== 9; ++i) {\n\t                    arr[i] = arr[i] / arr[8];\n\t                }\n\t            }\n\t            return arr;\n\t        },\n\t\n\t        getWebGlResources: function getWebGlResources(options) {\n\t            var obj = new ProjectiveImageWebGL(options);\n\t            return obj.gl ? obj : null;\n\t        }\n\t    };\n\t    L.gmx.projectiveImageWebGL = function (options) {\n\t        var res = new ProjectiveImageWebGL(options);\n\t        return res.gl ? res : null;\n\t    };\n\t})();\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t\t// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\n\t\tvar ProjectiveImage = function ProjectiveImage() {\n\t\t\tvar cnt = 0,\n\t\t\t    limit = 4,\n\t\t\t    patchSize = 64,\n\t\t\t    transform = null;\n\t\n\t\t\tvar allocate = function allocate(w, h) {\n\t\t\t\tvar values = [];\n\t\t\t\tfor (var i = 0; i < h; ++i) {\n\t\t\t\t\tvalues[i] = [];\n\t\t\t\t\tfor (var j = 0; j < w; ++j) {\n\t\t\t\t\t\tvalues[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t};\n\t\n\t\t\tvar Matrix = function Matrix(w, h, values) {\n\t\t\t\tthis.w = w;\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.values = values || allocate(h);\n\t\t\t};\n\t\n\t\t\tvar cloneValues = function cloneValues(values) {\n\t\t\t\tvar clone = [];\n\t\t\t\tfor (var i = 0; i < values.length; ++i) {\n\t\t\t\t\tclone[i] = [].concat(values[i]);\n\t\t\t\t}\n\t\t\t\treturn clone;\n\t\t\t};\n\t\n\t\t\tMatrix.prototype = {\n\t\t\t\tadd: function add(operand) {\n\t\t\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix add size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (var x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] + operand.values[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t},\n\t\t\t\ttransformProjectiveVector: function transformProjectiveVector(operand) {\n\t\t\t\t\tvar out = [],\n\t\t\t\t\t    x,\n\t\t\t\t\t    y;\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tout[y] = 0;\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar zn = out[out.length - 1];\n\t\t\t\t\tif (zn) {\n\t\t\t\t\t\tvar iz = 1 / out[out.length - 1];\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tout[y] *= iz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn out;\n\t\t\t\t},\n\t\t\t\tmultiply: function multiply(operand) {\n\t\t\t\t\tvar values, x, y;\n\t\t\t\t\tif (+operand !== operand) {\n\t\t\t\t\t\t// Matrix mult\n\t\t\t\t\t\tif (operand.h !== this.w) {\n\t\t\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\n\t\t\t\t\t\t\t\tvar accum = 0;\n\t\t\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\n\t\t\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvalues[y][x] = accum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(operand.w, this.h, values);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Scalar mult\n\t\t\t\t\t\tvalues = allocate(this.w, this.h);\n\t\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trowEchelon: function rowEchelon() {\n\t\t\t\t\tif (this.w <= this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = cloneValues(this.values);\n\t\n\t\t\t\t\t// Do Gauss-Jordan algorithm.\n\t\t\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\n\t\t\t\t\t\t// Look up pivot value.\n\t\t\t\t\t\tvar pivot = temp[yp][yp];\n\t\t\t\t\t\twhile (pivot === 0) {\n\t\t\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\n\t\t\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\n\t\t\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\n\t\t\t\t\t\t\t\t\t// Swap rows.\n\t\t\t\t\t\t\t\t\tvar tmpRow = temp[ys];\n\t\t\t\t\t\t\t\t\ttemp[ys] = temp[yp];\n\t\t\t\t\t\t\t\t\ttemp[yp] = tmpRow;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ys === this.h) {\n\t\t\t\t\t\t\t\t// No suitable pivot found. Abort.\n\t\t\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpivot = temp[yp][yp];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Normalize this row.\n\t\t\t\t\t\tvar scale = 1 / pivot;\n\t\t\t\t\t\tfor (var x = yp; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[yp][x] *= scale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Subtract this row from all other rows (scaled).\n\t\t\t\t\t\tfor (var y = 0; y < this.h; ++y) {\n\t\t\t\t\t\t\tif (y === yp) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar factor = temp[y][yp];\n\t\t\t\t\t\t\ttemp[y][yp] = 0;\n\t\t\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\n\t\t\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\n\t\t\t\t},\n\t\t\t\tinvert: function invert() {\n\t\t\t\t\tvar x, y;\n\t\n\t\t\t\t\tif (this.w !== this.h) {\n\t\t\t\t\t\tthrow new Error('Matrix invert size mismatch');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar temp = allocate(this.w * 2, this.h);\n\t\n\t\t\t\t\t// Initialize augmented matrix\n\t\t\t\t\tfor (y = 0; y < this.h; ++y) {\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\ttemp[y][x] = this.values[y][x];\n\t\t\t\t\t\t\ttemp[y][x + this.w] = x === y ? 1 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\n\t\t\t\t\ttemp = temp.rowEchelon();\n\t\n\t\t\t\t\t// Extract right block matrix.\n\t\t\t\t\tvar values = allocate(this.w, this.h);\n\t\t\t\t\tfor (y = 0; y < this.w; ++y) {\n\t\t\t\t\t\t// @todo check if \"x < this.w;\" is mistake\n\t\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\n\t\t\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new Matrix(this.w, this.h, values);\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tvar getProjectiveTransform = function getProjectiveTransform(points) {\n\t\t\t\tvar eqMatrix = new Matrix(9, 8, [[1, 1, 1, 0, 0, 0, -points[2][0], -points[2][0], -points[2][0]], [0, 1, 1, 0, 0, 0, 0, -points[3][0], -points[3][0]], [1, 0, 1, 0, 0, 0, -points[1][0], 0, -points[1][0]], [0, 0, 1, 0, 0, 0, 0, 0, -points[0][0]], [0, 0, 0, -1, -1, -1, points[2][1], points[2][1], points[2][1]], [0, 0, 0, 0, -1, -1, 0, points[3][1], points[3][1]], [0, 0, 0, -1, 0, -1, points[1][1], 0, points[1][1]], [0, 0, 0, 0, 0, -1, 0, 0, points[0][1]]]);\n\t\n\t\t\t\tvar kernel = eqMatrix.rowEchelon().values;\n\t\t\t\tvar transform = new Matrix(3, 3, [[-kernel[0][8], -kernel[1][8], -kernel[2][8]], [-kernel[3][8], -kernel[4][8], -kernel[5][8]], [-kernel[6][8], -kernel[7][8], 1]]);\n\t\t\t\treturn transform;\n\t\t\t};\n\t\n\t\t\tvar divide = function divide(u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\n\t\t\t\tif (limit) {\n\t\t\t\t\t// Measure patch non-affinity.\n\t\t\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\n\t\t\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\n\t\t\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\n\t\t\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\n\t\n\t\t\t\t\t// Measure patch area.\n\t\t\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\n\t\t\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\n\t\t\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\n\t\n\t\t\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\n\t\t\t\t\t// The non-affinity measure is used as a correction factor.\n\t\t\t\t\tif (u1 === 0 && u4 === 1 || (.25 + r * 5) * area > patchSize * patchSize) {\n\t\t\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\n\t\t\t\t\t\tvar umid = (u1 + u4) / 2;\n\t\t\t\t\t\tvar vmid = (v1 + v4) / 2;\n\t\t\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\n\t\t\t\t\t\tvar pt = transform.transformProjectiveVector([umid, v1, 1]);\n\t\t\t\t\t\tvar pb = transform.transformProjectiveVector([umid, v4, 1]);\n\t\t\t\t\t\tvar pl = transform.transformProjectiveVector([u1, vmid, 1]);\n\t\t\t\t\t\tvar pr = transform.transformProjectiveVector([u4, vmid, 1]);\n\t\n\t\t\t\t\t\t// Subdivide.\n\t\t\t\t\t\tlimit--;\n\t\t\t\t\t\tdivide.call(this, u1, v1, umid, vmid, p1, pt, pl, pmid, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, v1, u4, vmid, pt, p2, pmid, pr, limit, attr);\n\t\t\t\t\t\tdivide.call(this, u1, vmid, umid, v4, pl, pmid, p3, pb, limit, attr);\n\t\t\t\t\t\tdivide.call(this, umid, vmid, u4, v4, pmid, pr, pb, p4, limit, attr);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar ctx = attr.ctx;\n\t\n\t\t\t\t// Get patch edge vectors.\n\t\t\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\n\t\t\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\n\t\t\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\n\t\t\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\n\t\n\t\t\t\t// Find the corner that encloses the most area\n\t\t\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\n\t\t\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\n\t\t\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\n\t\t\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\n\t\t\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\n\t\t\t\tvar dx = 0,\n\t\t\t\t    dy = 0,\n\t\t\t\t    padx = 0,\n\t\t\t\t    pady = 0;\n\t\n\t\t\t\t// Align the transform along this corner.\n\t\t\t\t// Calculate 1.05 pixel padding on vector basis.\n\t\t\t\tif (amax === a1) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t} else if (amax === a2) {\n\t\t\t\t\tctx.setTransform(d12[0], d12[1], d24[0], d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t} else if (amax === a4) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdx = -1;\n\t\t\t\t\tdy = -1;\n\t\t\t\t} else if (amax === a3) {\n\t\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\n\t\t\t\t\tif (u4 !== 1) {\n\t\t\t\t\t\tpadx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (v4 !== 1) {\n\t\t\t\t\t\tpady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]);\n\t\t\t\t\t}\n\t\t\t\t\tdy = -1;\n\t\t\t\t}\n\t\n\t\t\t\t// Calculate image padding to match.\n\t\t\t\tvar du = u4 - u1;\n\t\t\t\tvar dv = v4 - v1;\n\t\t\t\tpadx++;\n\t\t\t\tpady++;\n\t\n\t\t\t\tvar iw = attr.imageObj.width,\n\t\t\t\t    ih = attr.imageObj.height,\n\t\t\t\t    sx = Math.floor(u1 * iw),\n\t\t\t\t    sy = Math.floor(v1 * ih),\n\t\t\t\t    sw = Math.floor(Math.min(padx * du, 1) * iw),\n\t\t\t\t    sh = Math.floor(Math.min(pady * dv, 1) * ih);\n\t\n\t\t\t\tcnt++;\n\t\t\t\tctx.drawImage(attr.imageObj, sx, sy, sw, sh, dx, dy, padx, pady);\n\t\t\t};\n\t\n\t\t\tthis.getCanvas = function (attr) {\n\t\t\t\tcnt = 0;\n\t\t\t\ttransform = getProjectiveTransform(attr.points);\n\t\t\t\t// Begin subdivision process.\n\t\n\t\t\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\n\t\t\t\t    ptr = transform.transformProjectiveVector([1, 0, 1]),\n\t\t\t\t    pbl = transform.transformProjectiveVector([0, 1, 1]),\n\t\t\t\t    pbr = transform.transformProjectiveVector([1, 1, 1]);\n\t\n\t\t\t\tvar canvas = document.createElement('canvas');\n\t\t\t\tcanvas.width = canvas.height = 256;\n\t\t\t\tattr.canvas = canvas;\n\t\t\t\tattr.ctx = canvas.getContext('2d');\n\t\n\t\t\t\tvar boundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\n\t\t\t\t    maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\n\t\n\t\t\t\tlimit = 'limit' in attr ? attr.limit : maxSize < 200 ? 1 : 4;\n\t\t\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log('Error: ProjectiveImage event:', e);\n\t\t\t\t\tcanvas = null;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tcanvas: canvas,\n\t\t\t\t\tptl: ptl,\n\t\t\t\t\tptr: ptr,\n\t\t\t\t\tpbl: pbl,\n\t\t\t\t\tpbr: pbr,\n\t\t\t\t\tcnt: cnt\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tL.gmx.projectiveImage = function () {\n\t\t\treturn new ProjectiveImage();\n\t\t};\n\t})();\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\n\t\n\tL.RotatedMarker = L.Marker.extend({\n\t    options: {\n\t        angle: 0\n\t    },\n\t\n\t    statics: {\n\t        TRANSFORM_ORIGIN: L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\n\t    },\n\t\n\t    _initIcon: function _initIcon() {\n\t        L.Marker.prototype._initIcon.call(this);\n\t\n\t        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\n\t    },\n\t\n\t    _getTransformOrigin: function _getTransformOrigin() {\n\t        var iconAnchor = this.options.icon.options.iconAnchor;\n\t\n\t        if (!iconAnchor) {\n\t            return '50% 50%';\n\t        }\n\t\n\t        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\n\t    },\n\t\n\t    _setPos: function _setPos(pos) {\n\t        L.Marker.prototype._setPos.call(this, pos);\n\t\n\t        if (L.DomUtil.TRANSFORM) {\n\t            // use the CSS transform rule if available\n\t            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\n\t        } else if (L.Browser.ie) {\n\t            // fallback for IE6, IE7, IE8\n\t            var rad = this.options.angle * (Math.PI / 180),\n\t                costheta = Math.cos(rad),\n\t                sintheta = Math.sin(rad);\n\t            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + costheta + ', M12=' + -sintheta + ', M21=' + sintheta + ', M22=' + costheta + ')';\n\t        }\n\t    },\n\t\n\t    setAngle: function setAngle(ang) {\n\t        this.options.angle = ang;\n\t    }\n\t});\n\t\n\tL.rotatedMarker = function (pos, options) {\n\t    return new L.RotatedMarker(pos, options);\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tL.gmx.ExternalLayer = L.Class.extend({\n\t    createExternalLayer: function createExternalLayer() {\n\t        // extend: must return <ILayer> or null = this.externalLayer\n\t        return null;\n\t    },\n\t\n\t    isExternalVisible: function isExternalVisible() /*zoom*/{\n\t        // extend: return true view this.externalLayer, return false view this.parentLayer\n\t        return true;\n\t    },\n\t\n\t    updateData: function updateData() /*data*/{// extend: for data update in this.externalLayer\n\t    },\n\t\n\t    setDateInterval: function setDateInterval() {\n\t        if (this._observer) {\n\t            var gmx = this.parentLayer._gmx;\n\t            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\n\t        }\n\t    },\n\t\n\t    options: {\n\t        useDataManager: true,\n\t        observerOptions: {\n\t            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\n\t        }\n\t    },\n\t\n\t    initialize: function initialize(options, layer) {\n\t        L.setOptions(this, options);\n\t        this.parentLayer = layer;\n\t        layer.on('add', this._addEvent, this).on('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this.options.useDataManager) {\n\t            this._addObserver(this.options.observerOptions);\n\t        }\n\t\n\t        this.externalLayer = this.createExternalLayer();\n\t\n\t        if (layer._map) {\n\t            this._addEvent({ target: { _map: layer._map } });\n\t            this._updateBbox();\n\t        }\n\t    },\n\t\n\t    _addObserver: function _addObserver(opt) {\n\t        this._items = {};\n\t        this._observer = this.parentLayer.addObserver(L.extend({\n\t            bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\n\t            callback: L.bind(this.updateData, this)\n\t        }, opt)).deactivate();\n\t    },\n\t\n\t    unbindLayer: function unbindLayer() {\n\t        this.parentLayer.off('add', this._addEvent, this).off('dateIntervalChanged', this.setDateInterval, this);\n\t\n\t        if (this._observer) {\n\t            delete this.parentLayer.repaintObservers[this._observer.id];\n\t        }\n\t        var map = this._map || this.parentLayer._map;\n\t        this._onRemove(!map);\n\t        this._removeMapHandlers();\n\t    },\n\t\n\t    _addMapHandlers: function _addMapHandlers(map) {\n\t        this._map = map;\n\t        this._map.on({\n\t            moveend: this._updateBbox,\n\t            zoomend: this._chkZoom,\n\t            layeradd: this._layeradd,\n\t            layerremove: this._layerremove\n\t        }, this);\n\t    },\n\t\n\t    _removeMapHandlers: function _removeMapHandlers() {\n\t        if (this._map) {\n\t            this._map.off({\n\t                moveend: this._updateBbox,\n\t                zoomend: this._chkZoom,\n\t                layeradd: this._layeradd,\n\t                layerremove: this._layerremove\n\t            }, this);\n\t        }\n\t        this._map = null;\n\t    },\n\t\n\t    _addEvent: function _addEvent(ev) {\n\t        this._addMapHandlers(ev.target._map);\n\t        this._updateBbox();\n\t        this._chkZoom();\n\t    },\n\t\n\t    _isParentLayer: function _isParentLayer(ev) {\n\t        var layer = ev.layer;\n\t        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\n\t    },\n\t\n\t    _layeradd: function _layeradd(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._chkZoom();\n\t        }\n\t    },\n\t\n\t    _layerremove: function _layerremove(ev) {\n\t        if (this._isParentLayer(ev)) {\n\t            this._onRemove(true);\n\t            this._removeMapHandlers();\n\t        }\n\t    },\n\t\n\t    _onRemove: function _onRemove(fromMapFlag) {\n\t        // remove external layer from parent layer\n\t        if (this._observer) {\n\t            this._observer.deactivate();\n\t        }\n\t        var map = this._map;\n\t        if (map) {\n\t            if (map.hasLayer(this.externalLayer)) {\n\t                this._chkZoom();\n\t                map.removeLayer(this.externalLayer);\n\t            }\n\t            if (!fromMapFlag) {\n\t                this.parentLayer.onAdd(map);\n\t            }\n\t        }\n\t    },\n\t\n\t    _chkZoom: function _chkZoom() {\n\t        if (!this._map) {\n\t            return;\n\t        }\n\t\n\t        var layer = this.parentLayer,\n\t            observer = this._observer,\n\t            map = this._map,\n\t            isExtLayerOnMap = map.hasLayer(this.externalLayer);\n\t\n\t        layer.setCurrentZoom(map);\n\t        if (!this.isExternalVisible(map.getZoom())) {\n\t            if (observer) {\n\t                observer.deactivate();\n\t            }\n\t            if (!layer._map) {\n\t                if (isExtLayerOnMap) {\n\t                    map.removeLayer(this.externalLayer);\n\t                }\n\t                layer.onAdd(map);\n\t            }\n\t            layer.enablePopup();\n\t        } else if (layer._map) {\n\t            layer.onRemove(map);\n\t            if (!isExtLayerOnMap) {\n\t                map.addLayer(this.externalLayer);\n\t            }\n\t            this.setDateInterval();\n\t            if (observer) {\n\t                layer.getIcons(function () {\n\t                    observer.activate();\n\t                }.bind(this));\n\t            }\n\t            layer.disablePopup();\n\t        }\n\t    },\n\t\n\t    _updateBbox: function _updateBbox() {\n\t        if (!this._map || !this._observer) {\n\t            return;\n\t        }\n\t\n\t        var screenBounds = this._map.getBounds(),\n\t            p1 = screenBounds.getNorthWest(),\n\t            p2 = screenBounds.getSouthEast(),\n\t            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\n\t        this._observer.setBounds(bbox);\n\t    }\n\t});\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var BindWMS = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minZoom: 1,\n\t            maxZoom: 6,\n\t            useDataManager: false,\n\t            format: 'png',\n\t            transparent: true\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var poptions = this.parentLayer.options,\n\t                opt = {\n\t                map: poptions.mapID,\n\t                layers: poptions.layerID,\n\t                format: this.options.format,\n\t                transparent: this.options.transparent\n\t            },\n\t                rawProperties = this.parentLayer.getGmxProperties();\n\t\n\t            if (rawProperties && rawProperties.Temporal) {\n\t                this._extendOptionsByDateInterval(opt);\n\t            }\n\t            if (this.options.apikey) {\n\t                opt.apikey = this.options.apikey;\n\t            }\n\t            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\n\t        },\n\t\n\t        _extendOptionsByDateInterval: function _extendOptionsByDateInterval(options) {\n\t            var dateInterval = this.parentLayer.getDateInterval(),\n\t                beginDate = dateInterval.beginDate,\n\t                endDate = dateInterval.endDate;\n\t            L.extend(options, {\n\t                StartDate: beginDate && beginDate.toLocaleDateString(),\n\t                EndDate: endDate && endDate.toLocaleDateString()\n\t            });\n\t        },\n\t\n\t        setDateInterval: function setDateInterval() {\n\t            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\n\t            this.externalLayer.redraw();\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindWMS: function bindWMS(options) {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t            }\n\t            this._layerWMS = new BindWMS(options, this);\n\t            this.isExternalVisible = this._layerWMS.isExternalVisible;\n\t            return this;\n\t        },\n\t\n\t        unbindWMS: function unbindWMS() {\n\t            if (this._layerWMS) {\n\t                this._layerWMS.unbindLayer();\n\t                this._layerWMS = null;\n\t                this.isExternalVisible = null;\n\t                this.enablePopup();\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var GmxHeatMap = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            minHeatMapZoom: 1,\n\t            maxHeatMapZoom: 6,\n\t            intensityField: '',\n\t            intensityScale: 1,\n\t            observerOptions: {\n\t                type: 'resend'\n\t            }\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            return L.heatLayer([], L.extend({\n\t                // minOpacity: 0.05,\n\t                // maxZoom: 18,\n\t                // radius: 25,\n\t                // blur: 15,\n\t                // max: 1.0\n\t            }, this.options));\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            if (data.added) {\n\t                var latlngs = [],\n\t                    indexes = this.parentLayer.getTileAttributeIndexes(),\n\t                    altIndex = null,\n\t                    intensityField = this.options.intensityField || '',\n\t                    intensityScale = this.options.intensityScale || 1;\n\t\n\t                if (intensityField && intensityField in indexes) {\n\t                    altIndex = indexes[intensityField];\n\t                }\n\t                for (var i = 0, len = data.added.length; i < len; i++) {\n\t                    var it = data.added[i].properties,\n\t                        alt = altIndex !== null ? it[altIndex] : 1,\n\t                        geo = it[it.length - 1],\n\t                        coord = geo.coordinates,\n\t                        point = L.Projection.Mercator.unproject({ x: coord[0], y: coord[1] });\n\t\n\t                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\n\t                }\n\t                this.externalLayer.setLatLngs(latlngs);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindHeatMap: function bindHeatMap(options) {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                }\n\t                this._heatmap = new GmxHeatMap(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindHeatMap: function unbindHeatMap() {\n\t            if (L.heatLayer) {\n\t                if (this._heatmap) {\n\t                    this._heatmap.unbindLayer();\n\t                    this._heatmap = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t(function () {\n\t    'use strict';\n\t\n\t    var _DEFAULTS = {\n\t        radiusFunc: function radiusFunc(count) {\n\t            var r = Math.floor(count / 15);\n\t            if (r > 40) {\n\t                r = 40;\n\t            } else if (r < 20) {\n\t                r = 20;\n\t            }\n\t            return r;\n\t        },\n\t        text: {\n\t            stroke: 'black',\n\t            'stroke-width': 1,\n\t            'text-anchor': 'middle',\n\t            fill: 'white'\n\t        }\n\t    };\n\t    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\n\t        options: {\n\t            observerOptions: {\n\t                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\n\t            },\n\t            spiderfyOnMaxZoom: true,\n\t            minZoom: 1,\n\t            maxZoom: 6\n\t        },\n\t\n\t        createExternalLayer: function createExternalLayer() {\n\t            var mOptions = L.extend({\n\t                showCoverageOnHover: false,\n\t                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\n\t            }, this.options);\n\t\n\t            if ('clusterIconOptions' in this.options) {\n\t                var opt = this.options.clusterIconOptions;\n\t                if ('radialGradient' in opt) {\n\t                    var radialGradient = opt.radialGradient,\n\t                        text = opt.text || _DEFAULTS.text;\n\t                    mOptions.iconCreateFunction = function (cluster) {\n\t                        var childCount = cluster.getChildCount();\n\t\n\t                        text.count = childCount;\n\t                        return L.gmxUtil.getSVGIcon({\n\t                            type: 'circle',\n\t                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\n\t                            text: text,\n\t                            fillRadialGradient: radialGradient\n\t                        });\n\t                    };\n\t                }\n\t            }\n\t\n\t            if (this.options.clusterclick) {\n\t                mOptions.clusterclick = this.options.clusterclick;\n\t                if (mOptions.clusterclick === true) {\n\t                    mOptions.zoomToBoundsOnClick = false;\n\t                }\n\t            }\n\t\n\t            this._popup = new L.Popup({ maxWidth: 10000, className: 'gmxPopup' });\n\t            var markers = new L.MarkerClusterGroup(mOptions);\n\t\n\t            //   \n\t            var currentSpiderfiedCluster = null;\n\t\n\t            markers.on('click', function (ev) {\n\t                var propsArr = ev.layer.options.properties,\n\t                    properties = this.parentLayer.getItemProperties(propsArr),\n\t                    geometry = [propsArr[propsArr.length - 1]],\n\t                    id = propsArr[0];\n\t\n\t                if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\n\t                    currentSpiderfiedCluster.unspiderfy();\n\t                    markers.once('unspiderfied', function () {\n\t                        this._openPopup(propsArr, ev.latlng);\n\t                    }, this);\n\t                } else {\n\t                    this._openPopup(propsArr, ev.latlng);\n\t                }\n\t\n\t                this.parentLayer.fire('click', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'click',\n\t                    gmx: {\n\t                        id: id,\n\t                        layer: this.parentLayer,\n\t                        properties: properties,\n\t                        target: {\n\t                            id: id,\n\t                            properties: propsArr,\n\t                            geometry: geometry\n\t                        }\n\t                    }\n\t                }));\n\t            }, this).on('animationend', function () {\n\t                if (this._popup && this._popup._map) {\n\t                    this._popup._map.removeLayer(this._popup);\n\t                }\n\t            }, this).on('clusterclick', function (ev) {\n\t                this.parentLayer.fire('clusterclick', L.extend(ev, {\n\t                    eventFrom: 'markerClusters',\n\t                    originalEventType: 'clusterclick'\n\t                }));\n\t            }, this).on('spiderfied', function (ev) {\n\t                currentSpiderfiedCluster = ev.cluster;\n\t            }, this).on('unspiderfied', function () {\n\t                currentSpiderfiedCluster = null;\n\t            }, this);\n\t\n\t            if (mOptions.clusterclick) {\n\t                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\n\t                    a.layer.spiderfy();\n\t                });\n\t            }\n\t\n\t            return markers;\n\t        },\n\t\n\t        isExternalVisible: function isExternalVisible(zoom) {\n\t            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\n\t        },\n\t\n\t        updateData: function updateData(data) {\n\t            var arr = [],\n\t                i,\n\t                len,\n\t                vectorTileItem,\n\t                id,\n\t                marker;\n\t            if (data.removed) {\n\t                for (i = 0, len = data.removed.length; i < len; i++) {\n\t                    vectorTileItem = data.removed[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    if (marker) {\n\t                        arr.push(marker);\n\t                    }\n\t                    delete this._items[id];\n\t                }\n\t                this.externalLayer.removeLayers(arr);\n\t                arr = [];\n\t            }\n\t            if (data.added) {\n\t                for (i = 0, len = data.added.length; i < len; i++) {\n\t                    vectorTileItem = data.added[i];\n\t                    id = vectorTileItem.id;\n\t                    marker = this._items[id];\n\t                    var item = vectorTileItem.properties;\n\t                    if (marker && item.processing) {\n\t                        this.externalLayer.removeLayer(marker);\n\t                        marker = null;\n\t                    }\n\t                    if (!marker) {\n\t                        if (!vectorTileItem.item.parsedStyleKeys) {\n\t                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\n\t                        }\n\t                        var geo = item[item.length - 1],\n\t                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\n\t                            p = geo.coordinates,\n\t                            latlng = L.Projection.Mercator.unproject({ x: p[0], y: p[1] }),\n\t                            opt = {\n\t                            properties: vectorTileItem.properties,\n\t                            mPoint: p\n\t                        };\n\t\n\t                        if (this.options.notClusteredIcon) {\n\t                            var icon = this.options.notClusteredIcon;\n\t                            if (icon instanceof L.Icon) {\n\t                                opt.icon = icon;\n\t                            } else {\n\t                                opt.icon = L.icon(icon);\n\t                            }\n\t                        } else if (parsedStyle) {\n\t                            if (parsedStyle.iconUrl) {\n\t                                var iconAnchor = parsedStyle.iconAnchor;\n\t                                if (!iconAnchor) {\n\t                                    var style = this.parentLayer.getItemStyle(id);\n\t                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\n\t                                }\n\t                                opt.icon = L.icon({\n\t                                    iconAnchor: iconAnchor,\n\t                                    iconUrl: parsedStyle.iconUrl\n\t                                });\n\t                            } else {\n\t                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\n\t                            }\n\t                        }\n\t                        if (parsedStyle.rotate) {\n\t                            marker = L.rotatedMarker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        } else {\n\t                            marker = L.marker(latlng, L.extend(opt, {\n\t                                angle: parsedStyle.rotate\n\t                            }));\n\t                        }\n\t                        this._items[id] = marker;\n\t                    }\n\t                    arr.push(marker);\n\t                }\n\t                this.externalLayer.addLayers(arr);\n\t            }\n\t        },\n\t\n\t        _openPopup: function _openPopup(propsArr, latlng) {\n\t            var gmx = this.parentLayer._gmx,\n\t                id = propsArr[0],\n\t                balloonData = gmx.styleManager.getItemBalloon(id),\n\t                properties = this.parentLayer.getItemProperties(propsArr),\n\t                geometry = [propsArr[propsArr.length - 1]];\n\t\n\t            if (balloonData && !balloonData.DisableBalloonOnClick) {\n\t                var style = this.parentLayer.getItemStyle(id);\n\t                if (style && style.iconAnchor) {\n\t                    var protoOffset = L.Popup.prototype.options.offset;\n\t                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2, protoOffset[1] - style.iconAnchor[1] + style.sy / 2];\n\t                }\n\t                this._popup.setLatLng(latlng).setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\n\t                    properties: properties,\n\t                    tileAttributeTypes: gmx.tileAttributeTypes,\n\t                    unitOptions: this._map.options || {},\n\t                    geometries: geometry\n\t                })).openOn(this._map);\n\t            }\n\t        }\n\t    });\n\t\n\t    L.gmx.VectorLayer.include({\n\t        bindClusters: function bindClusters(options) {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                }\n\t                this._clusters = new GmxMarkerCluster(options, this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        unbindClusters: function unbindClusters() {\n\t            if (L.MarkerClusterGroup) {\n\t                if (this._clusters) {\n\t                    this._clusters.unbindLayer();\n\t                    this._clusters = null;\n\t                    this.enablePopup();\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t    });\n\t})();\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Utils = __webpack_require__(4);\n\t\n\tL.gmx = L.gmx || {};\n\t\n\t\n\tvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\n\tvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\n\t\n\t//Build in layer classes\n\tL.gmx._layerClasses = {\n\t    'Raster': L.gmx.RasterLayer,\n\t    'Vector': L.gmx.VectorLayer,\n\t    'VectorView': L.gmx.DummyLayer\n\t};\n\t\n\tL.gmx._loadingLayerClasses = {};\n\t\n\tL.gmx.addLayerClass = function (type, layerClass) {\n\t    L.gmx._layerClasses[type] = layerClass;\n\t};\n\t\n\tL.gmx._layerClassLoaders = [];\n\t\n\tL.gmx.addLayerClassLoader = function (layerClassLoader) {\n\t    L.gmx._layerClassLoaders.push(layerClassLoader);\n\t\n\t    //delete all loading promises to ensure that new loader will be invoked\n\t    L.gmx._loadingLayerClasses = {};\n\t};\n\t\n\tL.gmx._loadLayerClass = function (type) {\n\t    if (!L.gmx._loadingLayerClasses[type]) {\n\t        var promise = new L.gmx.Deferred();\n\t        promise.resolve();\n\t\n\t        L.gmx._layerClassLoaders.forEach(function (loader) {\n\t            promise = promise.then(function (layerClass) {\n\t                if (layerClass) {\n\t                    L.gmx._layerClasses[type] = layerClass;\n\t                    return layerClass;\n\t                }\n\t\n\t                return loader(type);\n\t            }, function () {\n\t                //just skip loader errors\n\t            });\n\t        });\n\t\n\t        promise = promise.then(function (layerClass) {\n\t            if (layerClass) {\n\t                L.gmx._layerClasses[type] = layerClass;\n\t                return layerClass;\n\t            }\n\t        }, function () {\n\t            //just skip loader errors\n\t        });\n\t\n\t        L.gmx._loadingLayerClasses[type] = promise;\n\t    }\n\t\n\t    return L.gmx._loadingLayerClasses[type];\n\t};\n\t\n\tL.gmx.loadLayer = function (mapID, layerID, options) {\n\t\n\t    var promise = new L.gmx.Deferred(),\n\t        layerParams = {\n\t        mapID: mapID,\n\t        layerID: layerID\n\t    };\n\t\n\t    options = options || {};\n\t\n\t    for (var p in options) {\n\t        layerParams[p] = options[p];\n\t    }\n\t\n\t    var hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t    layerParams.hostName = hostName;\n\t\n\t    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(function () {\n\t        var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\n\t\n\t        if (!layerInfo) {\n\t            promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\n\t            return;\n\t        }\n\t\n\t        //to know from what host the layer was loaded\n\t        layerInfo.properties.hostName = hostName;\n\t\n\t        var type = layerInfo.properties.ContentID || layerInfo.properties.type;\n\t\n\t        var doCreateLayer = function doCreateLayer() {\n\t            var layer = L.gmx.createLayer(layerInfo, layerParams);\n\t            if (layer) {\n\t                promise.resolve(layer);\n\t            } else {\n\t                promise.reject('Unknown type of layer ' + layerID);\n\t            }\n\t        };\n\t\n\t        if (type in L.gmx._layerClasses) {\n\t            doCreateLayer();\n\t        } else {\n\t            L.gmx._loadLayerClass(type).then(doCreateLayer);\n\t        }\n\t    }, function (response) {\n\t        promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\n\t    });\n\t\n\t    return promise;\n\t};\n\t\n\tL.gmx.loadLayers = function (layers, globalOptions) {\n\t    var defs = layers.map(function (layerInfo) {\n\t        var options = L.extend({}, globalOptions, layerInfo.options);\n\t        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\n\t    });\n\t\n\t    return L.gmx.Deferred.all.apply(null, defs);\n\t};\n\t\n\tL.gmx.loadMap = function (mapID, options) {\n\t    options = L.extend({}, options);\n\t    options.hostName = _Utils.gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\n\t\n\t    var def = new L.gmx.Deferred();\n\t\n\t    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function (mapInfo) {\n\t        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\n\t\n\t        loadedMap.layersCreated.then(function () {\n\t            if (options.leafletMap || options.setZIndex) {\n\t                var curZIndex = 0,\n\t                    layer,\n\t                    rawProperties;\n\t\n\t                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\n\t                    layer = loadedMap.layers[l];\n\t                    rawProperties = layer.getGmxProperties();\n\t                    if (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\n\t                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\n\t                    }\n\t                    if (options.setZIndex && layer.setZIndex) {\n\t                        layer.setZIndex(++curZIndex);\n\t                    }\n\t\n\t                    if (options.leafletMap && rawProperties.visible) {\n\t                        layer.addTo(options.leafletMap);\n\t                    }\n\t                }\n\t            }\n\t            def.resolve(loadedMap);\n\t        });\n\t    }, function (response) {\n\t        var errorMessage = response && response.ErrorInfo && response.ErrorInfo.ErrorMessage || 'Server error';\n\t        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\n\t    });\n\t    return def;\n\t};\n\t\n\tL.gmx.DummyLayer = function (props) {\n\t    this.onAdd = this.onRemove = function () {};\n\t    this.getGmxProperties = function () {\n\t        return props;\n\t    };\n\t};\n\t\n\tL.gmx.createLayer = function (layerInfo, options) {\n\t    if (!layerInfo) {\n\t        layerInfo = {};\n\t    }\n\t    if (!layerInfo.properties) {\n\t        layerInfo.properties = { type: 'Vector' };\n\t    }\n\t\n\t    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\n\t        layer;\n\t\n\t    if (type in L.gmx._layerClasses) {\n\t        try {\n\t            layer = new L.gmx._layerClasses[type](options);\n\t            layer = layer.initFromDescription(layerInfo);\n\t        } catch (e) {\n\t            layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t        }\n\t    } else {\n\t        layer = new L.gmx.DummyLayer(layerInfo.properties);\n\t    }\n\t\n\t    return layer;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dist/geomixer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b6cea09a4e9f0707831","// import './commonjs.js';\r\nimport './Parsers.js';\r\nimport './Deferred.js';\r\nimport './ImageLoader.js';\r\nimport './Utils.js';\r\nimport './DrawCanvas.js';\r\nimport './SessionManager.js';\r\nimport './MapManager.js';\r\nimport './GeomixerMap.js';\r\nimport './EventsManager.js';\r\nimport './Locale.js';\r\nimport './lang_ru.js';\r\nimport './lang_en.js';\r\n\r\nimport './DataManager/VectorTileLoader.js';\r\nimport './DataManager/VectorTile.js';\r\nimport './DataManager/Observer.js';\r\nimport './DataManager/TilesTree.js';\r\nimport './DataManager/DataManager.js';\r\n\r\nimport './Layer/VectorLayer.js';\r\nimport './Layer/ScreenVectorTile.js';\r\nimport './Layer/ObjectsReorder.js';\r\nimport './Layer/StyleManager.js';\r\nimport './Layer/VectorLayer.Popup.js';\r\nimport './Layer/VectorLayer.Hover.js';\r\nimport './Layer/LayersVersion.js';\r\nimport './Layer/RasterLayer.js';\r\nimport './Layer/LabelsLayer.js';\r\nimport './Layer/ClipPolygon.js';\r\nimport './Layer/ImageTransform.js';\r\nimport './Layer/ProjectiveImageWebGL.js';\r\nimport './Layer/ProjectiveImage.js';\r\n\r\nimport './Layer/external/RotatedMarker.js';\r\nimport './Layer/external/ExternalLayer.js';\r\nimport './Layer/external/BindWMS.js';\r\nimport './Layer/external/HeatMap.js';\r\nimport './Layer/external/MarkerCluster.js';\r\n\r\nimport './LayerFactory.js';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/includes.js","/*\r\n   Single-pass recursive descent PEG parser library:\r\n      http://en.wikipedia.org/wiki/Parsing_expression_grammar\r\n   Inspired by Chris Double's parser combinator library in JavaScript:\r\n      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html\r\n\t+  : Math.floor\r\n*/\r\n(function() {\r\n    var regexExpression = /\\[(.+?)\\]/g,\r\n        regexMath = /(floor\\()/g;\r\n\tvar Parsers = {\t\t\t\t\t\t// \r\n        functionFromExpression: function(s) {\r\n/*eslint-disable no-new-func*/\r\n            return new Function(\r\n/*eslint-enable */\r\n                'props',\r\n                'indexes',\r\n                'return ' +\r\n                    s\r\n                     .replace(regexExpression, 'props[indexes[\"$1\"]]')\r\n                     .replace(regexMath, 'Math.$1')\r\n                    + ';'\r\n            );\r\n        }\r\n    };\r\n\r\n\tvar makePair = function(t1, t2) {\r\n\t\treturn {head: t1, tail: t2};\r\n\t};\r\n\r\n// C-style linked list via recursive typedef.\r\n//   Used purely functionally to get shareable sublists.\r\n//typedef LinkedList = Pair<Dynamic, LinkedList>;\r\n\tvar LinkedList = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser state contains position in string and some accumulated data.\r\n//typedef ParserState = Pair<Int, LinkedList>;\r\n\tvar ParserState = function(t1, t2) {\r\n\t\treturn makePair(t1, t2);\r\n\t};\r\n\r\n// Parser accepts string and state, returns another state.\r\n//typedef Parser = String->ParserState->ParserState;\r\n\r\n\t// A parser state that indicates failure.\r\n\tvar fail = new ParserState(-1, null);\r\n\r\n\t// Check for failure.\r\n\tvar failed = function(state) {\r\n\t\treturn (state.head === -1);\r\n\t};\r\n\r\n\t// Advance a parser state by n characters.\r\n\tvar advance = function(state, n) {\r\n\t\treturn new ParserState(state.head + n, state.tail);\r\n\t};\r\n\r\n\t// Match a specified string.\r\n\tvar token = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len) === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a string without regard to case.\r\n\tvar caseInsensitiveToken = function(tok) {\r\n\t\tvar len = tok.length;\r\n\t\ttok = tok.toLowerCase();\r\n\t\treturn function(s, state) {\r\n\t\t\treturn (s.substr(state.head, len).toLowerCase() === tok) ? advance(state, len) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a single character in a specified range.\r\n\tvar range = function(startChar, endChar) {\r\n\t\tvar startCode = startChar.charCodeAt(0);\r\n\t\tvar endCode = endChar.charCodeAt(0);\r\n\t\treturn function(s, state) {\r\n\t\t\tvar code = s.charCodeAt(state.head);\r\n\t\t\treturn ((code >= startCode) && (code <= endCode)) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match any character outside a certain set.\r\n\t//   This combinator is intended only for single character parsers.\r\n\tvar anythingExcept = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\treturn ((s.length > state.head) && failed(parser(s, state))) ? advance(state, 1) : fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, then thing2, ..., then thingN.\r\n\tvar sequence = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tstate = parsers[i](s, state);\r\n\t\t\t\tif (failed(state)) {\r\n\t\t\t\t\treturn fail;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn state;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match thing1, or thing2, ..., or thingN.\r\n\tvar choice = function(parsers) {\r\n\t\treturn function(s, state) {\r\n\t\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\t\tvar newState = parsers[i](s, state);\r\n\t\t\t\tif (!failed(newState)) {\r\n\t\t\t\t\treturn newState;\r\n                }\r\n\t\t\t}\r\n\t\t\treturn fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match immediately, without regard to what's in the string.\r\n\tvar nothing = function(s, state) {\r\n\t\treturn state;\r\n\t};\r\n\r\n\t// Match this thing or nothing.\r\n\tvar maybe = function(parser) {\r\n\t\treturn choice([parser, nothing]);\r\n\t};\r\n\r\n\t// Match minCount or more repetitions of this thing.\r\n\tvar repeat = function(minCount, parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar count = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar newState = parser(s, state);\r\n\t\t\t\tif (failed(newState)) {\r\n\t\t\t\t\treturn (count >= minCount) ? state : fail;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount += 1;\r\n\t\t\t\t\tstate = newState;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// return fail;\r\n\t\t};\r\n\t};\r\n\r\n\t// Match a list of minCount or more instances of thing1, separated by thing2.\r\n\tvar separatedList = function(minCount, parser, separator) {\r\n\t\tvar parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);\r\n\t\treturn (minCount > 0) ? parser1 : choice([parser1, nothing]);\r\n\t};\r\n\r\n\tvar whitespace = repeat(0, choice([\r\n\t\ttoken(' '),\r\n\t\ttoken('\\t'),\r\n\t\ttoken('\\n')\r\n\t]));\r\n\r\n\t// Same as separatedList, but can have whitespace between items and separators.\r\n\tvar whitespaceSeparatedList = function(minCount, parser, separator) {\r\n\t\treturn separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));\r\n\t};\r\n\r\n\t// Same as sequence, but can have whitespace between items.\r\n\tvar whitespaceSeparatedSequence = function(parsers) {\r\n\t\tvar newParsers = [];\r\n\t\tfor (var i = 0; i < parsers.length; i++) {\r\n\t\t\tif (newParsers.length > 0) { newParsers.push(whitespace); }\r\n\t\t\tnewParsers.push(parsers[i]);\r\n\t\t}\r\n\t\treturn sequence(newParsers);\r\n\t};\r\n\r\n\t// This combinator captures the string that the parser matched\r\n\t//   and adds it to the current parser state, consing a new state.\r\n\tvar capture = function(parser) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar newState = parser(s, state);\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// This combinator passes the accumulated parser state to a given\r\n\t//  function for processing. The result goes into the new state.\r\n\tvar action = function(parser, func) {\r\n\t\treturn function(s, state) {\r\n\t\t\tvar oldState = state;\r\n\t\t\tvar newState = parser(s, new ParserState(oldState.head, null));\r\n\t\t\treturn failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));\r\n\t\t};\r\n\t};\r\n\r\n\t// Define a syntactic subset of SQL WHERE clauses.\r\n\tvar fieldName = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('', ''),\r\n\t\trange('', ''),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_')\r\n\t])));\r\n\r\n\tvar fieldNameWithSpaces = capture(repeat(1, choice([\r\n\t\trange('a', 'z'),\r\n\t\trange('A', 'Z'),\r\n\t\trange('', ''),\r\n\t\trange('', ''),\r\n\t\trange('0', '9'),\r\n\t\ttoken('_'),\r\n\t\ttoken(' ')\r\n\t])));\r\n\r\n\tvar quotedFieldName = choice([\r\n\t\tfieldName,\r\n\t\tsequence([token('\"'), fieldNameWithSpaces, token('\"')]),\r\n\t\tsequence([token('`'), fieldNameWithSpaces, token('`')])\r\n\t]);\r\n\r\n\tvar stringLiteral = sequence([\r\n\t\ttoken('\\''),\r\n\t\tcapture(repeat(0, anythingExcept(token('\\'')))),\r\n\t\ttoken('\\'')\r\n\t]);\r\n\r\n\tvar digits = repeat(1, range('0', '9'));\r\n\r\n\tvar numberLiteral = capture(sequence([\r\n\t\tmaybe(token('-')),\r\n\t\tdigits,\r\n\t\tmaybe(sequence([token('.'), digits]))\r\n\t]));\r\n\r\n\tvar literal = choice([numberLiteral, stringLiteral]);\r\n\r\n\tvar applyParser = function(s, parser) {\r\n\t\treturn parser(s, new ParserState(0, null));\r\n\t};\r\n\r\n\t// Order is important here: longer ops should be tried first.\r\n\tvar opTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcapture(choice([\r\n\t\t\t\ttoken('=='),\r\n\t\t\t\ttoken('!='),\r\n\t\t\t\ttoken('<>'),\r\n\t\t\t\ttoken('<='),\r\n\t\t\t\ttoken('>='),\r\n\t\t\t\ttoken('='),\r\n\t\t\t\ttoken('<'),\r\n\t\t\t\ttoken('>'),\r\n\t\t\t\tcaseInsensitiveToken('LIKE')\r\n\t\t\t])),\r\n            choice([literal, quotedFieldName])\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname, operation, value\r\n\t\t\t// (in reverse order).\r\n\r\n\t\t\tvar fieldName = state.tail.tail.head;\r\n\t\t\tvar op = state.tail.head;\r\n\t\t\tvar referenceValue = state.head;\r\n\r\n\t\t\tvar matchPattern = null;\r\n\t\t\tif (op.toUpperCase() === 'LIKE') {\r\n\t\t\t\tmatchPattern = function(fieldValue) {\r\n\t\t\t\t\tvar matchFrom = null;\r\n\t\t\t\t\tmatchFrom = function(referenceIdx, fieldIdx) {\r\n\t\t\t\t\t\tvar referenceChar = referenceValue.charAt(referenceIdx);\r\n\t\t\t\t\t\tvar fieldChar = fieldValue.charAt(fieldIdx);\r\n\t\t\t\t\t\tif (referenceChar === '') {\r\n\t\t\t\t\t\t\treturn (fieldChar === '');\r\n\t\t\t\t\t\t} else if (referenceChar === '%') {\r\n\t\t\t\t\t\t\treturn matchFrom(referenceIdx + 1, fieldIdx) || ((fieldChar !== '') && matchFrom(referenceIdx, fieldIdx + 1));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn (referenceChar === fieldChar) && matchFrom(referenceIdx + 1, fieldIdx + 1);\r\n                        }\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn matchFrom(0, 0);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar fieldValue = props[indexes[fieldName]],\r\n                    rValue = referenceValue;\r\n                if (referenceValue in indexes) { rValue = props[indexes[rValue]]; }\r\n                if (types[fieldName] === 'date' && typeof rValue === 'string') { rValue = L.gmxUtil.getUnixTimeFromStr(rValue); }\r\n                if (typeof fieldValue === 'boolean' && typeof rValue === 'string') {\r\n                    fieldValue = fieldValue ? 'True' : 'False';\r\n                }\r\n\t\t\t\tif (fieldValue === null) { return false; }\r\n\t\t\t\tif (matchPattern !== null) { return matchPattern(fieldValue);\r\n/*eslint-disable eqeqeq */\r\n                } else if ((op === '=') || (op === '==')) { return (fieldValue == rValue);\r\n\t\t\t\t} else if ((op === '!=') || (op === '<>')) { return (fieldValue != rValue);\r\n/*eslint-enable */\r\n                } else {\r\n                    var f1, f2;\r\n\t\t\t\t\tif (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {\r\n\t\t\t\t\t\tf1 = parseFloat(fieldValue);\r\n\t\t\t\t\t\tf2 = parseFloat(rValue);\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tf1 = fieldValue;\r\n\t\t\t\t\t\tf2 = rValue;\r\n\t\t\t\t\t\tif (op === '<') { return (f1 < f2);\r\n\t\t\t\t\t\t} else if (op === '>') { return (f1 > f2);\r\n\t\t\t\t\t\t} else if (op === '<=') { return (f1 <= f2);\r\n\t\t\t\t\t\t} else if (op === '>=') { return (f1 >= f2);\r\n\t\t\t\t\t\t} else { return false;\r\n                        }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar inTerm = action(\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\tquotedFieldName,\r\n\t\t\tcaseInsensitiveToken('IN'),\r\n\t\t\ttoken('('),\r\n\t\t\twhitespaceSeparatedList(0, literal, token(',')),\r\n\t\t\ttoken(')')\r\n\t\t]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains fieldname and multiple values\r\n\t\t\t//   (in reverse order).\r\n\r\n\t\t\tvar node = state;\r\n\t\t\twhile (node.tail != null) {\r\n\t\t\t\tnode = node.tail;\r\n\t\t\t}\r\n            var fieldName = node.head;\r\n\r\n\t\t\treturn function(props, indexes) {\r\n\t\t\t\tvar value = props[indexes[fieldName]];\r\n\t\t\t\tif (value == null) { return false; }\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node.tail !== null) {\r\n\t\t\t\t\tif (node.head === value) { return true; }\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Forward declarations to allow mutually recursive grammar definitions.\r\n\tvar term = function(s, state) { return term(s, state); };\r\n\tvar expression = function(s, state) { return expression(s, state); };\r\n\r\n\tvar notTerm = action(\r\n\t\twhitespaceSeparatedSequence([caseInsensitiveToken('NOT'), term]),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains only processed inner term.\r\n\t\t\tvar innerTerm = state.head;\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\treturn !innerTerm(props, indexes, types);\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tterm = choice([\r\n\t\tnotTerm,\r\n\t\topTerm,\r\n\t\tinTerm,\r\n\t\twhitespaceSeparatedSequence([token('('), expression, token(')')])\r\n\t]);\r\n\r\n\t// AND and OR expressions must have at least 2 terms,\r\n\t//   to disambiguate them from a single term.\r\n\r\n\tvar andExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('AND')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = true;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag && node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar orExpression = action(\r\n\t\twhitespaceSeparatedList(2, term, caseInsensitiveToken('OR')),\r\n\t\tfunction(state) {\r\n\t\t\t// Linked list contains multiple processed inner terms\r\n\t\t\t//   (in reverse order).\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar flag = false;\r\n\t\t\t\tvar node = state;\r\n\t\t\t\twhile (node != null) {\r\n\t\t\t\t\tflag = flag || node.head(props, indexes, types);\r\n\t\t\t\t\tnode = node.tail;\r\n\t\t\t\t}\r\n\t\t\t\treturn flag;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\t// Order is important here: term should be tried last,\r\n\t//   because andExpression and orExpression start with it.\r\n\texpression = choice([\r\n\t\tandExpression,\r\n\t\torExpression,\r\n\t\tterm\r\n\t]);\r\n\r\n\tvar whereClause = sequence([whitespace, expression, whitespace]);\r\n\r\n\tParsers.parseSQL = function(str) {\r\n\t\tvar result = applyParser(str, whereClause);\r\n\t\treturn result.head === str.length ?\r\n\t\t\tresult.tail.head :\r\n            (applyParser(str, whitespace).head === str.length) ?\r\n\t\t\t\tfunction(/*props*/) { return true; } :\r\n\t\t\t\tnull;\r\n\t};\r\n\r\n\tvar additiveExpression = function(s, state) { return additiveExpression(s, state); };\r\n\tvar multiplicativeExpression = function(s, state) { return multiplicativeExpression(s, state); };\r\n\tadditiveExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeExpression,\r\n\t\t\tcapture(choice([token('+'), token('-')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types)\r\n\t\t\t{\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 0.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm += pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '-') { term = -term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tvar multiplicativeTerm = choice([\r\n\t\taction(\r\n\t\t\tnumberLiteral,\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(/*props, indexes, types*/) {\r\n\t\t\t\t\treturn parseFloat(state.head);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('floor('), additiveExpression, token(')')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\tvar res = state.head(props, indexes, types);\r\n\t\t\t\t\treturn Math.floor(res);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\taction(\r\n\t\t\tsequence([token('['), fieldName, token(']')]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes) {\r\n\t\t\t\t\treturn parseFloat(props[indexes[state.head]]);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t),\r\n\t\twhitespaceSeparatedSequence([\r\n\t\t\ttoken('('),\r\n\t\t\tadditiveExpression,\r\n\t\t\ttoken(')')\r\n\t\t])\r\n\t]);\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\tmultiplicativeExpression = action(\r\n\t\twhitespaceSeparatedList(\r\n\t\t\t1,\r\n\t\t\tmultiplicativeTerm,\r\n\t\t\tcapture(choice([token('*'), token('/')]))\r\n\t\t),\r\n\t\tfunction(state)\r\n\t\t{\r\n\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\tvar pos = state;\r\n\t\t\t\tvar term = 1.0;\r\n\t\t\t\twhile (pos !== null) {\r\n\t\t\t\t\tterm *= pos.head(props, indexes, types);\r\n\t\t\t\t\tif (pos.tail === null) {\r\n\t\t\t\t\t\treturn term;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (pos.tail.head === '/') { term = 1.0 / term; }\r\n\t\t\t\t\t\tpos = pos.tail.tail;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn term;\r\n\t\t\t};\r\n\t\t}\r\n\t);\r\n\r\n\tmultiplicativeTerm = choice([\r\n\t\tmultiplicativeTerm,\r\n\t\taction(\r\n\t\t\twhitespaceSeparatedSequence([token('-'), multiplicativeTerm]),\r\n\t\t\tfunction(state) {\r\n\t\t\t\treturn function(props, indexes, types) {\r\n\t\t\t\t\treturn -state.head(props, indexes, types);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t)\r\n\t]);\r\n\r\n\tvar arithmeticExpression = sequence([whitespace, additiveExpression, whitespace]);\r\n\tParsers.parseExpression = function(s) {\r\n\t\tvar result = applyParser(s, arithmeticExpression);\r\n        return result.head === s.length ? result.tail.head : null;\r\n        // return result.head === s.length ? Parsers.functionFromExpression(s) : null;\r\n\t};\r\n\r\n\tvar svgPath = action(\r\n\t\trepeat(0, choice([\r\n\t\t\tnumberLiteral,\r\n\t\t\ttoken(','),\r\n\t\t\ttoken('M'),\r\n\t\t\ttoken('C'),\r\n\t\t\trepeat(1, choice([\r\n\t\t\t\ttoken(' '),\r\n\t\t\t\ttoken('\\t'),\r\n\t\t\t\ttoken('\\r'),\r\n\t\t\t\ttoken('\\n')\r\n\t\t\t]))\r\n\t\t])),\r\n\t\tfunction(state) {\r\n\t\t\tvar coords = [];\r\n\t\t\twhile (state !== null) {\r\n\t\t\t\tcoords.push(parseFloat(state.head));\r\n\t\t\t\tstate = state.tail;\r\n\t\t\t}\r\n\t\t\tcoords.reverse();\r\n\t\t\treturn coords;\r\n\t\t}\r\n\t);\r\n\r\n\tParsers.parseSVGPath = function(s) {\r\n\t\tvar result = applyParser(s, svgPath);\r\n\t\tif (result.head === s.length) {\r\n\t\t\treturn result.tail.head;\r\n\t\t} else {\r\n\t\t\treturn [];\r\n        }\r\n\t};\r\n\r\n\t//extend L.gmx namespace\r\n    L.gmx = L.gmx || {};\r\n\tL.gmx.Parsers = Parsers;\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Parsers.js","//all the methods can be called without instance itself\r\n//For example:\r\n//\r\n// var def = new Deferred();\r\n// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))\r\nvar Deferred = function(cancelFunc) {\r\n    var resolveCallbacks = [],\r\n        rejectCallbacks = [],\r\n        isFulfilled = false,\r\n        isResolved = false,\r\n        fulfilledData,\r\n        onceAdded = false,\r\n        isCancelled = false;\r\n\r\n    var fulfill = this._fulfill = function(resolved /*, data*/) {\r\n        if (isFulfilled) {\r\n            return;\r\n        }\r\n        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;\r\n        fulfilledData = [].slice.call(arguments, 1);\r\n        isFulfilled = true;\r\n        isResolved = resolved;\r\n\r\n        callbacks.forEach(function(callback) { callback.apply(null, fulfilledData); });\r\n        resolveCallbacks = rejectCallbacks = [];\r\n    };\r\n\r\n    this.resolve = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    this.reject = function(/*data*/) {\r\n        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    var cancel = this.cancel = function() {\r\n        if (!isCancelled && !isFulfilled) {\r\n            isCancelled = true;\r\n            cancelFunc && cancelFunc();\r\n        }\r\n    };\r\n\r\n    var then = this.then = function(resolveCallback, rejectCallback) {\r\n        if (isCancelled) {\r\n            return null;\r\n        }\r\n\r\n        var userFuncDef = null;\r\n        var def = new Deferred(function() {\r\n            cancel();\r\n            userFuncDef && userFuncDef.cancel();\r\n        });\r\n\r\n        var fulfillFunc = function(func, resolved) {\r\n            return function(/*data*/) {\r\n                if (!func) {\r\n                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));\r\n                } else {\r\n                    var res = func.apply(null, arguments);\r\n                    if (res instanceof Deferred) {\r\n                        userFuncDef = res;\r\n                        res.then(def.resolve, def.reject);\r\n                    } else {\r\n                        def.resolve(res);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n\r\n        if (isFulfilled) {\r\n            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);\r\n        } else {\r\n            resolveCallbacks.push(fulfillFunc(resolveCallback, true));\r\n            rejectCallbacks.push(fulfillFunc(rejectCallback, false));\r\n        }\r\n        return def;\r\n    };\r\n\r\n    this.once = function(onceResolveCallback) {\r\n        if (!onceAdded) {\r\n            onceAdded = true;\r\n            then(onceResolveCallback);\r\n        }\r\n    };\r\n\r\n    this.always = function(callback) {\r\n        then(callback, callback);\r\n    };\r\n\r\n    this.getFulfilledData = function() {\r\n        return fulfilledData;\r\n    };\r\n};\r\n\r\nDeferred.all = function() {\r\n    var defArray = [].slice.apply(arguments);\r\n    var resdef = new Deferred();\r\n    var left = defArray.length;\r\n    var results = new Array(defArray.length);\r\n\r\n    if (left) {\r\n        defArray.forEach(function(def, i) {\r\n            def.then(function(res) {\r\n                results[i] = res;\r\n                left--;\r\n                if (left === 0) {\r\n                    resdef.resolve.apply(resdef, results);\r\n                }\r\n            }, function() {\r\n                resdef.reject();\r\n            });\r\n        });\r\n    } else {\r\n        resdef.resolve();\r\n    }\r\n\r\n    return resdef;\r\n};\r\n\r\nL.gmx = L.gmx || {};\r\nL.gmx.Deferred = Deferred;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Deferred.js","(function() {\r\n\r\nvar ImageRequest = function(id, url, options) {\r\n    this._id = id;\r\n    this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));\r\n    this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);\r\n    this.url = url;\r\n    this.options = options || {};\r\n};\r\n\r\nvar GmxImageLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    statics: {\r\n        MAX_COUNT: 20 // max number of parallel requests\r\n    },\r\n\r\n    initialize: function() {\r\n        this.curCount = 0;        // number of currently processing requests (number of items in \"inProgress\")\r\n        this.requests = [];       // not yet processed image requests\r\n        this.inProgress = {};     // hash of in progress image loadings\r\n        this.requestsCache = {};  // for requests cache by uniqueID\r\n        this.uniqueID = 0;\r\n    },\r\n\r\n    _resolveRequest: function(request, image, canceled) {\r\n        var def = request.def;\r\n        if (image) {\r\n            if (!canceled && request.options.cache) {\r\n                var url = request.url,\r\n                    cacheItem = this.requestsCache[url],\r\n                    cacheKey = request._id;\r\n                if (!cacheItem) { cacheItem = this.requestsCache[url] = {image: image, requests:{}}; }\r\n                if (!cacheItem.requests[cacheKey]) { cacheItem.requests[cacheKey] = request; }\r\n            }\r\n            def.resolve(image);\r\n        } else if (!canceled) {\r\n            def.reject();\r\n        }\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _imageLoaded: function(url, image, canceled) {\r\n        if (url in this.inProgress) {\r\n            var resolveRequest = function(it) {\r\n                this._resolveRequest(it, image, canceled);\r\n            };\r\n            this.inProgress[url].requests.forEach(resolveRequest.bind(this));\r\n            --this.curCount;\r\n            delete this.inProgress[url];\r\n        }\r\n        L.gmxUtil.loaderStatus(url, true);\r\n        this.fire('imageloaded', {url: url});\r\n        this._nextLoad();\r\n    },\r\n\r\n    _nextLoad: function() {  //  \r\n        if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {\r\n            return;\r\n        }\r\n\r\n        var request = this.requests.shift(),\r\n            url = request.url;\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            var requests = [request];\r\n            this.inProgress[url] = {requests: requests};\r\n            ++this.curCount;\r\n\r\n            for (var k = this.requests.length - 1; k >= 0; k--) {\r\n                if (this.requests[k].url === url) {\r\n                    requests.push(this.requests[k]);\r\n                    this.requests.splice(k, 1);\r\n                }\r\n            }\r\n\r\n            var image = this._loadImage(request);\r\n            if (!image.width) {\r\n                L.gmxUtil.loaderStatus(url);\r\n            }\r\n\r\n            //theoretically image loading can be synchronous operation\r\n            if (this.inProgress[url]) {\r\n                this.inProgress[url].image = image;\r\n            }\r\n        }\r\n    },\r\n\r\n    _loadImage: function(request) {\r\n        var imageObj = new Image(),\r\n            url = request.url,\r\n            _this = this;\r\n\r\n        if (request.options.crossOrigin) {\r\n            imageObj.crossOrigin = request.options.crossOrigin;\r\n        }\r\n\r\n        imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);\r\n        imageObj.onerror = function() {\r\n            _this._imageLoaded(url);\r\n        };\r\n        imageObj.src = url;\r\n\r\n        this.fire('imageloadstart', {url: url});\r\n\r\n        return imageObj;\r\n    },\r\n\r\n    _cancelRequest: function(request) {\r\n        var id = request._id,\r\n            url = request.url,\r\n            i = 0, len;\r\n        if (url in this.inProgress) {\r\n            var loadingImg = this.inProgress[url],\r\n                requests = loadingImg.requests;\r\n\r\n            len = requests.length;\r\n            if (len === 1 && requests[0]._id === id) {\r\n                loadingImg.image.onload = L.Util.falseFn;\r\n                loadingImg.image.onerror = L.Util.falseFn;\r\n                loadingImg.image.src = L.Util.emptyImageUrl;\r\n                this._imageLoaded(url, null, true);\r\n            } else {\r\n                for (i = 0; i < len; i++) {\r\n                    if (requests[i]._id === id) {\r\n                        requests.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = this.requests.length; i < len; i++) {\r\n                if (this.requests[i]._id === id) {\r\n                    this.requests.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.fire('requestdone', {request: request});\r\n    },\r\n\r\n    _removeRequestFromCache: function(request) {    // remove request from cache\r\n        this._cancelRequest(request);\r\n        this._clearCacheItem(request.url, request._id);\r\n    },\r\n\r\n    _clearCacheItem: function(url, cacheKey) {    // remove cache item\r\n        if (this.requestsCache[url]) {\r\n            var cacheItem = this.requestsCache[url];\r\n            delete cacheItem.requests[cacheKey];\r\n            if (Object.keys(cacheItem.requests).length === 0) {\r\n                delete this.requestsCache[url];\r\n            }\r\n        }\r\n    },\r\n    _add: function(atBegin, url, options) {\r\n        var id = 'id' + (++this.uniqueID),\r\n            request = new ImageRequest(id, url, options);\r\n\r\n        if (url in this.inProgress) {\r\n            this.inProgress[url].requests.push(request);\r\n        } else {\r\n            atBegin ? this.requests.unshift(request) : this.requests.push(request);\r\n            this._nextLoad();\r\n        }\r\n\r\n        this.fire('request', {request: request});\r\n\r\n        return request;\r\n    },\r\n\r\n    push: function(url, options) {  //     \r\n        return this._add(false, url, options);\r\n    },\r\n\r\n    unshift: function(url, options) {   //     \r\n        return this._add(true, url, options);\r\n    }\r\n});\r\n\r\nL.gmx.imageLoader = new GmxImageLoader();\r\n\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ImageLoader.js","/**\r\n* @name L.gmxUtil\r\n* @namespace\r\n*/\r\nvar gmxAPIutils = {\r\n    lastMapId: 0,\r\n\r\n    newId: function()\r\n    {\r\n        gmxAPIutils.lastMapId += 1;\r\n        return '_' + gmxAPIutils.lastMapId;\r\n    },\r\n\r\n    uniqueGlobalName: function(thing)\r\n    {\r\n        var id = gmxAPIutils.newId();\r\n        window[id] = thing;\r\n        return id;\r\n    },\r\n\r\n    isPageHidden: function()\t{\t\t//   \r\n        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;\r\n    },\r\n\r\n    normalizeHostname: function(hostName) {\r\n        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? 'http://' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'\r\n\r\n        hostName = parsedHost.host + parsedHost.directory;\r\n\r\n        if (hostName[hostName.length - 1] === '/') {\r\n            hostName = hostName.substring(0, hostName.length - 1);\r\n        }\r\n\r\n        return hostName;\r\n    },\r\n\r\n\tgetLayerItemFromServer: function(options) {\r\n        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,\r\n            req = {\r\n                WrapStyle: 'func',\r\n                geometry: true,\r\n                layer: options.layerID,\r\n                query: query\r\n            };\r\n        if (options.border) { req.border = options.border; }\r\n        return gmxAPIutils.requestJSONP(\r\n            options.url || (window.serverBase || 'http://maps.kosmosnimki.ru/') + 'VectorLayer/Search.ashx',\r\n            req,\r\n            options\r\n        );\r\n    },\r\n\r\n\tgetCadastreFeatures: function(options) {\r\n\t\t// example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});\r\n        if (options.latlng) {\r\n\t\t\tvar latlng = options.latlng,\r\n\t\t\t\treq = {\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\ttext: (latlng.lat + ' ' + latlng.lng).replace(/\\./g, ','),\r\n\t\t\t\t\ttolerance: options.tolerance || 0\r\n\t\t\t\t};\r\n\t\t\treturn gmxAPIutils.requestJSONP(\r\n\t\t\t\toptions.url || 'http://pkk5.rosreestr.ru/api/features/',\r\n\t\t\t\treq,\r\n\t\t\t\toptions\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n    },\r\n\r\n\tgetFormData: function(json) {\r\n\t\tvar arr = [];\r\n\t\tfor (var key in json) {\r\n\t\t\tvar val = json[key];\r\n\t\t\tarr.push(key + '=' + (typeof val === 'object' ? JSON.stringify(val) : val));\r\n\t\t}\r\n\t\treturn arr.join('&');\r\n    },\r\n\r\n    /** Sends JSONP requests\r\n     * @memberof L.gmxUtil\r\n     * @param {String} url - request URL\r\n     * @param {Object} params - request params\r\n     * @param {Object} [options] - additional request options\r\n     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.\r\n       If callbackParamName is set to null, no params will be added (StaticJSONP)\r\n     * @return {Deferred} Promise with server JSON response or with error status\r\n    */\r\n\trequestJSONP: function(url, params, options) {\r\n        options = options || {};\r\n        var def = new L.gmx.Deferred();\r\n\r\n        var script = document.createElement('script');\r\n        script.setAttribute('charset', 'UTF-8');\r\n        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';\r\n        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);\r\n\r\n        if (callbackParamName) {\r\n            var callbackName = gmxAPIutils.uniqueGlobalName(function(obj) {\r\n                delete window[callbackName];\r\n                def.resolve(obj, options);\r\n            });\r\n\r\n            urlParams[callbackParamName] = callbackName;\r\n        }\r\n\r\n        var paramsStringItems = [];\r\n\r\n        for (var p in urlParams) {\r\n            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));\r\n        }\r\n\r\n        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');\r\n\r\n        script.onerror = function(e) {\r\n            def.reject(e);\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        script.onload = function() {\r\n            L.gmxUtil.loaderStatus(src, true);\r\n            script.parentNode.removeChild(script);\r\n        };\r\n        L.gmxUtil.loaderStatus(src, null, 'vector');\r\n        script.setAttribute('src', src);\r\n\r\n        document.getElementsByTagName('head').item(0).appendChild(script);\r\n        return def;\r\n    },\r\n    getXmlHttp: function() {\r\n        var xmlhttp;\r\n        if (typeof XMLHttpRequest !== 'undefined') {\r\n            xmlhttp = new XMLHttpRequest();\r\n        } else {\r\n          try {\r\n            xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');\r\n          } catch (e) {\r\n            try {\r\n              xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\r\n            } catch (E) {\r\n              xmlhttp = false;\r\n            }\r\n          }\r\n        }\r\n        return xmlhttp;\r\n    },\r\n    request: function(ph) { // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}\r\n        var xhr = gmxAPIutils.getXmlHttp();\r\n        if (xhr) {\r\n            xhr.open((ph.type ? ph.type : 'GET'), ph.url, ph.async || false);\r\n            if (ph.headers) {\r\n                for (var key in ph.headers) {\r\n                    xhr.setRequestHeader(key, ph.headers[key]);\r\n                }\r\n            }\r\n            var reqId = L.gmxUtil.loaderStatus();\r\n            if (ph.async) {\r\n                if (ph.withCredentials) {\r\n                    xhr.withCredentials = true;\r\n                }\r\n                xhr.onreadystatechange = function() {\r\n                    if (xhr.readyState === 4) {\r\n                        L.gmxUtil.loaderStatus(reqId, true);\r\n                        if (xhr.status === 200) {\r\n                            ph.callback(xhr.responseText);\r\n                            xhr = null;\r\n                        } else if (ph.onError) {\r\n                            ph.onError(xhr);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\t\t\tvar params = null;\r\n\t\t\tif (ph.params) {\r\n\t\t\t\tparams = ph.params;\r\n\t\t\t\tvar syncParams = L.gmx.gmxMapManager.getSyncParams(true);\r\n\t\t\t\tif (syncParams) {\r\n\t\t\t\t\tparams += '&' + syncParams;\r\n\t\t\t\t}\r\n\t\t\t}\r\n            xhr.send(params);\r\n            if (!ph.async && xhr.status === 200) {\r\n                ph.callback(xhr.responseText);\r\n                L.gmxUtil.loaderStatus(reqId, true);\r\n                return xhr.status;\r\n            }\r\n            return true;\r\n        }\r\n        if (ph.onError) {\r\n            ph.onError({Error: 'bad XMLHttpRequest!'});\r\n        }\r\n        return false;\r\n    },\r\n\r\n    tileSizes: [], //    zoom\r\n    getTileNumFromLeaflet: function (tilePoint, zoom) {\r\n        if ('z' in tilePoint) {\r\n            zoom = tilePoint.z;\r\n        }\r\n        var pz = Math.pow(2, zoom),\r\n            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),\r\n            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);\r\n        return {\r\n            z: zoom,\r\n            x: tx % pz - pz / 2,\r\n            y: pz / 2 - 1 - ty % pz\r\n        };\r\n    },\r\n\r\n\tgetTilePosZoomDelta: function(tilePoint, zoomFrom, zoomTo) {\t\t//      zoom\r\n        var dz = Math.pow(2, zoomFrom - zoomTo),\r\n            size = 256 / dz,\r\n            dx = tilePoint.x % dz,\r\n            dy = tilePoint.y % dz;\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tzDelta: dz,\r\n\t\t\tx: size * (dx < 0 ? dz + dx : dx),\r\n\t\t\ty: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)\r\n\t\t};\r\n    },\r\n\r\n    geoItemBounds: function(geo) {  // get item bounds array by geometry\r\n        if (!geo) {\r\n            return {\r\n                bounds: null,\r\n                boundsArr: []\r\n            };\r\n        }\r\n        var type = geo.type,\r\n            coords = geo.coordinates,\r\n            b = null,\r\n            i = 0,\r\n            len = 0,\r\n            bounds = null,\r\n            boundsArr = [];\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr1 = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr1.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                }\r\n                boundsArr.push(arr1);\r\n            }\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                boundsArr.push(b);\r\n                if (i === 0) { bounds.extendBounds(b); }\r\n            }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds([coords[i]]);\r\n                bounds.extendBounds(b);\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n            //boundsArr.push(bounds);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                b = gmxAPIutils.bounds(coords[i]);\r\n                bounds.extendBounds(b);\r\n                //boundsArr.push(b);\r\n            }\r\n        }\r\n        return {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n    },\r\n\r\n    getUnFlattenGeo: function(geo) {  // get unFlatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            coords = geo.coordinates,\r\n            coordsOut = coords;\r\n\r\n        if (isLikePolygon) {\r\n            coordsOut = [];\r\n            var isPolygon = type === 'POLYGON' || type === 'Polygon';\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                var ring = [];\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);\r\n                }\r\n                coordsOut.push(ring);\r\n            }\r\n            if (isPolygon) { coordsOut = coordsOut[0]; }\r\n        }\r\n        return {type: type, coordinates: coordsOut};\r\n    },\r\n\r\n    unFlattenRing: function(arr) {\r\n        if (typeof arr[0] !== 'number') {\r\n            return arr;\r\n        }\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            res = new Array(len / 2);\r\n\r\n        for (var i = 0; i < len; i += 2) {\r\n            res[cnt++] = [arr[i], arr[i + 1]];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    geoFlatten: function(geo) {  // get flatten geometry\r\n        var type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates;\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    flattenRing: function(arr) {\r\n        var len = arr.length,\r\n            cnt = 0,\r\n            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,\r\n            res = new CurArray(2 * len);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            res[cnt++] = arr[i][0];\r\n            res[cnt++] = arr[i][1];\r\n        }\r\n        return res;\r\n    },\r\n\r\n    /** Check rectangle type by coordinates\r\n     * @memberof L.gmxUtil\r\n     * @param {coordinates} coordinates - geoJSON coordinates data format\r\n     * @return {Boolean}\r\n    */\r\n    isRectangle: function(coords) {\r\n        return (coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4)\r\n            && ((coords[0][0][0] === coords[0][1][0]) || (coords[0][0][1] === coords[0][1][1]))\r\n            && ((coords[0][1][0] === coords[0][2][0]) || (coords[0][1][1] === coords[0][2][1]))\r\n            && ((coords[0][2][0] === coords[0][3][0]) || (coords[0][2][1] === coords[0][3][1]))\r\n            && ((coords[0][3][0] === coords[0][0][0]) || (coords[0][3][1] === coords[0][0][1]))\r\n        );\r\n    },\r\n\r\n    /** Get bounds from geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {geometry} geometry - Geomixer or geoJSON data format\r\n     * @return {Object} bounds\r\n    */\r\n    getGeometryBounds: function(geo) {\r\n        var pt = gmxAPIutils.geoItemBounds(geo);\r\n        return pt.bounds;\r\n    },\r\n\r\n    getMarkerPolygon: function(bounds, dx, dy) {\r\n        var x = (bounds.min.x + bounds.max.x) / 2,\r\n            y = (bounds.min.y + bounds.max.y) / 2;\r\n        return [\r\n            [x - dx, y - dy],\r\n            [x - dx, y + dy],\r\n            [x + dx, y + dy],\r\n            [x + dx, y - dy],\r\n            [x - dx, y - dy]\r\n        ];\r\n    },\r\n\r\n    getQuicklookPointsFromProperties: function(pArr, gmx) {\r\n        var indexes = gmx.tileAttributeIndexes;\r\n        var points = {\r\n                x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,\r\n                y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,\r\n                x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,\r\n                y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,\r\n                x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,\r\n                y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,\r\n                x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,\r\n                y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0\r\n            },\r\n            bounds = gmxAPIutils.bounds([\r\n                [points.x1, points.y1],\r\n                [points.x2, points.y2],\r\n                [points.x3, points.y3],\r\n                [points.x4, points.y4]\r\n            ]);\r\n\r\n        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {\r\n            return null;\r\n        }\r\n\r\n        if (!gmx.quicklookPlatform) {\r\n            var merc = L.Projection.Mercator.project(L.latLng(points.y1, points.x1));\r\n            points.x1 = merc.x; points.y1 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y2, points.x2));\r\n            points.x2 = merc.x; points.y2 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y3, points.x3));\r\n            points.x3 = merc.x; points.y3 = merc.y;\r\n            merc = L.Projection.Mercator.project(L.latLng(points.y4, points.x4));\r\n            points.x4 = merc.x; points.y4 = merc.y;\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /** Get hash properties from array properties\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} properties in Array format\r\n     * @param {Object} keys indexes\r\n     * @return {Object} properties in Hash format\r\n    */\r\n    getPropertiesHash: function(arr, indexes) {\r\n        var properties = {};\r\n        for (var key in indexes) {\r\n            properties[key] = arr[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    getPropItem: function(key, arr, indexes) {\r\n        return key in indexes ? arr[indexes[key]] : '';\r\n    },\r\n\r\n    dec2rgba: function(i, a)\t{\t\t\t\t// convert decimal to rgb\r\n        var r = (i >> 16) & 255,\r\n            g = (i >> 8) & 255,\r\n            b = i & 255;\r\n\t\treturn 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';\r\n\t},\r\n\r\n    dec2hex: function(i) {\t\t\t\t\t// convert decimal to hex\r\n        return (i + 0x1000000).toString(16).substr(-6);\r\n    },\r\n\r\n    dec2color: function(i, a)   {   // convert decimal to canvas color\r\n        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);\r\n    },\r\n\r\n    oneDay: 60 * 60 * 24,\t\t\t//  \r\n\r\n    isTileKeysIntersects: function(tk1, tk2) { //     \r\n        if (tk1.z < tk2.z) {\r\n            var t = tk1; tk1 = tk2; tk2 = t;\r\n        }\r\n\r\n        var dz = tk1.z - tk2.z;\r\n        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;\r\n\t},\r\n\r\n    rotatePoints: function(arr, angle, iconScale, center) {\t\t\t// rotate -  \r\n        var out = [];\r\n        angle *= Math.PI / 180.0;\r\n        var sin = Math.sin(angle);\r\n        var cos = Math.cos(angle);\r\n        if (!iconScale) { iconScale = 1; }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            var x = iconScale * arr[i].x - center.x;\r\n            var y = iconScale * arr[i].y - center.y;\r\n            out.push({\r\n                'x': cos * x - sin * y + center.x,\r\n                'y': sin * x + cos * y + center.y\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n    getPatternIcon: function(item, style, indexes) { //  bitmap  pattern\r\n        if (!style.fillPattern) { return null; }\r\n\r\n        var notFunc = true,\r\n            pattern = style.fillPattern,\r\n            prop = item ? item.properties : null,\r\n            step = pattern.step > 0 ? pattern.step : 0,\r\n            patternDefaults = {\r\n                minWidth: 1,\r\n                maxWidth: 1000,\r\n                minStep: 0,\r\n                maxStep: 1000\r\n            };\r\n        if (pattern.patternStepFunction && prop !== null) {\r\n            step = pattern.patternStepFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (step > patternDefaults.maxStep) {\r\n            step = patternDefaults.maxStep;\r\n        }\r\n        else if (step < patternDefaults.minStep) {\r\n            step = patternDefaults.minStep;\r\n        }\r\n\r\n        var size = pattern.width > 0 ? pattern.width : 8;\r\n        if (pattern.patternWidthFunction && prop !== null) {\r\n            size = pattern.patternWidthFunction(prop, indexes);\r\n            notFunc = false;\r\n        }\r\n        if (size > patternDefaults.maxWidth) {\r\n            size = patternDefaults.maxWidth;\r\n        } else if (size < patternDefaults.minWidth) {\r\n            size = patternDefaults.minWidth;\r\n        }\r\n\r\n        var op = style.fillOpacity;\r\n        if (style.opacityFunction && prop !== null) {\r\n            op = style.opacityFunction(prop, indexes) / 100;\r\n            notFunc = false;\r\n        }\r\n\r\n        var rgb = [0xff0000, 0x00ff00, 0x0000ff],\r\n            arr = (pattern.colors != null ? pattern.colors : rgb),\r\n            count = arr.length,\r\n            resColors = [],\r\n            i = 0;\r\n\r\n        for (i = 0; i < count; i++) {\r\n            var col = arr[i];\r\n            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {\r\n                col = (prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3]);\r\n                notFunc = false;\r\n            }\r\n            resColors.push(col);\r\n        }\r\n        if (count === 0) { resColors = [0]; op = 0; count = 1; }   // pattern without colors\r\n\r\n        var delta = size + step,\r\n            allSize = delta * count,\r\n            center = 0,\r\n            //radius,\r\n            rad = 0,\r\n            hh = allSize,\t\t\t\t//  \r\n            ww = allSize,\t\t\t\t//  \r\n            type = pattern.style || 'horizontal',\r\n            flagRotate = false;\r\n\r\n        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {\r\n            flagRotate = true;\r\n        } else if (type === 'circle') {\r\n            ww = hh = 2 * delta;\r\n            center = Math.floor(ww / 2);\t//  \r\n            //radius = Math.floor(size / 2);\t// \r\n            rad = 2 * Math.PI / count;\t\t//   .\r\n        } else if (type === 'vertical') {\r\n            hh = 1;\r\n        } else if (type === 'horizontal') {\r\n            ww = 1;\r\n        }\r\n        if (ww * hh > patternDefaults.maxWidth) {\r\n            console.log({'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big'});\r\n            return null;\r\n        }\r\n\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.clearRect(0, 0, canvas.width, canvas.height);\r\n        if (type === 'diagonal2' || type === 'vertical') {\r\n            ptx.translate(ww, 0);\r\n            ptx.rotate(Math.PI / 2);\r\n        }\r\n\r\n        for (i = 0; i < count; i++) {\r\n            ptx.beginPath();\r\n            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);\r\n            ptx.fillStyle = fillStyle;\r\n\r\n            if (flagRotate) {\r\n                var x1 = i * delta; var xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n\r\n                x1 += allSize; xx1 = x1 + size;\r\n                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);\r\n                if (type === 'cross' || type === 'cross1') {\r\n                    x1 = i * delta; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n\r\n                    x1 += allSize; xx1 = x1 + size;\r\n                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);\r\n                }\r\n            } else if (type === 'circle') {\r\n                ptx.arc(center, center, size, i * rad, (i + 1) * rad);\r\n                ptx.lineTo(center, center);\r\n            } else {\r\n                ptx.fillRect(0, i * delta, ww, size);\r\n            }\r\n            ptx.closePath();\r\n            ptx.fill();\r\n        }\r\n        var canvas1 = document.createElement('canvas');\r\n        canvas1.width = ww;\r\n        canvas1.height = hh;\r\n        var ptx1 = canvas1.getContext('2d');\r\n        ptx1.drawImage(canvas, 0, 0, ww, hh);\r\n        return {'notFunc': notFunc, 'canvas': canvas1};\r\n    },\r\n\r\n    getSVGIcon: function (options) {\r\n        var svg = '<svg xmlns=\"' + L.Path.SVG_NS + '\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"',\r\n            type = options.type,\r\n            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',\r\n            stroke = options.strokeStyle || '#0000ff',\r\n            strokeWidth = options.lineWidth || 2,\r\n            iconOptions = {\r\n                className: 'gmx-svg-icon'\r\n            };\r\n\r\n        if (options.className) {\r\n            iconOptions.className = options.className;\r\n        }\r\n        var size = options.iconSize;\r\n        iconOptions.iconSize = [size, size];\r\n        svg += ' height = \"' + size + 'px\"  width = \"' + size + 'px\">';\r\n\r\n        if (type === 'circle') {\r\n            if (options.fillRadialGradient) {\r\n                svg += '<defs><radialGradient id=\"myRadialGradient4\" spreadMethod=\"pad\">';\r\n                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop\r\n                    || [     // [%, color, opacity]\r\n                        [0, '#ffff00', 0.8],\r\n                        [1, '#ff0000', 0.8]\r\n                    ];\r\n\r\n                for (var i = 0, len = stopColor.length; i < len; i++) {\r\n                    var it = stopColor[i];\r\n                    svg += '<stop offset=\"' + (100 * it[0]) + '%\"   stop-color=\"' + it[1] + '\" stop-opacity=\"' + it[2] + '\"/>';\r\n                }\r\n                svg += '</radialGradient></defs>';\r\n                fill = 'url(#myRadialGradient4)';\r\n                stroke = strokeWidth = null;\r\n            }\r\n            size /= 2;\r\n            svg += '<g><circle cx=\"' + size + '\" cy=\"' + size + '\" r=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:\"' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:\"' + strokeWidth + ';'; }\r\n            svg += ';\" />';\r\n        } else if (type === 'square') {\r\n            svg += '<g><rect width=\"' + size + '\" height=\"' + size + '\" style=\"';\r\n            if (fill) { svg += ' fill:' + fill + ';'; }\r\n            if (stroke) { svg += ' stroke:' + stroke + ';'; }\r\n            if (strokeWidth) { svg += ' stroke-width:' + 2 * strokeWidth + ';'; }\r\n            svg += '\" />';\r\n        }\r\n        if (options.text) {\r\n            var text = options.text;\r\n            svg += '<text x=\"50%\" y=\"50%\" dy=\"0.4em\"';\r\n            for (var key in text) {\r\n                if (key !== 'count') { svg += ' ' + key + '=\"' + text[key] + '\"'; }\r\n            }\r\n            svg += '>' + text.count + '</text>';\r\n        }\r\n        svg += '</g></svg>';\r\n        iconOptions.html = svg;\r\n\r\n        return new L.DivIcon(iconOptions);\r\n    },\r\n\r\n    toPixels: function(p, tpx, tpy, mInPixel) { // get pixel point\r\n        var px1 = p[0] * mInPixel; \tpx1 = (0.5 + px1) << 0;\r\n        var py1 = p[1] * mInPixel;\tpy1 = (0.5 + py1) << 0;\r\n        return [px1 - tpx, tpy - py1].concat(p.slice(2));\r\n    },\r\n\r\n    getPixelPoint: function(attr, coords) {\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n            style = attr.style || {},\r\n            iconScale = currentStyle.iconScale || 1,\r\n            iconCenter = currentStyle.iconCenter || false,\r\n            sx = currentStyle.sx || style.sx || 4,\r\n            sy = currentStyle.sy || style.sy || 4,\r\n            weight = currentStyle.weight || style.weight || 0,\r\n            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy;\r\n\r\n        if (!iconCenter && iconAnchor) {\r\n            px1 -= iconAnchor[0];\r\n            py1 -= iconAnchor[1];\r\n        }\r\n        sx *= iconScale;\r\n        sy *= iconScale;\r\n        sx += weight;\r\n        sy += weight;\r\n\r\n        var py1 = py - coords[1] * mInPixel,\r\n\t\t\tpx1 = coords[0] * mInPixel - px;\r\n\r\n\t\tif (px1 - sx > 256) {\r\n\t\t\tpx1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t} else if (px1 < -sx) {\r\n\t\t\tpx1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;\r\n\t\t}\r\n\r\n        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0\r\n\t\t\t? null :\r\n            {\r\n                sx: sx,\r\n                sy: sy,\r\n                px1: (0.5 + px1) << 0,\r\n                py1: (0.5 + py1) << 0\r\n            }\r\n        ;\r\n    },\r\n    getImageData: function(img) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return null; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var ptx = canvas.getContext('2d');\r\n        ptx.drawImage(img, 0, 0);\r\n        return ptx.getImageData(0, 0, ww, hh).data;\r\n    },\r\n    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,\r\n    isIE: function(v) {\r\n        return v === gmxAPIutils.getIEversion();\r\n    },\r\n    gtIE: function(v) {\r\n        return v < gmxAPIutils.getIEversion();\r\n    },\r\n\r\n    getIEversion: function() {\r\n        var ua = navigator.userAgent || '',\r\n            msie = ua.indexOf('MSIE ');\r\n        if (msie > 0) {\r\n            // IE 10 or older => return version number\r\n            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n        }\r\n\r\n        var trident = ua.indexOf('Trident/');\r\n        if (trident > 0) {\r\n            // IE 11 => return version number\r\n            var rv = ua.indexOf('rv:');\r\n            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n        }\r\n\r\n        var edge = ua.indexOf('Edge/');\r\n        if (edge > 0) {\r\n            // Edge (IE 12+) => return version number\r\n            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n        }\r\n\r\n        // other browser\r\n        return -1;\r\n    },\r\n\r\n    replaceColor: function(img, color, fromData) {\r\n        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return img; }\r\n        var canvas = document.createElement('canvas'),\r\n            ww = img.width,\r\n            hh = img.height;\r\n\r\n        canvas.width = ww; canvas.height = hh;\r\n        var flag = false,\r\n            imageData,\r\n            ptx = canvas.getContext('2d');\r\n\r\n        if (typeof color === 'string') {\r\n            color = parseInt('0x' + color.replace(/#/, ''));\r\n        }\r\n        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {\r\n            var r = (color >> 16) & 255,\r\n                g = (color >> 8) & 255,\r\n                b = color & 255;\r\n\r\n            if (fromData) {\r\n                imageData = ptx.createImageData(ww, hh);\r\n            } else {\r\n                ptx.drawImage(img, 0, 0);\r\n                imageData = ptx.getImageData(0, 0, ww, hh);\r\n                fromData = imageData.data;\r\n            }\r\n            var toData = imageData.data;\r\n            for (var i = 0, len = fromData.length; i < len; i += 4) {\r\n                if ((fromData[i] === 0xff || fromData[i] === 238)\r\n                    && fromData[i + 1] === 0\r\n                    && fromData[i + 2] === 0xff\r\n                    ) {\r\n                    toData[i] = r;\r\n                    toData[i + 1] = g;\r\n                    toData[i + 2] = b;\r\n                    toData[i + 3] = fromData[i + 3];\r\n                    flag = true;\r\n                }\r\n            }\r\n        }\r\n        if (flag) {\r\n            ptx.putImageData(imageData, 0, 0);\r\n        } else {\r\n            ptx.drawImage(img, 0, 0);\r\n        }\r\n        return canvas;\r\n    },\r\n\r\n    drawIconPath: function(path, attr) { // draw iconPath in canvas\r\n        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) { return; }\r\n        var trFlag = false,\r\n            ctx = attr.ctx,\r\n            rad = attr.radian;\r\n\r\n        if (attr.px || attr.py) { ctx.translate(attr.px || 0, attr.py || 0); trFlag = true; }\r\n        if (!rad && attr.rotateRes) { rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes); }\r\n        if (rad) { ctx.rotate(rad); trFlag = true; }\r\n        ctx.moveTo(path[0], path[1]);\r\n        for (var i = 2, len = path.length; i < len; i += 2) {\r\n            ctx.lineTo(path[i], path[i + 1]);\r\n        }\r\n        if (trFlag) { ctx.setTransform(1, 0, 0, 1, 0, 0); }\r\n    },\r\n\r\n    pointToCanvas: function(attr) { //   canvas\r\n        var gmx = attr.gmx,\r\n            pointAttr = attr.pointAttr,\r\n            style = attr.style || {},\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconScale = currentStyle.iconScale || 1,\r\n            image = currentStyle.image,\r\n            sx = pointAttr.sx,\r\n            sy = pointAttr.sy,\r\n            px1 = pointAttr.px1,\r\n            py1 = pointAttr.py1,\r\n            px1sx = px1,\r\n            py1sy = py1,\r\n            ctx = attr.ctx;\r\n\r\n        if (currentStyle.type === 'image') {\r\n            sx = style.sx;\r\n            sy = style.sy;\r\n            image = style.image;\r\n        }\r\n        if (currentStyle.iconCenter) {\r\n            px1sx -= sx / 2;\r\n            py1sy -= sy / 2;\r\n        } else if (style.type === 'circle') {\r\n            px1 += sx / 2;\r\n            py1 += sy / 2;\r\n        }\r\n        if (currentStyle.iconPath) {\r\n            attr.px = px1;\r\n            attr.py = py1;\r\n            attr.rotateRes = currentStyle.rotate || 0;\r\n        }\r\n        if (image) {\r\n            if ('iconColor' in currentStyle) {\r\n                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);\r\n            }\r\n            style.rotateRes = currentStyle.rotate || 0;\r\n            if ('opacity' in style) { ctx.globalAlpha = currentStyle.opacity || style.opacity; }\r\n            if (gmx.transformFlag) {\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);\r\n                ctx.drawImage(image, px1, -py1, sx, sy);\r\n                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);\r\n            } else {\r\n\t\t\t\tif (iconScale !== 1) {\r\n\t\t\t\t\tsx *= iconScale;\r\n\t\t\t\t\tsy *= iconScale;\r\n\t\t\t\t\tpx1 = pointAttr.px1;\r\n\t\t\t\t\tpy1 = pointAttr.py1;\r\n\t\t\t\t\tpx1sx = px1;\r\n\t\t\t\t\tpy1sy = py1;\r\n\t\t\t\t\tif (currentStyle.iconCenter) {\r\n\t\t\t\t\t\tpx1sx -= sx / 2;\r\n\t\t\t\t\t\tpy1sy -= sy / 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (style.rotateRes) {\r\n\t\t\t\t\tctx.translate(px1, py1);\r\n\t\t\t\t\tctx.rotate(gmxAPIutils.degRad(style.rotateRes));\r\n\t\t\t\t\tctx.translate(-px1, -py1);\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tctx.drawImage(image, px1sx, py1sy, sx, sy);\r\n\t\t\t\t}\r\n            }\r\n            if ('opacity' in style) { ctx.globalAlpha = 1; }\r\n        } else if (style.fillColor || currentStyle.fillRadialGradient) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {\r\n                var circle = style.iconSize / 2;\r\n                if (currentStyle.fillRadialGradient) {\r\n                    var rgr = currentStyle.fillRadialGradient;\r\n                    circle = rgr.r2 * iconScale;\r\n                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);\r\n                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {\r\n                        var arr = rgr.addColorStop[i];\r\n                        radgrad.addColorStop(arr[0], arr[1]);\r\n                    }\r\n                    ctx.fillStyle = radgrad;\r\n                }\r\n                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.fillRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.fill();\r\n        }\r\n        if (currentStyle.strokeStyle) {\r\n            ctx.beginPath();\r\n            if (currentStyle.iconPath) {\r\n                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);\r\n            } else if (style.type === 'circle') {\r\n                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);\r\n            } else {\r\n                ctx.strokeRect(px1sx, py1sy, sx, sy);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n    },\r\n    lineToCanvasAsIcon: function(pixels, attr) {  // add line(as icon) to canvas\r\n        var len = pixels.length,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            iconPath = currentStyle.iconPath;\r\n\r\n        if (len > 0) {\r\n            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n                ctx.setLineDash([]);\r\n            }\r\n            ctx.beginPath();\r\n            for (var i = 0, p; i < len; i++) {\r\n                p = pixels[i];\r\n                gmxAPIutils.drawIconPath(iconPath, {ctx: ctx, px: p.x, py: p.y, radian: p.radian});\r\n            }\r\n            if (currentStyle.strokeStyle) {\r\n                ctx.stroke();\r\n            }\r\n            if (currentStyle.fillStyle) {\r\n                ctx.fill();\r\n            }\r\n        }\r\n    },\r\n    lineToCanvas: function(attr) {  // Lines in canvas\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            item = attr.item,\r\n            currentStyle = item.currentStyle || item.parsedStyleKeys,\r\n            pixels = currentStyle.iconPath ? [] : null;\r\n\r\n        var lastX = null, lastY = null;\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),\r\n                x = p[0],\r\n                y = p[1];\r\n            if (lastX !== x || lastY !== y) {\r\n                if (pixels) { pixels.push({x: x, y: y, radian: p[2]}); }\r\n                if (i === 0) {\r\n                    ctx.moveTo(x, y);\r\n                } else {\r\n                    ctx.lineTo(x, y);\r\n                }\r\n                lastX = x; lastY = y;\r\n            }\r\n        }\r\n        ctx.stroke();\r\n        return pixels;\r\n    },\r\n\r\n    getCoordsPixels: function(attr) {\r\n        var gmx = attr.gmx,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || [],\r\n            pixels = [],\r\n            hidden = [],\r\n            hiddenFlag = false,\r\n            hash = {\r\n                gmx: gmx,\r\n                tpx: attr.tpx,\r\n                tpy: attr.tpy,\r\n                coords: null,\r\n                hiddenLines: null\r\n            };\r\n        for (var j = 0, len = coords.length; j < len; j++) {\r\n            var coords1 = coords[j],\r\n                hiddenLines1 = hiddenLines[j] || [],\r\n                pixels1 = [], hidden1 = [];\r\n            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {\r\n                hash.coords = coords1[j1];\r\n                hash.hiddenLines = hiddenLines1[j1] || [];\r\n                var res = gmxAPIutils.getRingPixels(hash);\r\n                pixels1.push(res.coords);\r\n                hidden1.push(res.hidden);\r\n                if (res.hidden) {\r\n                    hiddenFlag = true;\r\n                }\r\n            }\r\n            pixels.push(pixels1);\r\n            hidden.push(hidden1);\r\n        }\r\n        return {coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom};\r\n    },\r\n\r\n    getRingPixels: function(attr) {\r\n        if (attr.coords.length === 0) { return null; }\r\n        var gmx = attr.gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            coords = attr.coords,\r\n            hiddenLines = attr.hiddenLines || null,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            lastX = null, lastY = null,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            pixels = [], hidden = [];\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var lineIsOnEdge = false;\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x1 = c[0] * mInPixel, y1 = c[1] * mInPixel,\r\n                x2 = Math.round(x1 - px), y2 = Math.round(py - y1);\r\n\r\n            if (lastX !== x2 || lastY !== y2) {\r\n                lastX = x2; lastY = y2;\r\n                if (lineIsOnEdge) {\r\n                    hidden.push(cnt);\r\n                }\r\n                pixels[cnt++] = x1;\r\n                pixels[cnt++] = y1;\r\n            }\r\n        }\r\n        return {coords: pixels, hidden: hidden.length ? hidden : null};\r\n    },\r\n\r\n    polygonToCanvas: function(attr) {       // Polygons in canvas\r\n        if (attr.coords.length === 0) { return null; }\r\n        var hiddenLines = attr.hiddenLines || null,\r\n            coords = attr.coords,\r\n            ctx = attr.ctx,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            cnt = 0, cntHide = 0,\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            lastX = null, lastY = null;\r\n\r\n        ctx.beginPath();\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                x = Math.round(c[0] - px),\r\n                y = Math.round(py - c[1]),\r\n                lineIsOnEdge = false;\r\n\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                lineIsOnEdge = true;\r\n                cntHide++;\r\n            }\r\n\r\n            if (lastX !== x || lastY !== y) {\r\n                ctx[(lineIsOnEdge ? 'moveTo' : 'lineTo')](x, y);\r\n                lastX = x; lastY = y;\r\n                cnt++;\r\n            }\r\n        }\r\n        if (cnt === 1) { ctx.lineTo(lastX + 1, lastY); }\r\n        ctx.stroke();\r\n    },\r\n\r\n    polygonToCanvasFill: function(attr) {     // Polygon fill\r\n        if (attr.coords.length < 3) { return; }\r\n        var coords = attr.coords,\r\n            px = attr.tpx,\r\n            py = attr.tpy,\r\n            vectorSize = 1,\r\n            ctx = attr.ctx;\r\n\r\n        ctx.lineWidth = 0;\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));\r\n        } else {\r\n            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));\r\n        }\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));\r\n        }\r\n    },\r\n\r\n    isPatternNode: function(it) {\r\n        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;\r\n    },\r\n    labelCanvasContext: null,    // 2dContext canvas for Label size\r\n    getLabelWidth: function(txt, style) {   // Get label size Label\r\n        if (style) {\r\n            if (!gmxAPIutils.labelCanvasContext) {\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = canvas.height = 512;\r\n                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');\r\n            }\r\n            var ptx = gmxAPIutils.labelCanvasContext;\r\n            ptx.clearRect(0, 0, 512, 512);\r\n\r\n            if (ptx.font !== style.font) { ptx.font = style.font; }\r\n            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }\r\n            if (ptx.fillStyle !== style.fillStyle) { ptx.fillStyle = style.fillStyle; }\r\n\t\t\tvar arr = txt.split('\\n');\r\n            return arr.map(function(it) {\r\n\t\t\t\tptx.fillText(it, 0, 0);\r\n\t\t\t\treturn [it, ptx.measureText(it).width];\r\n\t\t\t});\r\n        }\r\n        return 0;\r\n    },\r\n    setLabel: function(ctx, txt, coord, style) {\r\n        var x = coord[0],\r\n            y = coord[1];\r\n\r\n        if (ctx.shadowColor !== style.strokeStyle) { ctx.shadowColor = style.strokeStyle; }\r\n        if (ctx.shadowBlur !== style.shadowBlur) { ctx.shadowBlur = style.shadowBlur; }\r\n        if (ctx.font !== style.font) { ctx.font = style.font; }\r\n        if (ctx.strokeStyle !== style.strokeStyle) { ctx.strokeStyle = style.strokeStyle; }\r\n        if (ctx.fillStyle !== style.fillStyle) { ctx.fillStyle = style.fillStyle; }\r\n        ctx.strokeText(txt, x, y);\r\n        ctx.fillText(txt, x, y);\r\n    },\r\n    worldWidthMerc: 20037508,\r\n    rMajor: 6378137.000,\r\n    degRad: function(ang) {\r\n        return ang * (Math.PI / 180.0);\r\n    },\r\n\r\n    distVincenty: function(lon1, lat1, lon2, lat2) {\r\n        var p1 = {\r\n            lon: gmxAPIutils.degRad(lon1),\r\n            lat: gmxAPIutils.degRad(lat1)\r\n        },\r\n            p2 = {\r\n            lon: gmxAPIutils.degRad(lon2),\r\n            lat: gmxAPIutils.degRad(lat2)\r\n        },\r\n            a = gmxAPIutils.rMajor,\r\n            b = 6356752.3142,\r\n            f = 1 / 298.257223563;  // WGS-84 ellipsiod\r\n\r\n        var L1 = p2.lon - p1.lon,\r\n            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),\r\n            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),\r\n            sinU1 = Math.sin(U1), cosU1 = Math.cos(U1),\r\n            sinU2 = Math.sin(U2), cosU2 = Math.cos(U2),\r\n            lambda = L1,\r\n            lambdaP = 2 * Math.PI,\r\n            iterLimit = 20;\r\n        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {\r\n                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda),\r\n                    sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +\r\n                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\r\n                if (sinSigma === 0) { return 0; }\r\n                var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,\r\n                    sigma = Math.atan2(sinSigma, cosSigma),\r\n                    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,\r\n                    cosSqAlpha = 1 - sinAlpha * sinAlpha,\r\n                    cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\r\n                if (isNaN(cos2SigmaM)) { cos2SigmaM = 0; }\r\n                var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\r\n                lambdaP = lambda;\r\n                lambda = L1 + (1 - C) * f * sinAlpha *\r\n                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\r\n        }\r\n        if (iterLimit === 0) { return NaN; }\r\n\r\n        var uSq = cosSqAlpha * ((a * a) / (b * b) - 1),\r\n        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),\r\n            A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),\r\n            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),\r\n            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -\r\n                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),\r\n            s = b * A * (sigma - deltaSigma);\r\n\r\n        //s = s.toFixed(3);\r\n        return s;\r\n    },\r\n\r\n    _vfi: function(fi, a, b) {\r\n        return [\r\n            -Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a),\r\n            Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a),\r\n            -Math.sin(fi) * Math.cos(b)\r\n        ];\r\n    },\r\n\r\n    getCircleLatLngs: function(latlng, r) {   // Get latlngs for circle\r\n        var x = 0, y = 0;\r\n        if (latlng instanceof L.LatLng) {\r\n            x = latlng.lng;\r\n            y = latlng.lat;\r\n        } else if (L.Util.isArray(latlng)) {\r\n            x = latlng[1];\r\n            y = latlng[0];\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        var rad = Math.PI / 180,\r\n            a = x * rad,  //    \r\n            b = y * rad,  //    \r\n            R = gmxAPIutils.rMajor,\r\n            d = R * Math.sin(r / R),\r\n            Rd = R * Math.cos(r / R),\r\n            VR = [\r\n                Rd * Math.cos(b) * Math.cos(a),\r\n                Rd * Math.cos(b) * Math.sin(a),\r\n                Rd * Math.sin(b)\r\n            ],\r\n            latlngs = [];\r\n\r\n        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {\r\n            var v = gmxAPIutils._vfi(fi, a, b),\r\n                circle = [];\r\n            for (var i = 0; i < 3; i++) { circle[i] = VR[i] + d * v[i]; }\r\n\r\n            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;\r\n            if (circle[1] < 0) { t2 = -t2; }\r\n\r\n            if (t2 < x - 180) {\r\n                t2 += 360;\r\n            } else if (t2 > x + 180) {\r\n                t2 -= 360;\r\n            }\r\n            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);\r\n        }\r\n        return latlngs;\r\n    },\r\n\r\n    /** Get point coordinates from string\r\n     * @memberof L.gmxUtil\r\n     * @param {String} text - point coordinates in following formats:\r\n         <br/><i>55.74312, 37.61558</i>\r\n         <br/><i>5544'35\" N, 3736'56\" E</i>\r\n         <br/><i>4187347, 7472103</i>\r\n         <br/><i>4219783, 7407468 (EPSG:3395)</i>\r\n         <br/><i>4219783, 7442673 (EPSG:3857)</i>\r\n     * @return {Array} [lat, lng] or null\r\n    */\r\n    parseCoordinates: function(text) {\r\n        var crs = null,\r\n            regex = /\\(EPSG:(\\d+)\\)/g,\r\n            t = regex.exec(text);\r\n\r\n        if (t) {\r\n            crs = t[1];\r\n            text = text.replace(regex, '');\r\n        }\r\n\r\n        if (text.match(/[qrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {\r\n            return null;\r\n        }\r\n\r\n        //there should be a separator in the string (exclude strings like \"11E11\")\r\n        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {\r\n            return null;\r\n        }\r\n\r\n        if (text.indexOf(' ') !== -1) {\r\n            text = text.replace(/,/g, '.');\r\n        }\r\n        var results = [];\r\n        regex = /(-?\\d+(\\.\\d+)?)([^\\d\\-]*)/g;\r\n        t = regex.exec(text);\r\n        while (t) {\r\n            results.push(t[1]);\r\n            t = regex.exec(text);\r\n        }\r\n        if (results.length < 2) {\r\n            return null;\r\n        }\r\n        var ii = Math.floor(results.length / 2),\r\n            y = 0,\r\n            mul = 1,\r\n            i;\r\n        for (i = 0; i < ii; i++) {\r\n            y += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n        var x = 0;\r\n        mul = 1;\r\n        for (i = ii; i < results.length; i++) {\r\n            x += parseFloat(results[i]) * mul;\r\n            mul /= 60;\r\n        }\r\n\r\n        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {\r\n            t = x;\r\n            x = y;\r\n            y = t;\r\n        }\r\n\r\n        var pos;\r\n        if (crs === '3857') {\r\n            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n        if (Math.abs(x) > 180 || Math.abs(y) > 180) {\r\n            pos = L.Projection.Mercator.unproject(new L.Point(y, x));\r\n            x = pos.lng;\r\n            y = pos.lat;\r\n        }\r\n\r\n        if (text.indexOf('W') !== -1) {\r\n            x = -x;\r\n        }\r\n\r\n        if (text.indexOf('S') !== -1) {\r\n            y = -y;\r\n        }\r\n        return [y, x];\r\n    },\r\n\r\n\tpad2: function(t) {\r\n\t\treturn (t >= 0 && t < 10) ? ('0' + t) : ('' + t);\r\n\t},\r\n\r\n\ttrunc: function(x) {\r\n\t\treturn ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);\r\n\t},\r\n\r\n\tformatDegrees: function(angle, format) {\r\n\t\tangle = Math.round(10000000 * angle) / 10000000 + 0.00000001;\r\n\t\tvar a1 = Math.floor(angle),\r\n\t\t\ta2 = Math.floor(60 * (angle - a1)),\r\n\t\t\ta3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),\r\n\t\t\tst = gmxAPIutils.pad2(a1) + '';\r\n\r\n\t\tif (format ===  undefined ) { format = 2; }\r\n\t\tif (format > 0) {\r\n\t\t\tst += gmxAPIutils.pad2(a2) + '\\'';\r\n\t\t}\r\n\t\tif (format > 1) {\r\n\t\t\tst += gmxAPIutils.pad2(a3) + '\"';\r\n\t\t}\r\n\t\treturn st;\r\n\t},\r\n\r\n    /** Get point coordinates in string format with degrees\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format with degrees\r\n    */\r\n\tlatLonFormatCoordinates: function(x, y) {\r\n        x %= 360;\r\n        if (x > 180) { x -= 360; }\r\n        else if (x < -180) { x += 360; }\r\n\t\treturn  gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\r\n\tformatCoordinates: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates(x, y);\r\n\t},\r\n\r\n    /** Get point coordinates in string format\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} lng - point longitude\r\n     * @param {Number} lat - point latitude\r\n     * @return {String} point coordinates in string format\r\n    */\r\n\tlatLonFormatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +\r\n\t\t\tgmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');\r\n\t},\r\n\tformatCoordinates2: function(x, y) {\r\n\t\treturn  gmxAPIutils.latLonFormatCoordinates2(x, y);\r\n\t},\r\n\r\n    getPixelScale: function(zoom) {\r\n        return 256 / gmxAPIutils.tileSizes[zoom];\r\n    },\r\n\r\n    forEachPoint: function(coords, callback) {\r\n        if (!coords || coords.length === 0) { return []; }\r\n        var i, len, ret = [];\r\n        if (!coords[0].length) {\r\n            if (coords.length === 2) {\r\n                return callback(coords);\r\n            } else {\r\n                for (i = 0, len = coords.length / 2; i < len; i++) {\r\n                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));\r\n                }\r\n            }\r\n        } else {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                if (typeof coords[i] !== 'string') {\r\n                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    },\r\n/*\r\n\tgetQuicklookPoints: function(coord) { //  4   \r\n\t\tvar d1 = Number.MAX_VALUE;\r\n\t\tvar d2 = Number.MAX_VALUE;\r\n\t\tvar d3 = Number.MAX_VALUE;\r\n\t\tvar d4 = Number.MAX_VALUE;\r\n\t\tvar x1, y1, x2, y2, x3, y3, x4, y4;\r\n\t\tthis.forEachPoint(coord, function(p) {\r\n\t\t\tvar x = p[0];\r\n\t\t\tvar y = p[1];\r\n\t\t\tif ((x - y) < d1) {\r\n\t\t\t\td1 = x - y;\r\n\t\t\t\tx1 = p[0];\r\n\t\t\t\ty1 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x - y) < d2) {\r\n\t\t\t\td2 = -x - y;\r\n\t\t\t\tx2 = p[0];\r\n\t\t\t\ty2 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((-x + y) < d3) {\r\n\t\t\t\td3 = -x + y;\r\n\t\t\t\tx3 = p[0];\r\n\t\t\t\ty3 = p[1];\r\n\t\t\t}\r\n\t\t\tif ((x + y) < d4) {\r\n\t\t\t\td4 = x + y;\r\n\t\t\t\tx4 = p[0];\r\n\t\t\t\ty4 = p[1];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};\r\n\t},\r\n*/\r\n    getItemCenter: function(item, geoItems) {\r\n        var bounds = item.bounds,\r\n            min = bounds.min, max = bounds.max,\r\n            type = item.type,\r\n            isPoint = type === 'POINT' || type === 'MULTIPOINT',\r\n            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n\r\n        if (type === 'MULTIPOLYGON') {\r\n\t\t\treturn center;\r\n\t\t} else if (type === 'POLYGON') {\r\n            for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                var it = geoItems[i],\r\n                    geom = it.geo,\r\n                    coords = geom.coordinates,\r\n                    dataOption = it.dataOption,\r\n                    bbox = dataOption.bounds;\r\n\r\n                if (bbox.contains(center)) {\r\n                    if (geom.type === 'POLYGON') { coords = [coords]; }\r\n                    for (var j = 0, len1 = coords.length; j < len1; j++) {\r\n                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {\r\n                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);\r\n                            if (pt) {\r\n                                return pt.max.center;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (type === 'POINT' || type === 'MULTIPOINT') {\r\n            return center;\r\n        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {\r\n            return center;\r\n        }\r\n        return null;\r\n    },\r\n\r\n    getHSegmentsInPolygon: function(y, poly) {\r\n        var s = [], i, len, out,\r\n            vectorSize = 1,\r\n            p1 = poly[0];\r\n\r\n        if (typeof poly[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [poly[0], poly[1]];\r\n        }\r\n        var isGt1 = y > p1[1];\r\n        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],\r\n                isGt2 = y > p2[1];\r\n            if (isGt1 !== isGt2) {\r\n                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));\r\n            }\r\n            p1 = p2;\r\n            isGt1 = isGt2;\r\n        }\r\n        len = s.length;\r\n        if (len) {\r\n            s = s.sort();\r\n            var max = 0,\r\n                index = -1;\r\n            for (i = 1; i < len; i += 2) {\r\n                var j = i - 1,\r\n                    d = Math.abs(s[i] - s[j]);\r\n                if (d > max) {\r\n                    max = d;\r\n                    index = j;\r\n                }\r\n            }\r\n            out = {\r\n                y: y,\r\n                segArr: s,\r\n                max: {\r\n                    width: max,\r\n                    center: [(s[index] + s[index + 1]) / 2, y]\r\n                }\r\n            };\r\n        }\r\n        return out;\r\n    },\r\n\r\n    isPointInPolygonArr: function(chkPoint, coords) { //        \r\n        var isIn = false,\r\n            x = chkPoint[0],\r\n            y = chkPoint[1],\r\n            vectorSize = 1,\r\n            p1 = coords[0];\r\n\r\n        if (typeof coords[0] === 'number') {\r\n            vectorSize = 2;\r\n            p1 = [coords[0], coords[1]];\r\n        }\r\n\r\n        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {\r\n            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],\r\n                xmin = Math.min(p1[0], p2[0]),\r\n                xmax = Math.max(p1[0], p2[0]),\r\n                ymax = Math.max(p1[1], p2[1]);\r\n            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {\r\n                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];\r\n                if (p1[1] === p2[1] || y <= xinters) { isIn = !isIn; }\r\n            }\r\n            p1 = p2;\r\n        }\r\n        return isIn;\r\n    },\r\n\r\n    /** Is point in polygon with holes\r\n     * @memberof L.gmxUtil\r\n     * @param {chkPoint} chkPoint - point in [x, y] format\r\n     * @param {coords} coords - polygon from geoJSON coordinates data format\r\n     * @return {Boolean} true if polygon contain chkPoint\r\n    */\r\n    isPointInPolygonWithHoles: function(chkPoint, coords) {\r\n        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) { return false; }\r\n        for (var j = 1, len = coords.length; j < len; j++) {\r\n            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) { return false; }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /** Is polygon clockwise\r\n     * @memberof L.gmxUtil\r\n     * @param {ring} ring - ring from geoJSON coordinates data format\r\n     * @return {Boolean} true if ring is clockwise\r\n    */\r\n    isClockwise: function(ring) {\r\n        var area = 0;\r\n        for (var i = 0, j, len = ring.length; i < len; i++) {\r\n            j = (i + 1) % len;\r\n            area += ring[i][0] * ring[j][1];\r\n            area -= ring[j][0] * ring[i][1];\r\n        }\r\n        return (area < 0);\r\n    },\r\n\r\n    isPointInPolyLine: function(chkPoint, lineHeight, coords, hiddenLines) {\r\n        //  (  )   \r\n        var dx = chkPoint[0], dy = chkPoint[1],\r\n            nullPoint = {x: dx, y: dy},\r\n            minx = dx - lineHeight, maxx = dx + lineHeight,\r\n            miny = dy - lineHeight, maxy = dy + lineHeight,\r\n            cntHide = 0;\r\n\r\n        lineHeight *= lineHeight;\r\n        for (var i = 1, len = coords.length; i < len; i++) {\r\n            if (hiddenLines && i === hiddenLines[cntHide]) {\r\n                cntHide++;\r\n            } else {\r\n                var p1 = coords[i - 1], p2 = coords[i],\r\n                    x1 = p1[0], y1 = p1[1],\r\n                    x2 = p2[0], y2 = p2[1];\r\n\r\n                if (!(Math.max(x1, x2) < minx\r\n                    || Math.min(x1, x2) > maxx\r\n                    || Math.max(y1, y2) < miny\r\n                    || Math.min(y1, y2) > maxy)) {\r\n                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, {x: x1, y: y1}, {x: x2, y: y2}, true);\r\n                    if (sqDist < lineHeight) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    isPointInLines: function (attr) {\r\n        var arr = attr.coords,\r\n            point = attr.point,\r\n            delta = attr.delta,\r\n            boundsArr = attr.boundsArr,\r\n            hidden = attr.hidden;\r\n        for (var j = 0, len = arr.length, flag = false; j < len; j++) {\r\n            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;\r\n            if (flag\r\n                && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)\r\n            ) {\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /** Get length\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} latlngs array\r\n     * @param {Boolean} isMerc - true if coordinates in Mercator\r\n     * @return {Number} length\r\n    */\r\n    getLength: function(latlngs, isMerc) {\r\n        var length = 0;\r\n        if (latlngs && latlngs.length) {\r\n            var lng = false,\r\n                lat = false;\r\n\r\n            isMerc = isMerc === undefined || isMerc;\r\n            latlngs.forEach(function(latlng) {\r\n                if (L.Util.isArray(latlng)) {\r\n                    if (L.Util.isArray(latlng[0])) {\r\n                        length += gmxAPIutils.getLength(latlng, isMerc);\r\n                        return length;\r\n                    } else if (isMerc) {   // From Mercator array\r\n                        latlng = L.Projection.Mercator.unproject({x: latlng[0], y: latlng[1]});\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));\r\n                }\r\n                lng = latlng.lng;\r\n                lat = latlng.lat;\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get prettify length\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area\r\n     * @param {String} type: ('km', 'm', 'nm')\r\n     * @return {String} prettify length\r\n    */\r\n    prettifyDistance: function(length, type) {\r\n        var km = ' ' + L.gmxLocale.getText('units.km');\r\n        if (type === 'nm') {\r\n            return (Math.round(0.539956803 * length) / 1000) + ' ' + L.gmxLocale.getText('units.nm');\r\n        } else if (type === 'km') {\r\n            return (Math.round(length) / 1000) + km;\r\n        } else if (length < 2000 || type === 'm') {\r\n            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');\r\n        } else if (length < 200000) {\r\n            return (Math.round(length / 10) / 100) + km;\r\n        }\r\n        return Math.round(length / 1000) + km;\r\n    },\r\n\r\n    /** Get geoJSON length\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} length\r\n    */\r\n    geoJSONGetLength: function(geoJSON) {\r\n        var out = 0,\r\n            i, j, len, len1, coords;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);\r\n        } if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'LineString') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingLength(coords[i]);\r\n            }\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                for (j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    out += gmxAPIutils.getRingLength(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getRingLength: function(coords) {\r\n        var length = 0;\r\n        if (coords && coords.length) {\r\n            var lng = false, lat = false;\r\n            coords.forEach(function(lnglat) {\r\n                if (L.Util.isArray(lnglat)) {\r\n                    if (lnglat.length > 2) {\r\n                        length += gmxAPIutils.getRingLength(lnglat);\r\n                        return length;\r\n                    }\r\n                }\r\n                if (lng !== false && lat !== false) {\r\n                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));\r\n                }\r\n                lng = lnglat[0];\r\n                lat = lnglat[1];\r\n            });\r\n        }\r\n        return length;\r\n    },\r\n\r\n    /** Get geoJSON area\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geojson - object in <a href=\"http://geojson.org/geojson-spec.html\">GeoJSON format</a>\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoJSONGetArea: function(geoJSON) {\r\n        var out = 0;\r\n\r\n        if (geoJSON.type === 'GeometryCollection') {\r\n            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);\r\n        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {\r\n            var coords = geoJSON.coordinates;\r\n            if (geoJSON.type === 'Polygon') { coords = [coords]; }\r\n            for (var i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.getRingArea(coords[i][0]);\r\n                for (var j = 1, len1 = coords[i].length; j < len1; j++) {\r\n                    out -= gmxAPIutils.getRingArea(coords[i][j]);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    geoJSONGetLatLng: function(geoJSON) {\r\n        if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);\r\n        } else if (geoJSON.type === 'Point') {\r\n            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);\r\n        } else {\r\n            throw new Error('cannot get ' + geoJSON.type + ' latLng');\r\n        }\r\n    },\r\n\r\n    getRingArea: function(coords) {\r\n        var area = 0;\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = coords[i], p2 = coords[ipp];\r\n            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));\r\n        }\r\n        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n        return out;\r\n    },\r\n\r\n    /** Get area\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} L.latLng array\r\n     * @return {Number} area in square meters\r\n    */\r\n    getArea: function(arr) {\r\n        var area = 0;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var ipp = (i === (len - 1) ? 0 : i + 1),\r\n                p1 = arr[i], p2 = arr[ipp];\r\n            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));\r\n        }\r\n        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);\r\n    },\r\n\r\n    /** Get prettified size of area\r\n     * @memberof L.gmxUtil\r\n     * @param {Number} area in square meters\r\n     * @param {String} type: ('km2', 'ha', 'm2')\r\n     * @return {String} prettified area\r\n    */\r\n    prettifyArea: function(area, type) {\r\n        var km2 = ' ' + L.gmxLocale.getText('units.km2');\r\n\r\n        if (type === 'km2') {\r\n            return ('' + (Math.round(area / 100) / 10000)) + km2;\r\n        } else if (type === 'ha') {\r\n            return ('' + (Math.round(area / 100) / 100)) + ' ' + L.gmxLocale.getText('units.ha');\r\n        } else if (area < 100000 || type === 'm2') {\r\n            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');\r\n        } else if (area < 3000000) {\r\n            return ('' + (Math.round(area / 1000) / 1000)).replace('.', ',') + km2;\r\n        } else if (area < 30000000) {\r\n            return ('' + (Math.round(area / 10000) / 100)).replace('.', ',') + km2;\r\n        } else if (area < 300000000) {\r\n            return ('' + (Math.round(area / 100000) / 10)).replace('.', ',') + km2;\r\n        }\r\n        return (Math.round(area / 1000000)) + km2;\r\n    },\r\n\r\n    geoLength: function(geom) {\r\n        var ret = 0,\r\n            type = geom.type;\r\n        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            for (var i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoLength({type: 'LINESTRING', coordinates: geom.coordinates[i]});\r\n            }\r\n            return ret;\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            ret = gmxAPIutils.getLength(geom.coordinates);\r\n        }\r\n        return ret;\r\n    },\r\n\r\n    /** Converts Geomixer geometry to geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - Geomixer geometry\r\n     * @param {Boolean} mercFlag - true if coordinates in Mercator\r\n     * @return {Object} geoJSON geometry\r\n    */\r\n    geometryToGeoJSON: function (geom, mercFlag) {\r\n        if (!geom) {\r\n            return null;\r\n        }\r\n\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    convertGeometry: function (geom, fromMerc) {\r\n        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'\r\n                : geom.type === 'POLYGON' ? 'Polygon'\r\n                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'\r\n                : geom.type === 'LINESTRING' ? 'LineString'\r\n                : geom.type === 'MULTIPOINT' ? 'MultiPoint'\r\n                : geom.type === 'POINT' ? 'Point'\r\n                : geom.type,\r\n            coords = geom.coordinates;\r\n        if (fromMerc) {\r\n            coords = gmxAPIutils.coordsFromMercator(type, coords);\r\n        } else {\r\n            coords = gmxAPIutils.coordsToMercator(type, coords);\r\n        }\r\n        return {\r\n            type: geom.type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    /** Converts GeoJSON object into GeoMixer format\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry - GeoJSON object\r\n     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection\r\n     * @return {Object} Geometry in GeoMixer format\r\n    */\r\n    geoJSONtoGeometry: function (geoJSON, mercFlag) {\r\n        if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        } else if (geoJSON.type === 'Feature') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);\r\n        } else if (geoJSON.type === 'FeatureCollection') {\r\n            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);\r\n        }\r\n\r\n        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON'\r\n                : geoJSON.type === 'Polygon' ? 'POLYGON'\r\n                : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING'\r\n                : geoJSON.type === 'LineString' ? 'LINESTRING'\r\n                : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT'\r\n                : geoJSON.type === 'Point' ? 'POINT'\r\n                : geoJSON.type,\r\n            coords = geoJSON.coordinates;\r\n        if (mercFlag) {\r\n            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);\r\n        }\r\n        return {\r\n            type: type,\r\n            coordinates: coords\r\n        };\r\n    },\r\n\r\n    _coordsConvert: function(type, coords, toMerc) {\r\n        var i, len, p,\r\n            resCoords = [];\r\n        if (type === 'Point') {\r\n            if (toMerc) {\r\n                p = L.Projection.Mercator.project({lat: coords[1], lng: coords[0]});\r\n                resCoords = [p.x, p.y];\r\n            } else {\r\n                p = L.Projection.Mercator.unproject({y: coords[1], x: coords[0]});\r\n                resCoords = [p.lng, p.lat];\r\n            }\r\n        } else if (type === 'LineString' || type === 'MultiPoint') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'Polygon' || type === 'MultiLineString') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc));\r\n            }\r\n        } else if (type === 'MultiPolygon') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc));\r\n            }\r\n        }\r\n        return resCoords;\r\n    },\r\n\r\n    coordsFromMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, false);\r\n    },\r\n\r\n    coordsToMercator: function(type, coords) {\r\n        return gmxAPIutils._coordsConvert(type, coords, true);\r\n    },\r\n\r\n    transformGeometry: function(geom, callback) {\r\n        return !geom ? geom : {\r\n            type: geom.type,\r\n            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function(p) {\r\n                return callback(p);\r\n            })\r\n        };\r\n    },\r\n\r\n    /** Get area for geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geometry\r\n     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator\r\n     * @return {Number} area in square meters\r\n    */\r\n    geoArea: function(geom, isMerc) {\r\n        var i, len, ret = 0,\r\n            type = geom.type || '';\r\n        isMerc = isMerc === undefined || isMerc;\r\n        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {\r\n            for (i = 0, len = geom.coordinates.length; i < len; i++) {\r\n                ret += gmxAPIutils.geoArea({type: 'POLYGON', coordinates: geom.coordinates[i]}, isMerc);\r\n            }\r\n            return ret;\r\n        } else if (type === 'POLYGON' || type === 'Polygon') {\r\n            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);\r\n            for (i = 1, len = geom.coordinates.length; i < len; i++) {\r\n                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);\r\n            }\r\n            return ret;\r\n        } else if (geom.length) {\r\n            var latlngs = [],\r\n                vectorSize = typeof geom[0] === 'number' ? 2 : 1;\r\n\r\n            for (i = 0, len = geom.length; i < len; i += vectorSize) {\r\n                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];\r\n                latlngs.push(\r\n                    isMerc ?\r\n                    L.Projection.Mercator.unproject({y: p[1], x: p[0]}) :\r\n                    {lat: p[1], lng: p[0]}\r\n                );\r\n            }\r\n            return gmxAPIutils.getArea(latlngs);\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    /** Get summary for geoJSON geometry\r\n     * @memberof L.gmxUtil\r\n     * @param {Object} geoJSON geometry\r\n     * @param {Object} unitOptions {\r\n     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default\r\n     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default\r\n     *               }\r\n     * @return {String} Summary string for geometry\r\n    */\r\n    getGeoJSONSummary: function(geom, unitOptions) {\r\n        var type = geom.type,\r\n            units = unitOptions || {},\r\n            out = 0,\r\n            i, len, coords;\r\n        if (type === 'Point') {\r\n            coords = geom.coordinates;\r\n            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);\r\n        } else if (type === 'Polygon') {\r\n            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);\r\n        } else if (type === 'MultiPolygon') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoArea({type: 'Polygon', coordinates: coords[i]}, false);\r\n            }\r\n            out = gmxAPIutils.prettifyArea(out, units.squareUnit);\r\n        } else if (type === 'LineString') {\r\n            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);\r\n        } else if (type === 'MultiLineString') {\r\n            coords = geom.coordinates;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                out += gmxAPIutils.geoJSONGetLength({type: 'LineString', coordinates: coords[i]});\r\n            }\r\n            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for point\r\n     * @memberof L.gmxUtil\r\n     * @param {latlng} point\r\n     * @param {num} format number:\r\n     *         0: 6252'30.68\" N, 2248'27.42\" E\r\n     *         1: 62.875188 N, 22.807617 E\r\n     *         2: 2538932, 9031643 (EPSG:3395)\r\n     *         3: 2538932, 9069712 (EPSG:3857)\r\n     * @return {String} Summary string for LatLng point\r\n    */\r\n    getCoordinatesString: function(latlng, num) {\r\n        var x = latlng.lng,\r\n            y = latlng.lat,\r\n            formats = [\r\n                '',\r\n                '',\r\n                ' (EPSG:3395)',\r\n                ' (EPSG:3857)'\r\n            ],\r\n            len = formats.length,\r\n            merc,\r\n            out = '';\r\n        num = num || 0;\r\n        if (x > 180) { x -= 360; }\r\n        if (x < -180) { x += 360; }\r\n        if (num % len === 0) {\r\n            out = gmxAPIutils.formatCoordinates2(x, y);\r\n        } else if (num % len === 1) {\r\n            out = gmxAPIutils.formatCoordinates(x, y);\r\n        } else if (num % len === 2) {\r\n            merc = L.Projection.Mercator.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];\r\n        } else {\r\n            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));\r\n            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    /** Get summary for geometries array\r\n     * @memberof L.gmxUtil\r\n     * @param {Array} geometries array in Geomixer format\r\n     * @param {Object} units Options for length and area\r\n     * @return {String} Summary string for geometries array\r\n    */\r\n    getGeometriesSummary: function(arr, unitOptions) {\r\n        var out = '',\r\n            type = '',\r\n            res = 0;\r\n        if (!unitOptions) { unitOptions = {}; }\r\n        if (arr) {\r\n            arr.forEach(function(geom) {\r\n                if (geom) {\r\n                    type = geom.type.toUpperCase();\r\n                    if (type.indexOf('POINT') !== -1) {\r\n                        var latlng = L.Projection.Mercator.unproject({y: geom.coordinates[1], x: geom.coordinates[0]});\r\n                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: '\r\n                            + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);\r\n                    } else if (type.indexOf('LINESTRING') !== -1) {\r\n                        res += gmxAPIutils.geoLength(geom);\r\n                    } else if (type.indexOf('POLYGON') !== -1) {\r\n                        res += gmxAPIutils.geoArea(geom);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (!out) {\r\n            if (type.indexOf('LINESTRING') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: '\r\n                    + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);\r\n            } else if (type.indexOf('POLYGON') !== -1) {\r\n                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: '\r\n                    + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getGeometrySummary: function(geom, unitOptions) {\r\n        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});\r\n    },\r\n\r\n    chkOnEdge: function(p1, p2, ext) { //   \r\n        if ((p1[0] < ext.min.x && p2[0] < ext.min.x) || (p1[0] > ext.max.x && p2[0] > ext.max.x)) { return true; }\r\n        if ((p1[1] < ext.min.y && p2[1] < ext.min.y) || (p1[1] > ext.max.y && p2[1] > ext.max.y)) { return true; }\r\n        return false;\r\n    },\r\n\r\n    getHidden: function(coords, tb) {  //     \r\n        var hiddenLines = [],\r\n            vectorSize = typeof coords[0] === 'number' ? 2 : 1,\r\n            prev = null;\r\n        for (var i = 0, len = coords.length; i < len; i += vectorSize) {\r\n            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];\r\n            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {\r\n                hiddenLines.push(i);\r\n            }\r\n            prev = p;\r\n        }\r\n        return hiddenLines;\r\n    },\r\n\r\n    getNormalizeBounds: function (screenBounds, mercDeltaY) { // get bounds array from -180 180 lng\r\n        var northWest = screenBounds.getNorthWest(),\r\n            southEast = screenBounds.getSouthEast(),\r\n            minX = northWest.lng,\r\n            maxX = southEast.lng,\r\n            w = (maxX - minX) / 2,\r\n            minX1 = null,\r\n            maxX1 = null,\r\n            out = [];\r\n\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = {x: minX, y: southEast.lat},\r\n            m2 = {x: maxX, y: northWest.lat};\r\n\r\n        if (mercDeltaY !== undefined) {\r\n            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));\r\n            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));\r\n            m1.y -= mercDeltaY;\r\n            m2.y -= mercDeltaY;\r\n        }\r\n        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));\r\n\r\n        if (minX1) {\r\n            var m11 = {x: minX1, y: southEast.lat},\r\n                m12 = {x: maxX1, y: northWest.lat};\r\n            if (mercDeltaY !== undefined) {\r\n                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));\r\n                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));\r\n                m11.y -= mercDeltaY;\r\n                m12.y -= mercDeltaY;\r\n            }\r\n            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));\r\n        }\r\n        return out;\r\n    },\r\n\r\n    toPrecision: function(x, prec) {\r\n        var zn = Math.pow(10, prec ? prec : 4);\r\n        return Math.round(zn * x) / zn;\r\n    },\r\n\r\n    getTileBounds: function(x, y, z) {  //x, y, z - GeoMixer tile coordinates\r\n        var tileSize = gmxAPIutils.tileSizes[z],\r\n            minx = x * tileSize,\r\n            miny = y * tileSize;\r\n        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);\r\n    },\r\n\r\n    parseTemplate: function(str, properties) {\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = key in properties ? properties[key] : '';\r\n\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    getDefaultBalloonTemplate: function(properties, tileAttributeTypes) {\r\n        var str = '';\r\n        for (var key in properties) {\r\n            if (!tileAttributeTypes || (key in tileAttributeTypes)) {\r\n\t\t\t\tstr += '<b>' + key + ':</b> [' +  key + ']<br />';\r\n\t\t\t}\r\n        }\r\n        str += '<br />[SUMMARY]<br />';\r\n        return str;\r\n    },\r\n\r\n    parseBalloonTemplate: function(str, options) {\r\n        var properties = options.properties;\r\n\r\n        if (!str) {\r\n            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);\r\n        }\r\n        var matches = str.match(/\\[([^\\]]+)\\]/ig);\r\n        if (matches) {\r\n            var tileAttributeTypes = options.tileAttributeTypes,\r\n                unitOptions = options.unitOptions,\r\n                geometries = options.geometries;\r\n            for (var i = 0, len = matches.length; i < len; i++) {\r\n                var key1 = matches[i],\r\n                    key = key1.substr(1, key1.length - 2),\r\n                    res = '';\r\n\r\n                if (key in properties) {\r\n                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);\r\n                } else if (key === 'SUMMARY') {\r\n                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                str = str.replace(key1, res);\r\n            }\r\n        }\r\n        return str;\r\n    },\r\n\r\n    styleKeys: {\r\n        marker: {\r\n            server: ['image',   'angle',     'scale',     'minScale',     'maxScale',     'size',         'circle',     'center',     'color'],\r\n            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']\r\n        },\r\n        outline: {\r\n            server: ['color',  'opacity',   'thickness', 'dashes'],\r\n            client: ['color',  'opacity',   'weight',    'dashArray']\r\n        },\r\n        fill: {\r\n            server: ['color',     'opacity',   'image',       'pattern',     'radialGradient',     'linearGradient'],\r\n            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']\r\n        },\r\n        label: {\r\n            server: ['text',      'field',      'template',      'color',      'haloColor',      'size',          'spacing',      'align'],\r\n            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']\r\n        }\r\n    },\r\n    styleFuncKeys: {\r\n        iconSize: 'iconSizeFunction',\r\n        iconAngle: 'rotateFunction',\r\n        iconScale: 'scaleFunction',\r\n        iconColor: 'iconColorFunction',\r\n        opacity: 'opacityFunction',\r\n        fillOpacity: 'fillOpacityFunction',\r\n        color: 'colorFunction',\r\n        fillColor: 'fillColorFunction'\r\n    },\r\n    styleFuncError: {\r\n        iconSize: function() { return 8; },\r\n        iconAngle: function() { return 0; },\r\n        iconScale: function() { return 1; },\r\n        iconColor: function() { return 0xFF; },\r\n        opacity: function() { return 1; },\r\n        fillOpacity: function() { return 0.5; },\r\n        color: function() { return 0xFF; },\r\n        fillColor: function() { return 0xFF; }\r\n    },\r\n    defaultStyles: {\r\n       MinZoom: 1,\r\n       MaxZoom: 21,\r\n       Filter: '',\r\n       Balloon: '',\r\n       DisableBalloonOnMouseMove: true,\r\n       DisableBalloonOnClick: false,\r\n       RenderStyle: {\r\n            point: {    // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},\r\n                color: 0xFF,\r\n                weight: 1,\r\n                iconSize: 8\r\n            },\r\n            linestring: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            },\r\n            polygon: {    // old = {outline: {color: 255, thickness: 1}},\r\n                color: 0xFF,\r\n                weight: 1\r\n            }\r\n        }\r\n    },\r\n\r\n    getDefaultStyle: function(type) {\r\n        var from = gmxAPIutils.defaultStyles,\r\n            out = L.extend({}, from);\r\n        out.RenderStyle = from.RenderStyle[type];\r\n        return out;\r\n    },\r\n\r\n    toServerStyle: function(style) {   // Style leaflet->Scanex\r\n        var out = {};\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (var i = 0, len = keys.client.length; i < len; i++) {\r\n                var key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    if (!out[key]) { out[key] = {}; }\r\n                    var zn = style[key1];\r\n                    if (key1 === 'opacity' || key1 === 'fillOpacity') {\r\n                        zn *= 100;\r\n                    }\r\n                    out[key][keys.server[i]] = zn;\r\n                }\r\n            }\r\n        }\r\n        if ('iconAnchor' in style) {\r\n            if (!out.marker) { out.marker = {}; }\r\n            out.marker.dx = -style.iconAnchor[0];\r\n            out.marker.dy = -style.iconAnchor[1];\r\n        }\r\n        return out;\r\n    },\r\n\r\n    fromServerStyle: function(style) {   // Style Scanex->leaflet\r\n        var st, i, len, key1,\r\n            out = {\r\n                type: ''    // 'polygon', 'line', 'circle', 'square', 'image'\r\n            };\r\n\r\n        for (var key in gmxAPIutils.styleKeys) {\r\n            var keys = gmxAPIutils.styleKeys[key];\r\n            for (i = 0, len = keys.client.length; i < len; i++) {\r\n                key1 = keys.client[i];\r\n                if (key1 in style) {\r\n                    out[key1] = style[key1];\r\n                }\r\n            }\r\n            st = style[key];\r\n            if (st && typeof (st) === 'object') {\r\n                for (i = 0, len = keys.server.length; i < len; i++) {\r\n                    key1 = keys.server[i];\r\n                    if (key1 in st) {\r\n                        var newKey = keys.client[i],\r\n                            zn = st[key1];\r\n                        if (typeof (zn) === 'string') {\r\n                            if (gmxAPIutils.styleFuncKeys[newKey]) {\r\n                                if (zn.match(/[^\\d\\.]/) === null) {\r\n                                    zn = Number(zn);\r\n                                } else {\r\n                                    var func = L.gmx.Parsers.parseExpression(zn);\r\n                                    if (func === null) {\r\n                                        zn = gmxAPIutils.styleFuncError[newKey]();\r\n                                    } else {\r\n                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else if (key1 === 'opacity') {\r\n                            zn /= 100;\r\n                        }\r\n                        out[newKey] = zn;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (style.marker) {\r\n            st = style.marker;\r\n            if ('dx' in st || 'dy' in st) {\r\n                var dx = st.dx || 0,\r\n                    dy = st.dy || 0;\r\n                out.iconAnchor = [-dx, -dy];    // For leaflet type iconAnchor\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getUnixTimeFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\treturn Date.UTC(arr[0], arr[1] - 1, arr[2]) / 1000;\r\n    },\r\n\r\n    getDateFromStr: function(st) {\r\n\t\tvar arr = L.Util.trim(st).split(' ');\r\n\t\tarr = arr[0].split('.');\r\n\r\n        if (arr[2].length === 4) {\r\n\t\t\tarr = arr.reverse();\r\n\t\t}\r\n\t\tvar dt = new Date(arr[0], arr[1] - 1, arr[2]);\r\n        return dt;\r\n    },\r\n\r\n    getUTCdate: function(utime) {\r\n        var dt = new Date(utime * 1000);\r\n\r\n        return [\r\n            dt.getUTCFullYear(),\r\n            gmxAPIutils.pad2(dt.getUTCMonth() + 1),\r\n            gmxAPIutils.pad2(dt.getUTCDate())\r\n        ].join('.');\r\n    },\r\n\r\n    getUTCtime: function(utime) {\r\n        var h = Math.floor(utime / 3600),\r\n            m = Math.floor((utime - h * 3600) / 60),\r\n            s = Math.floor(utime - h * 3600 - m * 60);\r\n\r\n        return [\r\n            //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),\r\n            gmxAPIutils.pad2(h),\r\n            gmxAPIutils.pad2(m),\r\n            gmxAPIutils.pad2(s)\r\n        ].join(':');\r\n    },\r\n\r\n    getUTCdateTime: function(utime) {\r\n        var time = utime % (3600 * 24);\r\n\r\n        if (time) {\r\n            return [\r\n                gmxAPIutils.getUTCdate(utime),\r\n                gmxAPIutils.getUTCtime(utime % (3600 * 24))\r\n            ].join(' ');\r\n        } else {\r\n            return gmxAPIutils.getUTCdate(utime);\r\n        }\r\n    },\r\n\r\n    attrToString: function(type, value) {\r\n        if (type === 'date') {\r\n            return value ? L.gmxUtil.getUTCdate(value) : value;\r\n        } else if (type === 'time') {\r\n            return value ? L.gmxUtil.getUTCtime(value) : value;\r\n        } else if (type === 'datetime') {\r\n            return value ? L.gmxUtil.getUTCdateTime(value) : value;\r\n        } else {\r\n            return value;\r\n        }\r\n    },\r\n\r\n    getTileAttributes: function(prop) {\r\n        var tileAttributeIndexes = {},\r\n            tileAttributeTypes = {};\r\n        if (prop.attributes) {\r\n            var attrs = prop.attributes,\r\n                attrTypes = prop.attrTypes || null;\r\n            if (prop.identityField) { tileAttributeIndexes[prop.identityField] = 0; }\r\n            for (var a = 0; a < attrs.length; a++) {\r\n                var key = attrs[a];\r\n                tileAttributeIndexes[key] = a + 1;\r\n                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';\r\n            }\r\n        }\r\n        return {\r\n            tileAttributeTypes: tileAttributeTypes,\r\n            tileAttributeIndexes: tileAttributeIndexes\r\n        };\r\n    }\r\n};\r\n\r\ngmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0);\t\t\t\t// 111319.5;\r\ngmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI;\t// 6335440.712613423;\r\n\r\n(function() {\r\n    //pre-calculate tile sizes\r\n    for (var z = 0; z < 30; z++) {\r\n        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);\r\n    }\r\n})();\r\n\r\ngmxAPIutils.Bounds = function(arr) {\r\n    this.min = {\r\n        x: Number.MAX_VALUE,\r\n        y: Number.MAX_VALUE\r\n    };\r\n    this.max = {\r\n        x: -Number.MAX_VALUE,\r\n        y: -Number.MAX_VALUE\r\n    };\r\n    this.extendArray(arr);\r\n};\r\ngmxAPIutils.Bounds.prototype = {\r\n    extend: function(x, y) {\r\n        if (x < this.min.x) { this.min.x = x; }\r\n        if (x > this.max.x) { this.max.x = x; }\r\n        if (y < this.min.y) { this.min.y = y; }\r\n        if (y > this.max.y) { this.max.y = y; }\r\n        return this;\r\n    },\r\n    extendBounds: function(bounds) {\r\n        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);\r\n    },\r\n    extendArray: function(arr) {\r\n        if (!arr || !arr.length) { return this; }\r\n        var i, len;\r\n        if (typeof arr[0] === 'number') {\r\n            for (i = 0, len = arr.length; i < len; i += 2) {\r\n                this.extend(arr[i], arr[i + 1]);\r\n            }\r\n        } else {\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                this.extend(arr[i][0], arr[i][1]);\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n    addBuffer: function(dxmin, dymin, dxmax, dymax) {\r\n        this.min.x -= dxmin;\r\n        this.min.y -= dymin || dxmin;\r\n        this.max.x += dxmax || dxmin;\r\n        this.max.y += dymax || dymin || dxmin;\r\n        return this;\r\n    },\r\n    contains: function (point) { // ([x, y]) -> Boolean\r\n        var min = this.min, max = this.max,\r\n            x = point[0], y = point[1];\r\n        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;\r\n    },\r\n    getCenter: function () {\r\n        var min = this.min, max = this.max;\r\n        return [(min.x + max.x) / 2, (min.y + max.y) / 2];\r\n    },\r\n    addOffset: function (offset) {\r\n        this.min.x += offset[0]; this.max.x += offset[0];\r\n        this.min.y += offset[1]; this.max.y += offset[1];\r\n        return this;\r\n    },\r\n    intersects: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;\r\n    },\r\n    intersectsWithDelta: function (bounds, dx, dy) { // (Bounds, dx, dy) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            x = dx || 0,\r\n            y = dy || 0,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;\r\n    },\r\n    isEqual: function (bounds) { // (Bounds) -> Boolean\r\n        var min = this.min,\r\n            max = this.max,\r\n            min2 = bounds.min,\r\n            max2 = bounds.max;\r\n        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;\r\n    },\r\n    isNodeIntersect: function (coords) {\r\n        for (var i = 0, len = coords.length; i < len; i++) {\r\n            if (this.contains(coords[i])) {\r\n                return {\r\n                    num: i,\r\n                    point: coords[i]\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n    clipPolygon: function (coords) { // (coords) -> clip coords\r\n        var min = this.min,\r\n            max = this.max,\r\n            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],\r\n            cp1, cp2, s, e,\r\n            inside = function (p) {\r\n                return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);\r\n            },\r\n            intersection = function () {\r\n                var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\r\n                    dp = [s[0] - e[0], s[1] - e[1]],\r\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\r\n                    n2 = s[0] * e[1] - s[1] * e[0],\r\n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\r\n                return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\r\n            };\r\n\r\n        var outputList = coords;\r\n        cp1 = clip[3];\r\n        for (var j = 0; j < 4; j++) {\r\n            cp2 = clip[j];\r\n            var inputList = outputList,\r\n                len = inputList.length;\r\n            outputList = [];\r\n            s = inputList[len - 1]; //last on the input list\r\n            for (var i = 0; i < len; i++) {\r\n                e = inputList[i];\r\n                if (inside(e)) {\r\n                    if (!inside(s)) { outputList.push(intersection()); }\r\n                    outputList.push(e);\r\n                } else if (inside(s)) {\r\n                    outputList.push(intersection());\r\n                }\r\n                s = e;\r\n            }\r\n            cp1 = cp2;\r\n        }\r\n        return outputList;\r\n    },\r\n    clipPolyLine: function (coords, angleFlag, delta) { // (coords) -> clip coords\r\n        delta = delta || 0;\r\n        var min = this.min,\r\n            max = this.max,\r\n            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],\r\n            bitCode = function (p) {\r\n                var code = 0;\r\n\r\n                if (p[0] < bbox[0]) code |= 1; // left\r\n                else if (p[0] > bbox[2]) code |= 2; // right\r\n\r\n                if (p[1] < bbox[1]) code |= 4; // bottom\r\n                else if (p[1] > bbox[3]) code |= 8; // top\r\n\r\n                return code;\r\n            },\r\n            getAngle = function (a, b) {\r\n                return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);\r\n            },\r\n            intersect = function (a, b, edge) {\r\n                return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\r\n                       edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\r\n                       edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\r\n                       edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\r\n                       null;\r\n            },\r\n            result = [],\r\n            len = coords.length,\r\n            codeA = bitCode(coords[0], bbox),\r\n            part = [],\r\n            i, a, b, c, codeB, lastCode;\r\n\r\n        for (i = 1; i < len; i++) {\r\n            a = coords[i - 1];\r\n            b = coords[i];\r\n            if (a[0] === b[0] && a[1] === b[1]) { continue; }\r\n            codeB = lastCode = bitCode(b, bbox);\r\n\r\n            while (true) {\r\n\r\n                if (!(codeA | codeB)) { // accept\r\n                    if (angleFlag) {\r\n                        a[2] = getAngle(a, b);\r\n                        c = coords[i + 1];\r\n                        b[2] = c ? getAngle(b, c) : a[2];\r\n                    }\r\n                    part.push(a);\r\n\r\n                    if (codeB !== lastCode) { // segment went outside\r\n                        part.push(b);\r\n\r\n                        if (i < len - 1) { // start a new line\r\n                            result.push(part);\r\n                            part = [];\r\n                        }\r\n                    } else if (i === len - 1) {\r\n                        part.push(b);\r\n                    }\r\n                    break;\r\n\r\n                } else if (codeA & codeB) { // trivial reject\r\n                    break;\r\n\r\n                } else if (codeA) { // a outside, intersect with clip edge\r\n                    a = intersect(a, b, codeA, bbox);\r\n                    codeA = bitCode(a, bbox);\r\n\r\n                } else { // b outside\r\n                    b = intersect(a, b, codeB, bbox);\r\n                    codeB = bitCode(b, bbox);\r\n                }\r\n            }\r\n\r\n            codeA = lastCode;\r\n        }\r\n\r\n        if (part.length) result.push(part);\r\n\r\n        return result;\r\n    }\r\n};\r\n\r\ngmxAPIutils.bounds = function(arr) {\r\n    return new gmxAPIutils.Bounds(arr);\r\n};\r\n\r\n//  API     \r\ngmxAPIutils.parseUri = function (str) {\r\n    var\to   = gmxAPIutils.parseUri.options,\r\n        m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),\r\n        uri = {},\r\n        i   = 14;\r\n\r\n    while (i--) {\r\n        uri[o.key[i]] = m[i] || '';\r\n    }\r\n\r\n    uri[o.q.name] = {};\r\n    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n        if ($1) { uri[o.q.name][$1] = $2; }\r\n    });\r\n\r\n    uri.hostOnly = uri.host;\r\n    uri.host = uri.authority; // HACK\r\n\r\n    return uri;\r\n};\r\n\r\ngmxAPIutils.parseUri.options = {\r\n    strictMode: false,\r\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\r\n    q:   {\r\n        name:   'queryKey',\r\n        parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n    },\r\n    parser: {\r\n        strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n        loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n    }\r\n};\r\n\r\nif (!L.gmxUtil) { L.gmxUtil = {}; }\r\n\r\n//public interface\r\nL.extend(L.gmxUtil, {\r\n    newId: gmxAPIutils.newId,\r\n    loaderStatus: function () {},\r\n    isIE9: gmxAPIutils.isIE(9),\r\n    isIE10: gmxAPIutils.isIE(10),\r\n    isIE11: gmxAPIutils.isIE(11),\r\n    gtIE11: gmxAPIutils.gtIE(11),\r\n    getFormData: gmxAPIutils.getFormData,\r\n    requestJSONP: gmxAPIutils.requestJSONP,\r\n    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,\r\n    request: gmxAPIutils.request,\r\n    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,\r\n    fromServerStyle: gmxAPIutils.fromServerStyle,\r\n    toServerStyle: gmxAPIutils.toServerStyle,\r\n    getDefaultStyle: gmxAPIutils.getDefaultStyle,\r\n    bounds: gmxAPIutils.bounds,\r\n    getGeometryBounds: gmxAPIutils.getGeometryBounds,\r\n    tileSizes: gmxAPIutils.tileSizes,\r\n    getDateFromStr: gmxAPIutils.getDateFromStr,\r\n    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,\r\n    getUTCdate: gmxAPIutils.getUTCdate,\r\n    getUTCtime: gmxAPIutils.getUTCtime,\r\n    getUTCdateTime: gmxAPIutils.getUTCdateTime,\r\n    attrToString: gmxAPIutils.attrToString,\r\n    getTileAttributes: gmxAPIutils.getTileAttributes,\r\n    formatCoordinates: function (latlng, type) {\r\n        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);\r\n    },\r\n    formatDegrees: gmxAPIutils.formatDegrees,\r\n    pad2: gmxAPIutils.pad2,\r\n    dec2hex: gmxAPIutils.dec2hex,\r\n\tdec2rgba: gmxAPIutils.dec2rgba,\r\n    trunc: gmxAPIutils.trunc,\r\n    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,\r\n    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,\r\n    getLength: gmxAPIutils.getLength,\r\n    geoLength: gmxAPIutils.geoLength,\r\n    prettifyDistance: gmxAPIutils.prettifyDistance,\r\n    getArea: gmxAPIutils.getArea,\r\n    prettifyArea: gmxAPIutils.prettifyArea,\r\n    geoArea: gmxAPIutils.geoArea,\r\n    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,\r\n    getSVGIcon: gmxAPIutils.getSVGIcon,\r\n    getCoordinatesString: gmxAPIutils.getCoordinatesString,\r\n    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,\r\n    getGeometrySummary: gmxAPIutils.getGeometrySummary,\r\n    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,\r\n    getPropertiesHash: gmxAPIutils.getPropertiesHash,\r\n    distVincenty: gmxAPIutils.distVincenty,\r\n    parseCoordinates: gmxAPIutils.parseCoordinates,\r\n    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,\r\n    convertGeometry: gmxAPIutils.convertGeometry,\r\n    transformGeometry: gmxAPIutils.transformGeometry,\r\n    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,\r\n    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,\r\n    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,\r\n    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,\r\n    parseUri: gmxAPIutils.parseUri,\r\n    isRectangle: gmxAPIutils.isRectangle,\r\n    isClockwise: gmxAPIutils.isClockwise,\r\n    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,\r\n    getPatternIcon: gmxAPIutils.getPatternIcon,\r\n    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,\r\n    normalizeHostname: gmxAPIutils.normalizeHostname,\r\n    getTileBounds: gmxAPIutils.getTileBounds,\r\n    parseTemplate: gmxAPIutils.parseTemplate\r\n});\r\n\r\n(function() {\r\n    var requests = {};\r\n    var lastRequestId = 0;\r\n\r\n    var processMessage = function(e) {\r\n\r\n        if (!(e.origin in requests)) {\r\n            return;\r\n        }\r\n\r\n        var dataStr = decodeURIComponent(e.data.replace(/\\n/g, '\\n\\\\'));\r\n        try {\r\n            var dataObj = JSON.parse(dataStr);\r\n        } catch (ev) {\r\n            console.log({Status:'error', ErrorInfo: {ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr}});\r\n        }\r\n        var request = requests[e.origin][dataObj.CallbackName];\r\n        if (!request) {\r\n            return;    // message   \r\n        }\r\n\r\n        delete requests[e.origin][dataObj.CallbackName];\r\n        delete dataObj.CallbackName;\r\n\r\n        if (request.iframe.parentNode) {\r\n            request.iframe.parentNode.removeChild(request.iframe);\r\n        }\r\n        if ('callback' in request) { request.callback(dataObj); }\r\n    };\r\n\r\n    L.DomEvent.on(window, 'message', processMessage);\r\n\r\n    function createPostIframe2(id, callback, url) {\r\n        var uniqueId = 'gmxAPIutils_id' + (lastRequestId++),\r\n            iframe = L.DomUtil.create('iframe');\r\n\r\n        iframe.style.display = 'none';\r\n        iframe.setAttribute('id', id);\r\n        iframe.setAttribute('name', id);    /*eslint-disable no-script-url */\r\n        iframe.src = 'javascript:true';     /*eslint-enable */\r\n        iframe.callbackName = uniqueId;\r\n\r\n        var parsedURL = gmxAPIutils.parseUri(url);\r\n        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);\r\n\r\n        requests[origin] = requests[origin] || {};\r\n        requests[origin][uniqueId] = {callback: callback, iframe: iframe};\r\n\r\n        return iframe;\r\n    }\r\n\r\n\t// namespace\r\n    gmxAPIutils.createPostIframe2 = createPostIframe2;\r\n\r\n})();\r\n\r\n//  POST \r\n(function()\r\n{\r\n\t/**   POST \r\n\t* @namespace L.gmxUtil\r\n    * @ignore\r\n\t* @function\r\n\t*\r\n\t* @param url {string} - URL \r\n\t* @param params {object} -  -\r\n\t* @param callback {function} - callback,       .   - -  \r\n\t* @param baseForm {DOMElement} -   . ,      .\r\n\t*                                     ,         .\r\n\t*/\r\n\tfunction sendCrossDomainPostRequest(url, params, callback, baseForm) {\r\n        var form,\r\n            id = '$$iframe_' + gmxAPIutils.newId();\r\n\r\n        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),\r\n            originalFormAction;\r\n\r\n        if (baseForm) {\r\n            form = baseForm;\r\n            originalFormAction = form.getAttribute('action');\r\n            form.setAttribute('action', url);\r\n            form.target = id;\r\n        } else if (L.Browser.ielt9) {\r\n            var str = '<form id=' + id + '\" enctype=\"multipart/form-data\" style=\"display:none\" target=\"' + id + '\" action=\"' + url + '\" method=\"post\"></form>';\r\n            form = document.createElement(str);\r\n        } else {\r\n            form = document.createElement('form');\r\n            form.style.display = 'none';\r\n            form.setAttribute('enctype', 'multipart/form-data');\r\n            form.target = id;\r\n            form.setAttribute('method', 'POST');\r\n            form.setAttribute('action', url);\r\n            form.id = id;\r\n        }\r\n\r\n        var hiddenParamsDiv = document.createElement('div');\r\n        hiddenParamsDiv.style.display = 'none';\r\n\r\n        if (params.WrapStyle === 'window') {\r\n            params.WrapStyle = 'message';\r\n        }\r\n\r\n        if (params.WrapStyle === 'message') {\r\n            params.CallbackName = iframe.callbackName;\r\n        }\r\n\r\n        for (var paramName in params) {\r\n            var input = document.createElement('input');\r\n            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';\r\n            input.setAttribute('type', 'hidden');\r\n            input.setAttribute('name', paramName);\r\n            input.setAttribute('value', value);\r\n            hiddenParamsDiv.appendChild(input);\r\n        }\r\n\r\n        form.appendChild(hiddenParamsDiv);\r\n\r\n        if (!baseForm) {\r\n            document.body.appendChild(form);\r\n        }\r\n        document.body.appendChild(iframe);\r\n\r\n        form.submit();\r\n\r\n        if (baseForm) {\r\n            form.removeChild(hiddenParamsDiv);\r\n            if (originalFormAction !== null) {\r\n                form.setAttribute('action', originalFormAction);\r\n            } else {\r\n                form.removeAttribute('action');\r\n            }\r\n        } else {\r\n            form.parentNode.removeChild(form);\r\n        }\r\n    }\r\n    // namespace\r\n    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;\r\n})();\r\nexport {gmxAPIutils};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Utils.js","import {gmxAPIutils as utils} from './Utils.js';\r\n\r\nvar styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],\r\n    styleCanvasKeysLen = styleCanvasKeys.length;\r\n\r\nvar setCanvasStyle = function(prop, indexes, ctx, style) {\r\n    for (var i = 0; i < styleCanvasKeysLen; i++) {\r\n        var key = styleCanvasKeys[i],\r\n            valKey = style[key];\r\n        if (valKey !== ctx[key]) {\r\n            ctx[key] = valKey;\r\n        }\r\n    }\r\n    if (style.dashArray) {\r\n        var dashes = style.dashArray,\r\n            dashOffset = style.dashOffset || 0;\r\n        if ('setLineDash' in ctx) {\r\n            ctx.setLineDash(dashes);\r\n            if (ctx.lineDashOffset !== dashOffset) {\r\n                ctx.lineDashOffset = dashOffset;\r\n            }\r\n        }\r\n    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {\r\n        ctx.setLineDash([]);\r\n    }\r\n    if (ctx.lineCap !== 'round') { ctx.lineCap = 'round'; }\r\n    if (ctx.lineJoin !== 'round') { ctx.lineJoin = 'round'; }\r\n\r\n    if (style.canvasPattern) {\r\n        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');\r\n    } else if (style.fillLinearGradient) {\r\n        var rgr = style.fillLinearGradient,\r\n            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,\r\n            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,\r\n            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,\r\n            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,\r\n            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);\r\n        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {\r\n            var arr1 = rgr.addColorStop[j],\r\n                arrFunc = rgr.addColorStopFunctions[j],\r\n                p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0]),\r\n                p2 = (arr1.length < 3 ? 100 : (arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2])),\r\n                p1 = utils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);\r\n            lineargrad.addColorStop(p0, p1);\r\n        }\r\n        ctx.fillStyle = style.fillStyle = lineargrad;\r\n    }\r\n};\r\n\r\n/*\r\ngeoItem\r\n     properties:  (   )\r\n     dataOption:   \r\nitem\r\n     skipRasters:  \r\n     currentStyle:  canvas  \r\n     parsedStyleKeys:   \r\noptions\r\n     ctx: canvas context\r\n     tbounds: tile bounds\r\n     tpx: X  \r\n     tpy: Y  \r\n     gmx:   layer._gmx\r\n        gmx.currentZoom\r\n        gmx.lastHover\r\n        gmx.tileAttributeIndexes\r\n     bgImage:   background\r\n     rasters:     background\r\ncurrentStyle\r\n     \r\nstyle\r\n       \r\n    style.image -  type='image' (`<HTMLCanvasElement || HTMLImageElement>`)\r\n*/\r\nL.gmxUtil.drawGeoItem = function(geoItem, item, options, currentStyle, style) {\r\n    var propsArr = geoItem.properties,\r\n        idr = propsArr[0],\r\n        i, len, j, len1,\r\n        gmx = options.gmx,\r\n        ctx = options.ctx,\r\n        geom = propsArr[propsArr.length - 1],\r\n        coords = null,\r\n        dataOption = geoItem.dataOption,\r\n        rasters = options.rasters || {},\r\n        tbounds = options.tbounds;\r\n\r\n    item.currentStyle = L.extend({}, currentStyle);\r\n    if (style) {\r\n        if (gmx.styleHook) {\r\n            if (!geoItem.styleExtend) {\r\n                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);\r\n            }\r\n            if (geoItem.styleExtend) {\r\n                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);\r\n    } else {\r\n        style = {};\r\n    }\r\n\r\n    var geoType = geom.type,\r\n        dattr = {\r\n            gmx: gmx,\r\n            item: item,\r\n            style: style,\r\n            styleExtend: geoItem.styleExtend || {},\r\n            ctx: ctx,\r\n            tpx: options.tpx,\r\n            tpy: options.tpy\r\n        };\r\n    if (geoType === 'POINT') {\r\n        dattr.pointAttr = utils.getPixelPoint(dattr, geom.coordinates);\r\n        if (!dattr.pointAttr) { return false; }   // point not in canvas tile\r\n    }\r\n    if (geoType === 'POINT' || geoType === 'MULTIPOINT') { //   \r\n        coords = geom.coordinates;\r\n        if ('iconColor' in style && style.image) {\r\n            if (style.lastImage !== style.image) {\r\n                style.lastImage = style.image;\r\n                style.lastImageData = utils.getImageData(style.image);\r\n            }\r\n            dattr.imageData = style.lastImageData;\r\n        }\r\n\r\n        if (geoType === 'MULTIPOINT') {\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                dattr.coords = coords[i];\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            dattr.coords = coords;\r\n            utils.pointToCanvas(dattr);\r\n        }\r\n    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {\r\n        if (style.image) { // set MULTIPOLYGON as marker\r\n            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];\r\n            dattr.pointAttr = utils.getPixelPoint(dattr, dattr.coords);\r\n            if (dattr.pointAttr) {\r\n                utils.pointToCanvas(dattr);\r\n            }\r\n        } else {\r\n            coords = geom.coordinates;\r\n            if (geoType === 'POLYGON') { coords = [coords]; }\r\n\r\n            var hiddenLines = dataOption.hiddenLines || [],\r\n                pixelsMap = dataOption.pixels,\r\n                flagPixels = true;\r\n\r\n            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {\r\n                pixelsMap = dataOption.pixels = utils.getCoordsPixels({\r\n                    gmx: gmx,\r\n                    coords: coords,\r\n                    tpx: options.tpx,\r\n                    tpy: options.tpy,\r\n                    hiddenLines: hiddenLines\r\n                });\r\n            }\r\n\r\n            var coordsToCanvas = function(func, flagFill) {\r\n                coords = pixelsMap.coords;\r\n                hiddenLines = pixelsMap.hidden || [];\r\n                dattr.flagPixels = flagPixels;\r\n                for (i = 0, len = coords.length; i < len; i++) {\r\n                    var coords1 = coords[i];\r\n                    var hiddenLines1 = hiddenLines[i] || [];\r\n                    ctx.beginPath();\r\n                    for (j = 0, len1 = coords1.length; j < len1; j++) {\r\n                        dattr.coords = coords1[j];\r\n                        dattr.hiddenLines = hiddenLines1[j] || [];\r\n                        func(dattr);\r\n                    }\r\n                    ctx.closePath();\r\n                    if (flagFill) { ctx.fill(); }\r\n                }\r\n            };\r\n            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,\r\n                lineWidth = item.currentStyle.lineWidth || style.lineWidth;\r\n            if (strokeStyle && lineWidth) {\r\n                coordsToCanvas(utils.polygonToCanvas);\r\n            }\r\n            if (options.bgImage) {\r\n                dattr.bgImage = options.bgImage;\r\n            } else if (rasters[idr]) {\r\n                dattr.bgImage = rasters[idr];\r\n            }\r\n            if (dattr.styleExtend.skipRasters || item.skipRasters) {\r\n                delete dattr.bgImage;\r\n            }\r\n            if (style.imagePattern) {\r\n                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');\r\n            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                if (utils.isPatternNode(dattr.bgImage)) {\r\n                    if ('rasterOpacity' in gmx) { ctx.globalAlpha = gmx.rasterOpacity; }\r\n                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');\r\n                    style.bgImage = true;\r\n                }\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n                ctx.globalAlpha = 1;\r\n            }\r\n            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {\r\n                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;\r\n                coordsToCanvas(utils.polygonToCanvasFill, true);\r\n            }\r\n        }\r\n    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {\r\n        coords = geom.coordinates;\r\n        if (geoType === 'LINESTRING') { coords = [coords]; }\r\n        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;\r\n        for (i = 0, len = coords.length; i < len; i++) {\r\n            var arr = tbounds.clipPolyLine(coords[i], true, size);\r\n            for (j = 0, len1 = arr.length; j < len1; j++) {\r\n                dattr.coords = arr[j];\r\n                var pixels = utils.lineToCanvas(dattr);\r\n                if (pixels) {\r\n                    ctx.save();\r\n                    utils.lineToCanvasAsIcon(pixels, dattr);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DrawCanvas.js","/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)\r\n*/\r\nvar gmxSessionManager = {\r\n    APIKEY_PARAM: 'key',\r\n    SCRIPT_REGEXP: [\r\n\t\t/\\bleaflet-geomixer(-\\w*)?\\.js\\b/,\r\n\t\t/\\bgeomixer(-\\w*)?\\.js\\b/\r\n\t],\r\n    _scriptSearched: false,\r\n    _scriptAPIKey: null,\r\n    _searchScriptAPIKey: function() {\r\n        var _this = this;\r\n        if (this._scriptSearched) {\r\n            return this._scriptAPIKey;\r\n        }\r\n\r\n        var scripts = document.getElementsByTagName('script');\r\n        for (var i = 0; i < scripts.length; i++) {\r\n            var src = scripts[i].getAttribute('src'),\r\n\t\t\t\tarr = this.SCRIPT_REGEXP;\r\n\t\t\tfor (var j = 0, len = arr.length; j < len; j++) {\r\n\t\t\t\tif (arr[j].exec(src)) {\r\n\t\t\t\t\tvar query = src.split('?')[1];\r\n\r\n\t\t\t\t\tif (query) {\r\n\t\t\t\t\t\tvar params = query.split('&');\r\n\t\t\t\t\t\tfor (var p = 0; p < params.length; p++) {\r\n\t\t\t\t\t\t\tvar parsedParam = params[p].split('=');\r\n\t\t\t\t\t\t\tif (parsedParam[0] === _this.APIKEY_PARAM) {\r\n\t\t\t\t\t\t\t\t_this._scriptAPIKey = parsedParam[1];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n            }\r\n\t\t\tif (_this._scriptAPIKey) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n        }\r\n        this._scriptSearched = true;\r\n        return this._scriptAPIKey;\r\n    },\r\n\r\n    //we will search apiKey in script tags iff apiKey parameter is undefined.\r\n    //if it is defined as falsy (null, '', etc), we won't send any requests to server\r\n    requestSessionKey: function(serverHost, apiKey) {\r\n        var keys = this._sessionKeys;\r\n\r\n        if (!(serverHost in keys)) {\r\n            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;\r\n            keys[serverHost] = new L.gmx.Deferred();\r\n            if (apiKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/ApiKey.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        Key: apiKey\r\n                    }\r\n                ).then(function(response) {\r\n                    if (response && response.Status === 'ok') {\r\n                        keys[serverHost].resolve(response.Result.Key);\r\n                    } else {\r\n                        keys[serverHost].reject();\r\n                    }\r\n                }, keys[serverHost].reject);\r\n            } else {\r\n                keys[serverHost].resolve('');\r\n            }\r\n        }\r\n        return keys[serverHost];\r\n    },\r\n\r\n    //get already received session key\r\n    getSessionKey: function(serverHost) {\r\n        var keyPromise = this._sessionKeys[serverHost];\r\n\r\n        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];\r\n    },\r\n    _sessionKeys: {} //deferred for each host\r\n};\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxSessionManager = gmxSessionManager;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/SessionManager.js","/** Asynchronously request information about map given server host and map name\r\n*/\r\nimport {gmxAPIutils} from './Utils.js';\r\nvar gmxMapManager = {\r\n    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes\r\n    getMap: function(serverHost, apiKey, mapName, skipTiles) {\r\n        var maps = this._maps;\r\n        if (!maps[serverHost] || !maps[serverHost][mapName]) {\r\n            var def = new L.gmx.Deferred();\r\n            maps[serverHost] = maps[serverHost] || {};\r\n            maps[serverHost][mapName] = {promise: def};\r\n\r\n            L.gmx.gmxSessionManager.requestSessionKey(serverHost, apiKey).then(function(sessionKey) {\r\n                gmxAPIutils.requestJSONP(\r\n                    'http://' + serverHost + '/TileSender.ashx',\r\n                    {\r\n                        WrapStyle: 'func',\r\n                        skipTiles: skipTiles || 'None', // All, NotVisible, None\r\n                        key: sessionKey,\r\n                        MapName: mapName,\r\n                        ModeKey: 'map'\r\n                    }\r\n                ).then(function(json) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        json.Result.properties.hostName = serverHost;\r\n                        def.resolve(json.Result);\r\n                    } else {\r\n                        def.reject(json);\r\n                    }\r\n                }, def.reject);\r\n            }, def.reject);\r\n        }\r\n        return maps[serverHost][mapName].promise;\r\n    },\r\n\r\n\tsyncParams: {},\r\n    //      \r\n    setSyncParams: function(hash) {\r\n\t\tthis.syncParams = hash;\r\n    },\r\n    getSyncParams: function(stringFlag) {\r\n\t\tvar res = this.syncParams;\r\n\t\tif (stringFlag) {\r\n\t\t\tvar arr = [];\r\n\t\t\tfor (var key in res) {\r\n\t\t\t\tarr.push(key + '=' + res[key]);\r\n\t\t\t}\r\n\t\t\tres = arr.join('&');\r\n\t\t}\r\n\t\treturn res;\r\n    },\r\n\r\n    //we will (lazy) create index by layer name to speed up multiple function calls\r\n    findLayerInfo: function(serverHost, mapID, layerID) {\r\n        var hostMaps = this._maps[serverHost],\r\n            mapInfo = hostMaps && hostMaps[mapID];\r\n\r\n        if (!mapInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (mapInfo.layers) {\r\n            return mapInfo.layers[layerID];\r\n        }\r\n\r\n        var serverData = mapInfo.promise.getFulfilledData();\r\n\r\n        if (!serverData) {\r\n            return null;\r\n        }\r\n\r\n        mapInfo.layers = {};\r\n\r\n        //create index by layer name\r\n        gmxMapManager.iterateLayers(serverData[0], function(layerInfo) {\r\n            mapInfo.layers[layerInfo.properties.name] = layerInfo;\r\n        });\r\n\r\n        return mapInfo.layers[layerID];\r\n    },\r\n    iterateLayers: function(treeInfo, callback) {\r\n        var iterate = function(arr) {\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var layer = arr[i];\r\n\r\n                if (layer.type === 'group') {\r\n                    iterate(layer.content.children);\r\n                } else if (layer.type === 'layer') {\r\n                    callback(layer.content);\r\n                }\r\n            }\r\n        };\r\n\r\n        treeInfo && iterate(treeInfo.children);\r\n    },\r\n    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}\r\n};\r\n\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxMapManager = gmxMapManager;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/MapManager.js","//Helper class, that represents layers of single Geomixer's map\r\n//Creates layers from given map description\r\nvar gmxMap = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    initialize: function(mapInfo, commonLayerOptions) {\r\n\t\tthis.layers = [];\r\n\t\tthis.layersByTitle = {};\r\n\t\tthis.layersByID = {};\r\n\t\tthis.dataManagers = {};\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.properties = L.extend({}, mapInfo.properties);\r\n\t\tthis.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];\r\n\t\tthis.rawTree = mapInfo;\r\n\r\n\t\tthis.layersCreated = new L.gmx.Deferred();\r\n\r\n\t\tvar missingLayerTypes = {},\r\n\t\t\tdataSources = {};\r\n\r\n\t\tL.gmx.gmxMapManager.iterateLayers(mapInfo, function(layerInfo) {\r\n\t\t\tvar props = layerInfo.properties,\r\n\t\t\t\tmeta = props.MetaProperties || {},\r\n\t\t\t\toptions = {\r\n\t\t\t\t\tmapID: mapInfo.properties.name,\r\n\t\t\t\t\tlayerID: props.name\r\n\t\t\t\t};\r\n\r\n\t\t\tprops.hostName = mapInfo.properties.hostName;\r\n\r\n\t\t\tvar type = props.ContentID || props.type,\r\n\t\t\t\tlayerOptions = L.extend(options, commonLayerOptions);\r\n\r\n\t\t\tif (props.dataSource || 'parentLayer' in meta) {      \t// Set dataSource layer\r\n\t\t\t\tlayerOptions.parentLayer = props.dataSource || '';\r\n\t\t\t\tif ('parentLayer' in meta) {      \t// todo     \r\n\t\t\t\t\tlayerOptions.parentLayer = meta.parentLayer.Value || '';\r\n\t\t\t\t}\r\n\t\t\t\tdataSources[options.layerID] = {\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t};\r\n\t\t\t} else if (type in L.gmx._layerClasses) {\r\n\t\t\t\t_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));\r\n\t\t\t} else {\r\n\t\t\t\tmissingLayerTypes[type] = missingLayerTypes[type] || [];\r\n\t\t\t\tmissingLayerTypes[type].push({\r\n\t\t\t\t\tinfo: layerInfo,\r\n\t\t\t\t\toptions: layerOptions\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t//load missing layer types\r\n\t\tvar loaders = [];\r\n\t\tfor (var type in missingLayerTypes) {\r\n\t\t\tloaders.push(L.gmx._loadLayerClass(type).then(/*eslint-disable no-loop-func */function (type) {/*eslint-enable */\r\n\t\t\t\tvar it = missingLayerTypes[type];\r\n\t\t\t\tfor (var i = 0, len = it.length; i < len; i++) {\r\n\t\t\t\t\t_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));\r\n\t\t\t\t}\r\n\t\t\t}.bind(null, type)));\r\n\t\t}\r\n\t\tvar hosts = {}, host, id, it;\r\n\t\tfor (id in dataSources) {\r\n\t\t\tit = dataSources[id];\r\n\t\t\tvar opt = it.options,\r\n\t\t\t\tpId = opt.parentLayer,\r\n\t\t\t\tpLayer = this.layersByID[pId];\r\n\t\t\tif (pLayer) {\r\n\t\t\t\tit.options.parentOptions = pLayer.getGmxProperties();\r\n\t\t\t\tit.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);\r\n\t\t\t\tthis.dataManagers[pId] = it.options.dataManager;\r\n\t\t\t\tthis.addLayer(L.gmx.createLayer(it.info, it.options));\r\n\t\t\t} else {\r\n\t\t\t\thost = opt.hostName;\r\n\t\t\t\tif (!hosts[host]) { hosts[host] = {}; }\r\n\t\t\t\tif (!hosts[host][pId]) { hosts[host][pId] = []; }\r\n\t\t\t\thosts[host][pId].push(id);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (host in hosts) {\r\n\t\t\tvar arr = [],\r\n\t\t\t\tprefix = 'http://' + host;\r\n\t\t\tfor (id in hosts[host]) {\r\n\t\t\t\tarr.push({Layer: id});\r\n\t\t\t}\r\n\t\t\tloaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx',\r\n\t\t\t\t{\r\n\t\t\t\t\tWrapStyle: 'func',\r\n\t\t\t\t\tLayers: JSON.stringify(arr)\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tids: hosts[host]\r\n\t\t\t\t}\r\n\t\t\t).then(function(json, opt) {\r\n\t\t\t\tif (json && json.Status === 'ok' && json.Result) {\r\n\t\t\t\t\tjson.Result.forEach(function(it) {\r\n\t\t\t\t\t\tvar dataManager = _this.addDataManager(it),\r\n\t\t\t\t\t\t\tprops = it.properties,\r\n\t\t\t\t\t\t\tpId = props.name;\r\n\t\t\t\t\t\tif (opt && opt.ids && opt.ids[pId]) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\tvar pt = dataSources[id];\r\n\t\t\t\t\t\t\t\tpt.options.parentOptions = it.properties;\r\n\t\t\t\t\t\t\t\tpt.options.dataManager = dataManager;\r\n\t\t\t\t\t\t\t\t_this.addLayer(L.gmx.createLayer(pt.info, pt.options));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);\r\n\t\t\t\t\tif (opt && opt.ids) {\r\n\t\t\t\t\t\tfor (var pId in opt.ids) {\r\n\t\t\t\t\t\t\topt.ids[pId].forEach(function(id) {\r\n\t\t\t\t\t\t\t\t_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\tL.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);\r\n\t},\r\n\r\n\taddDataManager: function(it) {\r\n\t\tvar pid = it.properties.name;\r\n\t\tif (!this.dataManagers[pid]) {\r\n\t\t\tthis.dataManagers[pid] = new DataManager(it.properties);\r\n\t\t}\r\n\t\treturn this.dataManagers[pid];\r\n\t},\r\n\tgetDataManager: function(id) {\r\n\t\treturn this.dataManagers[id];\r\n\t},\r\n\r\n\taddLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tthis.layers.push(layer);\r\n\t\tthis.layersByTitle[props.title] = layer;\r\n\t\tthis.layersByID[props.name] = layer;\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function(layer) {\r\n\t\tvar props = layer.getGmxProperties();\r\n\r\n\t\tfor (var i = 0; i < this.layers.length; i++) {\r\n\t\t\tif (this.layers[i].getGmxProperties().name === props.name) {\r\n\t\t\t\tthis.layers.splice(i, 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdelete this.layersByTitle[props.title];\r\n\t\tdelete this.layersByID[props.name];\r\n\t\tthis.fire('layerremove', {layer: layer});\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddLayersToMap: function(leafletMap) {\r\n\t\tfor (var l = this.layers.length - 1; l >= 0; l--) {\r\n\t\t\tvar layer = this.layers[l];\r\n\t\t\tif (layer.getGmxProperties().visible) {\r\n\t\t\t\tleafletMap.addLayer(layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\nL.gmx = L.gmx || {};\r\nL.gmx.gmxMap = gmxMap;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/GeomixerMap.js","/*\r\n * gmxEventsManager - handlers manager\r\n */\r\nvar GmxEventsManager = L.Handler.extend({\r\n    options: {\r\n    },\r\n\r\n    initialize: function (map) {\r\n        this._map = map;\r\n        this._layers = {};\r\n        this._lastLayer = null;\r\n        this._lastId = null;\r\n        var _this = this;\r\n        this._drawstart = null;\r\n        this._lastCursor = '';\r\n\r\n        var isDrawing = function () {\r\n            if (_this._drawstart) {\r\n                return true;\r\n            } else if (_this._drawstart === null) {\r\n                if (map.gmxControlsManager) {\r\n                    var drawingControl = map.gmxControlsManager.get('drawing');\r\n                    if (drawingControl) {\r\n                        drawingControl.on('activechange', function (ev) {\r\n                            _this._drawstart = ev.activeIcon;\r\n                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';\r\n                        });\r\n                    }\r\n                }\r\n                _this._drawstart = false;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        var getDomIndex = function (layer) {\r\n            var container = layer._container;\r\n            if (container) {\r\n                var arr = container.parentNode.childNodes;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    if (container === arr[i]) {\r\n                        return i;\r\n                    }\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n\r\n        var skipNodeName = {\r\n            IMG: true,\r\n            DIV: true,\r\n            path: true\r\n        };\r\n\r\n        var clearLastHover = function () {\r\n            if (_this._lastLayer) {\r\n                _this._lastLayer.gmxEventCheck({type: 'mousemove'}, true);\r\n                _this._lastLayer = null;\r\n            }\r\n        };\r\n\r\n        var eventCheck = function (ev) {\r\n            var type = ev.type,\r\n                map = _this._map,\r\n                skipNode = false;\r\n            if (ev.originalEvent) {\r\n                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;\r\n                var target = ev.originalEvent.target;\r\n                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');\r\n            }\r\n            if (map._animatingZoom ||\r\n                isDrawing() ||\r\n                skipNode ||\r\n                (type === 'click' &&  map._skipClick) ||        // from drawing\r\n                (type === 'mousemove' &&  map.gmxMouseDown)\r\n                ) {\r\n                clearLastHover();\r\n                map._skipClick = false;\r\n                return;\r\n            }\r\n            if (ev.layerPoint) {\r\n                map._gmxMouseLatLng = ev.latlng;\r\n                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);\r\n            }\r\n\r\n            var arr = Object.keys(_this._layers).sort(function(a, b) {\r\n                var la = map._layers[a],\r\n                    lb = map._layers[b];\r\n                if (la && lb) {\r\n                    var oa = la.options, ob = lb.options,\r\n                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),\r\n                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),\r\n                        delta = zb - za;\r\n                    return delta ? delta : _this._layers[b] - _this._layers[a];\r\n                }\r\n                return 0;\r\n            });\r\n\r\n            var layer,\r\n                foundLayer = null,\r\n                cursor = '';\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                layer = map._layers[id];\r\n                if (layer && layer._map && !layer._animating && layer.options.clickable) {\r\n                    if (layer.gmxEventCheck(ev)) {\r\n                        if (layer.hasEventListeners('mouseover')) {\r\n                            cursor = 'pointer';\r\n                        }\r\n                        foundLayer = layer;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (_this._lastCursor !== cursor && !isDrawing()) {\r\n                map._container.style.cursor = cursor;\r\n            }\r\n            _this._lastCursor = cursor;\r\n\r\n            if (type !== 'zoomend') {\r\n                if (foundLayer) {\r\n                    if (_this._lastLayer !== foundLayer) {\r\n                        clearLastHover();\r\n                    }\r\n                    _this._lastLayer = foundLayer;\r\n                } else {\r\n                    clearLastHover();\r\n                }\r\n            }\r\n        };\r\n\r\n        map.on({\r\n            zoomend: function () {\r\n                if (map._gmxMouseLatLng) {\r\n                    setTimeout(function () {\r\n                        eventCheck({type: 'mousemove', latlng: map._gmxMouseLatLng});\r\n                    }, 0);\r\n                }\r\n            },\r\n            click: eventCheck,\r\n            dblclick: eventCheck,\r\n            mousedown: eventCheck,\r\n            mouseup: eventCheck,\r\n            mousemove: eventCheck,\r\n            contextmenu: eventCheck,\r\n            layeradd: function (ev) {\r\n                var layer = ev.layer;\r\n                if ('gmxEventCheck' in layer && layer.options.clickable) {\r\n                    _this._layers[layer._leaflet_id] = getDomIndex(layer);\r\n                }\r\n            },\r\n            layerremove: function (ev) {\r\n                var id = ev.layer._leaflet_id;\r\n                delete _this._layers[id];\r\n                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {\r\n                    _this._lastLayer = null;\r\n                    _this._lastId = 0;\r\n                }\r\n            }\r\n        }, this);\r\n    }\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n    // Check to see if handler has already been initialized.\r\n    if (!this._gmxEventsManager) {\r\n        this._gmxEventsManager = new GmxEventsManager(this);\r\n\t\tthis.isGmxDrawing = function () {\r\n\t\t\treturn this._gmxEventsManager._drawstart;\r\n\t\t};\r\n\r\n        this.on('remove', function () {\r\n            if (this._gmxEventsManager) {\r\n                this._gmxEventsManager.removeHooks();\r\n            }\r\n        });\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/EventsManager.js","(function() {\r\n    var DEFAULT_LANGUAGE = 'rus',\r\n        _setKeyText = function(lang, key, item, hash) {\r\n            if (!hash[lang]) { hash[lang] = {}; }\r\n            hash[lang][key] = item;\r\n        };\r\n    L.gmxLocale = {\r\n\r\n        setLanguage: function(lang) {\r\n            this._language = lang;\r\n        },\r\n\r\n        getLanguage: function() {\r\n            return window.language || this._language || DEFAULT_LANGUAGE;\r\n        }\r\n    };\r\n\r\n    L.gmxLocaleMixin = {\r\n        addText: function() {\r\n            var lang = arguments[0],\r\n                newHash = arguments[1];\r\n            if (arguments.length === 1) {\r\n                newHash = lang;\r\n                lang = null;\r\n            }\r\n            for (var k in newHash) {\r\n                if (lang === null) {\r\n                    for (var k1 in newHash[k]) {\r\n                        _setKeyText(k, k1, newHash[k][k1], this);\r\n                    }\r\n                } else {\r\n                    _setKeyText(lang, k, newHash[k], this);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n\r\n        getText: function(key) {\r\n            var lang = L.gmxLocale.getLanguage(),\r\n                locale = this[lang] || {};\r\n\r\n            var keyArr = key ? key.split(/\\./) : [];\r\n            for (var i = 0, len = keyArr.length; i < len; i++) {\r\n                if (!locale) { break; }\r\n                locale = locale[keyArr[i]];\r\n            }\r\n            return locale;\r\n        }\r\n    };\r\n    L.extend(L.gmxLocale, L.gmxLocaleMixin);\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Locale.js","L.extend(L.gmxLocale, {\r\n    rus: {\r\n        Coordinates : '',\r\n        Length : '',\r\n        nodeLength : '  ',\r\n        edgeLength : ' ',\r\n        Area : '',\r\n        Perimeter : '',\r\n        units: {\r\n            m: '',\r\n            nm: '.',\r\n            km: '',\r\n            m2: '. ',\r\n            km2: '. ',\r\n            ha: '',\r\n            m2html: '<sup>2',\r\n            km2html: '<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_ru.js","L.extend(L.gmxLocale, {\r\n    eng: {\r\n        Coordinates : 'Coordinates',\r\n        Length : 'Length',\r\n        nodeLength : 'From start point',\r\n        edgeLength : 'Segment length',\r\n        Area : 'Area',\r\n        Perimeter : 'Perimeter',\r\n        units: {\r\n            m: 'm',\r\n            nm: 'nmi',\r\n            km: 'km',\r\n            m2: 'sq. m',\r\n            km2: 'sq. km',\r\n            ha: 'ha',\r\n            m2html: 'm<sup>2',\r\n            km2html: 'km<sup>2'\r\n        }\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/lang_en.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar gmxVectorTileLoader = {\r\n    _loadedTiles: {},\r\n    _getKey: function(ti) {\r\n        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');\r\n    },\r\n    load: function(tileSenderPrefix, tileInfo) {\r\n        var key = gmxVectorTileLoader._getKey(tileInfo);\r\n\r\n        if (!this._loadedTiles[key]) {\r\n            var def = new L.gmx.Deferred();\r\n            this._loadedTiles[key] = def;\r\n\r\n            var requestParams = {\r\n                ModeKey: 'tile',\r\n                r: 'j',\r\n                LayerName: tileInfo.layerID,\r\n                z: tileInfo.z,\r\n                x: tileInfo.x,\r\n                y: tileInfo.y,\r\n                v: tileInfo.v\r\n            };\r\n\r\n            if (tileInfo.d !== -1) {\r\n                requestParams.Level = tileInfo.d;\r\n                requestParams.Span = tileInfo.s;\r\n            }\r\n\r\n            gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, {callbackParamName: null}).then(null, function() {\r\n                def.reject();\r\n            });\r\n        }\r\n\r\n        return this._loadedTiles[key];\r\n    }\r\n};\r\n\r\nwindow.gmxAPI = window.gmxAPI || {};\r\nwindow.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function(data) {\r\n    var key = gmxVectorTileLoader._getKey({\r\n        layerID: data.LayerName,\r\n        x: data.x,\r\n        y: data.y,\r\n        z: data.z,\r\n        d: data.level,\r\n        s: data.span,\r\n        v: data.v\r\n    });\r\n\r\n    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox);\r\n};\r\nexport {gmxVectorTileLoader};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTileLoader.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n//Single vector tile, received from GeoMixer server\r\n//  dataProvider: has single method \"load\": function(x, y, z, v, s, d, callback), which calls \"callback\" with the following parameters:\r\n//      - {Object[]} data - information about vector objects in tile\r\n//      - {Number[4]} [bbox] - optional bbox of objects in tile\r\n//  options:\r\n//      x, y, z, v, s, d: GeoMixer vector tile point\r\n//      dateZero: zero Date for temporal layers\r\n//      isGeneralized: flag for generalized tile\r\nvar VectorTile = function(dataProvider, options) {\r\n    this.dataProvider = dataProvider;\r\n    this.loadDef = new L.gmx.Deferred();\r\n    this.data = null;\r\n    this.dataOptions = null;\r\n\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.z = options.z;\r\n    this.v = options.v;\r\n    this.s = options.s || -1;\r\n    this.d = options.d || -1;\r\n    this.isGeneralized = options.isGeneralized;\r\n    this.isFlatten = options.isFlatten;\r\n    this.bounds = gmxAPIutils.getTileBounds(this.x, this.y, this.z);\r\n    this.gmxTilePoint = {x: this.x, y: this.y, z: this.z, s: this.s, d: this.d};\r\n    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);\r\n\r\n    if (this.s >= 0 && options.dateZero) {\r\n        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * gmxAPIutils.oneDay * 1000);\r\n        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * gmxAPIutils.oneDay * 1000);\r\n    }\r\n\r\n    this.state = 'notLoaded'; //notLoaded, loading, loaded\r\n};\r\n\r\nVectorTile.prototype = {\r\n    addData: function(data, keys) {\r\n\r\n        if (keys) {\r\n            this.removeData(keys, true);\r\n        }\r\n\r\n        var len = data.length,\r\n            dataOptions = new Array(len),\r\n            dataBounds = gmxAPIutils.bounds();\r\n        for (var i = 0; i < len; i++) {\r\n            var dataOption = this._parseItem(data[i]);\r\n            dataOptions[i] = dataOption;\r\n            dataBounds.extendBounds(dataOption.bounds);\r\n        }\r\n\r\n        if (!this.data) {\r\n            this.data = data;\r\n            this.dataOptions = dataOptions;\r\n        } else {\r\n            this.data = this.data.concat(data);\r\n            this.dataOptions = this.dataOptions.concat(dataOptions);\r\n        }\r\n\r\n        this.state = 'loaded';\r\n\r\n        this.loadDef.resolve(this.data);\r\n        return dataBounds;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {\r\n            if (keys[arr[i][0]]) {\r\n                arr.splice(i, 1);\r\n                if (this.dataOptions) { this.dataOptions.splice(i, 1); }\r\n            }\r\n        }\r\n    },\r\n\r\n    load: function() {\r\n        if (this.state === 'notLoaded') {\r\n            this.state = 'loading';\r\n            var _this = this;\r\n            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function(data, bbox) {\r\n                _this.bbox = bbox;\r\n                _this.addData(data);\r\n            });\r\n        }\r\n\r\n        return this.loadDef;\r\n    },\r\n\r\n    clear: function() {\r\n        this.state = 'notLoaded';\r\n        this.data = null;\r\n        this.dataOptions = null;\r\n\r\n        this.loadDef = new L.gmx.Deferred();\r\n    },\r\n\r\n    _parseItem: function(it) {\r\n        var len = it.length,\r\n            i;\r\n\r\n        // TODO: old properties null = ''\r\n        for (i = 0; i < len; i++) {\r\n            if (it[i] === null) { it[i] = ''; }\r\n        }\r\n\r\n        var geo = it[len - 1],\r\n            needFlatten = this.isFlatten,\r\n            type = geo.type,\r\n            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,\r\n            isPolygon = type === 'POLYGON' || type === 'Polygon',\r\n            coords = geo.coordinates,\r\n            hiddenLines = [],\r\n            bounds = null,\r\n            boundsArr = [];\r\n\r\n        if (isLikePolygon) {\r\n            if (isPolygon) { coords = [coords]; }\r\n            bounds = gmxAPIutils.bounds();\r\n            var edgeBounds = gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),\r\n                hiddenFlag = false;\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                var arr = [],\r\n                    hiddenLines1 = [];\r\n\r\n                for (var j = 0, len1 = coords[i].length; j < len1; j++) {\r\n                    if (needFlatten && typeof coords[i][j][0] !== 'number') {\r\n                        coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);\r\n                    }\r\n                    var b = gmxAPIutils.bounds(coords[i][j]);\r\n                    arr.push(b);\r\n                    if (j === 0) { bounds.extendBounds(b); }\r\n                    // EdgeLines calc\r\n                    var edgeArr = gmxAPIutils.getHidden(coords[i][j], edgeBounds);\r\n                    hiddenLines1.push(edgeArr);\r\n                    if (edgeArr.length) {\r\n                        hiddenFlag = true;\r\n                    }\r\n                }\r\n                boundsArr.push(arr);\r\n                hiddenLines.push(hiddenLines1);\r\n            }\r\n            if (!hiddenFlag) { hiddenLines = null; }\r\n            if (isPolygon) { boundsArr = boundsArr[0]; }\r\n        } else if (type === 'POINT' || type === 'Point') {\r\n            bounds = gmxAPIutils.bounds([coords]);\r\n        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds([coords[i]]));\r\n            }\r\n        } else if (type === 'LINESTRING' || type === 'LineString') {\r\n            bounds = gmxAPIutils.bounds(coords);\r\n        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {\r\n            bounds = gmxAPIutils.bounds();\r\n            for (i = 0, len = coords.length; i < len; i++) {\r\n                bounds.extendBounds(gmxAPIutils.bounds(coords[i]));\r\n            }\r\n        }\r\n        var dataOption = {\r\n            bounds: bounds,\r\n            boundsArr: boundsArr\r\n        };\r\n        if (hiddenLines) {\r\n            dataOption.hiddenLines = hiddenLines;\r\n        }\r\n        return dataOption;\r\n    }\r\n};\r\n//class methods\r\n\r\nVectorTile.makeTileKey = function(x, y, z, v, s, d) {\r\n    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;\r\n};\r\n\r\nVectorTile.createTileKey = function(opt) {\r\n    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');\r\n};\r\n\r\nVectorTile.parseTileKey = function(gmxTileKey) {\r\n    var p = gmxTileKey.split('_').map(function(it) { return Number(it); });\r\n    return {z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5]};\r\n};\r\n\r\nVectorTile.boundsFromTileKey = function(gmxTileKey) {\r\n    var p = VectorTile.parseTileKey(gmxTileKey);\r\n    return gmxAPIutils.getTileBounds(p.x, p.y, p.z);\r\n};\r\nexport {VectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/VectorTile.js","//Single observer with vector data\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nvar Observer = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    /* options : {\r\n            type: 'resend | update',    // `resend` - send all data (like screen tile observer)\r\n                                        // `update` - send only changed data\r\n            callback: Func,             // will be called when layer's data for this observer is changed\r\n            dateInterval: [dateBegin,dateEnd], // temporal interval\r\n            bbox: bbox,                 // bbox to observe on Mercator\r\n            filters: [String]           // filter keys array\r\n            active: [Boolean=true]      // is this observer active\r\n            targetZoom: [Number]        // for zoom generalized type default(null)\r\n        }\r\n    */\r\n    initialize: function(options) {\r\n        this.type = options.type || 'update';\r\n        this._callback = options.callback;\r\n        this._items = null;\r\n        this.bbox = options.bbox;      // set bbox by Mercator bounds\r\n        this.filters = options.filters || [];\r\n        this.targetZoom = options.targetZoom || null;\r\n        this.active = 'active' in options ? options.active : true;\r\n\r\n        if (options.bounds) {   // set bbox by LatLngBounds\r\n            this.setBounds(options.bounds);\r\n        }\r\n\r\n\t\tvar w = gmxAPIutils.worldWidthMerc,\r\n\t\t\tdx;\r\n        if (!this.bbox) {\r\n            this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n            this.world = true;\r\n        } else if (this.bbox.max.x > w) {\r\n\t\t\tdx = this.bbox.max.x - w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);\r\n        } else if (this.bbox.min.x < -w) {\r\n\t\t\tdx = this.bbox.min.x + w;\r\n            this.bbox1 = gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);\r\n        }\r\n\r\n        if (options.dateInterval) {\r\n            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);\r\n        }\r\n    },\r\n\r\n    hasFilter: function(filterName) {\r\n        for (var i = 0, len = this.filters.length; i < len; i++) {\r\n            if (this.filters[i] === filterName) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    activate: function() {\r\n        if (!this.active) {\r\n            this.active = true;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    deactivate: function() {\r\n        if (this.active) {\r\n            this.active = false;\r\n            this.fire('activate');\r\n        }\r\n        return this;\r\n    },\r\n\r\n    toggleActive: function(isActive) {\r\n        return isActive ? this.activate() : this.deactivate();\r\n    },\r\n\r\n    isActive: function() {\r\n        return this.active;\r\n    },\r\n\r\n    updateData: function(data) {\r\n        var len = data.length,\r\n            out = {count: len};\r\n\r\n        if (this.type === 'update') {\r\n            //calculate difference with previous data\r\n            if (!this._items) { this._items = {}; }\r\n            var prevItems = this._items,\r\n                newItems = {},\r\n                added = [],\r\n                removed = [],\r\n                key;\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                var it = data[i];\r\n\r\n                key = it.id + '_' + it.tileKey;\r\n\r\n                newItems[key] = it;\r\n\r\n                if (!prevItems[key]) {\r\n                    added.push(it);\r\n                }\r\n            }\r\n\r\n            for (key in prevItems) {\r\n                if (!newItems[key]) {\r\n                    removed.push(prevItems[key]);\r\n                }\r\n            }\r\n\r\n            if (added.length) {\r\n                out.added = added;\r\n            }\r\n            if (removed.length) {\r\n                out.removed = removed;\r\n            }\r\n\r\n            this._items = newItems;\r\n\r\n        } else {\r\n            out.added = data;\r\n        }\r\n        this._callback(out);\r\n        out = null;\r\n        data = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    removeData: function(keys) {\r\n        if (this.type !== 'update' || !this._items) {\r\n            return this;\r\n        }\r\n\r\n        var items = this._items,\r\n            removed = [];\r\n\r\n        for (var id in keys) {\r\n            if (items[id]) {\r\n                removed.push(items[id]);\r\n                delete items[id];\r\n            }\r\n        }\r\n\r\n        if (removed.length) {\r\n            this._callback({removed: removed});\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /*setFilter: function (func) {\r\n        this._filters.userFilter = func;\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        delete this._filters.userFilter;\r\n        this.fire('update');\r\n        return this;\r\n    },*/\r\n\r\n    setBounds: function(bounds) {\r\n        var w;\r\n        if (!bounds) {\r\n            if (!this.world) {\r\n                w = gmxAPIutils.worldWidthMerc;\r\n                this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);\r\n                this.bbox1 = null;\r\n                this.world = true;\r\n                this.fire('update');\r\n            }\r\n            return this;\r\n        }\r\n\r\n        var min = bounds.min,\r\n            max = bounds.max;\r\n        if (!min || !max) {\r\n            var latLngBounds = L.latLngBounds(bounds),\r\n                sw = latLngBounds.getSouthWest(),\r\n                ne = latLngBounds.getNorthEast();\r\n            min = {x: sw.lng, y: sw.lat};\r\n            max = {x: ne.lng, y: ne.lat};\r\n        }\r\n        var minX = min.x, maxX = max.x,\r\n            minY = min.y, maxY = max.y,\r\n            minX1 = null,\r\n            maxX1 = null;\r\n\r\n        this.world = false;\r\n        w = (maxX - minX) / 2;\r\n        if (w >= 180) {\r\n            minX = -180; maxX = 180;\r\n            this.world = true;\r\n        } else if (maxX > 180 || minX < -180) {\r\n            var center = ((maxX + minX) / 2) % 360;\r\n            if (center > 180) { center -= 360; }\r\n            else if (center < -180) { center += 360; }\r\n            minX = center - w; maxX = center + w;\r\n            if (minX < -180) {\r\n                minX1 = minX + 360; maxX1 = 180; minX = -180;\r\n            } else if (maxX > 180) {\r\n                minX1 = -180; maxX1 = maxX - 360; maxX = 180;\r\n            }\r\n        }\r\n        var m1 = L.Projection.Mercator.project(L.latLng(minY, minX)),\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX));\r\n\r\n        this.bbox = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        this.bbox1 = null;\r\n        if (minX1) {\r\n            m1 = L.Projection.Mercator.project(L.latLng(minY, minX1));\r\n            m2 = L.Projection.Mercator.project(L.latLng(maxY, maxX1));\r\n            this.bbox1 = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);\r\n        }\r\n\r\n        this.fire('update');\r\n        return this;\r\n    },\r\n\r\n    intersects: function(bounds) {\r\n        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));\r\n    },\r\n\r\n    intersectsWithTile: function(tile) {\r\n        if (this.targetZoom) {\r\n            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);\r\n            if ((tile.isGeneralized && tile.z !== z) || tile.z > z) { return false; }\r\n        }\r\n        var di = this.dateInterval;\r\n        return this.intersects(tile.bounds) && (!tile.beginDate || (di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate));\r\n    },\r\n\r\n    _setDateInterval: function(beginDate, endDate) {\r\n        if (beginDate && endDate) {\r\n            // var beginValue = beginDate.valueOf(),\r\n                // endValue = endDate.valueOf();\r\n            this.dateInterval = {\r\n                beginDate: beginDate,\r\n                endDate: endDate\r\n            };\r\n        } else {\r\n            this.dateInterval = null;\r\n        }\r\n    },\r\n\r\n    setDateInterval: function(beginDate, endDate) {\r\n        var isValid = beginDate && endDate;\r\n\r\n        if (!this.dateInterval !== !isValid ||\r\n            isValid && (\r\n                this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() ||\r\n                this.dateInterval.endDate.valueOf() !== endDate.valueOf()\r\n            )\r\n        ) {\r\n            this._setDateInterval(beginDate, endDate);\r\n            this.fire('update', {temporalFilter: true});\r\n        }\r\n        return this;\r\n    }\r\n});\r\nL.gmx.observer = function(options) {\r\n    return new Observer(options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/Observer.js","(function() {\r\n//tree for fast tiles selection inside temporal interval\r\n//  options:\r\n//      TemporalTiles: tilePoints array\r\n//      TemporalVers: tiles version array\r\n//      TemporalPeriods: periods\r\n//      ZeroDate: start Date\r\nvar TilesTree = function(options) {\r\n    var _rootNodes = [],\r\n        tiles = options.TemporalTiles || [],\r\n        vers = options.TemporalVers || [],\r\n        periods = options.TemporalPeriods || [],\r\n        maxPeriod = periods[periods.length - 1],\r\n        smin = Number.MAX_VALUE,\r\n        arr = options.ZeroDate.split('.'),\r\n        zn = new Date(\r\n            (arr.length > 2 ? arr[2] : 2008),\r\n            (arr.length > 1 ? arr[1] - 1 : 0),\r\n            (arr.length > 0 ? arr[0] : 1)\r\n        ),\r\n        dateZero = new Date(zn.getTime()  - zn.getTimezoneOffset() * 60000),\r\n        zeroUT = dateZero.getTime() / 1000;\r\n\r\n    this.dateZero = dateZero;\r\n\r\n    var addTile = function (node, tile, key) {\r\n        var d = node.d;\r\n        if (tile.d === periods[d]) {\r\n            node.count++;\r\n            node.tiles.push(key);\r\n            return;\r\n        }\r\n\r\n        var pd = periods[d - 1],\r\n            childrenCount = periods[d] / pd;\r\n\r\n        if (!('children' in node)) {\r\n            node.children = new Array(childrenCount);\r\n        }\r\n\r\n        var sChild = Math.floor(tile.s * tile.d / pd),\r\n            ds = sChild - node.s * childrenCount;\r\n\r\n        if (!node.children[ds]) {\r\n            var pdOneDay = pd * gmxAPIutils.oneDay,\r\n                t1 = sChild * pdOneDay + zeroUT;\r\n            node.children[ds] = {\r\n                d: d - 1,\r\n                s: sChild,\r\n                t1: t1,\r\n                t2: t1 + pdOneDay,\r\n                count: 0,\r\n                children: [],\r\n                tiles: []\r\n            };\r\n        }\r\n\r\n        addTile(node.children[ds], tile, key);\r\n    };\r\n\r\n    var dmax = periods.length - 1,\r\n        dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,\r\n        i, len;\r\n\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var s = Number(arr[1]),\r\n            d = Number(arr[0]);\r\n\r\n        if (d === maxPeriod) {\r\n            smin = Math.min(smin, s);\r\n        }\r\n    }\r\n    for (i = 0, len = tiles.length; i < len; i++) {\r\n        arr = tiles[i];\r\n        var t = {\r\n            x: Number(arr[2]),\r\n            y: Number(arr[3]),\r\n            z: Number(arr[4]),\r\n            v: Number(vers[i]),\r\n            s: Number(arr[1]),\r\n            d: Number(arr[0])\r\n        };\r\n        if (t.d < 0) {\r\n            continue;\r\n        }\r\n\r\n        var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,\r\n            cs = ds + smin;\r\n\r\n        _rootNodes[ds] = _rootNodes[ds] || {\r\n            d: dmax,\r\n            s: cs,\r\n            t1: cs * dmaxOneDay + zeroUT,\r\n            t2: (cs + 1) * dmaxOneDay + zeroUT,\r\n            count: 0,\r\n            tiles: []\r\n        };\r\n        var key = VectorTile.createTileKey(t);\r\n\r\n        addTile(_rootNodes[ds], t, key);\r\n    }\r\n    tiles = vers = null;\r\n\r\n    //options: bounds (in mercator projection)\r\n    this.selectTiles = function(t1, t2, options) {\r\n\r\n        options = options || {};\r\n\r\n        var t1Val = t1.valueOf() / 1000,\r\n            t2Val = t2.valueOf() / 1000;\r\n\r\n        // We will restrict tile levels by the nearest two levels to target date interval length\r\n        // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles\r\n        var minLevel = 0,\r\n            dateIntervalLength = (t2Val - t1Val) / 3600 / 24;\r\n\r\n        for (var i = 0; i < periods.length; i++) {\r\n            if (periods[i] > dateIntervalLength) {\r\n                minLevel = Math.max(0, i - 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (periods[periods.length - 1] <= dateIntervalLength) {\r\n            minLevel = periods.length - 1;\r\n        }\r\n\r\n        var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));\r\n\r\n        var getCountOfIntersected = function(tileBounds, bounds) {\r\n            var count = 0;\r\n            for (var t = 0; t < tileBounds.length; t++) {\r\n                if (tileBounds[t].intersects(bounds)) {\r\n                    count++;\r\n                }\r\n            }\r\n\r\n            return count;\r\n        };\r\n\r\n        // --------------------\r\n        var selectTilesForNode = function(node, t1, t2) {\r\n            if (t1 >= node.t2 || t2 <= node.t1) {\r\n                return {count: 0, tiles: [], nodes: []};\r\n            }\r\n\r\n            if (options.bounds && !node.tileBounds) {\r\n                node.tileBounds = node.tiles.map(function(it) {\r\n                    return VectorTile.boundsFromTileKey(it);\r\n                });\r\n            }\r\n\r\n            if (node.d === minLevel) {\r\n                var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: count,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n\r\n            var childrenCount = 0, //number of tiles if we use shorter intervals\r\n                childrenRes = [],\r\n\t\t\t\tlen = node.children ? node.children.length : 0,\r\n                ds;\r\n\r\n            for (ds = 0; ds < len; ds++) {\r\n                if (node.children[ds]) {\r\n                    childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));\r\n                } else {\r\n                    childrenRes[ds] = {count: 0, tiles: [], nodes: []};\r\n                }\r\n                childrenCount += childrenRes[ds].count;\r\n            }\r\n\r\n            var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;\r\n\r\n            if (node.d > maxLevel || childrenCount < intersectCount) {\r\n                var resTilesArr = [],\r\n                    resNodesArr = [];\r\n                for (ds = 0; ds < childrenRes.length; ds++) {\r\n                    resNodesArr.push(childrenRes[ds].nodes);\r\n                    resTilesArr.push(childrenRes[ds].tiles);\r\n                }\r\n\r\n                return {\r\n                    tiles: [].concat.apply([], resTilesArr),\r\n                    count: childrenCount,\r\n                    nodes: [].concat.apply([], resNodesArr)\r\n                };\r\n            } else {\r\n                return {\r\n                    tiles: node.tiles,\r\n                    count: intersectCount,\r\n                    nodes: [node]\r\n                };\r\n            }\r\n        };\r\n\r\n        var resTiles = [];\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            if (_rootNodes[ds]) {\r\n                var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);\r\n                if (nodeSelection.tiles.length) {\r\n                    resTiles = resTiles.concat(nodeSelection.tiles);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resTilesHash = {};\r\n        for (var t = 0; t < resTiles.length; t++) {\r\n            resTilesHash[resTiles[t]] = true;\r\n        }\r\n\r\n        return {tiles: resTilesHash};\r\n    };\r\n\r\n    this.getNode = function(d, s) {\r\n        if (d < 0 || s < 0) {\r\n            return null;\r\n        }\r\n\r\n        var findNode = function(node, d, s) {\r\n            if (!node) { return null; }\r\n\r\n            if (periods[node.d] === d) {\r\n                return node.s === s ? node : null;\r\n            }\r\n\r\n            var childrenCount = periods[node.d] / periods[node.d - 1];\r\n            var sChild = Math.floor(s * d / periods[node.d - 1]);\r\n            var ds = sChild - node.s * childrenCount;\r\n\r\n            return node.children[ds] ? findNode(node.children[ds], d, s) : null;\r\n        };\r\n\r\n        for (var ds = 0; ds < _rootNodes.length; ds++) {\r\n            var node = findNode(_rootNodes[ds], d, s);\r\n            if (node) {\r\n                return node;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n};\r\nL.gmx.tilesTree = function(options) {\r\n    return new TilesTree(options);\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/TilesTree.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {VectorTile} from './VectorTile.js';\r\nimport {gmxVectorTileLoader} from './VectorTileLoader.js';\r\n\r\nvar ObserverTileLoader = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n    initialize: function(dataManager) {\r\n        this._dataManager = dataManager;\r\n        this._observerData = {};\r\n        this._tileData = {};\r\n    },\r\n\r\n    addObserver: function(observer) {\r\n        this._observerData[observer.id] = {\r\n            observer: observer,\r\n            tiles: {},\r\n            leftToLoad: 0,\r\n            loadingState: false //are we loading any tiles for this observer?\r\n        };\r\n\r\n        observer.on('update', this._updateObserver.bind(this, observer));\r\n\r\n        this._updateObserver(observer);\r\n\r\n        return this;\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        var obsTiles = this._observerData[id].tiles;\r\n\r\n        for (var tileId in obsTiles) {\r\n            delete this._tileData[tileId].observers[id];\r\n        }\r\n\r\n        delete this._observerData[id];\r\n\r\n        return this;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;\r\n        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));\r\n\r\n        var tileObservers = {};\r\n\r\n        for (var key in this._observerData) {\r\n            var obsInfo = this._observerData[key];\r\n\r\n            if (obsInfo.observer.intersectsWithTile(tile)) {\r\n                obsInfo.tiles[tile.vectorTileKey] = true;\r\n                obsInfo.leftToLoad += leftToLoadDelta;\r\n                tileObservers[key] = true;\r\n            }\r\n        }\r\n\r\n        this._tileData[tile.vectorTileKey] = {\r\n            observers: tileObservers,\r\n            tile: tile\r\n        };\r\n\r\n        return this;\r\n    },\r\n\r\n    removeTile: function(tileId) {\r\n        var tileData = this._tileData[tileId],\r\n            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;\r\n\r\n        for (var id in tileData.observers) {\r\n            var observerData = this._observerData[id];\r\n            observerData.leftToLoad -= leftToLoadDelta;\r\n            delete observerData.tiles[tileId];\r\n        }\r\n\r\n        delete this._tileData[tileId];\r\n\r\n        return this;\r\n    },\r\n\r\n    startLoadTiles: function(observer) {\r\n\r\n        //force active tile list update\r\n        this._dataManager._getActiveTileKeys();\r\n\r\n        var obsData = this._observerData[observer.id];\r\n        if (obsData.leftToLoad === 0) {\r\n            this.fire('observertileload', {observer: observer});\r\n            return this;\r\n        }\r\n\r\n        if (!obsData.loadingState) {\r\n            obsData.loadingState = true;\r\n            observer.fire('startLoadingTiles');\r\n        }\r\n\r\n        for (var tileId in obsData.tiles) {\r\n            this._tileData[tileId].tile.load();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getTileObservers: function(tileId) {\r\n        return this._tileData[tileId].observers;\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerData[observer.id].loadingState;\r\n    },\r\n\r\n    _updateObserver: function(observer) {\r\n        var obsData = this._observerData[observer.id],\r\n            newObserverTiles = {},\r\n            leftToLoad = 0,\r\n            key;\r\n\r\n        for (key in this._tileData) {\r\n            var tile = this._tileData[key].tile;\r\n            if (observer.intersectsWithTile(tile)) {\r\n                newObserverTiles[key] = true;\r\n                if (tile.state !== 'loaded') {\r\n                    leftToLoad++;\r\n                }\r\n                this._tileData[key].observers[observer.id] = true;\r\n            }\r\n        }\r\n\r\n        for (key in obsData.tiles) {\r\n            if (!(key in newObserverTiles)) {\r\n                delete this._tileData[key].observers[observer.id];\r\n            }\r\n        }\r\n\r\n        obsData.tiles = newObserverTiles;\r\n        obsData.leftToLoad = leftToLoad;\r\n    },\r\n\r\n    _tileLoadedCallback: function(tile) {\r\n        this.fire('tileload', {tile: tile});\r\n\r\n        if (!(tile.vectorTileKey in this._tileData)) {\r\n            return;\r\n        }\r\n\r\n        var tileObservers = this._tileData[tile.vectorTileKey].observers;\r\n        for (var id in tileObservers) {\r\n            var obsData = this._observerData[id];\r\n            obsData.leftToLoad--;\r\n\r\n            if (obsData.leftToLoad === 0) {\r\n                if (obsData.loadingState) {\r\n                    obsData.loadingState = false;\r\n                    obsData.observer.fire('stopLoadingTiles');\r\n                }\r\n                this.fire('observertileload', {observer: obsData.observer});\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar DataManager = L.Class.extend({\r\n    includes: L.Mixin.Events,\r\n\r\n    options: {\r\n        name: null,                         // layer ID\r\n        identityField: '',                  // attribute name for identity items\r\n        attributes: [],                     // attributes names\r\n        attrTypes: [],                      // attributes types\r\n        tiles: null,                        // tiles array for nontemporal data\r\n        tilesVers: null,                    // tiles version array for nontemporal data\r\n        LayerVersion: -1,                   // layer version\r\n        GeoProcessing: null,                // processing data\r\n        Temporal: false,                    // only for temporal data\r\n        TemporalColumnName: '',             // temporal attribute name\r\n        ZeroDate: '01.01.2008',             // 0 date string\r\n        TemporalPeriods: [],                // temporal periods\r\n        TemporalTiles: [],                  // temporal tiles array\r\n        TemporalVers: [],                   // temporal version array\r\n        hostName: 'maps.kosmosnimki.ru',    // default hostName\r\n        sessionKey: '',                     // session key\r\n        isGeneralized: false,               // flag for use generalized tiles\r\n        isFlatten: false                    // flag for flatten geometry\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        this._clearProcessing();\r\n        if (options.GeoProcessing) {\r\n            this.processingTile = this.addData([]);\r\n            this._chkProcessing(options.GeoProcessing);\r\n        }\r\n        L.setOptions(this, options);\r\n        this.optionsLink = options;\r\n\r\n        this._isTemporalLayer = this.options.Temporal;\r\n\r\n        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);\r\n        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;\r\n        var hostName = this.options.hostName,\r\n            sessionKey = this.options.sessionKey;\r\n        if (!sessionKey) {\r\n            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);\r\n        }\r\n        this.tileSenderPrefix = 'http://' + hostName + '/' +\r\n            'TileSender.ashx?WrapStyle=None' +\r\n            '&key=' + encodeURIComponent(sessionKey);\r\n\r\n        this._needCheckActiveTiles = true;\r\n    },\r\n\r\n    _vectorTileDataProviderLoad: function(x, y, z, v, s, d, callback) {\r\n        var _this = this;\r\n        gmxVectorTileLoader.load(\r\n            _this.tileSenderPrefix,\r\n            {x: x, y: y, z: z, v: v, s: s, d: d, layerID: _this.options.name}\r\n        ).then(callback, function() {\r\n            console.log('Error loading vector tile');\r\n            callback([]);\r\n            _this.fire('chkLayerUpdate', {dataProvider: _this}); //TODO: do we really need event here?\r\n        });\r\n    },\r\n\r\n    initialize: function(options, clearVersion) {\r\n        this._tilesTree = null;\r\n        this._activeTileKeys = {};\r\n        this._endDate = null;\r\n        this._beginDate = null;\r\n\r\n        this._tiles = {};\r\n        this._filters = {};\r\n        this._freeSubscrID = 0;\r\n        this._items = {};\r\n        this._observers = {};\r\n\r\n        this._needCheckDateInterval = false;\r\n        this._needCheckActiveTiles = true;\r\n\r\n        var _this = this;\r\n        this._vectorTileDataProvider = {\r\n            load: this._vectorTileDataProviderLoad.bind(this)\r\n        };\r\n\r\n        this._observerTileLoader = new ObserverTileLoader(this);\r\n        this._observerTileLoader.on('tileload', function(event) {\r\n            var tile = event.tile;\r\n            _this._updateItemsFromTile(tile);\r\n\r\n            if (_this._tilesTree) {\r\n                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);\r\n                treeNode && treeNode.count--; //decrease number of tiles to load inside this node\r\n            }\r\n        });\r\n\r\n        this._observerTileLoader.on('observertileload', function(event) {\r\n            var observer = event.observer;\r\n            if (observer.isActive()) {\r\n                observer.needRefresh = false;\r\n                observer.updateData(_this.getItems(observer.id));\r\n            }\r\n        });\r\n        this.setOptions(options);\r\n        if (clearVersion) {\r\n\t\t\tthis.options.LayerVersion = -1;\r\n\t\t}\r\n        if (this._isTemporalLayer) {\r\n            this.addFilter('TemporalFilter', function(item, tile, observer) {\r\n                var unixTimeStamp = item.options.unixTimeStamp,\r\n                    dates = observer.dateInterval;\r\n                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();\r\n            });\r\n        }\r\n    },\r\n\r\n    _getActiveTileKeys: function() {\r\n\r\n        this._chkMaxDateInterval();\r\n        if (!this._needCheckActiveTiles) {\r\n            return this._activeTileKeys;\r\n        }\r\n\r\n        this._needCheckActiveTiles = false;\r\n\r\n        if (this._isTemporalLayer) {\r\n            var newTileKeys = {};\r\n            if (this._beginDate && this._endDate) {\r\n                if (!this._tilesTree) {\r\n                    this.initTilesTree();\r\n                }\r\n\r\n                /*var commonBounds = L.gmxUtil.bounds();\r\n                for (var obs in this._observers) {\r\n                    commonBounds.extendBounds(this._observers[obs].bbox);\r\n                }*/\r\n\r\n                newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;\r\n            }\r\n            this._updateActiveTilesList(newTileKeys);\r\n        } else {\r\n            this.initTilesList();\r\n        }\r\n\r\n        return this._activeTileKeys;\r\n    },\r\n\r\n    _getObserversByFilterName: function(filterName) {\r\n        var oKeys = {};\r\n        for (var id in this._observers) {\r\n            if (this._observers[id].hasFilter(filterName)) {\r\n                oKeys[id] = true;\r\n            }\r\n        }\r\n        return oKeys;\r\n    },\r\n\r\n    addFilter: function(filterName, filterFunc) {\r\n        this._filters[filterName] = filterFunc;\r\n        this._triggerObservers(this._getObserversByFilterName(filterName));\r\n    },\r\n\r\n    removeFilter: function(filterName) {\r\n        if (this._filters[filterName]) {\r\n            var oKeys = this._getObserversByFilterName(filterName);\r\n            delete this._filters[filterName];\r\n            this._triggerObservers(oKeys);\r\n        }\r\n    },\r\n\r\n    getItems: function(oId) {\r\n        var resItems = [],\r\n            observer = this._observers[oId];\r\n\r\n        if (!observer) {\r\n            return [];\r\n        }\r\n\r\n        //add internal filters\r\n        var filters = observer.filters.concat('processingFilter');\r\n        this._isTemporalLayer && filters.push('TemporalFilter');\r\n\r\n        filters = filters.filter(function(filter) {\r\n            return filter in this._filters;\r\n        }.bind(this));\r\n\r\n        var _this = this,\r\n            putData = function(tile) {\r\n                var data = tile.data;\r\n                for (var i = 0, len = data.length; i < len; i++) {\r\n                    var dataOption = tile.dataOptions[i];\r\n                    if (!observer.intersects(dataOption.bounds)) { continue; }\r\n\r\n                    var it = data[i],\r\n                        id = it[0],\r\n                        item = _this.getItem(id);\r\n\r\n                    var geom = it[it.length - 1],\r\n                        isFiltered = false;\r\n\r\n                    for (var f = 0; f < filters.length; f++) {\r\n                        var filterFunc = _this._filters[filters[f]];\r\n                        if (!filterFunc(item, tile, observer, geom, dataOption)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!isFiltered) {\r\n                        resItems.push({\r\n                            id: id,\r\n                            properties: it,\r\n                            item: item,\r\n                            dataOption: dataOption,\r\n                            tileKey: tile.vectorTileKey\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n        var activeTileKeys =  this._getActiveTileKeys();\r\n        for (var tkey in activeTileKeys) {\r\n            var tile = _this._tiles[tkey].tile;\r\n            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {\r\n                putData(tile);\r\n            }\r\n        }\r\n\r\n        return resItems;\r\n    },\r\n\r\n    _updateItemsFromTile: function(tile) {\r\n        var vectorTileKey = tile.vectorTileKey,\r\n            data = tile.data || [],\r\n            len = data.length,\r\n            geomIndex = data[0] && (data[0].length - 1);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            var it = data[i],\r\n                geom = it[geomIndex],\r\n                id = it[0],\r\n                item = this._items[id];\r\n            if (item) {\r\n                if (!item.processing) {\r\n                    item.properties = it;\r\n                    if (item.type.indexOf('MULTI') === -1) {\r\n                        item.type = 'MULTI' + item.type;\r\n                    }\r\n                } else {\r\n                    tile.data[i] = item.properties;\r\n                }\r\n                delete item.bounds;\r\n                item.currentFilter = null;\r\n            } else {\r\n                item = {\r\n                    id: id,\r\n                    type: geom.type,\r\n                    properties: it,\r\n                    options: {\r\n                        fromTiles: {}\r\n                    }\r\n                };\r\n                this._items[id] = item;\r\n            }\r\n            item.options.fromTiles[vectorTileKey] = i;\r\n            if (tile.isGeneralized) {\r\n                item.options.isGeneralized = true;\r\n            }\r\n\r\n            if (this.options.TemporalColumnName) {\r\n                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];\r\n                item.options.unixTimeStamp = zn * 1000;\r\n            }\r\n        }\r\n        return len;\r\n    },\r\n\r\n    getMaxDateInterval: function() {\r\n        this._chkMaxDateInterval();\r\n\t\treturn {\r\n\t\t\tbeginDate: this._beginDate,\r\n\t\t\tendDate: this._endDate\r\n\t\t};\r\n    },\r\n\r\n    _chkMaxDateInterval: function() {\r\n        if (this._isTemporalLayer && this._needCheckDateInterval) {\r\n            this._needCheckDateInterval = false;\r\n            var observers = this._observers,\r\n                newBeginDate = null,\r\n                newEndDate = null;\r\n            for (var oId in observers) {\r\n                var observer = observers[oId],\r\n                    dateInterval = observer.dateInterval;\r\n\r\n                if (!dateInterval) {\r\n                    continue;\r\n                }\r\n\r\n                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {\r\n                    newBeginDate = dateInterval.beginDate;\r\n                }\r\n\r\n                if (!newEndDate || dateInterval.endDate > newEndDate) {\r\n                    newEndDate = dateInterval.endDate;\r\n                }\r\n            }\r\n            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {\r\n                this._beginDate = newBeginDate;\r\n                this._endDate = newEndDate;\r\n                this._needCheckActiveTiles = true;\r\n            }\r\n        }\r\n    },\r\n\r\n    addObserver: function(options, id) {\r\n        id = id || 's' + (++this._freeSubscrID);\r\n        var _this = this,\r\n            observer = L.gmx.observer(options);\r\n\r\n        observer.id = id;\r\n        observer.needRefresh = true;\r\n        this._observerTileLoader.addObserver(observer);\r\n\r\n        observer\r\n            .on('update', function(ev) {\r\n                observer.needRefresh = true;\r\n                if (ev.temporalFilter) {\r\n                    _this._needCheckDateInterval = true;\r\n                }\r\n\r\n                _this._waitCheckObservers();\r\n            })\r\n            .on('activate', function() {\r\n                _this.fire('observeractivate');\r\n                _this.checkObserver(observer);\r\n            });\r\n\r\n        _this._needCheckDateInterval = true;\r\n        this._observers[id] = observer;\r\n        this._waitCheckObservers();\r\n\r\n        if (observer.isActive()) {\r\n            this.fire('observeractivate');\r\n        }\r\n\r\n        return observer;\r\n    },\r\n\r\n    getActiveObserversCount: function() {\r\n        var count = 0;\r\n        for (var k in this._observers) {\r\n            if (this._observers[k].isActive()) { count++; }\r\n        }\r\n        return count;\r\n    },\r\n\r\n    getObserver: function(id) {\r\n        return this._observers[id];\r\n    },\r\n\r\n    removeObserver: function(id) {\r\n        if (this._observers[id]) {\r\n            this._observerTileLoader.removeObserver(id);\r\n            var isActive = this._observers[id].isActive();\r\n\r\n            delete this._observers[id];\r\n\r\n            if (isActive) {\r\n                this.fire('observeractivate');\r\n            }\r\n        }\r\n    },\r\n\r\n    getObserverLoadingState: function(observer) {\r\n        return this._observerTileLoader.getObserverLoadingState(observer);\r\n    },\r\n\r\n    getItemsBounds: function() {\r\n        if (!this._itemsBounds) {\r\n            this._itemsBounds = gmxAPIutils.bounds();\r\n            for (var id in this._items) {\r\n                var item = this.getItem(id);\r\n                this._itemsBounds.extendBounds(item.bounds);\r\n            }\r\n        }\r\n        return this._itemsBounds;\r\n    },\r\n\r\n    //combine and return all parts of geometry\r\n    getItem: function(id) {\r\n        var item = this._items[id];\r\n        if (item && !item.bounds) {\r\n            var fromTiles = item.options.fromTiles,\r\n                arr = [];\r\n            for (var key in fromTiles) {    // get full object bounds\r\n                if (this._tiles[key]) {\r\n                    var num = fromTiles[key],\r\n                        tile = this._tiles[key].tile;\r\n                    if (tile.state === 'loaded' && tile.dataOptions[num]) {\r\n                        arr.push(tile.dataOptions[num].bounds);\r\n                    } else {\r\n                        delete fromTiles[key];\r\n                    }\r\n                }\r\n            }\r\n            if (arr.length === 1) {\r\n                item.bounds = arr[0];\r\n            } else {\r\n                item.bounds = gmxAPIutils.bounds();\r\n                var w = gmxAPIutils.worldWidthMerc;\r\n                for (var i = 0, len = arr.length; i < len; i++) {\r\n                    var it = arr[i];\r\n                    if (item.bounds.max.x - it.min.x > w) {\r\n                        it = gmxAPIutils.bounds([\r\n                            [it.min.x + 2 * w, it.min.y],\r\n                            [it.max.x + 2 * w, it.max.y]\r\n                        ]);\r\n                    }\r\n                    item.bounds.extendBounds(it);\r\n                }\r\n            }\r\n        }\r\n        return item;\r\n    },\r\n\r\n    getItemMembers: function(id) {\r\n        var fromTiles = this._items[id].options.fromTiles,\r\n            members = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key]) {\r\n                var tile = this._tiles[key].tile;\r\n                if (tile.data) {\r\n                    var objIndex = fromTiles[key],\r\n                        props = tile.data[objIndex],\r\n                        dataOption = tile.dataOptions[objIndex],\r\n                        bbox = dataOption.bounds;\r\n\r\n                    members.push({\r\n                        geo: props[props.length - 1],\r\n                        width: bbox.max.x - bbox.min.x,\r\n                        dataOption: dataOption\r\n                    });\r\n                }\r\n\r\n            }\r\n        }\r\n        return members.sort(function(a, b) {\r\n            return b.width - a.width;\r\n        });\r\n    },\r\n\r\n    getItemGeometries: function(id) {\r\n        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},\r\n            geomItems = [];\r\n        for (var key in fromTiles) {\r\n            if (this._tiles[key] && this._tiles[key].tile.data) {\r\n                var tileData = this._tiles[key].tile.data,\r\n                    props = tileData[fromTiles[key]];\r\n\r\n                geomItems.push(gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));\r\n            }\r\n        }\r\n        return geomItems;\r\n    },\r\n\r\n    addTile: function(tile) {\r\n        this._tiles[tile.vectorTileKey] = {tile: tile};\r\n        this._getActiveTileKeys()[tile.vectorTileKey] = true;\r\n        this._observerTileLoader.addTile(tile);\r\n        this.checkObservers();\r\n    },\r\n\r\n    checkObserver: function(observer) {\r\n        if (observer.needRefresh && observer.isActive()) {\r\n            this._observerTileLoader.startLoadTiles(observer);\r\n        }\r\n    },\r\n\r\n    checkObservers: function() {\r\n        var observers = this._observers;\r\n        for (var id in this._observers) {\r\n            this.checkObserver(observers[id]);\r\n        }\r\n    },\r\n\r\n    _waitCheckObservers: function() {\r\n        //TODO: refactor\r\n        if (this._checkObserversTimer) {\r\n            clearTimeout(this._checkObserversTimer);\r\n        }\r\n\r\n        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);\r\n    },\r\n\r\n    _triggerObservers: function(oKeys) {\r\n        var keys = oKeys || this._observers;\r\n\r\n        for (var id in keys) {\r\n            if (this._observers[id]) {\r\n                this._observers[id].needRefresh = true;\r\n            }\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    _removeDataFromObservers: function(data) {\r\n        var keys = this._observers;\r\n        for (var id in keys) {\r\n            this._observers[id].removeData(data);\r\n        }\r\n        this._waitCheckObservers();\r\n    },\r\n\r\n    preloadTiles: function(dateBegin, dateEnd, bounds) {\r\n        var tileKeys = {};\r\n        if (this._isTemporalLayer) {\r\n            if (!this._tilesTree) {\r\n                this.initTilesTree();\r\n            }\r\n            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;\r\n        } else {\r\n            this._needCheckActiveTiles = true;\r\n            tileKeys = this._getActiveTileKeys();\r\n        }\r\n\r\n        var loadingDefs = [];\r\n        for (var key in tileKeys) {\r\n            var tile = this._getVectorTile(key, true).tile;\r\n\r\n            if (tile.state !== 'notLoaded') {\r\n                continue;\r\n            }\r\n\r\n            if (bounds && !bounds.intersects(tile.bounds)) {\r\n                continue;\r\n            }\r\n\r\n            var loadDef = tile.load();\r\n            loadingDefs.push(loadDef);\r\n        }\r\n\r\n        return Deferred.all.apply(null, loadingDefs);\r\n    },\r\n\r\n    _updateActiveTilesList: function(newTilesList) {\r\n\r\n        if (this._tileFilteringHook) {\r\n            var filteredTilesList = {};\r\n            for (var tk in newTilesList) {\r\n                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {\r\n                    filteredTilesList[tk] = true;\r\n                }\r\n            }\r\n            newTilesList = filteredTilesList;\r\n        }\r\n\r\n        var oldTilesList = this._activeTileKeys || {};\r\n\r\n        var observersToUpdate = {},\r\n            _this = this,\r\n            key;\r\n\r\n        if (this.processingTile) {\r\n            newTilesList[this.processingTile.vectorTileKey] = true;\r\n        }\r\n        if (this._rasterVectorTile) {\r\n\t\t\tkey = this._rasterVectorTile.vectorTileKey;\r\n            newTilesList[key] = true;\r\n\t\t\tthis._tiles[key] = {tile: this._rasterVectorTile};\r\n\t\t}\r\n\r\n        var checkSubscription = function(vKey) {\r\n            var observerIds = _this._observerTileLoader.getTileObservers(vKey);\r\n            for (var sid in observerIds) {\r\n                observersToUpdate[sid] = true;\r\n            }\r\n        };\r\n\r\n        for (key in newTilesList) {\r\n            if (!oldTilesList[key]) {\r\n                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);\r\n                checkSubscription(key);\r\n            }\r\n        }\r\n\r\n        for (key in oldTilesList) {\r\n            if (!newTilesList[key]) {\r\n                checkSubscription(key);\r\n                this._observerTileLoader.removeTile(key);\r\n            }\r\n        }\r\n\r\n        this._activeTileKeys = newTilesList;\r\n\r\n        this._triggerObservers(observersToUpdate);\r\n    },\r\n\r\n    _propertiesToArray: function(it) {\r\n        var prop = it.properties,\r\n            indexes = this.tileAttributeIndexes,\r\n            arr = [];\r\n\r\n        for (var key in indexes)\r\n            arr[indexes[key]] = prop[key];\r\n\r\n        arr[arr.length] = it.geometry;\r\n        arr[0] = it.id;\r\n        return arr;\r\n    },\r\n\r\n    _clearProcessing: function() {\r\n        if (this.processingTile) {\r\n            var _items = this._items,\r\n                tile = this.processingTile,\r\n                vKey = tile.vectorTileKey,\r\n                data = tile.data || [];\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i][0];\r\n                if (_items[id]) {\r\n                    var item = _items[id];\r\n                    item.processing = null;\r\n                    item.currentFilter = null;\r\n                    delete item.options.fromTiles[vKey];\r\n                    delete item.fromServerProps;\r\n                    delete item.geometry;\r\n               }\r\n            }\r\n            tile.clear();\r\n        }\r\n    },\r\n\r\n    _chkProcessing: function(processing) {\r\n        var _items = this._items,\r\n            needProcessingFilter = false,\r\n            skip = {},\r\n            id, i, len, it, data;\r\n\r\n        if (processing) {\r\n            if (processing.Deleted) {\r\n                for (i = 0, len = processing.Deleted.length; i < len; i++) {\r\n                    id = processing.Deleted[i];\r\n                    skip[id] = true;\r\n                    if (_items[id]) {\r\n                        _items[id].processing = true;\r\n                        _items[id].currentFilter = null;\r\n                    }\r\n                    if (len > 0) { needProcessingFilter = true; }\r\n                }\r\n            }\r\n\r\n            var out = {};\r\n            if (processing.Inserted) {\r\n                for (i = 0, len = processing.Inserted.length; i < len; i++) {\r\n                    it = processing.Inserted[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n            }\r\n\r\n            if (processing.Updated) {\r\n                for (i = 0, len = processing.Updated.length; i < len; i++) {\r\n                    it = processing.Updated[i];\r\n                    if (!skip[it[0]]) { out[it[0]] = it; }\r\n                }\r\n                if (!needProcessingFilter && len > 0) { needProcessingFilter = true; }\r\n            }\r\n\r\n            data = [];\r\n            for (id in out) {\r\n                if (this._items[id]) {\r\n                    this._items[id].properties = out[id];\r\n                    this._items[id].processing = true;\r\n                    this._items[id].currentFilter = null;\r\n                }\r\n                data.push(out[id]);\r\n            }\r\n\r\n            if (data.length > 0) {\r\n                this.processingTile = this.addData(data);\r\n            }\r\n        }\r\n        if (needProcessingFilter) {\r\n            this.addFilter('processingFilter', function(item, tile) {\r\n                return tile.z === 0 || !item.processing;\r\n            });\r\n        } else {\r\n            this.removeFilter('processingFilter');\r\n        }\r\n    },\r\n\r\n    enableGeneralization: function() {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function() {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            this._resetTilesTree();\r\n        }\r\n    },\r\n\r\n    _resetTilesTree: function() {\r\n        this._tilesTree = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    updateVersion: function(options) {\r\n        if (options) {\r\n            this.setOptions(options);\r\n        }\r\n        this._resetTilesTree();\r\n\t\t// this.fire('versionchange');\r\n    },\r\n\r\n    _getDataKeys: function(data) {\r\n        var chkKeys = {};\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            chkKeys[data[i][0]] = true;\r\n        }\r\n        return chkKeys;\r\n    },\r\n\r\n    _getProcessingTile: function() {\r\n        if (!this.processingTile) {\r\n        var x = -0.5, y = -0.5, z = 0, v = 0, s = -1, d = -1, isFlatten = this.options.isFlatten;\r\n\r\n            this.processingTile = new VectorTile({load: function(x, y, z, v, s, d, callback) {\r\n                            callback([]);\r\n            }}, {x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten});\r\n\r\n            this.addTile(this.processingTile);\r\n        }\r\n        return this.processingTile;\r\n    },\r\n\r\n    addData: function(data) {\r\n        if (!data) {\r\n            data = [];\r\n        }\r\n        var vTile = this._getProcessingTile(),\r\n            chkKeys = this._getDataKeys(data),\r\n            dataBounds = vTile.addData(data, chkKeys);\r\n\r\n        if (this._itemsBounds) {\r\n            this._itemsBounds.extendBounds(dataBounds);\r\n        }\r\n        this._updateItemsFromTile(vTile);\r\n        this._triggerObservers();\r\n        return vTile;\r\n    },\r\n\r\n    removeData: function(data) {\r\n        this._itemsBounds = null;\r\n        var vTile = this.processingTile;\r\n        if (vTile) {\r\n            var chkKeys = {};\r\n\r\n            if (!data || !data.length) {\r\n                return vTile;\r\n            }\r\n\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                var id = data[i];\r\n                chkKeys[id] = true;\r\n                delete this._items[id];\r\n            }\r\n            this._removeDataFromObservers(chkKeys);\r\n            vTile.removeData(chkKeys, true);\r\n            this._updateItemsFromTile(vTile);\r\n\r\n            this._triggerObservers();\r\n        }\r\n\r\n        return vTile;\r\n    },\r\n\r\n    initTilesTree: function() {\r\n        this._tilesTree = L.gmx.tilesTree(this.options);\r\n        this.options.TemporalTiles = this.options.TemporalVers = null;\r\n\r\n        if ('TemporalTiles' in this.optionsLink) {\r\n            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;\r\n        }\r\n        this.dateZero = this._tilesTree.dateZero;\r\n        if (this.processingTile) {\r\n            this._tiles[this.processingTile.vectorTileKey] = {\r\n                tile: this.processingTile\r\n            };\r\n        }\r\n    },\r\n\r\n    _getVectorTile: function(vKey, createFlag) {\r\n        if (!this._tiles[vKey] && createFlag) {\r\n            var info = VectorTile.parseTileKey(vKey);\r\n            info.dateZero = this.dateZero;\r\n            this._addVectorTile(info);\r\n        }\r\n        return this._tiles[vKey];\r\n    },\r\n\r\n    _addVectorTile: function(info) {\r\n        info.isFlatten = this.options.isFlatten;\r\n        var tile = new VectorTile(this._vectorTileDataProvider, info),\r\n            vKey = tile.vectorTileKey;\r\n\r\n        this._tiles[vKey] = {tile: tile};\r\n        return vKey;\r\n    },\r\n\r\n    _getGeneralizedTileKeys: function(vTilePoint) {\r\n        var dz = vTilePoint.z % 2 ? 1 : 2,\r\n            pz = Math.pow(2, dz),\r\n            z = vTilePoint.z - dz,\r\n            x = Math.floor(vTilePoint.x / pz),\r\n            y = Math.floor(vTilePoint.y / pz),\r\n            temp = {v: vTilePoint.v, s: -1, d: -1, isGeneralized: true},\r\n            keys = {};\r\n\r\n        while (z > 1) {\r\n            var gKey = [z, x, y].join('_');\r\n            keys[gKey] = L.extend({}, temp, {x: x, y: y, z: z});\r\n            z -= 2;\r\n            x = Math.floor(x / 4);\r\n            y = Math.floor(y / 4);\r\n        }\r\n        return keys;\r\n    },\r\n\r\n    initTilesList: function() {         // For non temporal layers we create all Vector tiles\r\n        var newActiveTileKeys = {};\r\n        if (this.options.tiles) {\r\n            var arr = this.options.tiles || [],\r\n                vers = this.options.tilesVers,\r\n                generalizedKeys = this.options.isGeneralized ? {} : null,\r\n                newTiles = {},\r\n                gKey, tKey, info, tHash;\r\n\r\n            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {\r\n                info = {\r\n                    x: Number(arr[i]),\r\n                    y: Number(arr[i + 1]),\r\n                    z: Number(arr[i + 2]),\r\n                    v: Number(vers[cnt]),\r\n                    s: -1,\r\n                    d: -1\r\n                };\r\n\r\n                tHash = this._getVectorTile(VectorTile.createTileKey(info), true);\r\n                tKey = tHash.tile.vectorTileKey;\r\n                newTiles[tKey] = tHash;\r\n                newActiveTileKeys[tKey] = true;\r\n                if (generalizedKeys) {\r\n                    var gKeys = this._getGeneralizedTileKeys(info);\r\n                    for (gKey in gKeys) {\r\n                        var gPoint = gKeys[gKey];\r\n                        if (generalizedKeys[gKey]) {\r\n                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);\r\n                        } else {\r\n                            generalizedKeys[gKey] = gPoint;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (generalizedKeys) {\r\n                for (gKey in generalizedKeys) {\r\n                    info = generalizedKeys[gKey];\r\n                    tKey = VectorTile.createTileKey(info);\r\n                    if (!newTiles[tKey]) {\r\n                        if (!this._tiles[tKey]) { this._addVectorTile(info); }\r\n                        newTiles[tKey] = this._tiles[tKey];\r\n                        newActiveTileKeys[tKey] = true;\r\n                    }\r\n                }\r\n            }\r\n            this._tiles = newTiles;\r\n            if (this.processingTile) {\r\n                this._tiles[this.processingTile.vectorTileKey] = {\r\n                    tile: this.processingTile\r\n                };\r\n            }\r\n        }\r\n        this._updateActiveTilesList(newActiveTileKeys);\r\n    },\r\n\r\n    //Tile filtering hook filters out active vector tiles.\r\n    //Can be used to prevent loading data from some spatial-temporal region\r\n    setTileFilteringHook: function(filteringHook) {\r\n        this._tileFilteringHook = filteringHook;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    },\r\n\r\n    removeTileFilteringHook: function() {\r\n        this._tileFilteringHook = null;\r\n        this._needCheckActiveTiles = true;\r\n        this._getActiveTileKeys(); //force list update\r\n    }\r\n\r\n});\r\nL.gmx = L.gmx || {};\r\nL.gmx.DataManager = DataManager;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/DataManager/DataManager.js","import {gmxAPIutils} from '../Utils.js';\r\nimport {StyleManager} from './StyleManager.js';\r\nimport {ScreenVectorTile} from './ScreenVectorTile.js';\r\n\r\nL.gmx.VectorLayer = L.TileLayer.Canvas.extend(\r\n{\r\n    options: {\r\n        openPopups: [],\r\n        minZoom: 1,\r\n        zIndexOffset: 0,\r\n        isGeneralized: true,\r\n        isFlatten: false,\r\n        useWebGL: false,\r\n        clickable: true\r\n    },\r\n\r\n    initialize: function(options) {\r\n        options = L.setOptions(this, options);\r\n\r\n        this.initPromise = new L.gmx.Deferred();\r\n\r\n        this._drawQueue = [];\r\n        this._drawQueueHash = {};\r\n\r\n        this._drawInProgress = {};\r\n\r\n        this._anyDrawings = false; //are we drawing something?\r\n        this.repaintObservers = {};    // external observers like screen\r\n\r\n        var _this = this;\r\n\r\n        this._gmx = {\r\n            hostName: gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),\r\n            mapName: options.mapID,\r\n            useWebGL: options.useWebGL,\r\n            layerID: options.layerID,\r\n            beginDate: options.beginDate,\r\n            endDate: options.endDate,\r\n            sortItems: options.sortItems || null,\r\n            styles: options.styles || [],\r\n            tileSubscriptions: {},\r\n            _tilesToLoad: 0,\r\n            shiftXlayer: 0,\r\n            shiftYlayer: 0,\r\n            renderHooks: [],\r\n            preRenderHooks: [],\r\n            _needPopups: {}\r\n        };\r\n        if (options.crossOrigin) {\r\n            this._gmx.crossOrigin = options.crossOrigin;\r\n        }\r\n\r\n        this.on('tileunload', function(e) {\r\n            _this._clearTileSubscription(e.tile.zKey);\r\n        });\r\n    },\r\n\r\n    // extended from L.TileLayer.Canvas\r\n    _removeTile: function (zKey) {\r\n        var tileLink = this._tiles[zKey];\r\n        if (tileLink) {\r\n            var tile = tileLink.el;\r\n            if (tile && tile.parentNode) {\r\n                tile.parentNode.removeChild(tile);\r\n            }\r\n\r\n            delete this._tiles[zKey];\r\n        }\r\n    },\r\n\r\n    onAdd: function(map) {\r\n        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {\r\n            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';\r\n        }\r\n        var gmx = this._gmx;\r\n\r\n        gmx.shiftY = 0;\r\n        gmx.applyShift = map.options.crs === L.CRS.EPSG3857;\r\n        gmx.currentZoom = map.getZoom();\r\n        gmx.styleManager.initStyles();\r\n\r\n        L.TileLayer.Canvas.prototype.onAdd.call(this, map);\r\n\r\n        map.on('zoomstart', this._zoomStart, this);\r\n        map.on('zoomend', this._zoomEnd, this);\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.on('moveend', this._moveEnd, this);\r\n        }\r\n        if (this.options.clickable === false) {\r\n            this._container.style.pointerEvents = 'none';\r\n        }\r\n        if (gmx.balloonEnable && !this._popup) { this.bindPopup(''); }\r\n        this.on('stylechange', this._onStyleChange, this);\r\n        this.on('versionchange', this._onVersionChange, this);\r\n\r\n        // this._zIndexOffsetCheck();\r\n        L.gmx.layersVersion.add(this);\r\n        this.fire('add');\r\n    },\r\n\r\n    onRemove: function(map) {\r\n        if (this._container) {\r\n            this._container.parentNode.removeChild(this._container);\r\n        }\r\n\r\n        map.off({\r\n            'viewreset': this._reset,\r\n            'moveend': this._update\r\n        }, this);\r\n\r\n        if (this._animated) {\r\n            map.off({\r\n                'zoomanim': this._animateZoom,\r\n                'zoomend': this._endZoomAnim\r\n            }, this);\r\n        }\r\n\r\n        if (!this.options.updateWhenIdle) {\r\n            map.off('move', this._limitedUpdate, this);\r\n        }\r\n        this._container = null;\r\n        this._map = null;\r\n\r\n        this._clearAllSubscriptions();\r\n        map.off('zoomstart', this._zoomStart, this);\r\n        map.off('zoomend', this._zoomEnd, this);\r\n        this.off('stylechange', this._onStyleChange, this);\r\n\r\n        var gmx = this._gmx;\r\n\r\n        delete gmx.map;\r\n        if (gmx.properties.type === 'Vector') {\r\n            map.off('moveend', this._moveEnd, this);\r\n        }\r\n        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {\r\n            L.gmx.layersVersion.remove(this);\r\n        }\r\n        this.fire('remove');\r\n    },\r\n\r\n    _initContainer: function () {\r\n        L.TileLayer.Canvas.prototype._initContainer.call(this);\r\n        this._prpZoomData();\r\n        this.setZIndexOffset();\r\n    },\r\n\r\n    _updateZIndex: function () {\r\n        if (this._container) {\r\n            var options = this.options,\r\n                zIndex = options.zIndex || 0,\r\n                zIndexOffset = options.zIndexOffset || 0;\r\n\r\n            this._container.style.zIndex = zIndexOffset + zIndex;\r\n        }\r\n    },\r\n\r\n    _update: function () {\r\n        if (!this._map ||\r\n            this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom\r\n            ) {\r\n            this._clearAllSubscriptions();\r\n            return;\r\n        }\r\n        this._gmx.styleManager.deferred.then(this.__update.bind(this));\r\n    },\r\n\r\n    _addTile: function (tilePoint) {\r\n        var myLayer = this,\r\n            zoom = this._map._zoom,\r\n            gmx = this._gmx;\r\n\r\n        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {\r\n            this._tileLoaded();\r\n            return;\r\n        }\r\n\r\n        var zKey = this._tileCoordsToKey(tilePoint, zoom);\r\n        if (!gmx.tileSubscriptions[zKey]) {\r\n            gmx._tilesToLoad++;\r\n            var isDrawnFirstTime = false,\r\n                gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),\r\n                done = function() {\r\n                    if (!isDrawnFirstTime) {\r\n                        gmx._tilesToLoad--;\r\n                        myLayer._tileLoaded();\r\n                        isDrawnFirstTime = true;\r\n                    }\r\n                },\r\n                attr = {\r\n                    type: 'resend',\r\n                    active: false,\r\n                    bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),\r\n                    filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                    callback: function(data) {\r\n                        myLayer._drawTileAsync(tilePoint, zoom, data).always(done);\r\n                    }\r\n                };\r\n            if (this.options.isGeneralized) {\r\n                attr.targetZoom = zoom;\r\n            }\r\n            if (gmx.layerType === 'VectorTemporal') {\r\n                attr.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n\r\n            var observer = gmx.dataManager.addObserver(attr, zKey);\r\n            observer.on('activate', function() {\r\n                //if observer is deactivated before drawing,\r\n                //we can consider corresponding tile as already drawn\r\n                if (!observer.isActive()) {\r\n                    done();\r\n                }\r\n            });\r\n\r\n            observer.on('startLoadingTiles', this._chkDrawingState, this);\r\n\r\n            gmx.tileSubscriptions[zKey] = {\r\n                z: zoom,\r\n                x: tilePoint.x,\r\n                y: tilePoint.y,\r\n                px: 256 * gmxTilePoint.x,\r\n                py: 256 * (1 + gmxTilePoint.y)\r\n            };\r\n            observer.activate();\r\n        }\r\n    },\r\n\r\n    _chkDrawingState: function() {\r\n        var gmx = this._gmx,\r\n            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;\r\n\r\n        if (!isDrawing) {\r\n            for (var key in gmx.tileSubscriptions) {\r\n                var observer = gmx.dataManager.getObserver(key);\r\n                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {\r\n                    isDrawing = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isDrawing && this._anyDrawings) {\r\n            this.fire('doneDraw');\r\n        } else  if (isDrawing && !this._anyDrawings) {\r\n            this.fire('startDraw');\r\n        }\r\n\r\n        this._anyDrawings = isDrawing;\r\n    },\r\n\r\n    _getLoadedTilesPercentage: function (container) {\r\n        if (!container) { return 0; }\r\n        var len = 0, count = 0;\r\n        var arr = ['img', 'canvas'];\r\n        for (var key in arr) {\r\n            var tiles = container.getElementsByTagName(arr[key]);\r\n            if (tiles && tiles.length > 0) {\r\n                len += tiles.length;\r\n                for (var i = 0, len1 = tiles.length; i < len1; i++) {\r\n                    if (tiles[i]._tileComplete) {\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (len < 1) { return 0; }\r\n        return count / len;\r\n    },\r\n\r\n    _tileLoaded: function () {\r\n        if (this._animated) {\r\n            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n        }\r\n        if (this._gmx._tilesToLoad === 0) {\r\n            this.fire('load');\r\n\r\n            if (this._animated) {\r\n                // clear scaled tiles after all new tiles are loaded (for performance)\r\n                this._setClearBgBuffer(0);\r\n            }\r\n        }\r\n    },\r\n\r\n    _tileOnLoad: function (tile) {\r\n        if (tile) { L.DomUtil.addClass(tile, 'leaflet-tile-loaded'); }\r\n        this._tileLoaded();\r\n    },\r\n\r\n    _tileOnError: function () {\r\n    },\r\n\r\n    tileDrawn: function (tile) {\r\n        this._tileOnLoad(tile);\r\n    },\r\n\r\n    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer\r\n    // converts tile coordinates to key for the tile cache\r\n    _tileCoordsToKey: function (coords, zoom) {\r\n        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);\r\n    },\r\n\r\n    _getTiledPixelBounds: function (center) {\r\n        var map = this._map,\r\n            gmx = this._gmx,\r\n            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),\r\n            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),\r\n            halfSize = map.getSize().divideBy(2);\r\n\r\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\r\n    },\r\n\r\n    _pxBoundsToTileRange: function (bounds) {\r\n        var tileSize = this.options.tileSize;\r\n        return new L.Bounds(\r\n            bounds.min.divideBy(tileSize)._floor(),\r\n            bounds.max.divideBy(tileSize)._round());\r\n    },\r\n\r\n    // original for L.gmx.VectorLayer\r\n\r\n    //public interface\r\n    initFromDescription: function(ph) {\r\n        var gmx = this._gmx;\r\n\r\n        gmx.properties = ph.properties;\r\n        gmx.geometry = ph.geometry;\r\n\r\n        if (gmx.properties._initDone) {    // need delete tiles key\r\n            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];\r\n        }\r\n        gmx.properties._initDone = true;\r\n\r\n        if (!gmx.geometry) {\r\n            var worldSize = gmxAPIutils.tileSizes[1];\r\n            gmx.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n        // Original properties from the server.\r\n        // Descendant classes can override this property\r\n        // Not so good solution, but it works\r\n        gmx.rawProperties = ph.rawProperties || ph.properties;\r\n\r\n        this._updateProperties(ph.properties);\r\n\r\n        ph.properties.isGeneralized = this.options.isGeneralized;\r\n        ph.properties.isFlatten = this.options.isFlatten;\r\n\r\n        gmx.dataManager = this.options.dataManager || new L.gmx.DataManager(ph.properties);\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tif (!ph.properties.styles) { ph.properties.styles = this.options.parentOptions.styles; }\r\n\t\t\tgmx.dataManager.on('versionchange', this._onVersionChange, this);\r\n\t\t}\r\n\r\n\t\tgmx.styleManager = new StyleManager(gmx);\r\n        this.options.minZoom = gmx.styleManager.minZoom;\r\n        this.options.maxZoom = gmx.styleManager.maxZoom;\r\n\r\n        gmx.dataManager.on('observeractivate', function() {\r\n            if (gmx.dataManager.getActiveObserversCount()) {\r\n                L.gmx.layersVersion.add(this);\r\n            } else {\r\n                L.gmx.layersVersion.remove(this);\r\n            }\r\n        }, this);\r\n\r\n        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {\r\n            this.options.chkUpdate = true; //Check updates for vector layers by default\r\n        }\r\n        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {\r\n            this._objectsReorderInit(this);\r\n        }\r\n\r\n        if (gmx.clusters) {\r\n            this.bindClusters(JSON.parse(gmx.clusters));\r\n        }\r\n        if (gmx.filter) {\r\n            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (func) {\r\n\t\t\t\tgmx.dataManager.addFilter('userFilter_' + gmx.layerID, function(item) {\r\n\t\t\t\t\treturn gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes) ? item.properties : null;\r\n\t\t\t\t}.bind(this));\r\n            }\r\n        }\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);\r\n        }\r\n\r\n        this.initPromise.resolve();\r\n        return this;\r\n    },\r\n\r\n    getDataManager: function () {\r\n\t\treturn this._gmx.dataManager;\r\n    },\r\n\r\n    enableGeneralization: function () {\r\n        if (!this.options.isGeneralized) {\r\n            this.options.isGeneralized = true;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.enableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    disableGeneralization: function () {\r\n        if (this.options.isGeneralized) {\r\n            this.options.isGeneralized = false;\r\n            if (this._gmx.dataManager) {\r\n                this._clearAllSubscriptions();\r\n                this._gmx.dataManager.disableGeneralization();\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    setRasterOpacity: function (opacity) {\r\n        var _this = this;\r\n        if (this._gmx.rasterOpacity !== opacity) {\r\n            this._gmx.rasterOpacity = opacity;\r\n            this.initPromise.then(function() {\r\n                _this.repaint();\r\n            });\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStyles: function () {\r\n        return this._gmx.styleManager.getStyles();\r\n    },\r\n\r\n    getIcons: function (callback) {\r\n        this._gmx.styleManager.getIcons(callback);\r\n        return this;\r\n    },\r\n\r\n    setStyles: function (styles) {\r\n        var _this = this;\r\n\r\n        this.initPromise.then(function() {\r\n            _this._gmx.styleManager.clearStyles();\r\n            if (styles) {\r\n                styles.forEach(function(it, i) {\r\n                    _this.setStyle(it, i, true);\r\n                });\r\n            } else {\r\n                _this.fire('stylechange');\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    getStyle: function (num) {\r\n        return this.getStyles()[num];\r\n    },\r\n\r\n    setStyle: function (style, num, createFlag) {\r\n        var _this = this,\r\n            gmx = this._gmx;\r\n        this.initPromise.then(function() {\r\n            gmx.styleManager.setStyle(style, num, createFlag).then(function () {\r\n                _this.fire('stylechange', {num: num || 0});\r\n            });\r\n        });\r\n        return this;\r\n    },\r\n\r\n    setStyleHook: function (func) {\r\n        this._gmx.styleHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeStyleHook: function () {\r\n        this._gmx.styleHook = null;\r\n        return this;\r\n    },\r\n\r\n    setRasterHook: function (func) {\r\n        this._gmx.rasterProcessingHook = func;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    removeRasterHook: function () {\r\n        this._gmx.rasterProcessingHook = null;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    setFilter: function (func) {\r\n        var gmx = this._gmx;\r\n        gmx.dataManager.addFilter('userFilter', function(item) {\r\n            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;\r\n        }.bind(this));\r\n        return this;\r\n    },\r\n\r\n    removeFilter: function () {\r\n        this._gmx.dataManager.removeFilter('userFilter');\r\n        return this;\r\n    },\r\n\r\n    setDateInterval: function (beginDate, endDate) {\r\n        var gmx = this._gmx;\r\n\r\n        if (gmx.dateBegin && gmx.dateEnd) {\r\n\t\t\tbeginDate = gmx.dateBegin;\r\n\t\t\tendDate = gmx.dateEnd;\r\n\t\t}\r\n\r\n        //check that something changed\r\n        if (!gmx.beginDate !== !beginDate ||\r\n            !gmx.endDate !== !endDate ||\r\n            beginDate && (gmx.beginDate.valueOf() !== beginDate.valueOf()) ||\r\n            endDate && (gmx.endDate.valueOf() !== endDate.valueOf())\r\n        ) {\r\n            if (gmx.rawProperties.maxShownPeriod && beginDate) {\r\n                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;\r\n                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));\r\n            }\r\n\r\n            gmx.beginDate = beginDate;\r\n            gmx.endDate = endDate;\r\n\r\n            var observer = null,\r\n\t\t\t\tdataManager = gmx.dataManager;\r\n            for (var key in gmx.tileSubscriptions) {\r\n                observer = dataManager.getObserver(key);\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n            observer = dataManager.getObserver('_Labels');\r\n            if (observer) {\r\n                observer.setDateInterval(beginDate, endDate);\r\n            }\r\n\t\t\tif (window.gmxSkipTiles === 'NotVisible' || gmx.properties.UseTiles === false) {\r\n\t\t\t\tgmx.properties.LayerVersion = -1;\r\n\t\t\t\tdataManager.setOptions({LayerVersion: -1});\r\n\t\t\t\tif (this._map) {\r\n\t\t\t\t\tL.gmx.layersVersion.now();\r\n\t\t\t\t}\r\n\t\t\t}\r\n            this.fire('dateIntervalChanged');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    getDateInterval: function() {\r\n        return {\r\n            beginDate: this._gmx.beginDate,\r\n            endDate: this._gmx.endDate\r\n        };\r\n    },\r\n\r\n    addObserver: function (options) {\r\n        return this._gmx.dataManager.addObserver(options);\r\n    },\r\n\r\n    removeObserver: function(observer) {\r\n        return this._gmx.dataManager.removeObserver(observer.id);\r\n    },\r\n\r\n    setPositionOffset: function(dx, dy) {\r\n        var gmx = this._gmx;\r\n        gmx.shiftXlayer = dx;\r\n        gmx.shiftYlayer = dy;\r\n        this._update();\r\n        return this;\r\n    },\r\n\r\n    getPositionOffset: function() {\r\n        var gmx = this._gmx;\r\n        return {shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer};\r\n    },\r\n\r\n    setZIndexOffset: function (offset) {\r\n        if (arguments.length) {\r\n            this.options.zIndexOffset = offset;\r\n        }\r\n        this._updateZIndex();\r\n        return this;\r\n    },\r\n\r\n    repaint: function (zKeys) {\r\n        if (this._map) {\r\n            if (!zKeys) {\r\n                zKeys = {};\r\n                for (var key in this._gmx.tileSubscriptions) { zKeys[key] = true; }\r\n                L.extend(zKeys, this.repaintObservers);\r\n            }\r\n            this._gmx.dataManager._triggerObservers(zKeys);\r\n        }\r\n    },\r\n\r\n    redrawItem: function (id) {\r\n        if (this._map) {\r\n            var item = this._gmx.dataManager.getItem(id),\r\n                gmxTiles = this._getTilesByBounds(item.bounds);\r\n\r\n            this.repaint(gmxTiles);\r\n        }\r\n    },\r\n\r\n    gmxGetCanvasTile: function (tilePoint) {\r\n        var zKey = this._tileCoordsToKey(tilePoint);\r\n\r\n        if (zKey in this._tiles) {\r\n            return this._tiles[zKey];\r\n        }\r\n        // save tile in cache\r\n        var tile = this._getTile();\r\n        this._tiles[zKey] = {\r\n            el: tile,\r\n            coords: tilePoint,\r\n            current: true\r\n        };\r\n\r\n        // tile._zKey = zKey;\r\n        tile._zoom = this._map._zoom;\r\n        tile._tileComplete = true;\r\n        tile._tilePoint = tilePoint;\r\n        this.tileDrawn(tile);\r\n        return this._tiles[zKey];\r\n    },\r\n\r\n    appendTileToContainer: function (tile) {\r\n        this._tileContainer.appendChild(tile);\r\n        var tilePos = this._getTilePos(tile._tilePoint);\r\n        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);\r\n    },\r\n\r\n    addData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.addData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeData: function(data, options) {\r\n        if (!this._gmx.mapName) {     // client side layer\r\n            this._gmx.dataManager.removeData(data, options);\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    getStylesByProperties: function(propArray, zoom) {\r\n        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);\r\n    },\r\n\r\n    getItemStyle: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        return gmx.styleManager.getObjStyle(item);\r\n    },\r\n\r\n    getTileAttributeTypes: function() {\r\n        return this._gmx.tileAttributeTypes;\r\n    },\r\n\r\n    getTileAttributeIndexes: function() {\r\n        return this._gmx.tileAttributeIndexes;\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id),\r\n            styles = this.getStyles(),\r\n            out = '';\r\n\r\n        if (item && styles[item.currentFilter]) {\r\n            var propsArr = item.properties;\r\n            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {\r\n                properties: this.getItemProperties(propsArr),\r\n                geometries: [propsArr[propsArr.length - 1]],\r\n                tileAttributeTypes: gmx.tileAttributeTypes,\r\n                unitOptions: this._map ? this._map.options : {}\r\n            });\r\n        }\r\n        return out;\r\n    },\r\n\r\n    getItemProperties: function(propArray) {\r\n        var properties = {},\r\n            indexes = this._gmx.tileAttributeIndexes;\r\n        for (var key in indexes) {\r\n            properties[key] = propArray[indexes[key]];\r\n        }\r\n        return properties;\r\n    },\r\n\r\n    addPreRenderHook: function(renderHook) {\r\n        this._gmx.preRenderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removePreRenderHook: function(hook) {\r\n        var arr = this._gmx.preRenderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    addRenderHook: function(renderHook) {\r\n        this._gmx.renderHooks.push(renderHook);\r\n        this.repaint();\r\n    },\r\n\r\n    removeRenderHook: function(hook) {\r\n        var arr = this._gmx.renderHooks;\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === hook) {\r\n                arr.splice(i, 1);\r\n                this.repaint();\r\n                break;\r\n            }\r\n        }\r\n    },\r\n\r\n    //get original properties from the server\r\n    getGmxProperties: function() {\r\n        return this._gmx.rawProperties;\r\n    },\r\n\r\n    //returns L.LatLngBounds\r\n    getBounds: function() {\r\n        var proj = L.Projection.Mercator,\r\n            gmxBounds = this._gmx.layerID ? gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();\r\n\r\n        if (gmxBounds) {\r\n            return L.latLngBounds([proj.unproject(gmxBounds.min), proj.unproject(gmxBounds.max)]);\r\n        } else {\r\n            return new L.LatLngBounds();\r\n        }\r\n    },\r\n\r\n    getGeometry: function() {\r\n        if (!this._gmx.latLngGeometry) {\r\n            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true);\r\n        }\r\n\r\n        return this._gmx.latLngGeometry;\r\n    },\r\n\r\n    // internal methods\r\n    _clearTileSubscription: function(zKey) {\r\n        var gmx = this._gmx;\r\n\r\n        if (zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            delete gmx.tileSubscriptions[zKey];\r\n            this._removeTile(zKey);\r\n\r\n            if (this._anyDrawings) {\r\n                this._chkDrawingState();\r\n            }\r\n        }\r\n\r\n        if (zKey in this._drawQueueHash) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n    },\r\n\r\n    _clearAllSubscriptions: function() {\r\n        while (this._drawQueue.length) {\r\n            this._drawQueue[0].def.cancel();\r\n        }\r\n\r\n        var gmx = this._gmx;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.screenTile) {\r\n                subscription.screenTile.destructor();\r\n            }\r\n\t\t\tvar observer = gmx.dataManager.getObserver(zKey);\r\n            if (observer) { observer.deactivate(); }\r\n            gmx.dataManager.removeObserver(zKey);\r\n            delete gmx.tileSubscriptions[zKey];\r\n            delete this._tiles[zKey];\r\n        }\r\n\r\n        if (this._anyDrawings) {\r\n            this._chkDrawingState();\r\n        }\r\n\r\n        gmx._tilesToLoad = 0;\r\n    },\r\n\r\n    _zoomStart: function() {\r\n        this._gmx.zoomstart = true;\r\n    },\r\n\r\n    _zoomEnd: function() {\r\n        this._gmx.zoomstart = false;\r\n        this.setCurrentZoom(this._map);\r\n        // this._zIndexOffsetCheck();\r\n    },\r\n\r\n    _moveEnd: function() {\r\n        if ('dataManager' in this._gmx) {\r\n            this._gmx.dataManager.fire('moveend');\r\n        }\r\n    },\r\n\r\n    _onStyleChange: function() {\r\n        var gmx = this._gmx;\r\n        if (!gmx.balloonEnable && this._popup) {\r\n            this.unbindPopup();\r\n        } else if (gmx.balloonEnable && !this._popup) {\r\n            this.bindPopup('');\r\n        }\r\n        if (this._map) {\r\n            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {\r\n                this.options.minZoom = gmx.styleManager.minZoom;\r\n                this.options.maxZoom = gmx.styleManager.maxZoom;\r\n                this._map._updateZoomLevels();\r\n            }\r\n            if (gmx.labelsLayer) {\r\n                this._map._labelsLayer.add(this);\r\n            } else if (!gmx.labelsLayer) {\r\n                this._map._labelsLayer.remove(this);\r\n            }\r\n            if (Object.keys(gmx.tileSubscriptions).length > 0) {\r\n                for (var key in gmx.tileSubscriptions) {    // recheck bbox on screen observers\r\n                    var observer = gmx.dataManager.getObserver(key),\r\n                        parsedKey = gmx.tileSubscriptions[key],\r\n                        gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),\r\n                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);\r\n                    if (!observer.bbox.isEqual(bbox)) {\r\n                        var proj = L.Projection.Mercator;\r\n                        observer.setBounds(L.latLngBounds([proj.unproject(bbox.min), proj.unproject(bbox.max)]));\r\n                    }\r\n                }\r\n            } else {\r\n                this.redraw();\r\n            }\r\n        }\r\n    },\r\n\r\n    _removeInProgressDrawing: function(zKey) {\r\n        delete this._drawInProgress[zKey];\r\n        this._chkDrawingState();\r\n    },\r\n\r\n    _drawTileAsync: function (tilePoint, zoom, data) {\r\n        var queue = this._drawQueue,\r\n            isEmpty = queue.length === 0,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            _this = this;\r\n\r\n        if (this._drawQueueHash[zKey]) {\r\n            this._drawQueueHash[zKey].cancel();\r\n        }\r\n\r\n        var drawNextTile = function() {\r\n            _this._chkDrawingState();\r\n\r\n            if (!queue.length) {\r\n                return;\r\n            }\r\n\r\n            var queueItem = queue.shift();\r\n            delete _this._drawQueueHash[queueItem.zKey];\r\n            if (_this._map && queueItem.z === _this._map._zoom) {\r\n                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);\r\n\r\n                _this._drawInProgress[queueItem.zKey] = true;\r\n\r\n                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));\r\n\r\n                queueItem.drawDef.then(\r\n                    queueItem.def.resolve.bind(queueItem.def, queueItem.data),\r\n                    queueItem.def.reject\r\n                );\r\n            } else {\r\n                queueItem.def.reject();\r\n            }\r\n            setTimeout(drawNextTile, 0);\r\n        };\r\n\r\n        var gtp = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);\r\n        var queueItem = {gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data};\r\n        var def = queueItem.def = new L.gmx.Deferred(function() {\r\n            queueItem.drawDef && queueItem.drawDef.cancel();\r\n\r\n            _this._removeInProgressDrawing(zKey);\r\n\r\n            delete _this._drawQueueHash[zKey];\r\n            for (var i = queue.length - 1; i >= 0; i--) {\r\n                var elem = queue[i];\r\n                if (elem.zKey === zKey) {\r\n                    queue.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        queue.push(queueItem);\r\n\r\n        this._drawQueueHash[zKey] = def;\r\n\r\n        if (isEmpty) {\r\n            setTimeout(drawNextTile, 0);\r\n        }\r\n\r\n        return def;\r\n    },\r\n\r\n    _updateShiftY: function() {\r\n        var gmx = this._gmx,\r\n            map = this._map,\r\n            deltaY = 0;\r\n\r\n        if (map) {\r\n            var pos = map.getCenter();\r\n            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;\r\n        }\r\n\r\n        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));\r\n        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));\r\n        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY);     //  \r\n\r\n        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);\r\n    },\r\n\r\n    _prpZoomData: function() {\r\n        this.setCurrentZoom(this._map);\r\n        // this.repaint();\r\n    },\r\n\r\n    setCurrentZoom: function(map) {\r\n        var gmx = this._gmx;\r\n        gmx.currentZoom = map._zoom;\r\n        gmx.tileSize = gmxAPIutils.tileSizes[gmx.currentZoom];\r\n        gmx.mInPixel = 256 / gmx.tileSize;\r\n    },\r\n\r\n    // _zIndexOffsetCheck: function() {\r\n        // var gmx = this._gmx;\r\n        // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {\r\n            // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;\r\n            // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;\r\n            // if (zIndexOffset !== this.options.zIndexOffset) {\r\n                // this.setZIndexOffset(zIndexOffset);\r\n            // }\r\n        // }\r\n    // },\r\n\r\n    _setClearBgBuffer: function (zd) {\r\n        if (this._clearBgBufferTimer) { clearTimeout(this._clearBgBufferTimer); }\r\n        var _this = this;\r\n        this._clearBgBufferTimer = setTimeout(function () {\r\n            if (_this._bgBuffer) {\r\n                _this._clearBgBuffer();\r\n            }\r\n        }, zd || 0);\r\n    },\r\n\r\n    _getNeedPopups: function () {\r\n        var out = {},\r\n            openPopups = this.options.openPopups;\r\n        for (var i = 0, len = openPopups.length; i < len; i++) {\r\n            out[openPopups[i]] = false;\r\n        }\r\n        return out;\r\n    },\r\n\r\n    __update: function () {\r\n        var map = this._map;\r\n        if (!map) { return; }\r\n        var zoom = map.getZoom(),\r\n            center = map.getCenter();\r\n\r\n        if (this._gmx.applyShift) {\r\n            this._updateShiftY();\r\n        }\r\n        this._tileZoom = zoom;\r\n        if (this.options.openPopups.length) {\r\n            this._gmx._needPopups = this._getNeedPopups();\r\n            this.options.openPopups = [];\r\n        }\r\n\r\n        var pixelBounds = this._getTiledPixelBounds(center),\r\n            tileRange = this._pxBoundsToTileRange(pixelBounds),\r\n            limit = this._getWrapTileNum();\r\n\r\n        if (tileRange.min.y < 0) { tileRange.min.y = 0; }\r\n        if (tileRange.max.y >= limit.y) { tileRange.max.y = limit.y - 1; }\r\n\r\n        this._chkTileSubscriptions(zoom, tileRange);\r\n\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            this._setClearBgBuffer(500);\r\n            return;\r\n        }\r\n\r\n        // create a queue of coordinates to load tiles from\r\n        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\r\n            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\r\n                var coords = new L.Point(i, j);\r\n                coords.z = this._tileZoom;\r\n\r\n                if (!this._tiles[this._tileCoordsToKey(coords)]) {\r\n                    this._addTile(coords);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkTileSubscriptions: function (zoom, tileRange) {\r\n        //L.TileVector will remove all tiles from other zooms.\r\n        //But it will not remove subscriptions without tiles - we should do it ourself\r\n        var gmx = this._gmx,\r\n            min = tileRange.min,\r\n            max = tileRange.max;\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey];\r\n            if (subscription.z !== zoom\r\n                || subscription.x < min.x\r\n                || subscription.x > max.x\r\n                || subscription.y < min.y\r\n                || subscription.y > max.y\r\n            ) {\r\n                this._clearTileSubscription(zKey);\r\n            }\r\n        }\r\n    },\r\n\r\n    _getScreenTile: function (tilePoint, zoom) {\r\n        var gmx = this._gmx,\r\n            zKey = this._tileCoordsToKey(tilePoint, zoom),\r\n            subscription = gmx.tileSubscriptions[zKey],\r\n            screenTile = null;\r\n        if (subscription) {\r\n            if (subscription.screenTile) {\r\n                screenTile = subscription.screenTile;\r\n            } else {\r\n                subscription.screenTile = screenTile = new ScreenVectorTile(this, tilePoint, zoom);\r\n            }\r\n        }\r\n        return screenTile;\r\n    },\r\n\r\n    _gmxDrawTile: function (tilePoint, zoom, data) {\r\n        var gmx = this._gmx,\r\n            cancelled = false,\r\n            screenTileDrawPromise = null,\r\n            def = new L.gmx.Deferred(function() {\r\n                cancelled = true;\r\n                screenTileDrawPromise && screenTileDrawPromise.cancel();\r\n            });\r\n\r\n        if (!this._map) {\r\n            def.reject();\r\n            return def;\r\n        }\r\n        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);\r\n        if (screenTile) {\r\n            gmx.styleManager.deferred.then(function () {\r\n                if (!cancelled) {\r\n                    screenTileDrawPromise = screenTile.drawTile(data);\r\n                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);\r\n                }\r\n            });\r\n        }\r\n       return def;\r\n    },\r\n\r\n    _getTilesByBounds: function (bounds) {    //   gmxTiles  bounds\r\n        var gmx = this._gmx,\r\n            zoom = this._map._zoom,\r\n            shiftX = gmx.shiftX || 0,   //  \r\n            shiftY = gmx.shiftY || 0,   //   + OSM\r\n            minLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.min.x, bounds.min.y)),\r\n            maxLatLng = L.Projection.Mercator.unproject(new L.Point(bounds.max.x, bounds.max.y)),\r\n            screenBounds = this._map.getBounds(),\r\n            sw = screenBounds.getSouthWest(),\r\n            ne = screenBounds.getNorthEast(),\r\n            dx = 0;\r\n\r\n        if (ne.lng - sw.lng < 360) {\r\n            if (maxLatLng.lng < sw.lng) {\r\n                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));\r\n            } else if (minLatLng.lng > ne.lng) {\r\n                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);\r\n            }\r\n        }\r\n        minLatLng.lng += dx;\r\n        maxLatLng.lng += dx;\r\n\r\n        var pixelBounds = this._map.getPixelBounds(),\r\n            minPoint = this._map.project(minLatLng),\r\n            maxPoint = this._map.project(maxLatLng);\r\n\r\n        var minY, maxY, minX, maxX;\r\n        if (pixelBounds) {\r\n            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);\r\n            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);\r\n            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);\r\n            minX = Math.floor((minX + shiftX) / 256);\r\n            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);\r\n            maxX = Math.floor((maxX + shiftX) / 256);\r\n        } else {\r\n            minY = Math.floor((maxPoint.y + shiftY) / 256);\r\n            maxY = Math.floor((minPoint.y + shiftY) / 256);\r\n            minX = Math.floor((minPoint.x + shiftX) / 256);\r\n            maxX = Math.floor((maxPoint.x + shiftX) / 256);\r\n        }\r\n        var gmxTiles = {};\r\n        for (var x = minX; x <= maxX; x++) {\r\n            for (var y = minY; y <= maxY; y++) {\r\n                var zKey = this._tileCoordsToKey({x: x, y: y}, zoom);\r\n                gmxTiles[zKey] = true;\r\n            }\r\n        }\r\n        return gmxTiles;\r\n    },\r\n\r\n    _updateProperties: function (prop) {\r\n        var gmx = this._gmx,\r\n            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;\r\n\r\n        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || L.gmx.gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received\r\n\r\n        if (this.options.parentOptions) {\r\n\t\t\tprop = this.options.parentOptions;\r\n\t\t}\r\n\r\n        gmx.identityField = prop.identityField; // ogc_fid\r\n        gmx.GeometryType = (prop.GeometryType || '').toLowerCase();   //     \r\n        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1;// . zoom  \r\n        gmx.minZoomQuicklooks = gmx.minZoomRasters; //   minZoom     \r\n\r\n        var type = prop.type || 'Vector';\r\n        if (prop.Temporal) { type += 'Temporal'; }\r\n        gmx.layerType = type;   // VectorTemporal Vector\r\n        gmx.items = {};\r\n\r\n        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));\r\n        if (gmx.dataManager) {\r\n            gmx.dataManager.setOptions(prop);\r\n        }\r\n        if ('ZIndexField' in prop) {\r\n            if (prop.ZIndexField in gmx.tileAttributeIndexes) {\r\n                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField];   // sort field index\r\n            }\r\n        }\r\n        if (this._objectsReorder) {\r\n            this._objectsReorder.initialize();\r\n        }\r\n\r\n        // if ('clusters' in prop) {\r\n            // gmx.clusters = prop.clusters;\r\n        // }\r\n\r\n        gmx.filter = prop.filter; \t// for dataSource attr\r\n        gmx.dateBegin = prop.dateBegin;\r\n        gmx.dateEnd = prop.dateEnd;\r\n        gmx.dataSource = prop.dataSource;\r\n        if ('MetaProperties' in gmx.rawProperties) {\r\n            var meta = gmx.rawProperties.MetaProperties;\r\n            if ('parentLayer' in meta) {  //  \t\t// todo     \r\n                gmx.dataSource = meta.parentLayer.Value || '';\r\n            }\r\n            if ('filter' in meta) {  //  \r\n                gmx.filter = meta.filter.Value || '';\r\n            }\r\n            if ('dateBegin' in meta) {  //    \r\n                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');\r\n            }\r\n            if ('dateEnd' in meta) {  //    \r\n                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');\r\n            }\r\n            if ('shiftX' in meta || 'shiftY' in meta) {  //   \r\n                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;\r\n                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;\r\n            }\r\n            if ('shiftXfield' in meta || 'shiftYfield' in meta) {    //     \r\n                if (meta.shiftXfield) { gmx.shiftXfield = meta.shiftXfield.Value; }\r\n                if (meta.shiftYfield) { gmx.shiftYfield = meta.shiftYfield.Value; }\r\n            }\r\n            if ('quicklookPlatform' in meta) {    //  \r\n                gmx.quicklookPlatform = meta.quicklookPlatform.Value;\r\n                if (gmx.quicklookPlatform === 'image') { delete gmx.quicklookPlatform; }\r\n            }\r\n            if ('quicklookX1' in meta) { gmx.quicklookX1 = meta.quicklookX1.Value; }\r\n            if ('quicklookY1' in meta) { gmx.quicklookY1 = meta.quicklookY1.Value; }\r\n            if ('quicklookX2' in meta) { gmx.quicklookX2 = meta.quicklookX2.Value; }\r\n            if ('quicklookY2' in meta) { gmx.quicklookY2 = meta.quicklookY2.Value; }\r\n            if ('quicklookX3' in meta) { gmx.quicklookX3 = meta.quicklookX3.Value; }\r\n            if ('quicklookY3' in meta) { gmx.quicklookY3 = meta.quicklookY3.Value; }\r\n            if ('quicklookX4' in meta) { gmx.quicklookX4 = meta.quicklookX4.Value; }\r\n            if ('quicklookY4' in meta) { gmx.quicklookY4 = meta.quicklookY4.Value; }\r\n\r\n            if ('multiFilters' in meta) {    //      \r\n                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;\r\n            }\r\n            if ('isGeneralized' in meta) {    // Set generalization\r\n                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';\r\n            }\r\n            if ('isFlatten' in meta) {        // Set flatten geometry\r\n                this.options.isFlatten = meta.isFlatten.Value !== 'false';\r\n            }\r\n        }\r\n        if (prop.Temporal) {    // Clear generalization flag for Temporal layers\r\n            this.options.isGeneralized = false;\r\n        }\r\n\r\n        if (prop.IsRasterCatalog) {\r\n            gmx.IsRasterCatalog = prop.IsRasterCatalog;\r\n            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;\r\n            if (layerLink) {\r\n                gmx.rasterBGfunc = function(x, y, z, item) {\r\n                    var properties = item.properties;\r\n                    return 'http://' + gmx.hostName\r\n                        + '/TileSender.ashx?ModeKey=tile'\r\n                        + '&x=' + x\r\n                        + '&y=' + y\r\n                        + '&z=' + z\r\n                        + '&LayerName=' + properties[layerLink]\r\n                        + '&key=' + encodeURIComponent(gmx.sessionKey);\r\n                };\r\n            }\r\n        }\r\n        if (prop.Quicklook) {\r\n            var quicklookParams;\r\n\r\n            //       ,    JSON'\r\n            if (prop.Quicklook[0] === '{') {\r\n                quicklookParams = JSON.parse(prop.Quicklook);\r\n            } else {\r\n                quicklookParams = {\r\n                    minZoom: gmx.minZoomRasters,\r\n                    template: prop.Quicklook\r\n                };\r\n            }\r\n\r\n            if ('X1' in quicklookParams) { gmx.quicklookX1 = quicklookParams.X1; }\r\n            if ('Y1' in quicklookParams) { gmx.quicklookY1 = quicklookParams.Y1; }\r\n            if ('X2' in quicklookParams) { gmx.quicklookX2 = quicklookParams.X2; }\r\n            if ('Y2' in quicklookParams) { gmx.quicklookY2 = quicklookParams.Y2; }\r\n            if ('X3' in quicklookParams) { gmx.quicklookX3 = quicklookParams.X3; }\r\n            if ('Y3' in quicklookParams) { gmx.quicklookY3 = quicklookParams.Y3; }\r\n            if ('X4' in quicklookParams) { gmx.quicklookX4 = quicklookParams.X4; }\r\n            if ('Y4' in quicklookParams) { gmx.quicklookY4 = quicklookParams.Y4; }\r\n\r\n            var template = gmx.Quicklook = quicklookParams.template;\r\n            if ('minZoom' in quicklookParams) { gmx.minZoomQuicklooks = quicklookParams.minZoom; }\r\n            gmx.quicklookBGfunc = function(item) {\r\n                var url = template,\r\n                    reg = /\\[([^\\]]+)\\]/,\r\n                    matches = reg.exec(url);\r\n                while (matches && matches.length > 1) {\r\n                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);\r\n                    matches = reg.exec(url);\r\n                }\r\n                return url;\r\n            };\r\n            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;\r\n        }\r\n        this.options.attribution = prop.Copyright || '';\r\n    },\r\n\r\n    _onVersionChange: function () {\r\n        this._updateProperties(this._gmx.rawProperties);\r\n    },\r\n\r\n    getViewRasters: function() {\r\n        var gmx = this._gmx,\r\n\t\t\thash = {},\r\n\t\t\tout = [];\r\n\r\n        for (var zKey in gmx.tileSubscriptions) {\r\n            var subscription = gmx.tileSubscriptions[zKey],\r\n\t\t\t\tscreenTile = subscription.screenTile;\r\n            if (screenTile) {\r\n                screenTile.itemsView.forEach(function(it) {\r\n\t\t\t\t\thash[it.id] = true;\r\n\t\t\t\t});\r\n            }\r\n        }\r\n        for (var id in hash) {\r\n\t\t\tout.push(id);\r\n\t\t}\r\n\r\n        return out;\r\n    },\r\n\r\n    getPropItem: function (key, propArr) {\r\n        return gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nvar StyleManager = function(gmx) {\r\n    this.gmx = gmx;\r\n    this.deferred = new L.gmx.Deferred();\r\n\r\n    this._maxVersion = 0;\r\n    this._maxStyleSize = 0;\r\n    this._styles = [];\r\n    this._deferredIcons = [];\r\n    this._parserFunctions = {};\r\n    this._serverStylesParsed = false;\r\n\r\n    var minZoom = Infinity,\r\n        maxZoom = -Infinity,\r\n        arr = gmx.properties.styles || [];\r\n\r\n    for (var i = 0, len = arr.length; i < len; i++) {\r\n        var st = arr[i];\r\n        minZoom = Math.min(minZoom, st.MinZoom);\r\n        maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n    }\r\n    this.minZoom = minZoom === Infinity ? 0 : minZoom;\r\n    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;\r\n};\r\nStyleManager.prototype = {\r\n    _getMaxStyleSize: function(zoom) {  // estimete style size for arbitrary object\r\n        var maxSize = 0;\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom > style.MaxZoom || zoom < style.MinZoom) { continue; }\r\n            var RenderStyle = style.RenderStyle;\r\n            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {\r\n            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {\r\n                maxSize = StyleManager.MAX_STYLE_SIZE;\r\n                break;\r\n            }\r\n            var maxShift = 0;\r\n            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {\r\n                maxShift = Math.max(\r\n                    Math.abs(RenderStyle.iconAnchor[0]),\r\n                    Math.abs(RenderStyle.iconAnchor[1])\r\n                );\r\n            }\r\n            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);\r\n        }\r\n        return maxSize;\r\n    },\r\n\r\n    getStyleBounds: function(gmxTilePoint) {\r\n        if (!gmxTilePoint) {\r\n            return gmxAPIutils.bounds();\r\n        }\r\n\r\n        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);\r\n\r\n        var mercSize = 2 * this._maxStyleSize * gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula\r\n        return gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);\r\n    },\r\n\r\n    //is any style is visible at given zoom?\r\n    isVisibleAtZoom: function(zoom) {\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = this._styles[i];\r\n            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    getIcons: function(callback) {\r\n        var _this = this;\r\n        this.deferred.then(function() {\r\n            var out = [];\r\n            for (var i = 0, len = _this._styles.length; i < len; i++) {\r\n                var style = _this._styles[i],\r\n                    pt = {};\r\n                if (style.RenderStyle) {\r\n                    pt.RenderStyle = {image: style.RenderStyle.image};\r\n                }\r\n                if (style.HoverStyle) {\r\n                    pt.HoverStyle = {image: style.HoverStyle.image};\r\n                }\r\n                out.push(pt);\r\n            }\r\n            if (callback) {\r\n                callback(out);\r\n            }\r\n        });\r\n        this.initStyles();\r\n    },\r\n\r\n    _chkReady: function() {\r\n        if (this._needLoadIcons < 1) {\r\n            var _this = this;\r\n\t\t\tif (this.gmx.dataManager) {\r\n\t\t\t\tthis.gmx.dataManager.addFilter('styleFilter', function(it) { return _this._chkStyleFilter(it); });\r\n\t\t\t}\r\n            this.deferred.resolve();\r\n        }\r\n    },\r\n\r\n    initStyles: function() {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {\r\n            this._getImageSize(this._deferredIcons[i]);\r\n        }\r\n        this._deferredIcons = [];\r\n        this._chkReady();\r\n        return this.deferred;\r\n    },\r\n\r\n    getStyles: function () {\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        var out = [];\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var style = L.extend({}, this._styles[i]);\r\n            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);\r\n            if (style.HoverStyle) {\r\n                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);\r\n            }\r\n            delete style.filterFunction;\r\n            delete style.version;\r\n            delete style.common;\r\n            delete style.type;\r\n            out.push(style);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    clearStyles: function () {\r\n        this._styles = [];\r\n        this.gmx.balloonEnable = false;\r\n        this.gmx.labelsLayer = false;\r\n    },\r\n\r\n    _changeStylesVersion: function () {\r\n        var _this = this;\r\n        this._styles.map(function(it) {\r\n            it.version = ++_this._maxVersion;\r\n        });\r\n    },\r\n\r\n    setStyle: function(st, num, createFlag) {\r\n        num = num || 0;\r\n        if (num < this._styles.length || createFlag) {\r\n            var style = this._styles[num];\r\n            if (!style) {\r\n                style = this._prepareItem({});\r\n                this._styles[num] = style;\r\n            }\r\n            this.deferred = new L.gmx.Deferred();\r\n            style.version = ++this._maxVersion;\r\n            if ('Filter' in st) {\r\n                style.Filter = st.Filter;\r\n                var type = typeof (st.Filter);\r\n                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'))\r\n                    : type === 'function' ? style.Filter : null;\r\n\r\n                this._changeStylesVersion();\r\n            }\r\n            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {\r\n                var key = StyleManager.DEFAULT_KEYS[i];\r\n                if (key in st) { style[key] = st[key]; }\r\n            }\r\n            if (st.RenderStyle) {\r\n                style.RenderStyle = this._parseStyle(st.RenderStyle);\r\n            }\r\n            if (st.HoverStyle) { style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle); }\r\n            this._checkStyles();\r\n        }\r\n        return this.initStyles();\r\n    },\r\n\r\n    getItemBalloon: function(id) {\r\n        var item = this.gmx.dataManager.getItem(id),\r\n            currentFilter = item ? item.currentFilter : 0,\r\n            style = this._styles[currentFilter];\r\n        return style ? {\r\n                DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,\r\n                DisableBalloonOnClick: style.DisableBalloonOnClick || false,\r\n                templateBalloon: style.Balloon || null,\r\n                isSummary: /\\[SUMMARY\\]/.test(style.Balloon)\r\n            }\r\n            : null\r\n        ;\r\n    },\r\n\r\n    // apply styleHook func\r\n    // applyStyleHook: function(item, hoverFlag) {\r\n        // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));\r\n    // },\r\n\r\n    getObjStyle: function(item) {\r\n        this._chkStyleFilter(item);\r\n        var style = this._styles[item.currentFilter],\r\n            version;\r\n\r\n        if (!style) { return null; }\r\n        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {\r\n            if (style.HoverStyle) {\r\n                version = style.HoverStyle.version || -1;\r\n                if (version !== item.styleVersion) {\r\n                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);\r\n                }\r\n                return style.HoverStyle;\r\n            } else {\r\n                delete item.parsedStyleHover;\r\n            }\r\n            return null;\r\n        }\r\n        version = style.version || -1;\r\n        if (version !== item.styleVersion) {\r\n            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);\r\n        }\r\n        return style.RenderStyle;\r\n    },\r\n\r\n    _needLoadIcons: 0,\r\n    _getImageSize: function(pt) {     // check image size\r\n        var url = pt.iconUrl || pt.fillIconUrl,\r\n            opt = pt.iconAngle || pt.iconScale ? {crossOrigin: 'anonymous'} : {},\r\n            _this = this;\r\n\r\n        if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {\r\n            opt = {};   // skip bug in IE11\r\n        }\r\n        opt.layerID = this.gmx.layerID;\r\n        ++this._needLoadIcons;\r\n        L.gmx.imageLoader.unshift(url, opt).def.then(\r\n            function(it) {\r\n                pt.version = ++_this._maxVersion;\r\n                if (pt.fillIconUrl) {\r\n                    pt.imagePattern = it;\r\n                } else {\r\n                    var w = it.width,\r\n                        h = it.height;\r\n                    if (L.gmxUtil.isIE11 && /\\.svg$/.test(url)) {   // skip bug in IE11\r\n                        document.body.appendChild(it);\r\n                        w = it.offsetWidth;\r\n                        h = it.offsetHeight;\r\n                        document.body.removeChild(it);\r\n                    }\r\n                    pt.sx = w;\r\n                    pt.sy = h;\r\n                    pt.image = it;\r\n                    var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);\r\n                    if (!pt.scaleFunction && !pt.rotateFunction) {\r\n                        if (pt.iconScale || pt.iconScale === 1) { maxSize *= pt.iconScale; }\r\n                        pt.common = true;\r\n                    }\r\n                    pt.maxSize = Number(maxSize.toFixed());\r\n                }\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n            },\r\n            function() {\r\n                pt.version = ++_this._maxVersion;\r\n                pt.sx = 1;\r\n                pt.sy = 0;\r\n                pt.image = null;\r\n                _this._needLoadIcons--;\r\n                _this._chkReady();\r\n                console.log({url: url, func: '_getImageSize', Error: 'image not found'});\r\n            }\r\n        );\r\n    },\r\n\r\n    getCurrentFilters: function(propArray, zoom) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            types = gmx.tileAttributeTypes,\r\n            z = zoom || 1,\r\n            out = [];\r\n\r\n        if (!this._serverStylesParsed) {\r\n            this._parseServerStyles();\r\n        }\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n            if (z > st.MaxZoom || z < st.MinZoom\r\n                || (st.filterFunction && !st.filterFunction(propArray, indexes, types))) {\r\n                continue;\r\n            }\r\n            out.push(i);\r\n            if (!gmx.multiFilters) { break; }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    _chkStyleFilter: function(item) {\r\n        var gmx = this.gmx,\r\n            zoom = gmx.currentZoom,\r\n            fnum = gmx.multiFilters ? -1 : item.currentFilter,\r\n            curr = this._styles[fnum],\r\n            needParse = !curr || curr.version !== item.styleVersion;\r\n\r\n        if (needParse || item._lastZoom !== zoom) {\r\n            item.currentFilter = -1;\r\n            item.multiFilters = [];\r\n            var filters = this.getCurrentFilters(item.properties, zoom);\r\n            for (var i = 0, len = filters.length; i < len; i++) {\r\n                var num = filters[i],\r\n                    st = this._styles[num];\r\n                item.hoverDiff = st.hoverDiff;\r\n                item.currentFilter = num;\r\n                if (needParse || fnum !== num) {\r\n                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),\r\n                        parsedHover = null;\r\n\r\n                    item.parsedStyleKeys = parsed;\r\n                    if (st.HoverStyle) {\r\n                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);\r\n                        item.parsedStyleHover = parsedHover;\r\n                    }\r\n                    if (gmx.multiFilters) {\r\n                        item.multiFilters.push({\r\n                            style: st.RenderStyle,\r\n                            styleHover: st.HoverStyle,\r\n                            parsedStyle: parsed,\r\n                            parsedStyleHover: parsedHover\r\n                        });\r\n                    }\r\n                }\r\n                item.styleVersion = st.version;\r\n                if (!gmx.multiFilters) { break; }\r\n            }\r\n            item._lastZoom = zoom;\r\n        }\r\n        if (this._styles[item.currentFilter]) {\r\n            return true;\r\n        } else {\r\n            item.currentFilter = -1;\r\n            return false;\r\n        }\r\n    },\r\n\r\n    _parseServerStyles: function() {\r\n        var gmx = this.gmx,\r\n            props = gmx.properties,\r\n            arr = props.styles || [{MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE}],\r\n            len = Math.max(arr.length, gmx.styles.length);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            if (!this._styles[i]) {\r\n                var gmxStyle = gmx.styles[i] || arr[i];\r\n                if (!gmxStyle.RenderStyle) { gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE; }\r\n                if (gmxStyle.HoverStyle === undefined) {\r\n                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));\r\n                    if (hoveredStyle.outline) { hoveredStyle.outline.thickness += 1; }\r\n                    gmxStyle.HoverStyle = hoveredStyle;\r\n                } else if (gmxStyle.HoverStyle === null) {\r\n                    delete gmxStyle.HoverStyle;\r\n                }\r\n                var pt = this._prepareItem(gmxStyle);\r\n                this._styles.push(pt);\r\n                if (this._isLabel(pt.RenderStyle)) { gmx.labelsLayer = true; }\r\n            }\r\n        }\r\n        this._checkStyles();\r\n        this._serverStylesParsed = true;\r\n    },\r\n\r\n    _checkStyles: function() {\r\n        var minZoom = Infinity,\r\n            maxZoom = -Infinity,\r\n            balloonEnable = false,\r\n            labelsLayer = false;\r\n\r\n        for (var i = 0, len = this._styles.length; i < len; i++) {\r\n            var st = this._styles[i];\r\n\r\n            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;\r\n            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;\r\n            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {\r\n                balloonEnable = true;\r\n                st.BalloonEnable = true;\r\n            }\r\n            st.hoverDiff = null;\r\n            st.common = {};\r\n            if (st.RenderStyle) {\r\n                if (!labelsLayer) {\r\n                    if (this._isLabel(st.RenderStyle)) {\r\n                        labelsLayer = true;\r\n                    }\r\n                }\r\n                if (st.RenderStyle.common) {\r\n                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);\r\n                }\r\n                if (st.HoverStyle) {\r\n                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);\r\n                }\r\n            }\r\n            if (st.HoverStyle && st.HoverStyle.common) {\r\n                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);\r\n            }\r\n            minZoom = Math.min(minZoom, st.MinZoom);\r\n            maxZoom = Math.max(maxZoom, st.MaxZoom);\r\n        }\r\n        if (this.minZoom !== Infinity) { this.minZoom = minZoom; }\r\n        if (this.maxZoom !== -Infinity) { this.maxZoom = maxZoom; }\r\n        this.gmx.balloonEnable = balloonEnable;\r\n        this.gmx.labelsLayer = labelsLayer;\r\n    },\r\n\r\n    _parseStyle: function(st, renderStyle) {\r\n        if (st) {\r\n            st.common = true;\r\n            for (var key in st) {\r\n                if (gmxAPIutils.styleFuncKeys[key]) {\r\n                    var fkey = gmxAPIutils.styleFuncKeys[key],\r\n                        val = st[key];\r\n                    if (typeof (val) === 'string') {\r\n                        st.common = false;\r\n                        if (renderStyle && renderStyle[key] === val) {\r\n                            st[fkey] = renderStyle[fkey];\r\n                        } else {\r\n                            if (!this._parserFunctions[val]) {\r\n                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);\r\n                            }\r\n                            st[fkey] = this._parserFunctions[val];\r\n                        }\r\n                    } else if (typeof (val) === 'function') {\r\n                        st.common = false;\r\n                        st[fkey] = val;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var type = '';\r\n            if ('iconUrl' in st) {\r\n                type = 'image';\r\n                if (st.iconUrl) {\r\n                    st.maxSize = 256;\r\n                    this._deferredIcons.push(st);\r\n                }\r\n            } else if (st.fillIconUrl) {\r\n                type = 'square';\r\n                this._deferredIcons.push(st);\r\n            } else if (st.fillPattern) {\r\n                type = 'square';\r\n                st.common = StyleManager.parsePattern(st.fillPattern);\r\n                st.canvasPattern = gmxAPIutils.getPatternIcon(null, st);\r\n            } else if (st.iconCircle) {\r\n                type = 'circle';\r\n                if (!('iconSize' in st)) { st.iconSize = 4; }\r\n            } else if (st.iconPath) {\r\n                type = 'iconPath';\r\n                var iconSize = 0,\r\n                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;\r\n                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function(it, i) {\r\n                    var z = arr[i] || it;\r\n                    iconSize = Math.max(iconSize, z);\r\n                    return z;\r\n                });\r\n                st.iconSize = 2 * iconSize;\r\n            } else if (st.fillRadialGradient) {\r\n                type = 'circle';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);\r\n                if (size === null) {\r\n                    st.common = false;\r\n                } else {\r\n                    st.iconSize = size;\r\n                }\r\n            } else if (st.fillLinearGradient) {\r\n                type = 'square';\r\n                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);\r\n            } else if (st.iconSize) {\r\n                type = 'square';\r\n                if (!('iconCenter' in st)) { st.iconCenter = true; }\r\n            }\r\n            st.type = type;\r\n            if (st.common && !st.maxSize) {\r\n                st.maxSize = st.iconSize || 0;\r\n                st.maxSize += st.weight ? st.weight : 0;\r\n                if ('iconScale' in st) { st.maxSize *= st.iconScale; }\r\n            }\r\n        }\r\n        return st;\r\n    },\r\n\r\n    _prepareItem: function(style) { // Style Scanex->leaflet\r\n        var pt = {\r\n            MinZoom: style.MinZoom || 0,\r\n            MaxZoom: style.MaxZoom || 18,\r\n            Filter: style.Filter || null,\r\n            Balloon: style.Balloon || '',\r\n            RenderStyle: (style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {}),\r\n            version: ++this._maxVersion\r\n        };\r\n        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;\r\n        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;\r\n        if (style.HoverStyle) {\r\n            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);\r\n        }\r\n\r\n        if ('Filter' in style) {\r\n            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\\[\\]]/g, '\"'));\r\n            if (ph) { pt.filterFunction = ph; }\r\n        }\r\n        return pt;\r\n    },\r\n\r\n    _isLabel: function(st) {\r\n        var indexes = this.gmx.tileAttributeIndexes;\r\n        return (st && (st.labelTemplate || (st.labelField && st.labelField in indexes)));\r\n    },\r\n\r\n    _itemStyleParser: function(item, pt) {\r\n        pt = pt || {};\r\n        var out = {}, arr, i, len,\r\n            indexes = this.gmx.tileAttributeIndexes,\r\n            prop = item.properties || {},\r\n            itemType = item.type,\r\n            type = pt.type,\r\n            color = 'color' in pt ? pt.color : 255,\r\n            opacity = 'opacity' in pt ? pt.opacity : 1;\r\n\r\n        out.sx = pt.sx;\r\n        out.sy = pt.sy;\r\n        if (pt.maxSize) {\r\n            out.maxSize = pt.maxSize;\r\n        }\r\n        if (pt.iconAngle) {\r\n            var rotateRes = pt.iconAngle || 0;\r\n            if (rotateRes && typeof (rotateRes) === 'string') {\r\n                rotateRes = (pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0);\r\n            }\r\n            out.rotate = rotateRes || 0;\r\n        }\r\n        if ('iconColor' in pt) {\r\n            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;\r\n        }\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if (type === 'image') {\r\n            out.type = type;\r\n            if (pt.iconUrl) { out.iconUrl = pt.iconUrl; }\r\n            if (pt.image) { out.image = pt.image; }\r\n        } else if (pt.fillRadialGradient) {\r\n            var rgr = pt.fillRadialGradient,\r\n                r1 = (rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1),\r\n                r2 = (rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2),\r\n                x1 = (rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1),\r\n                y1 = (rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1),\r\n                x2 = (rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2),\r\n                y2 = (rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2);\r\n            if (rgr.r2max) {\r\n                r2 = Math.min(r2, rgr.r2max);\r\n            }\r\n            var colorStop = [];\r\n            len = rgr.addColorStop.length;\r\n            if (!rgr.addColorStopFunctions) {\r\n                rgr.addColorStopFunctions = new Array(len);\r\n            }\r\n            for (i = 0; i < len; i++) {\r\n                arr = rgr.addColorStop[i];\r\n                var arrFunc = rgr.addColorStopFunctions[i] || [],\r\n                    p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0]),\r\n                    p3 = arr[3];\r\n                if (arr.length < 4) {\r\n                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];\r\n                    p3 = gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);\r\n                 }\r\n                colorStop.push([p0, p3]);\r\n            }\r\n            out.maxSize = out.sx = out.sy = out.iconSize = r2;\r\n            out.fillRadialGradient = {\r\n                x1:x1, y1:y1, r1:r1, x2:x2, y2:y2, r2:r2,\r\n                addColorStop: colorStop\r\n            };\r\n            out._radialGradientParsed = {\r\n                create: [x1, y1, r1, x2, y2, r2],\r\n                colorStop: colorStop\r\n            };\r\n        } else if (pt.fillLinearGradient) {\r\n            out.fillLinearGradient = pt.fillLinearGradient;\r\n        } else {\r\n            if (pt.fillPattern) {\r\n                out.canvasPattern = (pt.canvasPattern ? pt.canvasPattern : gmxAPIutils.getPatternIcon(item, pt, indexes));\r\n            }\r\n\r\n            if (type === 'iconPath') {\r\n                out.type = type;\r\n                out.iconPath = pt.iconPath;\r\n            }\r\n\r\n            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {\r\n                type = 'polygon';\r\n            }\r\n            if (pt.iconSize) {\r\n                var iconSize = ('sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize);\r\n                out.sx = out.sy = iconSize;\r\n                // iconSize += pt.weight ? pt.weight : 0;\r\n                out.iconSize = iconSize;\r\n                if ('iconScale' in pt) {\r\n                    out.iconSize *= pt.iconScale;\r\n                }\r\n                out.maxSize = iconSize;\r\n            }\r\n            out.stroke = true;\r\n            if ('colorFunction' in pt || 'opacityFunction' in pt) {\r\n                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;\r\n                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;\r\n            }\r\n            out.strokeStyle = gmxAPIutils.dec2color(color, opacity);\r\n            out.lineWidth = 'weight' in pt ? pt.weight : 1;\r\n        }\r\n\r\n        if ('iconScale' in pt) {\r\n            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;\r\n        }\r\n        if ('iconAnchor' in pt) {\r\n            out.iconAnchor = pt.iconAnchor;\r\n        }\r\n        if ('iconCenter' in pt) {\r\n            out.iconCenter = pt.iconCenter;\r\n        }\r\n\r\n        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {\r\n            out.type = type;\r\n            var fop = pt.fillOpacity,\r\n                fc = pt.fillColor,\r\n                fcDec = typeof (fc) === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;\r\n\r\n            if ('fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, 1);\r\n            }\r\n            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {\r\n                color = ('fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255);\r\n                opacity = ('fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1);\r\n                out.fillStyle = gmxAPIutils.dec2color(color, opacity);\r\n            } else if ('fillOpacity' in pt && 'fillColor' in pt) {\r\n                out.fillStyle = gmxAPIutils.dec2color(fcDec, fop);\r\n            }\r\n        }\r\n\r\n        if ('dashArray' in pt) { out.dashArray = pt.dashArray; }\r\n        if ('dashOffset' in pt) { out.dashOffset = pt.dashOffset; }\r\n\r\n        if (this.gmx.labelsLayer) {\r\n            arr = gmxAPIutils.styleKeys.label.client;\r\n            for (i = 0, len = arr.length; i < len; i++) {\r\n                var it = arr[i];\r\n                if (it in pt) {\r\n                    if (it === 'labelField') {\r\n                        if (!indexes[pt[it]]) {\r\n                            continue;\r\n                        }\r\n                    } else if (it === 'labelTemplate') {\r\n                        var properties = gmxAPIutils.getPropertiesHash(prop, indexes);\r\n                        out.labelText = gmxAPIutils.parseTemplate(pt[it], properties);\r\n                    }\r\n                    out[it] = pt[it];\r\n                }\r\n            }\r\n            if ('labelAnchor' in pt) {\r\n                out.labelAnchor = pt.labelAnchor;\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n};\r\nStyleManager.MAX_STYLE_SIZE = 256;\r\n//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};\r\nStyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8}};\r\nStyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];\r\nStyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10];  // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]\r\n\r\nStyleManager.parsePattern = function(pattern) {\r\n    var common = true,\r\n        parsers = L.gmx.Parsers;\r\n    if ('step' in pattern && typeof (pattern.step) === 'string') {\r\n        pattern.patternStepFunction = parsers.parseExpression(pattern.step);\r\n        common = false;\r\n    }\r\n    if ('width' in pattern && typeof (pattern.width) === 'string') {\r\n        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);\r\n        common = false;\r\n    }\r\n    if ('colors' in pattern) {\r\n        var arr = [];\r\n        for (var i = 0, len = pattern.colors.length; i < len; i++) {\r\n            var rt = pattern.colors[i];\r\n            if (typeof (rt) === 'string') {\r\n                arr.push(parsers.parseExpression(rt));\r\n                common = false;\r\n            } else {\r\n                arr.push(null);\r\n            }\r\n        }\r\n        pattern.patternColorsFunction = arr;\r\n    }\r\n    return common;\r\n};\r\n\r\nStyleManager.getStyleKeys = function(style) {\r\n    var out = {};\r\n    for (var key in gmxAPIutils.styleKeys) {\r\n        var keys = gmxAPIutils.styleKeys[key];\r\n        for (var i = 0, len = keys.client.length; i < len; i++) {\r\n            var key1 = keys.client[i];\r\n            if (key1 in style) {\r\n                if (style[key1] !== undefined) {\r\n                    out[key1] = JSON.parse(JSON.stringify(style[key1]));\r\n                }\r\n                if (key1 === 'fillPattern') { delete out[key1].patternColorsFunction; }\r\n                else if (key1 === 'fillLinearGradient') { delete out[key1].addColorStopFunctions; }\r\n            }\r\n        }\r\n    }\r\n    if ('iconAnchor' in style) {\r\n        out.iconAnchor = style.iconAnchor;\r\n    }\r\n    if ('labelAnchor' in style) {\r\n        out.labelAnchor = style.labelAnchor;\r\n    }\r\n    return out;\r\n};\r\n\r\nStyleManager.checkDiff = function(st, st1) {\r\n    for (var key in st) {\r\n        if (st[key] !== st1[key]) {\r\n            return key;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nStyleManager.parseRadialGradient = function(rg) {\r\n    //\tx1,y1,r1       ;\r\n    //\tx2,y2,r2       .\r\n    //\taddColorStop -     [[position, color]...]\r\n    //\t\tposition     .      0.0 ()  1.0 ();\r\n    //\t\tcolor     .\r\n    //\t\topacity  \r\n    //\t\tcanvasStyleColor      canvas\r\n    var common = true,\r\n        parsers = L.gmx.Parsers,\r\n        i = 0,\r\n        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (!rg[it]) { rg[it] = 0; }\r\n        if (typeof (rg[it]) === 'string') {\r\n            rg[it + 'Function'] = parsers.parseExpression(rg[it]);\r\n            common = false;\r\n        }\r\n    }\r\n\r\n    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];\r\n    rg.addColorStopFunctions = [];\r\n    for (i = 0, len = rg.addColorStop.length; i < len; i++) {\r\n        arr = rg.addColorStop[i];\r\n        var resFunc = [\r\n                (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n                (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n                (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n            ];\r\n        rg.addColorStopFunctions.push(resFunc);\r\n        if (resFunc[1] === null && resFunc[2] === null) {\r\n            arr[3] = gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);\r\n        } else {\r\n            common = false;\r\n        }\r\n    }\r\n    if ('r2Function' in rg) { common = false; }\r\n    return common ? Math.max(rg.r1, rg.r2) : null;\r\n};\r\n\r\nStyleManager.parseLinearGradient = function(lg) {\r\n    var common = true;\r\n    //\tx1,y1    \r\n    //\tx2,y2    \r\n    //\taddColorStop -     [[position, color]...]\r\n    //\t\tposition     .      0.0 ()  1.0 ();\r\n    //\t\tcolor     .\r\n    //\t\topacity  \r\n    var i = 0,\r\n        parsers = L.gmx.Parsers,\r\n        arr = ['x1', 'y1', 'x2', 'y2'],\r\n        def = [0, 0, 0, 256],\r\n        len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var it = arr[i];\r\n        if (it in lg) {\r\n            if (typeof (lg[it]) === 'string') {\r\n                lg[it + 'Function'] = parsers.parseExpression(lg[it]);\r\n                common = false;\r\n            }\r\n        } else {\r\n            lg[it] = def[i];\r\n        }\r\n    }\r\n\r\n    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];\r\n    lg.addColorStopFunctions = [];\r\n    for (i = 0, len = lg.addColorStop.length; i < len; i++) {\r\n        arr = lg.addColorStop[i];\r\n        lg.addColorStopFunctions.push([\r\n            (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),\r\n            (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),\r\n            (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)\r\n        ]);\r\n    }\r\n    return common;\r\n};\r\nexport {StyleManager};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/StyleManager.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n// Single tile on screen with vector data\r\nfunction ScreenVectorTile(layer, tilePoint, zoom) {\r\n    this.layer = layer;\r\n    this.tilePoint = tilePoint;\r\n    this.zoom = zoom;\r\n    this.gmx = layer._gmx;\r\n    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);\r\n    var utils = gmxAPIutils;\r\n    this.worldWidthMerc = utils.worldWidthMerc;\r\n    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);\r\n    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);\r\n    this.tpx = 256 * gmxTilePoint.x;\r\n    this.tpy = 256 * (1 + gmxTilePoint.y);\r\n    this.gmxTilePoint = gmxTilePoint;\r\n\r\n    this.showRaster =\r\n        (zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx) ||\r\n        (zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx);\r\n    this.rasters = {}; //combined and processed canvases for each vector item in tile\r\n    this.rasterRequests = {};   // all cached raster requests\r\n    this.itemsView = [];   \t\t// items on screen tile + todo: without not visible\r\n    this._uniqueID = 0;         // draw attempt id\r\n    this.gmx.badTiles = this.gmx.badTiles || {};\r\n}\r\n\r\nScreenVectorTile.prototype = {\r\n\r\n    //return promise, which resolves with object {gtp, image}\r\n    _loadTileRecursive: function (gtp, urlFunction) {\r\n        var gmx = this.gmx,\r\n            _this = this,\r\n            requestPromise = null,\r\n            currentUrl,\r\n            def = new L.gmx.Deferred(function() {\r\n                if (requestPromise) {\r\n                    //don't store cancelled requests in request cache\r\n                    delete _this.rasterRequests[currentUrl];\r\n                    requestPromise.cancel();\r\n                }\r\n            });\r\n\r\n        var tryLoad = function(gtp, crossOrigin) {\r\n            var rUrl = urlFunction(gtp);\r\n\r\n            var tryHigherLevelTile = function() {\r\n                if (gtp.z > 1) {\r\n                    tryLoad({\r\n                        x: Math.floor(gtp.x / 2),\r\n                        y: Math.floor(gtp.y / 2),\r\n                        z: gtp.z - 1\r\n                    }, ''); // 'anonymous' 'use-credentials'\r\n                } else {\r\n                    def.reject();\r\n                }\r\n            };\r\n\r\n            if (gmx.badTiles[rUrl] || (gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z)) {\r\n                tryHigherLevelTile();\r\n                return;\r\n            }\r\n            var request = _this.rasterRequests[rUrl];\r\n            if (!request) {\r\n                if (gmx.rasterProcessingHook) {\r\n                    crossOrigin = 'anonymous';\r\n                }\r\n                request = L.gmx.imageLoader.push(rUrl, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    zoom: _this.zoom,\r\n                    cache: true,\r\n                    crossOrigin: crossOrigin || ''\r\n                });\r\n                _this.rasterRequests[rUrl] = request;\r\n            } else {\r\n                request.options.tileRastersId = _this._uniqueID;\r\n            }\r\n            currentUrl = rUrl;\r\n            requestPromise = request.def;\r\n\r\n            requestPromise.then(\r\n                function(imageObj) {\r\n                    def.resolve({gtp: gtp, image: imageObj});\r\n                },\r\n                function() {\r\n                    gmx.badTiles[rUrl] = true;\r\n                    tryHigherLevelTile();\r\n                }\r\n            );\r\n        };\r\n\r\n        tryLoad(gtp);\r\n        return def;\r\n    },\r\n\r\n    _rasterHook: function (attr) {\r\n        var source = attr.sourceTilePoint || attr.destinationTilePoint,\r\n            info = {\r\n                geoItem: attr.geoItem,\r\n                destination: {\r\n                    z: attr.destinationTilePoint.z,\r\n                    x: attr.destinationTilePoint.x,\r\n                    y: attr.destinationTilePoint.y\r\n                },\r\n                source: {\r\n                    z: source.z,\r\n                    x: source.x,\r\n                    y: source.y\r\n                }\r\n            };\r\n        if (attr.url) { info.quicklook = attr.url; }\r\n        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(\r\n            attr.res, attr.image,\r\n            attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256,\r\n            attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256,\r\n            info\r\n        );\r\n    },\r\n\r\n    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp\r\n    _defaultRasterHook: function (res, image, sx, sy, sw, sh, dx, dy, dw, dh) {\r\n        var ptx = res.getContext('2d');\r\n        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    },\r\n\r\n    // get pixels parameters for shifted object\r\n    _getShiftPixels: function (it) {\r\n        var w = it.dx + (it.dx < 0 ? 256 : 0),\r\n            h = it.dy + (it.dy < 0 ? 256 : 0),\r\n            sx = 0, sw = 256 - w, dx = w, dw = sw;\r\n        if (it.tx > it.x) {\r\n            sx = sw; sw = w; dx = 0; dw = sw;\r\n        }\r\n        if (sx === 256 || sw < 1) { return null; }\r\n\r\n        var sy = h, sh = 256 - h, dy = 0, dh = sh;\r\n        if (it.ty > it.y) {\r\n            sy = 0; dy = sh; sh = h; dh = sh;\r\n        }\r\n        if (sy === 256 || sh < 1) { return null; }\r\n\r\n        return {\r\n            sx: sx, sy: sy, sw: sw, sh: sh,\r\n            dx: dx, dy: dy, dw: dw, dh: dh\r\n        };\r\n    },\r\n\r\n    // get tiles parameters for shifted object\r\n    _getShiftTilesArray: function (bounds, shiftX, shiftY) {\r\n        var mInPixel = this.gmx.mInPixel,\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            px = shiftX * mInPixel,\r\n            py = shiftY * mInPixel,\r\n            deltaX = Math.floor(0.5 + px % 256),            // shift on tile in pixel\r\n            deltaY = Math.floor(0.5 + py % 256),\r\n            tileSize = 256 / mInPixel,\r\n            tminX = gmxTilePoint.x - shiftX / tileSize,     // by screen tile\r\n            tminY = gmxTilePoint.y - shiftY / tileSize,\r\n            rminX = Math.floor(tminX),\r\n            rmaxX = rminX + (tminX === rminX ? 0 : 1),\r\n            rminY = Math.floor(tminY),\r\n            rmaxY = rminY + (tminY === rminY ? 0 : 1),\r\n            minX = Math.floor((bounds.min.x - shiftX) / tileSize),  // by geometry bounds\r\n            maxX = Math.floor((bounds.max.x - shiftX) / tileSize),\r\n            minY = Math.floor((bounds.min.y - shiftY) / tileSize),\r\n            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);\r\n\r\n        if (rminX < minX) { rminX = minX; }\r\n        if (rmaxX > maxX) { rmaxX = maxX; }\r\n        if (rminY < minY) { rminY = minY; }\r\n        if (rmaxY > maxY) { rmaxY = maxY; }\r\n\r\n        var arr = [];\r\n        for (var j = rminY; j <= rmaxY; j++) {\r\n            for (var i = rminX; i <= rmaxX; i++) {\r\n                arr.push({\r\n                    z: gmxTilePoint.z,\r\n                    x: i,\r\n                    y: j,\r\n                    dx: deltaX,\r\n                    dy: deltaY,\r\n                    tx: tminX,\r\n                    ty: tminY\r\n                });\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    // Loads missing rasters for single item and combines them in canvas.\r\n    // Stores resulting canvas in this.rasters\r\n    _getItemRasters: function (geo) {\r\n        var properties = geo.properties,\r\n            idr = properties[0],\r\n            _this = this,\r\n            gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            rasters = this.rasters,\r\n            mainRasterLoader = null,\r\n            recursiveLoaders,\r\n            shiftX = Number(gmx.shiftXfield ? gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,\r\n            shiftY = Number(gmx.shiftYfield ? gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),\r\n            isShift = shiftX || shiftY,\r\n            urlBG = gmxAPIutils.getPropItem('urlBG', properties, indexes),\r\n            url = '',\r\n            itemImageProcessingHook = null,\r\n            isTiles = false,\r\n            item = gmx.dataManager.getItem(idr),\r\n            gmxTilePoint = this.gmxTilePoint,\r\n            resCanvas = null,\r\n            imageItem = null;\r\n\r\n        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {\r\n            isTiles = true;                     // Raster Layer\r\n        } else if (gmx.quicklookBGfunc) {\r\n            url = gmx.quicklookBGfunc(item);    // Quicklook\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        } else if (urlBG) {\r\n            url = urlBG;                        // Image urlBG from properties\r\n            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;\r\n        }\r\n        if (isTiles) {\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                recursiveLoaders.forEach(function(it) {\r\n                    it.cancel();\r\n                });\r\n                recursiveLoaders = null;\r\n            });\r\n        } else {\r\n            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey;  //  for browser cache from another tabs\r\n            var request = this.rasterRequests[url];\r\n            if (!request) {\r\n                request = L.gmx.imageLoader.push(url, {\r\n                    tileRastersId: _this._uniqueID,\r\n                    crossOrigin: gmx.crossOrigin || 'anonymous'\r\n                });\r\n                this.rasterRequests[url] = request;\r\n            } else {\r\n                request.options.tileRastersId = this._uniqueID;\r\n            }\r\n\r\n            // in fact, we want to return request.def, but need to do additional action during cancellation.\r\n            // so, we consctruct new promise and add pipe it with request.def\r\n            mainRasterLoader = new L.gmx.Deferred(function() {\r\n                //don't cache cancelled requests\r\n                delete _this.rasterRequests[url];\r\n                request.def.cancel();\r\n            });\r\n            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);\r\n        }\r\n        var itemRasterPromise = new L.gmx.Deferred(function() {\r\n            if (mainRasterLoader) {\r\n                mainRasterLoader.cancel();\r\n                mainRasterLoader = null;\r\n            }\r\n        });\r\n\r\n        if (isTiles) {\r\n            var dataOption = geo.dataOption || {},\r\n                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],\r\n                cnt = tileToLoadPoints.length,\r\n                chkReadyRasters = function() {\r\n                    if (cnt < 1) { mainRasterLoader.resolve(); }\r\n                },\r\n                skipRasterFunc = function() {\r\n                    cnt--;\r\n                    chkReadyRasters();\r\n                },\r\n                urlFunction = function(gtp) {\r\n                    return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);\r\n                },\r\n                onLoadFunction = function(gtp, p, img) {\r\n                    item.skipRasters = false;\r\n                    var isImage = true;\r\n\r\n                    if (itemImageProcessingHook) {\r\n                        img = itemImageProcessingHook(img, {\r\n                            gmx: gmx,\r\n                            geoItem: geo,\r\n                            item: item,\r\n                            gmxTilePoint: gtp\r\n                        });\r\n                        isImage = false;\r\n                    }\r\n\r\n                    var info = {\r\n                            geoItem: geo,\r\n                            image: img,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            sourceTilePoint: gtp,\r\n                            sx: 0, sy: 0, sw: 256, sh: 256,\r\n                            dx: 0, dy: 0, dw: 256, dh: 256\r\n                        };\r\n\r\n                    if (isShift) {\r\n                        var pos = _this._getShiftPixels(p);\r\n                        if (pos === null) {\r\n                            skipRasterFunc();\r\n                            return;\r\n                        }\r\n                        L.extend(info, pos);\r\n                        isImage = false;\r\n                    }\r\n\r\n                    if (gtp.z !== gmxTilePoint.z) {\r\n                        var posInfo = gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);\r\n                        if (posInfo.size < 1 / 256) {//  1px\r\n                            chkReadyRasters();\r\n                            return;\r\n                        }\r\n                        isImage = false;\r\n                        info.sx = Math.floor(posInfo.x);\r\n                        info.sy = Math.floor(posInfo.y);\r\n                        info.sw = info.sh = posInfo.size;\r\n                        if (isShift) {\r\n                            var sw = Math.floor(info.dw / posInfo.zDelta);\r\n                            info.sx = (info.dx === 0 ? info.sw : 256) - sw;\r\n                            info.sw = sw;\r\n\r\n                            var sh = Math.floor(info.dh / posInfo.zDelta);\r\n                            info.sy = (info.dy === 0 ? info.sh : 256) - sh;\r\n                            info.sh = sh;\r\n                        }\r\n                    }\r\n                    if (isImage && !gmx.rasterProcessingHook) {\r\n                        cnt--;\r\n                        resCanvas = img;\r\n                        chkReadyRasters();\r\n                    } else {\r\n                        if (!resCanvas) {\r\n                            resCanvas = document.createElement('canvas');\r\n                            resCanvas.width = resCanvas.height = 256;\r\n                        }\r\n                        info.res = resCanvas;\r\n                        var hookResult = _this._rasterHook(info),\r\n                            then = function() {\r\n                                cnt--;\r\n                                p.resImage = resCanvas;\r\n                                chkReadyRasters();\r\n                            };\r\n\r\n                        if (hookResult) {\r\n                            if (hookResult instanceof L.gmx.Deferred) {\r\n                                hookResult.then(then);\r\n                            }\r\n                        } else if (hookResult === null) {\r\n                            item.skipRasters = true;\r\n                            skipRasterFunc();\r\n                        } else {\r\n                            then();\r\n                        }\r\n                    }\r\n                };\r\n            recursiveLoaders = tileToLoadPoints.map(function(it) {\r\n                var loader = _this._loadTileRecursive(it, urlFunction);\r\n                loader.then(function(loadResult) {\r\n                    onLoadFunction(loadResult.gtp, it, loadResult.image);\r\n                }, skipRasterFunc);\r\n                return loader;\r\n            });\r\n\r\n            mainRasterLoader.then(function() {\r\n                rasters[idr] = resCanvas;\r\n                itemRasterPromise.resolve();\r\n            });\r\n        } else {\r\n            // for quicklook\r\n            item.skipRasters = false;\r\n            var imageLoaded = function(img) {\r\n                var imgAttr = {\r\n                    gmx: gmx,\r\n                    geoItem: geo,\r\n                    item: item,\r\n                    gmxTilePoint: gmxTilePoint\r\n                };\r\n                if (!resCanvas) {\r\n                    resCanvas = document.createElement('canvas');\r\n                    resCanvas.width = resCanvas.height = 256;\r\n                }\r\n                var prepareItem = function(imageElement) {\r\n                    var promise = _this._rasterHook({\r\n                            geoItem: geo,\r\n                            res: resCanvas,\r\n                            image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,\r\n                            destinationTilePoint: gmxTilePoint,\r\n                            url: url\r\n                        }),\r\n                        then = function() {\r\n                            rasters[idr] = resCanvas;\r\n                            itemRasterPromise.resolve();\r\n                        };\r\n                    if (promise) {\r\n                        if (promise instanceof L.gmx.Deferred) {\r\n                            promise.then(then);\r\n                        }\r\n                    } else if (promise === null) {\r\n                        item.skipRasters = true;\r\n                        itemRasterPromise.resolve();\r\n                    } else {\r\n                        then();\r\n                    }\r\n                };\r\n                prepareItem(img);\r\n                delete _this.rasterRequests[url];\r\n            };\r\n            if (imageItem) {\r\n                imageLoaded(imageItem);\r\n            } else {\r\n                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);\r\n            }\r\n        }\r\n        itemRasterPromise.always(function() {\r\n            mainRasterLoader = null;\r\n            if (recursiveLoaders) {\r\n                recursiveLoaders = null;\r\n            }\r\n        });\r\n        return itemRasterPromise;\r\n    },\r\n\r\n    _getVisibleItems: function (geoItems) {\r\n        if (geoItems.length < 2) {\r\n\t\t\tthis.itemsView = geoItems;\r\n            return geoItems;\r\n        }\r\n        if (!gmxAPIutils._tileCanvas) {\r\n            gmxAPIutils._tileCanvas = document.createElement('canvas');\r\n            gmxAPIutils._tileCanvas.width = gmxAPIutils._tileCanvas.height = 256;\r\n        }\r\n        var i, len,\r\n            gmx = this.gmx,\r\n            dm = gmx.dataManager,\r\n            canvas = gmxAPIutils._tileCanvas,\r\n            ctx = canvas.getContext('2d'),\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        ctx.clearRect(0, 0, 256, 256);\r\n        ctx.imageSmoothingEnabled = false;\r\n        for (i = 0, len = geoItems.length; i < len; i++) {\r\n            ctx.fillStyle = gmxAPIutils.dec2rgba(i + 1, 1);\r\n            var geoItem = geoItems[i];\r\n            L.gmxUtil.drawGeoItem(\r\n                geoItem,\r\n                dm.getItem(geoItem.properties[0]),\r\n                dattr,\r\n                {fillStyle: ctx.fillStyle}\r\n            );\r\n        }\r\n        var items = {},\r\n            data = ctx.getImageData(0, 0, 256, 256).data;\r\n\r\n        for (i = 0, len = data.length; i < len; i += 4) {\r\n            if (data[i + 3] === 255) {\r\n                var color = data[i + 2];\r\n                if (data[i + 1]) { color += (data[i + 1] << 8); }\r\n                if (data[i]) { color += (data[i] << 16); }\r\n                if (color) { items[color] = true; }\r\n            }\r\n        }\r\n        var out = [];\r\n        for (var num in items) {\r\n            var it = geoItems[Number(num) - 1];\r\n            if (it) { out.push(it); }\r\n        }\r\n\t\tthis.itemsView = out;\r\n        return out;\r\n    },\r\n\r\n    _getNeedRasterItems: function (geoItems) {\r\n        var gmx = this.gmx,\r\n            indexes = gmx.tileAttributeIndexes,\r\n            tbounds = this.tbounds,\r\n            out = [];\r\n        for (var i = 0, len = geoItems.length; i < len; i++) {\r\n            var geo = geoItems[i],\r\n                properties = geo.properties,\r\n                idr = properties[0],\r\n                dataOption = geo.dataOption || {},\r\n                skipRasters = false;\r\n\r\n            if (gmx.quicklookBGfunc && !gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {\r\n                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) { continue; }\r\n                var platform = gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';\r\n                if ((!platform || platform === 'imageMercator') &&\r\n                    !gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)\r\n                ) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (gmx.styleHook) {\r\n                geo.styleExtend = gmx.styleHook(\r\n                    gmx.dataManager.getItem(idr),\r\n                    gmx.lastHover && idr === gmx.lastHover.id\r\n                );\r\n                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;\r\n            }\r\n            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {\r\n                out.push(geo);\r\n            }\r\n        }\r\n        return this._getVisibleItems(out);\r\n    },\r\n\r\n    _getTileRasters: function (geoItems) {   //load all missing rasters for items we are going to render\r\n        var itemPromises = [],\r\n            def = new L.gmx.Deferred(function() {\r\n                itemPromises.forEach(function(promise) {\r\n                    promise.cancel();\r\n                });\r\n                itemPromises = null;\r\n            }),\r\n            itemRasters = this._getNeedRasterItems(geoItems),\r\n            needLoadRasters = itemRasters.length;\r\n\r\n        if (needLoadRasters) {\r\n            var _this = this,\r\n                chkReadyRasters = function() {\r\n                    if (needLoadRasters < 1) {\r\n                        def.resolve();\r\n                    }\r\n                };\r\n            itemRasters.forEach(function (geo) {\r\n                var itemRasterPromise = _this._getItemRasters(geo);\r\n                itemRasterPromise.then(function() {\r\n                    needLoadRasters--;\r\n                    chkReadyRasters();\r\n                });\r\n                itemPromises.push(itemRasterPromise);\r\n            });\r\n        } else {\r\n            def.resolve();\r\n        }\r\n        return def;\r\n    },\r\n\r\n    _chkItems: function (data) {\r\n        var layer = this.layer;\r\n        if (!layer._map) {\r\n            return null;\r\n        }\r\n        var items = data && data.added && data.added.length ? data.added : null;\r\n\r\n        if (!items) {\r\n            var tLink = layer._tiles[this.zKey];\r\n            if (tLink && tLink.el) {\r\n                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);\r\n            }\r\n            return null;\r\n        }\r\n        return this.gmx.sortItems ? layer.getSortedItems(items) : items;\r\n    },\r\n\r\n    _cancelRastersPromise: function () {\r\n        if (this.rastersPromise) {\r\n            this.rastersPromise.cancel();\r\n            this.rastersPromise = null;\r\n        }\r\n    },\r\n\r\n    drawTile: function (data) {\r\n        var drawPromise = this.currentDrawPromise,\r\n            _this = this;\r\n\r\n        this._uniqueID++;       // count draw attempt\r\n\r\n        if (drawPromise) {\r\n            this._cancelRastersPromise();\r\n            if (this._preRenderPromise) {\r\n                this._preRenderPromise.cancel();        // cancel preRenderHooks chain if exists\r\n            }\r\n            if (this._renderPromise) {\r\n                this._renderPromise.cancel();           // cancel renderHooks chain if exists\r\n            }\r\n            drawPromise.reject();\r\n        }\r\n        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));\r\n        drawPromise.always(function() {\r\n            _this._drawDone();\r\n            _this.currentDrawPromise = null;\r\n            _this.rastersPromise = null;\r\n            _this._preRenderPromise = null;\r\n            _this._renderPromise = null;\r\n        });\r\n\r\n        this.currentDrawPromise = drawPromise;\r\n\r\n        var geoItems = this._chkItems(data);\r\n        if (!geoItems) {\r\n            drawPromise.resolve();\r\n            return drawPromise;\r\n        }\r\n        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),\r\n            tile = tileLink.el,\r\n            ctx = tile.getContext('2d'),\r\n            gmx = this.gmx,\r\n            dattr = {\r\n                tbounds: this.tbounds,\r\n                rasters: this.rasters,\r\n                gmx: gmx,\r\n                tpx: this.tpx,\r\n                tpy: this.tpy,\r\n                ctx: ctx\r\n            };\r\n        tile.zKey = tileLink.el._zKey = this.zKey;\r\n\r\n        var doDraw = function() {\r\n            ctx.clearRect(0, 0, 256, 256);\r\n            var hookInfo = {\r\n                    tpx: _this.tpx,\r\n                    tpy: _this.tpy,\r\n                    x: _this.tilePoint.x,\r\n                    y: _this.tilePoint.y,\r\n                    z: _this.zoom\r\n                },\r\n                bgImage = null;\r\n\r\n            _this._preRenderPromise = new L.gmx.Deferred();\r\n            _this._preRenderPromise.resolve(bgImage);\r\n\r\n            gmx.preRenderHooks.forEach(function (f) {\r\n                _this._preRenderPromise = _this._preRenderPromise.then(function(hookBgImage) {\r\n\r\n                    //in-place modifications are possible\r\n                    bgImage = hookBgImage || bgImage;\r\n\r\n                    if (!bgImage) {\r\n                        bgImage = document.createElement('canvas');\r\n                        bgImage.width = bgImage.height = 256;\r\n                    }\r\n                    return f(bgImage, hookInfo);\r\n                });\r\n            });\r\n            _this._preRenderPromise.then(function(hookBgImage) {\r\n                bgImage = hookBgImage || bgImage;\r\n                if (bgImage) { dattr.bgImage = bgImage; }\r\n                //ctx.save();\r\n                for (var i = 0, len = geoItems.length; i < len; i++) {\r\n                    var geoItem = geoItems[i],\r\n                        id = geoItem.id,\r\n                        item = gmx.dataManager.getItem(id);\r\n                    if (item) {     // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)\r\n                        var style = gmx.styleManager.getObjStyle(item),\r\n                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;\r\n\r\n                        if (gmx.multiFilters) {\r\n                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                                var it = item.multiFilters[j];\r\n                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);\r\n                            }\r\n                        } else {\r\n                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);\r\n                        }\r\n                        if (id in gmx._needPopups && !gmx._needPopups[id]) {\r\n                            gmx._needPopups[id] = true;\r\n                        }\r\n                    }\r\n                }\r\n                //ctx.restore();\r\n                _this.rasters = {}; // clear rasters\r\n                if (_this.layer._map && !tile.parentNode) {\r\n                    _this.layer.appendTileToContainer(tile);\r\n                }\r\n                //async chain\r\n                _this._renderPromise = new L.gmx.Deferred();\r\n                _this._renderPromise.resolve(tile);\r\n                gmx.renderHooks.forEach(function (f) {\r\n                    _this._renderPromise = _this._renderPromise.then(function(hookTile) {\r\n                        tile = hookTile || tile;\r\n                        return f(tile, hookInfo);\r\n                    });\r\n                });\r\n                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);\r\n            }, drawPromise.reject);\r\n        };\r\n\r\n        if (this.showRaster) {\r\n            this.rastersPromise = this._getTileRasters(geoItems);\r\n            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once\r\n        } else {\r\n            doDraw();\r\n        }\r\n\r\n        return drawPromise;\r\n    },\r\n\r\n    destructor: function () {\r\n        this._cancelRastersPromise();\r\n        this._clearCache();\r\n\r\n        this.currentDrawPromise && this.currentDrawPromise.reject();\r\n    },\r\n\r\n    _drawDone: function () {\r\n        for (var url in this.rasterRequests) {\r\n            var req = this.rasterRequests[url];\r\n            if (this._uniqueID !== req.options.tileRastersId) {\r\n                req.remove();\r\n                delete this.rasterRequests[url];\r\n            }\r\n        }\r\n        // this.layer.fire('tiledrawdone', {zKey: this.zKey});\r\n    },\r\n\r\n    _clearCache: function () {\r\n        for (var url in this.rasterRequests) {\r\n            this.rasterRequests[url].remove();\r\n        }\r\n        this.rasterRequests = {};\r\n    }\r\n};\r\nexport {ScreenVectorTile};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ScreenVectorTile.js","/*\r\n * ObjectsReorder  - Reorder objects in Gemixer layer\r\n */\r\n(function() {\r\n\r\nvar MAX = 1000000,\r\n    ObjectsReorder = function (layer) {\r\n        this.all = {};\r\n        this.userSetSortFunc = false;     // user sort func flag\r\n        this.sortFunc = null;\r\n        this.count = 0;\r\n        this.disabled = false;\r\n        this.layer = layer;\r\n        layer.on('add', this.onAdd, this);\r\n        layer.on('remove', this.onRemove, this);\r\n    };\r\n    ObjectsReorder.prototype = {\r\n        addToReorder: function (id, bottomFlag) {\r\n            ++this.count;\r\n            this.all[id] = bottomFlag ? -this.count : this.count;\r\n        },\r\n        clickFunc: function (ev) {\r\n            if (!this.disabled) {\r\n                var id = ev.gmx.id;\r\n                this.addToReorder(id, ev.originalEvent.ctrlKey);\r\n                this.layer.redrawItem(id);\r\n            }\r\n        },\r\n        sortItems: function(a, b) {     // layer context\r\n            var reorder = this._objectsReorder;\r\n            if (reorder.count > 0) {\r\n                var ap = reorder.all[a.id],\r\n                    bp = reorder.all[b.id];\r\n\r\n                if (ap || bp) {\r\n                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;\r\n                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;\r\n                    return ap - bp;\r\n                }\r\n            }\r\n            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;\r\n        },\r\n        resetSortFunc: function () {\r\n            var layer = this.layer,\r\n                gmx = layer._gmx,\r\n                zIndexField = gmx.zIndexField;\r\n            gmx.sortItems = this.sortItems;\r\n            this.sortFunc = (zIndexField && !this.userSetSortFunc ?\r\n                function(a, b) {    // layer context\r\n                    var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);\r\n                    return res ? res : a.id - b.id;\r\n                }\r\n                :\r\n                function(a, b) {\r\n                    return a.id - b.id;\r\n                }\r\n            );\r\n        },\r\n        initialize: function () {\r\n            var gmx = this.layer._gmx;\r\n            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {\r\n                this.resetSortFunc();\r\n            }\r\n        },\r\n        onAdd: function () {\r\n            this.initialize();\r\n            this.layer.on('click', this.clickFunc, this);\r\n        },\r\n        onRemove: function () {\r\n            this.layer.off('click', this.clickFunc, this);\r\n        }\r\n    };\r\n\r\nL.gmx.VectorLayer.include({\r\n    _objectsReorder: null,\r\n\r\n    _objectsReorderInit: function () {\r\n        if (!this._objectsReorder) {\r\n            this._objectsReorder = new ObjectsReorder(this);\r\n        }\r\n    },\r\n\r\n    getReorderArrays: function () {\r\n        var out = {top: [], bottom: []};\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder,\r\n                arr = Object.keys(reorder.all).sort(function(a, b) {\r\n                    return reorder.all[a] - reorder.all[b];\r\n                });\r\n\r\n            for (var i = 0, len = arr.length; i < len; i++) {\r\n                var id = arr[i];\r\n                if (reorder.all[id] > 0) {\r\n                    out.top.push(id);\r\n                } else {\r\n                    out.bottom.push(id);\r\n                }\r\n            }\r\n        }\r\n        return out;\r\n    },\r\n\r\n    bringToTopItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    bringToBottomItem: function (id) {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.addToReorder(id, true);\r\n        this.redrawItem(id);\r\n        return this;\r\n    },\r\n\r\n    clearReorderArrays: function () {\r\n        if (this._objectsReorder) {\r\n            var reorder = this._objectsReorder;\r\n            reorder.all = {};\r\n            reorder.count = 0;\r\n            this.repaint();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    setReorderArrays: function (top, bottom) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.all = {};\r\n        reorder.count = 0;\r\n        bottom.forEach(function (id) { reorder.addToReorder(id, true); });\r\n        top.forEach(function (id) { reorder.addToReorder(id); });\r\n        this.repaint();\r\n        return this;\r\n    },\r\n\r\n    getSortedItems: function (arr) {\r\n        this._objectsReorderInit();\r\n        return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));\r\n    },\r\n\r\n    setSortFunc: function (func) {\r\n        this._objectsReorderInit();\r\n        var reorder = this._objectsReorder;\r\n        reorder.sortFunc = func;\r\n        reorder.userSetSortFunc = func ? true : false;\r\n        this._gmx.sortItems = reorder.sortItems;\r\n        this.repaint();\r\n        return this;\r\n    },\r\n    disableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = true;\r\n        return this;\r\n    },\r\n    enableFlip: function() {\r\n        this._objectsReorderInit();\r\n        this._objectsReorder.disabled = false;\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ObjectsReorder.js","L.gmx.VectorLayer.include({\r\n    bindPopup: function (content, options) {\r\n        var popupOptions = L.extend({maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID}, options);\r\n\r\n        if (this._popup) { this.unbindPopup(); }\r\n        if (content instanceof L.Popup) {\r\n            this._popup = content;\r\n        } else {\r\n            if (!this._popup || options) {\r\n                this._popup = new L.Popup(popupOptions);\r\n            }\r\n            this._popup.setContent(content);\r\n        }\r\n        this._popup._initContent = content;\r\n        this._popup._state = '';\r\n\r\n        if (!this._popupHandlersAdded) {\r\n            this\r\n                .on('click', this._openClickPopup, this)\r\n                .on('mousemove', this._movePopup, this)\r\n                .on('mouseover', this._overPopup, this)\r\n                .on('mouseout', this._outPopup, this)\r\n                .on('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupHandlersAdded = true;\r\n        }\r\n        if (popupOptions && popupOptions.popupopen) {\r\n            this._popupopen = popupOptions.popupopen;\r\n        }\r\n\r\n        this._popup.updateLayout = this._popup._updateLayout;\r\n\r\n        return this;\r\n    },\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openClickPopup, this)\r\n                .off('mousemove', this._movePopup, this)\r\n\t\t\t    .off('mouseover', this._overPopup, this)\r\n                .off('mouseout', this._outPopup, this)\r\n                .off('doneDraw', this._chkNeedOpenPopup, this);\r\n\r\n            this._popupopen = null;\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n        this._gmx.balloonEnable = false;\r\n\t\treturn this;\r\n\t},\r\n\r\n    _chkNeedOpenPopup: function () {\r\n        for (var id in this._gmx._needPopups) {\r\n            if (this._gmx._needPopups[id]) {\r\n                this.addPopup(id);\r\n                delete this._gmx._needPopups[id];\r\n            }\r\n        }\r\n    },\r\n\r\n    disablePopup: function () {\r\n        this._popupDisabled = true;\r\n\t\treturn this;\r\n    },\r\n\r\n    enablePopup: function () {\r\n        this._popupDisabled = false;\r\n\t\treturn this;\r\n    },\r\n\r\n\topenPopup: function (latlng, options) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\toptions = options || {};\r\n            options.latlng = latlng;\r\n            this._openPopup(options);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n            this.fire('popupclose', {popup: this._popup});\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n    _movePopup: function (options) {\r\n        if (this._popup._state === 'mouseover') {\r\n            var id = this._popup.options._gmxID || -1;\r\n            if (id !== options.gmx.id) {\r\n                this._setPopupContent(options);\r\n            }\r\n            this._popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _overPopup: function (options) {\r\n        var _popup = this._popup;\r\n        if (!_popup._map) {\r\n            this._openPopup(options);\r\n        } else {\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: this._setPopupContent(options, _popup)\r\n            });\r\n        }\r\n        if (_popup._state === 'mouseover') {\r\n            _popup.setLatLng(options.latlng);\r\n        }\r\n    },\r\n\r\n    _outPopup: function (ev) {\r\n        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {\r\n            this.closePopup();\r\n        }\r\n    },\r\n\r\n    _callBalloonHook: function (props, div) {\r\n\r\n        var spans = div.getElementsByTagName('span'),\r\n            hooksCount = {},\r\n            key, i, len;\r\n        for (key in this._balloonHook) {    // collect hook counts\r\n            var hookID = this._balloonHook[key].hookID;\r\n            hooksCount[key] = 0;\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                if (spans[i].id === hookID) {\r\n                    hooksCount[key]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (key in this._balloonHook) {\r\n            var hook = this._balloonHook[key],\r\n                fid = hook.hookID,\r\n                notFound = true;\r\n\r\n            for (i = 0, len = spans.length; i < len; i++) {\r\n                var node = spans[i];\r\n                if (node.id === fid) {\r\n                    notFound = false;\r\n                    node.id += '_' + i;\r\n                    hook.callback(props, div, node, hooksCount);\r\n                }\r\n            }\r\n            if (notFound) {\r\n                hook.callback(props, div, null, hooksCount);\r\n            }\r\n        }\r\n    },\r\n\r\n    _setPopupContent: function (options, _popup) {\r\n        if (!_popup) { _popup = this._popup; }\r\n        var gmx = options.gmx || {},\r\n            balloonData = gmx.balloonData || {},\r\n            properties = L.extend({}, gmx.properties),\r\n            target = gmx.target || {},\r\n            geometry = target.geometry || {},\r\n            offset = target.offset,\r\n            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',\r\n            type = options.type,\r\n            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),\r\n            outItem = {\r\n                id: gmx.id,\r\n                type: type,\r\n                nodePoint: gmx.nodePoint,\r\n                latlng: options.latlng,\r\n                properties: properties,\r\n                templateBalloon: templateBalloon\r\n            };\r\n\r\n        if (geometry.type === 'POINT') {\r\n            var coord = geometry.coordinates;\r\n            outItem.latlng = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n        }\r\n        if (offset) {\r\n            var protoOffset = L.Popup.prototype.options.offset;\r\n            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];\r\n        }\r\n\r\n        if (this._popupopen) {\r\n            this._popupopen({\r\n                popup: _popup,\r\n                latlng: outItem.latlng,\r\n                layerPoint: options.layerPoint,\r\n                contentNode: _popup._contentNode,\r\n                containerPoint: options.containerPoint,\r\n                originalEvent: options.originalEvent,\r\n                gmx: outItem\r\n            });\r\n        } else if (!(templateBalloon instanceof L.Popup)) {\r\n            if (!(templateBalloon instanceof HTMLElement)) {\r\n                var geometries,\r\n                    summary = '',\r\n                    unitOptions = this._map ? this._map.options : {};\r\n\r\n                if (!skipSummary) {\r\n                    geometries = target.geometry ? [target.geometry] : (gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || []);\r\n                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);\r\n                }\r\n                if (this._balloonHook) {\r\n                    if (!templateBalloon) {\r\n                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);\r\n                    }\r\n                    for (var key in this._balloonHook) {\r\n                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);\r\n                    }\r\n                }\r\n                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {\r\n                    properties: properties,\r\n                    tileAttributeTypes: this._gmx.tileAttributeTypes,\r\n                    unitOptions: unitOptions,\r\n                    summary: summary,\r\n                    geometries: geometries\r\n                });\r\n            }\r\n\r\n            var contentDiv = L.DomUtil.create('div', '');\r\n            contentDiv.innerHTML = templateBalloon;\r\n            _popup.setContent(contentDiv);\r\n            if (this._balloonHook) {\r\n                this._callBalloonHook(gmx.properties, _popup.getContent());\r\n            }\r\n            //outItem.templateBalloon = templateBalloon;\r\n        }\r\n        _popup.options._gmxID = gmx.id;\r\n        return outItem;\r\n    },\r\n\r\n    _openClickPopup: function (options) {\r\n        var originalEvent = options.originalEvent || {},\r\n            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                gmx = options.gmx,\r\n                balloonData = gmx.balloonData,\r\n                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,\r\n                item = gmx.target;\r\n\r\n            if (flag && item.options.isGeneralized && !item.geometry) {\r\n                var layerProp = gmx.layer.getGmxProperties();\r\n                gmxAPIutils.getLayerItemFromServer({\r\n                    options: options,\r\n                    layerID: layerProp.name,\r\n                    value: item.id,\r\n                    field: layerProp.identityField\r\n                }).then(function(json, params) {\r\n                    if (json && json.Status === 'ok' && json.Result) {\r\n                        var pArr = json.Result.values[0];\r\n                        params.options.gmx.target.fromServerProps = pArr;\r\n                        params.options.gmx.target.geometry = pArr[pArr.length - 1];\r\n                        this._openPopup(params.options);\r\n                    }\r\n                }.bind(this));\r\n            } else {\r\n                this._openPopup(options);\r\n            }\r\n        }\r\n    },\r\n\r\n    _openPopup: function (options, notSkip) {\r\n        var map = this._map,\r\n            originalEvent = options.originalEvent || {},\r\n            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;\r\n\r\n        if (!skip) {\r\n            var type = options.type,\r\n                _popup = this._popup,\r\n                gmx = options.gmx || {},\r\n                balloonData = gmx.balloonData || {};\r\n\r\n            if (type === 'click') {\r\n                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) { return; }\r\n\r\n                if (!('_gmxPopups' in map)) {\r\n                    map._gmxPopups = [];\r\n                }\r\n                if (!('maxPopupCount' in map.options)) { map.options.maxPopupCount = 1; }\r\n                if (!this._gmx._gmxPopupsInit) {\r\n                    this._gmx._gmxPopupsInit = true;\r\n                    map.on({\r\n                        layerremove: function (ev) {\r\n                            if (ev.layer instanceof L.Popup) {\r\n                                this._clearPopup(ev.layer);\r\n                            } else if (ev.layer === this) {\r\n                                if (map._gmxPopups) {\r\n                                    var layerId = this._gmx.layerID;\r\n                                    map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                                        if (c._map) {\r\n                                            if (c.options.layerId === layerId) { c._map.removeLayer(c); }\r\n                                            else { p.push(c); }\r\n                                        }\r\n                                        return p;\r\n                                    }, []);\r\n                                }\r\n                                this.closePopup();\r\n                            }\r\n                        }\r\n                    }, this);\r\n                }\r\n\r\n                this._clearPopup(gmx.id);\r\n                var opt = this._popup ? this._popup.options : {maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID};\r\n                _popup = new L.Popup(L.extend({}, opt, {closeOnClick: map.options.maxPopupCount === 1, autoPan: true}));\r\n            } else if (type === 'mouseover') {\r\n                if (balloonData.DisableBalloonOnMouseMove) {\r\n                    _popup._state = '';\r\n                    return;\r\n                }\r\n                _popup.options.autoPan = false;\r\n            } else {\r\n                return;\r\n            }\r\n            _popup.options.objectId = gmx.id;\r\n            _popup._state = type;\r\n            var outItem = this._setPopupContent(options, _popup);\r\n            _popup.setLatLng(outItem.latlng);\r\n\r\n            this.fire('popupopen', {\r\n                popup: _popup,\r\n                gmx: outItem\r\n            });\r\n            if (type === 'click') {\r\n                if (map._gmxPopups.length >= map.options.maxPopupCount) {\r\n                    map.removeLayer(map._gmxPopups.shift());\r\n                }\r\n                map._gmxPopups.push(_popup);\r\n            }\r\n            _popup.addTo(map);    // this._map.openPopup(_popup);\r\n\r\n            if (_popup._closeButton) {\r\n                var closeStyle = _popup._closeButton.style;\r\n                if (type === 'mouseover' && closeStyle !== 'hidden') {\r\n                    closeStyle.visibility = 'hidden';\r\n                    _popup._container.style.marginBottom = '7px';\r\n                    _popup._container.style.pointerEvents = 'none';\r\n                } else if (type === 'click' && closeStyle !== 'inherit') {\r\n                    closeStyle.visibility = 'inherit';\r\n                    _popup._container.style.marginBottom = '';\r\n                    _popup._container.style.pointerEvents = '';\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n\t_clearPopup: function (item /* <L.Popup> or objectId */) {\r\n        var map = this._map;\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID,\r\n                flagPopup = item instanceof L.Popup;\r\n            map._gmxPopups = map._gmxPopups.reduce(function(p, c) {\r\n                if (c._map) {\r\n                    if (flagPopup && c === item) { c._map.removeLayer(c); }\r\n                    else if (c.options.layerId === layerId && c.options.objectId === item) { c._map.removeLayer(c); }\r\n                    else { p.push(c); }\r\n                }\r\n                return p;\r\n            }, []);\r\n        }\r\n    },\r\n\r\n    getPopups: function (flag) {\r\n        var map = this._map,\r\n            out = [];\r\n        if (map && map._gmxPopups) {\r\n            var layerId = this._gmx.layerID;\r\n            map._gmxPopups.reduce(function(p, c) {\r\n                if (c.options.layerId === layerId) { p.push(flag ? c : c.options.objectId); }\r\n                return p;\r\n            }, out);\r\n        }\r\n        return out;\r\n    },\r\n\r\n    addPopup: function (id) {\r\n        var gmx = this._gmx,\r\n            item = gmx.dataManager.getItem(id);\r\n        if (!item || !this._map) {\r\n            gmx._needPopups[id] = false;\r\n        } else {\r\n            var center = item.bounds.getCenter(),\r\n                latlng = L.Projection.Mercator.unproject(new L.Point(center[0], center[1]));\r\n            this._openPopup({\r\n                type: 'click',\r\n                latlng: latlng,\r\n                gmx: this.getHoverOption(item)\r\n            }, true);\r\n            delete gmx._needPopups[id];\r\n        }\r\n        return this;\r\n    },\r\n\r\n    addPopupHook: function (key, callback) {\r\n        if (!this._balloonHook) { this._balloonHook = {}; }\r\n        if (!this._balloonHook[key]) {\r\n            var hookID = '_' + L.stamp({});\r\n            this._balloonHook[key] = {\r\n                key: key,\r\n                hookID: hookID,\r\n                resStr: '<span id=\"' + hookID + '\"></span>',\r\n                callback: callback\r\n            };\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removePopupHook: function(key) {\r\n        if (this._balloonHook) { delete this._balloonHook[key]; }\r\n        return this;\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Popup.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\nL.gmx.VectorLayer.include({\r\n    _gmxFirstObjectsByPoint: function (geoItems, mercPoint, bounds) {    //      mouseClick\r\n        var gmx = this._gmx,\r\n            mInPixel = gmx.mInPixel,\r\n            j,\r\n            len;\r\n\r\n        for (var i = geoItems.length - 1; i >= 0; i--) {\r\n            var geoItem = geoItems[i].properties,\r\n                idr = geoItem[0],\r\n                dataOption = geoItems[i].dataOption || {},\r\n                item = gmx.dataManager.getItem(idr),\r\n                currentStyle = item.currentStyle || item.parsedStyleKeys || {},\r\n                iconScale = currentStyle.iconScale || 1,\r\n                iconCenter = currentStyle.iconCenter,\r\n                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,\r\n                parsedStyle = gmx.styleManager.getObjStyle(item),\r\n                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,\r\n                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),\r\n                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),\r\n                offset = [\r\n                    iconScale * sx / 2,\r\n                    iconScale * sy / 2\r\n                ],\r\n                point = mercPoint,\r\n                geom = geoItem[geoItem.length - 1],\r\n                type = geom.type;\r\n\r\n            if (type === 'POINT' && parsedStyle.type === 'circle') {\r\n                offset[0] *= 2;\r\n                offset[1] *= 2;\r\n            }\r\n            var radius = offset[0],\r\n                objBounds = gmxAPIutils.bounds()\r\n                    .extendBounds(dataOption.bounds)\r\n                    .addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n            if (iconAnchor) {\r\n                offset = [\r\n                    iconAnchor[0] - offset[0],\r\n                    iconAnchor[1] - offset[1]\r\n                ];\r\n                point = [\r\n                    mercPoint[0] + offset[0] / mInPixel,\r\n                    mercPoint[1] - offset[1] / mInPixel\r\n                ];\r\n            }\r\n            if (!objBounds.contains(point)) { continue; }\r\n\r\n            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,\r\n                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,\r\n                chktype = type,\r\n                hiddenLines = dataOption.hiddenLines || [],\r\n                boundsArr = dataOption.boundsArr,\r\n                coords = geom.coordinates,\r\n                nodePoint = null,\r\n                ph = {\r\n                    point: mercPoint,\r\n                    bounds: bounds,\r\n                    coords: coords,\r\n                    boundsArr: boundsArr\r\n                };\r\n\r\n            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {\r\n                if (marker) {\r\n                    chktype = 'POINT';\r\n                } else if (!fill) {\r\n                    if (type === 'POLYGON') {\r\n                        chktype = 'MULTILINESTRING';\r\n                        hiddenLines = hiddenLines[0];\r\n                    } else {\r\n                        chktype = 'LIKEMULTILINESTRING';\r\n                    }\r\n                    ph.hidden = hiddenLines;\r\n                }\r\n            }\r\n\r\n            if (chktype === 'LINESTRING') {\r\n                if (!gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {\r\n                    nodePoint = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'LIKEMULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                var flag = false;\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    ph.coords = coords[j];\r\n                    ph.hidden = hiddenLines ? hiddenLines[j] : null;\r\n                    ph.boundsArr = boundsArr[j];\r\n                    if (gmxAPIutils.isPointInLines(ph)) {\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'MULTILINESTRING') {\r\n                ph.delta = lineWidth / mInPixel;\r\n                ph.hidden = hiddenLines;\r\n                if (!gmxAPIutils.isPointInLines(ph)) {\r\n                    var pBounds = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);\r\n                    for (j = 0, len = coords.length; j < len; j++) {\r\n                        nodePoint = pBounds.isNodeIntersect(coords[j]);\r\n                        if (nodePoint !== null) {\r\n                            nodePoint.ring = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (nodePoint === null) { continue; }\r\n                }\r\n            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {\r\n                var chkPoint = mercPoint;\r\n                flag = false;\r\n                if (chktype === 'POLYGON') {\r\n                    coords = [geom.coordinates];\r\n                    boundsArr = [dataOption.boundsArr];\r\n                }\r\n                for (j = 0, len = coords.length; j < len; j++) {\r\n                    var arr = coords[j],\r\n                        bbox = boundsArr[j];\r\n                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {\r\n                        var b = bbox[j1];\r\n                        if (b.intersects(bounds)) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {\r\n                                flag = j1 === 0 ? true : false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!flag) { continue; }\r\n            } else if (chktype === 'POINT') {\r\n                if (parsedStyle.type === 'circle') {\r\n                    var x = (coords[0] - point[0]) * mInPixel,\r\n                        y = (coords[1] - point[1]) * mInPixel;\r\n                    if (x * x + y * y > radius * radius) { continue; }\r\n                }\r\n            }\r\n            if (!this.isPointInClipPolygons(mercPoint)) {\r\n                continue;\r\n            }\r\n\r\n            return {\r\n                id: idr,\r\n                properties: item.properties,\r\n                geometry: geom,\r\n                bounds: item.bounds,\r\n                nodePoint: nodePoint,\r\n                offset: iconAnchor ? offset : null,\r\n                parsedStyle: parsedStyle\r\n            };\r\n        }\r\n        return null;\r\n    },\r\n\r\n    gmxEventCheck: function (ev, skipOver) {\r\n        if (!this._map) {\r\n            return 0;\r\n        }\r\n        var layer = this,\r\n            gmx = layer._gmx,\r\n            type = ev.type,\r\n            lastHover = gmx.lastHover,\r\n            chkHover = function (evType) {\r\n                if (lastHover && type === 'mousemove') {\r\n                    if (evType && layer.hasEventListeners(evType)) {\r\n                        ev.gmx = lastHover;\r\n                        layer.fire(evType, ev);\r\n                    }\r\n                    if (lastHover.hoverDiff) { layer.redrawItem(lastHover.id); }\r\n                }\r\n            };\r\n\r\n        var zoom = this._map.getZoom();\r\n        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n            skipOver = true;\r\n        }\r\n        if (skipOver) {\r\n            if (lastHover) { lastHover.prevId = null; }\r\n            chkHover('mouseout');\r\n            gmx.lastHover = null;\r\n        } else if (\r\n            this.hasEventListeners('mouseover') ||\r\n            this.hasEventListeners('mouseout') ||\r\n            this.hasEventListeners(type) ||\r\n            (type === 'mousemove' && gmx.properties.fromType !== 'Raster')\r\n            ) {\r\n\r\n            var lng = ev.latlng.lng % 360,\r\n                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : (lng > 180 ? -360 : 0))),\r\n                point = L.Projection.Mercator.project(latlng)._subtract(\r\n                    {x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0}\r\n                ),\r\n                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,\r\n                mercatorPoint = [point.x, point.y];\r\n\r\n            // observer   ,      \r\n            var observerOptions = {\r\n                type: 'resend',\r\n                bbox: gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),\r\n                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,\r\n                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'],\r\n                active: false //  ,       \r\n            };\r\n            if (this.options.isGeneralized) {\r\n                observerOptions.targetZoom = zoom;\r\n            }\r\n\r\n            gmx.dataManager.addObserver(observerOptions, 'hover');\r\n\r\n            var geoItems = gmx.dataManager.getItems('hover');\r\n\r\n            gmx.dataManager.removeObserver('hover');\r\n\r\n            if (geoItems && geoItems.length) {\r\n                if (geoItems.length > 1 && gmx.sortItems) { geoItems = this.getSortedItems(geoItems); }\r\n\r\n                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);\r\n                if (target) {\r\n                    var idr = target.id,\r\n                        item = gmx.dataManager.getItem(idr),\r\n                        prevId = lastHover ? lastHover.id : null,\r\n                        changed = !lastHover || lastHover.id !== idr;\r\n                    if (type === 'mousemove' && lastHover) {\r\n                        if (!changed) {\r\n                            ev.gmx = lastHover;\r\n                            this.fire(type, ev);\r\n                            return idr;\r\n                        }\r\n                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');\r\n                        gmx.lastHover = null;\r\n                    }\r\n\r\n                    ev.gmx = L.extend(this.getHoverOption(item), {\r\n                        targets: geoItems,\r\n                        nodePoint: target.nodePoint,\r\n                        prevId: prevId,\r\n                        hoverDiff: item.hoverDiff\r\n                    });\r\n                    if (this.hasEventListeners(type)) { this.fire(type, ev); }\r\n                    if (type === 'mousemove' && changed) {\r\n                        lastHover = gmx.lastHover = ev.gmx;\r\n                        chkHover('mouseover');\r\n                        gmx.lastMouseover = gmx.lastHover;\r\n                    }\r\n                    this._map.doubleClickZoom.disable();\r\n                    return idr;\r\n                }\r\n            }\r\n        }\r\n        if (this._map) {\r\n            this._map.doubleClickZoom.enable();\r\n        }\r\n        return 0;\r\n    },\r\n\r\n    getHoverOption: function (item) {\r\n        return {\r\n            layer: this,\r\n            target: item,\r\n            balloonData: this._gmx.styleManager.getItemBalloon(item.id),\r\n            properties: this.getItemProperties(item.properties),\r\n            currentFilter: item.currentFilter || 0,\r\n            id: item.id\r\n        };\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/VectorLayer.Hover.js","import {gmxAPIutils} from '../Utils.js';\r\n\r\n(function() {\r\nvar delay = 20000,\r\n    layers = {},\r\n    dataManagersLinks = {},\r\n    script = '/Layer/CheckVersion.ashx',\r\n    intervalID = null,\r\n    timeoutID = null,\r\n    lastLayersStr = '';\r\n\r\nvar isExistsTiles = function(prop) {\r\n    var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';\r\n    return tilesKey in prop;\r\n};\r\nvar getParams = function(prop, dm, layerDateInterval) {\r\n    var pt = {\r\n        Name: prop.name,\r\n        Version: isExistsTiles(prop) ? prop.LayerVersion : -1\r\n    };\r\n\tif (dm && (prop.UseTiles === false || window.gmxSkipTiles === 'NotVisible')) {\r\n\t\tvar maxDateInterval = dm.getMaxDateInterval(),\r\n\t\t\tbeginDate = maxDateInterval.beginDate || layerDateInterval.beginDate,\r\n\t\t\tendDate = maxDateInterval.endDate || layerDateInterval.endDate;\r\n        if (beginDate) { pt.dateBegin = Math.floor(beginDate.getTime() / 1000); }\r\n        if (endDate) { pt.dateEnd = Math.floor(endDate.getTime() / 1000); }\r\n    }\r\n    return pt;\r\n};\r\nvar getRequestParams = function(layer) {\r\n    var hosts = {},\r\n        prop, hostName, dm, layerDateInterval;\r\n    if (layer) {\r\n        if (layer instanceof L.gmx.DataManager) {\r\n\t\t\tdm = layer;\r\n\t\t\tprop = dm.options;\r\n\t\t} else {\r\n\t\t\tprop = layer._gmx.properties;\r\n\t\t\tdm = layer._gmx.dataManager;\r\n\t\t\tlayerDateInterval = layer._gmx;\r\n\t\t}\r\n        hostName = prop.hostName || layer._gmx.hostName;\r\n\t\thosts[hostName] = [getParams(prop, dm, layerDateInterval)];\r\n    } else {\r\n        var skipItems = {};\r\n        for (var id in layers) {\r\n            var obj = layers[id],\r\n\t\t\t\tisDataManager = obj instanceof L.gmx.DataManager;\r\n            if (obj.options.chkUpdate || isDataManager) {\r\n\t\t\t\tdm = isDataManager ? obj : obj._gmx.dataManager;\r\n                prop = isDataManager ? obj.options : obj._gmx.properties;\r\n\t\t\t\tlayerDateInterval = isDataManager ? obj : obj._gmx;\r\n                hostName = prop.hostName || obj._gmx.hostName;\r\n                var pt = getParams(prop, dm, layerDateInterval),\r\n                    key = pt.Name + pt.Version;\r\n                if (!skipItems[key]) {\r\n                    if (hosts[hostName]) { hosts[hostName].push(pt); }\r\n                    else { hosts[hostName] = [pt]; }\r\n                }\r\n                skipItems[key] = true;\r\n            }\r\n        }\r\n    }\r\n    return hosts;\r\n};\r\n\r\nvar chkVersion = function (layer, callback) {\r\n    var processResponse = function(res) {\r\n        if (res && res.Status === 'ok' && res.Result) {\r\n            for (var i = 0, len = res.Result.length; i < len; i++) {\r\n                var item = res.Result[i],\r\n                    id = item.properties.name;\r\n\r\n\t\t\t\tif (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) { layer.updateVersion(item); }\r\n                for (var key in layers) {\r\n                    var curLayer = layers[key];\r\n\t\t\t\t\tif (layer && layer === curLayer) { continue; }\r\n                    if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {\t// \r\n\t\t\t\t\t\tcurLayer.updateVersion(item);\r\n\t\t\t\t\t} else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {\t//  \r\n\t\t\t\t\t\tcurLayer.updateVersion(item.properties);\r\n\t\t\t\t\t}\r\n                }\r\n            }\r\n        }\r\n        lastLayersStr = '';\r\n        if (callback) { callback(res); }\r\n    };\r\n\r\n    if (document.body && !gmxAPIutils.isPageHidden()) {\r\n        var hosts = getRequestParams(layer),\r\n            chkHost = function(hostName) {\r\n                var url = 'http://' + hostName + script,\r\n                    layersStr = JSON.stringify(hosts[hostName]);\r\n\r\n                if (lastLayersStr !== layersStr) {\r\n                    lastLayersStr = layersStr;\r\n                    if ('FormData' in window) {\r\n                        gmxAPIutils.request({\r\n                            url: url,\r\n                            async: true,\r\n                            headers: {\r\n                                'Content-type': 'application/x-www-form-urlencoded'\r\n                            },\r\n                            type: 'POST',\r\n                            params: 'WrapStyle=None&layers=' + encodeURIComponent(layersStr),\r\n                            withCredentials: true,\r\n                            callback: function(response) {\r\n                                processResponse(JSON.parse(response));\r\n                            },\r\n                            onError: function(response) {\r\n                                console.log('Error: LayerVersion ', response);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        gmxAPIutils.sendCrossDomainPostRequest(url, {\r\n                            WrapStyle: 'message',\r\n                            layers: layersStr\r\n                        }, processResponse);\r\n                    }\r\n                    var timeStamp = Date.now();\r\n                    for (var key in layers) {\r\n                        var it = layers[key];\r\n                        var options = it._gmx || it.options;\r\n                        if (options.hostName === hostName) { options._stampVersionRequest = timeStamp; }\r\n                    }\r\n                }\r\n            };\r\n        for (var hostName in hosts) {\r\n            chkHost(hostName);\r\n        }\r\n    }\r\n};\r\n\r\nvar layersVersion = {\r\n\r\n    addDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\t\tdataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\tlayers[id] = dataManager;\r\n    },\r\n\r\n    removeDataManager: function(dataManager) {\r\n        var id = dataManager.options.name;\r\n        if (id in layers) {\r\n\t\t\tdataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));\r\n\t\t\tdelete layers[id];\r\n\t\t}\r\n    },\r\n\r\n    remove: function(layer) {\r\n        delete layers[layer._leaflet_id];\r\n        var _gmx = layer._gmx,\r\n\t\t\tpOptions = layer.options.parentOptions;\r\n\t\tif (pOptions) {\r\n\t\t\tvar pId = pOptions.name;\r\n\t\t\tif (dataManagersLinks[pId]) {\r\n\t\t\t\tdelete dataManagersLinks[pId][_gmx.properties.name];\r\n\t\t\t\tif (!Object.keys(dataManagersLinks[pId]).length) {\r\n\t\t\t\t\tlayersVersion.removeDataManager(_gmx.dataManager);\r\n\t\t\t\t\tdelete dataManagersLinks[pId];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t}\r\n    },\r\n\r\n    add: function(layer) {\r\n        var id = layer._leaflet_id;\r\n        if (id in layers) {\r\n            return;\r\n\t\t}\r\n\r\n        var _gmx = layer._gmx,\r\n            prop = _gmx.properties;\r\n        if ('LayerVersion' in prop) {\r\n            layers[id] = layer;\r\n            _gmx._chkVersion = function () {\r\n                chkVersion(layer);\r\n            };\r\n            _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);\r\n\t\t\tvar pOptions = layer.options.parentOptions;\r\n\t\t\tif (pOptions) {\r\n\t\t\t\tvar pId = pOptions.name;\r\n\t\t\t\tlayersVersion.addDataManager(_gmx.dataManager);\r\n\t\t\t\tif (!dataManagersLinks[pId]) { dataManagersLinks[pId] = {}; }\r\n\t\t\t\tdataManagersLinks[pId][prop.name] = layer;\r\n\t\t\t}\r\n\r\n            layersVersion.start();\r\n            if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {\r\n\t\t\t\tlayersVersion.now();\r\n            }\r\n        }\r\n    },\r\n\r\n    chkVersion: chkVersion,\r\n\r\n    now: function() {\r\n\t\tif (timeoutID) { clearTimeout(timeoutID); }\r\n\t\ttimeoutID = setTimeout(chkVersion, 0);\r\n    },\r\n\r\n    stop: function() {\r\n        if (intervalID) { clearInterval(intervalID); }\r\n        intervalID = null;\r\n    },\r\n\r\n    start: function(msec) {\r\n        if (msec) { delay = msec; }\r\n        layersVersion.stop();\r\n        intervalID = setInterval(chkVersion, delay);\r\n    }\r\n};\r\n\r\nif (!L.gmx) { L.gmx = {}; }\r\nL.gmx.layersVersion = layersVersion;\r\n\r\nL.gmx.VectorLayer.include({\r\n    updateVersion: function (layerDescription) {\r\n        if (layerDescription) {\r\n            var gmx = this._gmx;\r\n            if (layerDescription.geometry) {\r\n                gmx.geometry = layerDescription.geometry;\r\n            }\r\n            if (layerDescription.properties) {\r\n                L.extend(gmx.properties, layerDescription.properties);\r\n                gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;\r\n                gmx.rawProperties = gmx.properties;\r\n                this.fire('versionchange');\r\n\t\t\t\tif (!gmx.dataSource) {\r\n\t\t\t\t\tgmx.dataManager.updateVersion(gmx.rawProperties);\r\n\t\t\t\t}\r\n            }\r\n        }\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LayersVersion.js","//Raster layer is just vector layer with the single object and special background tiles\r\nL.gmx.RasterLayer = L.gmx.VectorLayer.extend(\r\n{\r\n    options: {\r\n        isGeneralized: false,\r\n        zIndexOffset: 0\r\n        //clickable: false\r\n    },\r\n    initFromDescription: function(ph) {\r\n        var props = ph.properties,\r\n            styles = props.styles[0] || {MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21},\r\n            vectorProperties = {\r\n                type: 'Vector',\r\n                fromType: props.type,\r\n                identityField: 'ogc_fid',\r\n                GeometryType: 'POLYGON',\r\n                IsRasterCatalog: true,\r\n                Copyright: props.Copyright || '',\r\n                RCMinZoomForRasters: styles.MinZoom,\r\n                visible: props.visible,\r\n                styles: [{\r\n                    DisableBalloonOnClick: true,\r\n                    MinZoom: styles.MinZoom,\r\n                    MaxZoom: styles.MaxZoom,\r\n                    RenderStyle: {outline: {thickness: 0}, fill: {opacity: 100}},\r\n                    HoverStyle: null\r\n                }]\r\n            },\r\n            gmx = this._gmx,\r\n            worldSize = gmxAPIutils.tileSizes[1];\r\n\r\n        if (props.MaxZoom) {\r\n            gmx.maxNativeZoom = props.MaxZoom;\r\n        }\r\n        if (!ph.geometry) {\r\n            ph.geometry = {\r\n                type: 'POLYGON',\r\n                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]\r\n            };\r\n        }\r\n\r\n\t\tL.gmx.VectorLayer.prototype.initFromDescription.call(this, {geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties});\r\n\r\n        gmx.rasterBGfunc = function(x, y, z) {\r\n\t\t\treturn 'http://' + gmx.hostName + '/' +\r\n\t\t\t\t'TileSender.ashx?ModeKey=tile' +\r\n\t\t\t\t'&key=' + encodeURIComponent(gmx.sessionKey) +\r\n\t\t\t\t'&LayerName=' + gmx.layerID +\r\n\t\t\t\t'&z=' + z +\r\n\t\t\t\t'&x=' + x +\r\n\t\t\t\t'&y=' + y;\r\n\t\t};\r\n\r\n\t\tvar vectorDataProvider = {load: function(x, y, z, v, s, d, callback) {\r\n            var objects = [[777, ph.geometry]],\r\n                itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),\r\n                bounds = itemBounds.bounds;\r\n\r\n            if (bounds.max.x > worldSize) {\r\n                // for old layers geometry\r\n                var ww2 = 2 * worldSize,\r\n                    id = 777,\r\n                    coords = ph.geometry.coordinates,\r\n                    bboxArr = itemBounds.boundsArr;\r\n\r\n                objects = [];\r\n                if (ph.geometry.type === 'POLYGON') {\r\n                    coords = [coords];\r\n                    bboxArr = [bboxArr];\r\n                }\r\n\r\n                for (var i = 0, len = coords.length; i < len; i++) {\r\n                    var it = coords[i],\r\n                        bbox = bboxArr[i][0],\r\n                        arr = it;\r\n                    objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    if (bbox.max.x > worldSize) {\r\n                        arr = [];\r\n                        for (var j = 0, len1 = it.length; j < len1; j++) {\r\n                            var it1 = it[j];\r\n                            for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {\r\n                                var it2 = it1[j1];\r\n                                arr1.push([it2[0] - ww2, it2[1]]);\r\n                            }\r\n                            arr.push(arr1);\r\n                        }\r\n                        objects.push([id++, {type: 'POLYGON', coordinates: arr}]);\r\n                    }\r\n                }\r\n            }\r\n\t\t\tcallback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);\r\n\t\t}};\r\n\t\tgmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, {x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2});\r\n\t\tgmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);\r\n\r\n        return this;\r\n    },\r\n\r\n    setZoomBounds: function(minZoom, maxZoom) {\r\n        var styles = this.getStyles().slice(0);\r\n        styles[0] = L.extend({}, styles[0]);\r\n        styles[0].MinZoom = minZoom;\r\n        styles[0].MaxZoom = maxZoom;\r\n        this.setStyles(styles);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/RasterLayer.js","/*\r\n (c) 2014, Sergey Alekseev\r\n Leaflet.LabelsLayer, plugin for Gemixer layers.\r\n*/\r\nimport {gmxAPIutils} from '../Utils.js';\r\n\r\nL.LabelsLayer = L.Class.extend({\r\n\r\n    options: {\r\n        pane: 'overlayPane'\r\n    },\r\n\r\n    initialize: function (map, options) {\r\n        L.setOptions(this, options);\r\n        this._observers = {};\r\n        this._styleManagers = {};\r\n        this._labels = {};\r\n        var _this = this;\r\n\r\n        this.bbox = gmxAPIutils.bounds();\r\n\r\n        var chkData = function (data, layer) {\r\n            if (!data.added && !data.removed) { return; }\r\n\r\n            var opt = layer.options,\r\n                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],\r\n                layerId = '_' + layer._leaflet_id,\r\n                gmx = layer._gmx,\r\n                labels = {};\r\n\r\n            for (var i = 0, len = added.length; i < len; i++) {\r\n                var item = added[i].item,\r\n                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',\r\n                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};\r\n\r\n                if (gmx.styleHook) {\r\n                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);\r\n                    if (styleExtend) {\r\n                        currentStyle = L.extend({}, currentStyle, styleExtend);\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (item.multiFilters) {\r\n                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {\r\n                        var st = item.multiFilters[j].parsedStyle;\r\n                        if ('labelField' in st || 'labelText' in st) {\r\n                            currentStyle = st;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                var style = gmx.styleManager.getObjStyle(item) || {},\r\n                    labelText = currentStyle.labelText || style.labelText,\r\n                    labelField = currentStyle.labelField || style.labelField,\r\n                    fieldType = gmx.tileAttributeTypes[labelField],\r\n                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));\r\n\r\n                if (style.labelTemplate) {\r\n\t\t\t\t\tvar reg = /\\[([^\\]]*)\\]/g,\r\n\t\t\t\t\t\tmatch;\r\n\t\t\t\t\ttxt = style.labelTemplate;\r\n\r\n\t\t\t\t\twhile ((match = reg.exec(style.labelTemplate))) {\r\n\t\t\t\t\t\tif (match.length === 2) {\r\n\t\t\t\t\t\t\tlabelField = match[1];\r\n\t\t\t\t\t\t\tfieldType = gmx.tileAttributeTypes[labelField];\r\n\t\t\t\t\t\t\tvar val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));\r\n\t\t\t\t\t\t\ttxt = txt.replace(match[0], val);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                }\r\n\t\t\t\tif (txt || txt === 0) {\r\n                    var fontSize = currentStyle.labelFontSize || style.labelFontSize || 12,\r\n                        id = '_' + item.id,\r\n                        changed = true,\r\n                        width = 0,\r\n\t\t\t\t\t\tarrTxtWidth,\r\n                        options = item.options,\r\n                        labelStyle = {\r\n                            font: fontSize + 'px \"Arial\"',\r\n                            labelHaloColor: ('labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : ('labelHaloColor' in style ? style.labelHaloColor : 0xffffff)),\r\n                            labelColor: currentStyle.labelColor || style.labelColor,\r\n                            labelAlign: currentStyle.labelAlign || style.labelAlign,\r\n                            labelAnchor: currentStyle.labelAnchor || style.labelAnchor,\r\n                            labelFontSize: fontSize\r\n                        };\r\n                    if (options) {\r\n                        if (!('center' in options)) {\r\n                            var center = gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));\r\n                            if (!center) { continue; }\r\n                            options.center = center;\r\n                        }\r\n                        if (options.label) {\r\n                            width = options.label.width;\r\n                            arrTxtWidth = options.label.arrTxtWidth;\r\n                            var pstyle = options.label.style;\r\n                            changed = options.label.txt !== txt ||\r\n                                pstyle.labelHaloColor !== labelStyle.labelHaloColor ||\r\n                                pstyle.labelColor !== labelStyle.labelColor ||\r\n                                pstyle.labelAlign !== labelStyle.labelAlign ||\r\n                                pstyle.labelAnchor !== labelStyle.labelAnchor ||\r\n                                pstyle.labelFontSize !== labelStyle.labelFontSize;\r\n                        }\r\n                    }\r\n                    if (changed) {\r\n\t\t\t\t\t\twidth = 0;\r\n                        arrTxtWidth = gmxAPIutils.getLabelWidth(txt, labelStyle);\r\n\t\t\t\t\t\tif (arrTxtWidth) {\r\n\t\t\t\t\t\t    arrTxtWidth.forEach(function(it) {\r\n\t\t\t\t\t\t\t\twidth = Math.max(width, it[1]);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n                        if (!width) {\r\n                            delete labels[id];\r\n                            continue;\r\n                        }\r\n                        width += 4;\r\n                        item.options.labelStyle = null;\r\n                    }\r\n                    options.label = {\r\n                        isPoint: isPoint,\r\n                        width: width,\r\n                        sx: style.sx || 0,\r\n                        txt: txt,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        style: labelStyle\r\n                    };\r\n                    labels[id] = item;\r\n                }\r\n            }\r\n            _this._labels[layerId] = labels;\r\n        };\r\n\r\n        var addObserver = function (layer) {\r\n            var gmx = layer._gmx,\r\n                filters = ['styleFilter', 'userFilter'],\r\n                options = {\r\n                    type: 'resend',\r\n                    bbox: _this.bbox,\r\n                    filters: filters,\r\n                    callback: function(data) {\r\n                        chkData(data, layer);\r\n                        _this.redraw();\r\n                    }\r\n                };\r\n            if (gmx.beginDate && gmx.endDate) {\r\n                options.dateInterval = [gmx.beginDate, gmx.endDate];\r\n            }\r\n            return gmx.dataManager.addObserver(options, '_Labels');\r\n        };\r\n        this.add = function (layer) {\r\n            var id = layer._leaflet_id,\r\n                gmx = layer._gmx;\r\n\r\n            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {\r\n                gmx.styleManager.deferred.then(function () {\r\n                    var observer = addObserver(layer),\r\n\t\t\t\t\t\t_zoom = _this._map._zoom;\r\n                    if (layer.options.isGeneralized) {\r\n                        observer.targetZoom = _zoom;\t//need update to current zoom\r\n                    }\r\n                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {\r\n                        observer.deactivate();\r\n                    }\r\n                    _this._observers[id] = observer;\r\n                    _this._styleManagers[id] = gmx.styleManager;\r\n\r\n                    _this._labels['_' + id] = {};\r\n                    _this._updateBbox();\r\n                });\r\n            }\r\n        };\r\n        this.remove = function (layer) {\r\n            var id = layer._leaflet_id;\r\n            if (_this._observers[id]) {\r\n                var gmx = layer._gmx,\r\n                    dataManager = gmx.dataManager;\r\n                dataManager.removeObserver(_this._observers[id].id);\r\n                delete _this._observers[id];\r\n                delete _this._styleManagers[id];\r\n                delete _this._labels['_' + id];\r\n                _this.redraw();\r\n            }\r\n        };\r\n        this._layeradd = function (ev) {\r\n            _this.add(ev.layer);\r\n        };\r\n        this._layerremove = function (ev) {\r\n            _this.remove(ev.layer);\r\n        };\r\n    },\r\n\r\n    redraw: function () {\r\n        if (!this._frame && !this._map._animating) {\r\n            this._frame = L.Util.requestAnimFrame(this._redraw, this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    _addToPane: function () {\r\n        var pane = this._map.getPanes()[this.options.pane];\r\n        if (pane) {\r\n            pane.insertBefore(this._canvas, pane.firstChild);\r\n        }\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n\r\n        if (!this._canvas) {\r\n            this._initCanvas();\r\n        }\r\n        // this._addToPane();\r\n\r\n        map.on('moveend', this._reset, this);\r\n        map.on({\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        });\r\n        if (map.options.zoomAnimation && L.Browser.any3d) {\r\n            map.on('zoomanim', this._animateZoom, this);\r\n        }\r\n\r\n        this._reset();\r\n    },\r\n\r\n    onRemove: function (map) {\r\n        if (this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n\r\n        map.off('moveend', this._reset, this);\r\n        map.off('layeradd', this._layeradd);\r\n        map.off('layerremove', this._layerremove);\r\n\r\n        if (map.options.zoomAnimation) {\r\n            map.off('zoomanim', this._animateZoom, this);\r\n        }\r\n    },\r\n\r\n    addTo: function (map) {\r\n        map.addLayer(this);\r\n        return this;\r\n    },\r\n\r\n    _initCanvas: function () {\r\n        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),\r\n            size = this._map.getSize();\r\n        canvas.width  = size.x; canvas.height = size.y;\r\n        canvas.style.pointerEvents = 'none';\r\n        this._canvas = canvas;\r\n\r\n        var animated = this._map.options.zoomAnimation && L.Browser.any3d;\r\n        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\r\n    },\r\n\r\n    _updateBbox: function () {\r\n        var _map = this._map,\r\n            screenBounds = _map.getBounds(),\r\n            southWest = screenBounds.getSouthWest(),\r\n            northEast = screenBounds.getNorthEast(),\r\n            m1 = L.Projection.Mercator.project(southWest),\r\n            m2 = L.Projection.Mercator.project(northEast),\r\n\t\t\t_zoom = _map.getZoom();\r\n\r\n        this.mInPixel = gmxAPIutils.getPixelScale(_zoom);\r\n        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];\r\n        for (var id in this._observers) {\r\n\t\t\tvar observer = this._observers[id];\r\n\t\t\tif (observer.targetZoom) {\r\n\t\t\t\tobserver.targetZoom = _zoom;\r\n\t\t\t}\r\n            observer.setBounds({\r\n                min: {x: southWest.lng, y: southWest.lat},\r\n                max: {x: northEast.lng, y: northEast.lat}\r\n            });\r\n        }\r\n    },\r\n\r\n    _reset: function () {\r\n        this._updateBbox();\r\n        for (var id in this._observers) {\r\n            var observer = this._observers[id];\r\n            if (!observer.isActive() &&\r\n                this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())\r\n            ) {\r\n                observer.activate();\r\n            }\r\n            observer.fire('update');\r\n        }\r\n    },\r\n\r\n    _redraw: function () {\r\n        var out = [],\r\n            _map = this._map,\r\n            mapSize = _map.getSize(),\r\n            _canvas = this._canvas,\r\n            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),\r\n            topLeft = _map.containerPointToLayerPoint(offset);\r\n\r\n\t\t_canvas.width = mapSize.x; _canvas.height = mapSize.y;\r\n        L.DomUtil.setPosition(_canvas, topLeft);\r\n\r\n        var w2 = 2 * this.mInPixel * gmxAPIutils.worldWidthMerc,\r\n            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),\r\n            ctx = _canvas.getContext('2d'),\r\n            i, len, it;\r\n\r\n        for (var layerId in this._labels) {\r\n            var labels = this._labels[layerId];\r\n            for (var id in labels) {\r\n                it = labels[id];\r\n                var options = it.options,\r\n                    label = options.label,\r\n                    style = label.style,\r\n\t\t\t\t\tlabelAlign = style.labelAlign || 'center',\r\n                    arrTxtWidth = label.arrTxtWidth,\r\n\t\t\t\t\tcount = arrTxtWidth.length || 1,\r\n                    width = label.width,\r\n                    width2 = width / 2,\r\n                    size = style.labelFontSize || 12,\r\n                    size2 = size / 2,\r\n                    center = options.center,\r\n                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],\r\n                    isFiltered = false;\r\n\r\n                if (label.isPoint) {\r\n                    var delta = label.sx;\r\n                    if (labelAlign === 'left') {\r\n                        pos[0] += width2 + delta;\r\n                    } else if (labelAlign === 'right') {\r\n                        pos[0] -= width + delta;\r\n                    }\r\n                }\r\n                pos[0] -= width2 + this._ctxShift[0];\r\n                pos[1] = -size2 - pos[1] + this._ctxShift[1];\r\n\t\t\t\tsize2 *= count;\r\n                if (style.labelAnchor) {\r\n                    pos[0] += style.labelAnchor[0];\r\n                    pos[1] += style.labelAnchor[1];\r\n                }\r\n\r\n                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {\r\n                    var coord = [Math.floor(tx), Math.floor(pos[1])],\r\n                        bbox = gmxAPIutils.bounds([\r\n                            [coord[0] - width2, coord[1] - size2],\r\n                            [coord[0] + width2, coord[1] + size2]\r\n                        ]);\r\n                    for (i = 0, len = out.length; i < len; i++) {\r\n                        if (bbox.intersects(out[i].bbox)) {\r\n                            isFiltered = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (isFiltered) { continue; }\r\n\r\n                    if (!options.labelStyle) {\r\n                        options.labelStyle = {\r\n                            font: size + 'px \"Arial\"',\r\n                            fillStyle: gmxAPIutils.dec2color(style.labelColor || 0, 1),\r\n                            shadowBlur: 4\r\n                        };\r\n                        if (style.labelHaloColor !== -1) {\r\n                            options.labelStyle.strokeStyle =\r\n                            options.labelStyle.shadowColor =\r\n                                gmxAPIutils.dec2color(style.labelHaloColor, 1);\r\n                        }\r\n                    }\r\n                    out.push({\r\n                        arr: it.properties,\r\n                        bbox: bbox,\r\n                        arrTxtWidth: arrTxtWidth,\r\n                        width2: labelAlign === 'center' ? width2 : 0,\r\n                        txt: label.txt,\r\n                        style: options.labelStyle,\r\n                        size: size,\r\n                        coord: coord\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (out.length) {\r\n            ctx.clearRect(0, 0, _canvas.width, _canvas.height);\r\n            for (i = 0, len = out.length; i < len; i++) {\r\n                it = out[i];\r\n\t\t\t\tit.arrTxtWidth.forEach(function(pt, nm) {\r\n\t\t\t\t\tvar coord = [it.coord[0] + it.width2 - pt[1]/2, it.coord[1] + nm * it.size];\r\n\t\t\t\t\tgmxAPIutils.setLabel(ctx, pt[0], coord, it.style);\r\n\t\t\t\t});\r\n            }\r\n            if (!_canvas.parentNode) { this._addToPane(); }\r\n        } else if (_canvas.parentNode) {\r\n            _canvas.parentNode.removeChild(_canvas);\r\n        }\r\n\r\n        this._frame = null;\r\n    },\r\n\r\n    _animateZoom: function (e) {\r\n        var scale = this._map.getZoomScale(e.zoom),\r\n            pixelBoundsMin = this._map.getPixelBounds().min;\r\n\r\n        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());\r\n        if (pixelBoundsMin.y < 0) {\r\n            offset.y += pixelBoundsMin.multiplyBy(-scale).y;\r\n        }\r\n\r\n        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';\r\n    }\r\n});\r\n\r\nL.labelsLayer = function (map, options) {\r\n    return new L.LabelsLayer(map, options);\r\n};\r\n\r\nL.Map.addInitHook(function () {\r\n\t// Check to see if Labels has already been initialized.\r\n    if (!this._labelsLayer) {\r\n        this._labelsLayer = new L.LabelsLayer(this);\r\n        this._labelsLayer.addTo(this);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/LabelsLayer.js","(function() {\r\nvar isBoundsIntersects = function (bounds, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].intersects(bounds)) { return true; }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\nvar isObserverIntersects = function (observer, clipPolygons) {\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (observer.intersects(bbox[j1])) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar isPointInClipPolygons = function (chkPoint, clipPolygons) {\r\n    if (!clipPolygons || Object.keys(clipPolygons).length === 0) { return true; }\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var it = arr[i],\r\n                type = it.geometry.type,\r\n                boundsArr = it.boundsArr;\r\n            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {\r\n                var bbox = boundsArr[j];\r\n                if (type === 'Polygon') { bbox = [bbox]; }\r\n                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {\r\n                    if (bbox[j1].contains(chkPoint)) {\r\n                        var coords = it.geometry.coordinates,\r\n                            isIn = false;\r\n                        if (type === 'Polygon') { coords = [coords]; }\r\n                        for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {\r\n                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {\r\n                                isIn = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (isIn) { return true; }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nvar getClipPolygonItem = function (geo) {\r\n    var geometry = gmxAPIutils.convertGeometry(geo),\r\n        bboxArr = gmxAPIutils.geoItemBounds(geometry);\r\n    bboxArr.geometry = geometry;\r\n    return bboxArr;\r\n};\r\n\r\nvar clipTileByPolygon = function (dattr) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = canvas.height = 256;\r\n    var ctx = canvas.getContext('2d'),\r\n        clipPolygons = dattr.clipPolygons;\r\n\r\n    dattr.ctx = ctx;\r\n    ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');\r\n\r\n    for (var key in clipPolygons) {\r\n        var arr = clipPolygons[key];\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            var geo = arr[i].geometry,\r\n                coords = geo.coordinates;\r\n            if (geo.type === 'Polygon') { coords = [coords]; }\r\n            for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {\r\n                var coords1 = coords[i1];\r\n                ctx.beginPath();\r\n                for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {\r\n                    dattr.coords = coords1[j1];\r\n                    var pixels = gmxAPIutils.getRingPixels(dattr);\r\n                    dattr.coords = pixels.coords;\r\n                    gmxAPIutils.polygonToCanvasFill(dattr);\r\n                }\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    ctx = dattr.tile.getContext('2d');\r\n    ctx.clearRect(0, 0, 256, 256);\r\n    ctx.drawImage(canvas, 0, 0);\r\n};\r\n\r\nL.gmx.VectorLayer.include({\r\n\r\n    isPointInClipPolygons: function (point) { // point [x, y] in Mercator\r\n        return isPointInClipPolygons(point, this._gmx._clipPolygons);\r\n    },\r\n\r\n    addClipPolygon: function (polygon) { // (L.Polygon) or (L.GeoJSON with Polygons)\r\n        var item = [],\r\n            i, len;\r\n\r\n        if ('coordinates' in polygon && 'type' in polygon) {\r\n            item.push(getClipPolygonItem(polygon));\r\n        } else if (polygon instanceof L.Polygon) {\r\n            item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));\r\n        } else if (polygon instanceof L.GeoJSON) {\r\n            var layers = polygon.getLayers();\r\n            for (i = 0, len = layers.length; i < len; i++) {\r\n                var layer = layers[i];\r\n                if (layer instanceof L.Polygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                } else if (layer instanceof L.MultiPolygon && layer.feature) {\r\n                    item.push(getClipPolygonItem(layer.feature.geometry));\r\n                }\r\n            }\r\n        }\r\n        if (item.length) {\r\n            var gmx = this._gmx,\r\n                dataManager = gmx.dataManager,\r\n                _this = this,\r\n                id = L.stamp(polygon);\r\n\r\n            if (!this._gmx._clipPolygons) { this._gmx._clipPolygons = {}; }\r\n            this._gmx._clipPolygons[id] = item;\r\n            dataManager.setTileFilteringHook(function (tile) {\r\n                return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipFilter', function (item, tile, observer) {\r\n                return isObserverIntersects(observer, _this._gmx._clipPolygons);\r\n            });\r\n\r\n            dataManager.addFilter('clipPointsFilter', function (item) {\r\n                if (item.type === 'POINT') {\r\n                    var propArr = item.properties,\r\n                        geom = propArr[propArr.length - 1];\r\n                    return isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);\r\n                }\r\n                return true;\r\n            });\r\n            if (Object.keys(this._gmx._clipPolygons).length === 1) {\r\n                gmx.renderHooks.unshift(function (tile, hookInfo) {\r\n                    if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {\r\n                        clipTileByPolygon({\r\n                            tile: tile,\r\n                            tpx: hookInfo.tpx,\r\n                            tpy: hookInfo.tpy,\r\n                            gmx: {mInPixel: gmx.mInPixel},\r\n                            clipPolygons: _this._gmx._clipPolygons\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return this;\r\n    },\r\n\r\n    removeClipPolygon: function (polygon) {\r\n        var id = L.stamp(polygon);\r\n        if (this._gmx._clipPolygons) {\r\n            delete this._gmx._clipPolygons[id];\r\n            if (Object.keys(this._gmx._clipPolygons).length === 0) {\r\n                this._gmx.dataManager.removeTileFilteringHook();\r\n                this._gmx.dataManager.removeFilter('clipFilter');\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n});\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ClipPolygon.js","L.gmx.gmxImageTransform = function(img, hash) {\r\n    var gmx = hash.gmx,\r\n        gmxTilePoint = hash.gmxTilePoint,\r\n        mInPixel = gmx.mInPixel,\r\n        geoItem = hash.geoItem,\r\n        properties = geoItem.properties,\r\n        dataOption = geoItem.dataOption || {},\r\n        // geom = properties[properties.length - 1],\r\n        // coord = geom.coordinates[0],\r\n        indexes = gmx.tileAttributeIndexes,\r\n        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',\r\n        points = {};\r\n\r\n    // if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }\r\n    if (quicklookPlatform === 'LANDSAT8') {\r\n        points.x1 = dataOption.bounds.min.x; points.y1 = dataOption.bounds.max.y;\r\n        points.x2 = dataOption.bounds.max.x; points.y2 = dataOption.bounds.max.y;\r\n        points.x3 = dataOption.bounds.max.x; points.y3 = dataOption.bounds.min.y;\r\n        points.x4 = dataOption.bounds.min.x; points.y4 = dataOption.bounds.min.y;\r\n    } else {\r\n        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);\r\n    }\r\n\r\n    var x1 = mInPixel * points.x1, y1 = mInPixel * points.y1,\r\n        x2 = mInPixel * points.x2, y2 = mInPixel * points.y2,\r\n        x3 = mInPixel * points.x3, y3 = mInPixel * points.y3,\r\n        x4 = mInPixel * points.x4, y4 = mInPixel * points.y4,\r\n        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),\r\n        ww = Math.round(boundsP.max.x - boundsP.min.x),\r\n        hh = Math.round(boundsP.max.y - boundsP.min.y),\r\n        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,\r\n        itbounds = geoItem.item.bounds,\r\n        wMerc = gmxAPIutils.worldWidthMerc,\r\n        tpx = gmxTilePoint.x;\r\n\r\n    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {\t// For points intersects 180 deg\r\n\t\ttpx += Math.round(wMerc * mInPixel / 128);\r\n\t}\r\n\tvar dx = boundsP.min.x - 256 * tpx;\r\n\r\n    x1 -= boundsP.min.x; y1 = boundsP.max.y - y1;\r\n    x2 -= boundsP.min.x; y2 = boundsP.max.y - y2;\r\n    x3 -= boundsP.min.x; y3 = boundsP.max.y - y3;\r\n    x4 -= boundsP.min.x; y4 = boundsP.max.y - y4;\r\n\r\n    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];\r\n\r\n    if (!gmx.ProjectiveImage) {\r\n        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();\r\n    }\r\n    var pt = gmx.ProjectiveImage.getCanvas({\r\n        imageObj: img,\r\n        points: shiftPoints,\r\n        wView: ww,\r\n        hView: hh,\r\n        deltaX: dx,\r\n        deltaY: dy\r\n    });\r\n    return pt.canvas;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ImageTransform.js","(function() {\r\nvar ProjectiveImageWebGL = L.Class.extend({\r\n    options: {\r\n        antialias: true,\r\n        depth: false,\r\n        preserveDrawingBuffer: true,\r\n        shaderVS: 'attribute vec2 aVertCoord;\\\r\n            uniform mat4 uTransformMatrix;\\\r\n            varying vec2 vTextureCoord;\\\r\n            void main(void) {\\\r\n                vTextureCoord = aVertCoord;\\\r\n                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\\\r\n            }\\\r\n        ',\r\n        shaderFS: 'precision mediump float;\\\r\n            varying vec2 vTextureCoord;\\\r\n            uniform sampler2D uSampler;\\\r\n            void main(void) {\\\r\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\\\r\n            }\\\r\n        '\r\n    },\r\n\r\n    setOptions: function(options) {\r\n        L.setOptions(this, options);\r\n    },\r\n\r\n    initialize: function(options) {\r\n        this.setOptions(options);\r\n\r\n        var canvas = document.createElement('canvas'),\r\n            glOpts = {\r\n                antialias: this.options.antialias,\r\n                depth: this.options.depth,\r\n                preserveDrawingBuffer: this.options.preserveDrawingBuffer\r\n            },\r\n            gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);\r\n        if (!gl) { return; }\r\n        var glResources = this._setupGlContext(gl);\r\n        if (!glResources) { return; }\r\n\r\n        canvas.width = canvas.height = 256;\r\n        glResources.canvas = canvas;\r\n\r\n        this.glResources = glResources;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n    },\r\n\r\n    _getShader: function (type, source, gl) {\r\n        var shader = gl.createShader(type);\r\n\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return shader;\r\n    },\r\n\r\n    _setupGlContext: function (gl) {\r\n        // Store return values here\r\n        var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),\r\n            fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);\r\n\r\n        if (vertexShader && fragmentShader) {\r\n            // Compile the program\r\n            var shaderProgram = gl.createProgram();\r\n            gl.attachShader(shaderProgram, vertexShader);\r\n            gl.attachShader(shaderProgram, fragmentShader);\r\n            gl.linkProgram(shaderProgram);\r\n\r\n            if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n                // Find and set up the uniforms and attributes\r\n                gl.useProgram(shaderProgram);\r\n                this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n                var vertexBuffer = gl.createBuffer(),    // Create a buffer to hold the vertices\r\n                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);\r\n\r\n                // draw the triangles\r\n                gl.enableVertexAttribArray(vertAttrib);\r\n                gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);\r\n                return {\r\n                    transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),\r\n                    samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),\r\n                    screenTexture: gl.createTexture() // Create a texture to use for the screen image\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    _bindTexture: function (gl, image, texture) {\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n        // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        // Prevents s-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        // Prevents t-coordinate wrapping (repeating).\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    getCanvas: function (attr) {\r\n        var p = attr.points,\r\n            deltaX = attr.deltaX,\r\n            deltaY = attr.deltaY,\r\n            dstPoints = new Float32Array([\r\n                (p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128,\r\n                (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128,\r\n                (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128,\r\n                (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128\r\n            ]);\r\n\r\n        var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),\r\n            gl = this.gl,\r\n            glResources = this.glResources;\r\n\r\n        this._bindTexture(gl, attr.imageObj, glResources.screenTexture);\r\n\r\n        gl.viewport(0, 0, 256, 256);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    // set background to full transparency\r\n\r\n        gl.uniformMatrix4fv(\r\n            glResources.transMatUniform,\r\n            false, [\r\n                v[0], v[3],    0, v[6],\r\n                v[1], v[4],    0, v[7],\r\n                   0,    0,    1,    0,\r\n                v[2], v[5],    0,    1\r\n            ]);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);\r\n        gl.uniform1i(glResources.samplerUniform, 0);\r\n\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        return this;\r\n    }\r\n});\r\n\r\nfunction adj(m) { // Compute the adjugate of m\r\n    return [\r\n        m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4],\r\n        m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5],\r\n        m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]\r\n    ];\r\n}\r\n\r\nfunction multmm(a, b) { // multiply two matrices\r\n    var c = Array(9);\r\n    for (var i = 0; i !== 3; ++i) {\r\n        for (var j = 0; j !== 3; ++j) {\r\n            var cij = 0;\r\n            for (var k = 0; k !== 3; ++k) {\r\n                cij += a[3 * i + k] * b[3 * k + j];\r\n            }\r\n            c[3 * i + j] = cij;\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction multmv(m, v) { // multiply matrix and vector\r\n    return [\r\n        m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\r\n        m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\r\n        m[6] * v[0] + m[7] * v[1] + m[8] * v[2]\r\n    ];\r\n}\r\n\r\nfunction basisToPoints(p) {\r\n    var m = [\r\n        p[0], p[2], p[4],\r\n        p[1], p[3], p[5],\r\n        1,  1,  1\r\n    ];\r\n    var v = multmv(adj(m), [p[6], p[7], 1]);\r\n    return multmm(m, [\r\n        v[0], 0, 0,\r\n        0, v[1], 0,\r\n        0, 0, v[2]\r\n    ]);\r\n}\r\n\r\nProjectiveImageWebGL.Utils = {\r\n    general2DProjection: function(from, to) {\r\n        var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));\r\n        if (arr[8]) {\r\n            for (var i = 0; i !== 9; ++i) {\r\n                arr[i] = arr[i] / arr[8];\r\n            }\r\n        }\r\n        return arr;\r\n    },\r\n\r\n    getWebGlResources: function(options) {\r\n        var obj = new ProjectiveImageWebGL(options);\r\n        return obj.gl ? obj : null;\r\n    }\r\n};\r\nL.gmx.projectiveImageWebGL = function(options) {\r\n    var res = new ProjectiveImageWebGL(options);\r\n    return res.gl ? res : null;\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImageWebGL.js","(function() {\r\n// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.\r\nvar ProjectiveImage = function() {\r\n\tvar cnt = 0,\r\n        limit = 4,\r\n        patchSize = 64,\r\n        transform = null;\r\n\r\n\tvar allocate = function (w, h) {\r\n\t  var values = [];\r\n\t  for (var i = 0; i < h; ++i) {\r\n\t\tvalues[i] = [];\r\n\t\tfor (var j = 0; j < w; ++j) {\r\n\t\t  values[i][j] = 0;\r\n\t\t}\r\n\t  }\r\n\t  return values;\r\n\t};\r\n\r\n\tvar Matrix = function (w, h, values) {\r\n\t  this.w = w;\r\n\t  this.h = h;\r\n\t  this.values = values || allocate(h);\r\n\t};\r\n\r\n\tvar cloneValues = function (values) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0; i < values.length; ++i) {\r\n\t\t\tclone[i] = [].concat(values[i]);\r\n\t\t}\r\n\t\treturn clone;\r\n\t};\r\n\r\n\tMatrix.prototype = {\r\n\t\tadd : function (operand) {\r\n\t\t\tif (operand.w !== this.w || operand.h !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix add size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (var x = 0; x < this.w; ++x) {\r\n\t\t\t\t  values[y][x] = this.values[y][x] + operand.values[y][x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t},\r\n\t\ttransformProjectiveVector : function (operand) {\r\n\t\t\tvar out = [], x, y;\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tout[y] = 0;\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tout[y] += this.values[y][x] * operand[x];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar zn = out[out.length - 1];\r\n\t\t\tif (zn) {\r\n\t\t\t\tvar iz = 1 / (out[out.length - 1]);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tout[y] *= iz;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\tmultiply : function (operand) {\r\n\t\t\tvar values, x, y;\r\n\t\t\tif (+operand !== operand) {\r\n\t\t\t\t// Matrix mult\r\n\t\t\t\tif (operand.h !== this.w) {\r\n\t\t\t\t\tthrow new Error('Matrix mult size mismatch');\r\n\t\t\t\t}\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < operand.w; ++x) {\r\n\t\t\t\t\t\tvar accum = 0;\r\n\t\t\t\t\t\tfor (var s = 0; s < this.w; s++) {\r\n\t\t\t\t\t\t\taccum += this.values[y][s] * operand.values[s][x];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[y][x] = accum;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(operand.w, this.h, values);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Scalar mult\r\n\t\t\t\tvalues = allocate(this.w, this.h);\r\n\t\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\t\tvalues[y][x] = this.values[y][x] * operand;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t\t}\r\n\t\t},\r\n\t\trowEchelon : function () {\r\n\t\t\tif (this.w <= this.h) {\r\n\t\t\t\tthrow new Error('Matrix rowEchelon size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = cloneValues(this.values);\r\n\r\n\t\t\t// Do Gauss-Jordan algorithm.\r\n\t\t\tfor (var yp = 0; yp < this.h; ++yp) {\r\n\t\t\t\t// Look up pivot value.\r\n\t\t\t\tvar pivot = temp[yp][yp];\r\n\t\t\t\twhile (pivot === 0) {\r\n\t\t\t\t\t// If pivot is zero, find non-zero pivot below.\r\n\t\t\t\t\tfor (var ys = yp + 1; ys < this.h; ++ys) {\r\n\t\t\t\t\t\tif (temp[ys][yp] !== 0) {\r\n\t\t\t\t\t\t\t// Swap rows.\r\n\t\t\t\t\t\t\tvar tmpRow = temp[ys];\r\n\t\t\t\t\t\t\ttemp[ys] = temp[yp];\r\n\t\t\t\t\t\t\ttemp[yp] = tmpRow;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (ys === this.h) {\r\n\t\t\t\t\t\t// No suitable pivot found. Abort.\r\n\t\t\t\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpivot = temp[yp][yp];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Normalize this row.\r\n\t\t\t\tvar scale = 1 / pivot;\r\n\t\t\t\tfor (var x = yp; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[yp][x] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\t// Subtract this row from all other rows (scaled).\r\n\t\t\t\tfor (var y = 0; y < this.h; ++y) {\r\n\t\t\t\t\tif (y === yp) { continue; }\r\n\t\t\t\t\tvar factor = temp[y][yp];\r\n\t\t\t\t\ttemp[y][yp] = 0;\r\n\t\t\t\t\tfor (x = yp + 1; x < this.w; ++x) {\r\n\t\t\t\t\t\ttemp[y][x] -= factor * temp[yp][x];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn new Matrix(this.w, this.h, temp);\r\n\t\t},\r\n\t\tinvert : function () {\r\n\t\t\tvar x, y;\r\n\r\n\t\t\tif (this.w !== this.h) {\r\n\t\t\t\tthrow new Error('Matrix invert size mismatch');\r\n\t\t\t}\r\n\r\n\t\t\tvar temp = allocate(this.w * 2, this.h);\r\n\r\n\t\t\t// Initialize augmented matrix\r\n\t\t\tfor (y = 0; y < this.h; ++y) {\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\ttemp[y][x] = this.values[y][x];\r\n\t\t\t\t\ttemp[y][x + this.w] = (x === y) ? 1 : 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttemp = new Matrix(this.w * 2, this.h, temp);\r\n\t\t\ttemp = temp.rowEchelon();\r\n\r\n\t\t\t// Extract right block matrix.\r\n\t\t\tvar values = allocate(this.w, this.h);\r\n\t\t\tfor (y = 0; y < this.w; ++y) {\r\n\t\t\t\t// @todo check if \"x < this.w;\" is mistake\r\n\t\t\t\tfor (x = 0; x < this.w; ++x) {\r\n\t\t\t\t\tvalues[y][x] = temp.values[y][x + this.w];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Matrix(this.w, this.h, values);\r\n\t\t}\r\n\t};\r\n\r\n\tvar getProjectiveTransform = function (points) {\r\n\t  var eqMatrix = new Matrix(9, 8, [\r\n\t\t[1, 1, 1,   0, 0, 0, -points[2][0], -points[2][0], -points[2][0]],\r\n\t\t[0, 1, 1,   0, 0, 0,  0, -points[3][0], -points[3][0]],\r\n\t\t[1, 0, 1,   0, 0, 0, -points[1][0], 0, -points[1][0]],\r\n\t\t[0, 0, 1,   0, 0, 0,  0, 0, -points[0][0]],\r\n\r\n\t\t[0, 0, 0,  -1, -1, -1,  points[2][1], points[2][1], points[2][1]],\r\n\t\t[0, 0, 0,   0, -1, -1,  0, points[3][1], points[3][1]],\r\n\t\t[0, 0, 0,  -1,  0, -1,  points[1][1], 0, points[1][1]],\r\n\t\t[0, 0, 0,   0,  0, -1,  0, 0, points[0][1]]\r\n\r\n\t  ]);\r\n\r\n\t  var kernel = eqMatrix.rowEchelon().values;\r\n\t  var transform = new Matrix(3, 3, [\r\n\t\t[-kernel[0][8], -kernel[1][8], -kernel[2][8]],\r\n\t\t[-kernel[3][8], -kernel[4][8], -kernel[5][8]],\r\n\t\t[-kernel[6][8], -kernel[7][8],             1]\r\n\t  ]);\r\n\t  return transform;\r\n\t};\r\n\r\n\tvar divide = function (u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {\r\n\t\tif (limit) {\r\n\t\t\t// Measure patch non-affinity.\r\n\t\t\tvar d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];\r\n\t\t\tvar d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];\r\n\t\t\tvar d3 = [d1[0] + d2[0], d1[1] + d2[1]];\r\n\t\t\tvar r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));\r\n\r\n\t\t\t// Measure patch area.\r\n\t\t\td1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];\r\n\t\t\td2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];\r\n\t\t\tvar area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);\r\n\r\n\t\t\t// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)\r\n\t\t\t// The non-affinity measure is used as a correction factor.\r\n\t\t\tif ((u1 === 0 && u4 === 1) || ((.25 + r * 5) * area > (patchSize * patchSize))) {\r\n\t\t\t\t// Calculate subdivision points (middle, top, bottom, left, right).\r\n\t\t\t\tvar umid = (u1 + u4) / 2;\r\n\t\t\t\tvar vmid = (v1 + v4) / 2;\r\n\t\t\t\tvar pmid = transform.transformProjectiveVector([umid, vmid, 1]);\r\n\t\t\t\tvar pt   = transform.transformProjectiveVector([umid, v1, 1]);\r\n\t\t\t\tvar pb   = transform.transformProjectiveVector([umid, v4, 1]);\r\n\t\t\t\tvar pl   = transform.transformProjectiveVector([u1, vmid, 1]);\r\n\t\t\t\tvar pr   = transform.transformProjectiveVector([u4, vmid, 1]);\r\n\r\n\t\t\t\t// Subdivide.\r\n\t\t\t\tlimit--;\r\n\t\t\t\tdivide.call(this, u1,   v1, umid, vmid,   p1,   pt,   pl, pmid, limit, attr);\r\n\t\t\t\tdivide.call(this, umid,   v1,   u4, vmid,   pt,   p2, pmid,   pr, limit, attr);\r\n\t\t\t\tdivide.call(this, u1,  vmid, umid,   v4,   pl, pmid,   p3,   pb, limit, attr);\r\n\t\t\t\tdivide.call(this, umid, vmid,   u4,   v4, pmid,   pr,   pb,   p4, limit, attr);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar ctx = attr.ctx;\r\n\r\n\t\t// Get patch edge vectors.\r\n\t\tvar d12 = [p2[0] - p1[0], p2[1] - p1[1]];\r\n\t\tvar d24 = [p4[0] - p2[0], p4[1] - p2[1]];\r\n\t\tvar d43 = [p3[0] - p4[0], p3[1] - p4[1]];\r\n\t\tvar d31 = [p1[0] - p3[0], p1[1] - p3[1]];\r\n\r\n\t\t// Find the corner that encloses the most area\r\n\t\tvar a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);\r\n\t\tvar a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);\r\n\t\tvar a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);\r\n\t\tvar a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);\r\n\t\tvar amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));\r\n\t\tvar dx = 0, dy = 0, padx = 0, pady = 0;\r\n\r\n\t\t// Align the transform along this corner.\r\n\t\t// Calculate 1.05 pixel padding on vector basis.\r\n\t\tif (amax === a1) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t} else if (amax === a2) {\r\n\t\t\t\tctx.setTransform(d12[0], d12[1],  d24[0],  d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t} else if (amax === a4) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }\r\n\t\t\t\tdx = -1;\r\n\t\t\t\tdy = -1;\r\n\t\t} else if (amax === a3) {\r\n\t\t\t\tctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);\r\n\t\t\t\tif (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }\r\n\t\t\t\tif (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }\r\n\t\t\t\tdy = -1;\r\n\t\t}\r\n\r\n\t\t// Calculate image padding to match.\r\n\t\tvar du = (u4 - u1);\r\n\t\tvar dv = (v4 - v1);\r\n\t\tpadx++;\r\n\t\tpady++;\r\n\r\n        var iw = attr.imageObj.width,\r\n            ih = attr.imageObj.height,\r\n            sx = Math.floor(u1 * iw),\r\n            sy = Math.floor(v1 * ih),\r\n            sw = Math.floor(Math.min(padx * du, 1) * iw),\r\n            sh = Math.floor(Math.min(pady * dv, 1) * ih);\r\n\r\n\t\tcnt++;\r\n        ctx.drawImage(\r\n            attr.imageObj,\r\n            sx, sy,\r\n            sw, sh,\r\n            dx, dy,\r\n            padx, pady\r\n        );\r\n\t};\r\n\r\n\tthis.getCanvas = function (attr) {\r\n\t\tcnt = 0;\r\n\t\ttransform = getProjectiveTransform(attr.points);\r\n\t\t// Begin subdivision process.\r\n\r\n\t\tvar ptl = transform.transformProjectiveVector([0, 0, 1]),\r\n            ptr = transform.transformProjectiveVector([1, 0, 1]),\r\n            pbl = transform.transformProjectiveVector([0, 1, 1]),\r\n            pbr = transform.transformProjectiveVector([1, 1, 1]);\r\n\r\n\t\tvar canvas = document.createElement('canvas');\r\n\t\tcanvas.width = canvas.height = 256;\r\n\t\tattr.canvas = canvas;\r\n\t\tattr.ctx = canvas.getContext('2d');\r\n\r\n\t\tvar\tboundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),\r\n            maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);\r\n\r\n\t\tlimit = 'limit' in attr ? attr.limit : (maxSize < 200 ? 1 : 4);\r\n\t\tpatchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;\r\n\r\n\t\ttry {\r\n\t\t\tdivide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);\r\n\t\t} catch (e) {\r\n\t\t\tconsole.log('Error: ProjectiveImage event:', e);\r\n\t\t\tcanvas = null;\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tcanvas: canvas,\r\n\t\t\tptl: ptl,\r\n\t\t\tptr: ptr,\r\n\t\t\tpbl: pbl,\r\n\t\t\tpbr: pbr,\r\n\t\t\tcnt: cnt\r\n\t\t};\r\n\t};\r\n};\r\nL.gmx.projectiveImage = function() {\r\n    return new ProjectiveImage();\r\n};\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/ProjectiveImage.js","// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js\r\n\r\nL.RotatedMarker = L.Marker.extend({\r\n    options: {\r\n        angle: 0\r\n    },\r\n\r\n    statics: {\r\n        TRANSFORM_ORIGIN: L.DomUtil.testProp(\r\n            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])\r\n    },\r\n\r\n    _initIcon: function() {\r\n        L.Marker.prototype._initIcon.call(this);\r\n\r\n        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();\r\n    },\r\n\r\n    _getTransformOrigin: function() {\r\n        var iconAnchor = this.options.icon.options.iconAnchor;\r\n\r\n        if (!iconAnchor) {\r\n            return '50% 50%';\r\n        }\r\n\r\n        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';\r\n    },\r\n\r\n    _setPos: function(pos) {\r\n        L.Marker.prototype._setPos.call(this, pos);\r\n\r\n        if (L.DomUtil.TRANSFORM) {\r\n            // use the CSS transform rule if available\r\n            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n        } else if (L.Browser.ie) {\r\n            // fallback for IE6, IE7, IE8\r\n            var rad = this.options.angle * (Math.PI / 180),\r\n                costheta = Math.cos(rad),\r\n                sintheta = Math.sin(rad);\r\n            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' +\r\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';\r\n        }\r\n    },\r\n\r\n    setAngle: function(ang) {\r\n        this.options.angle = ang;\r\n    }\r\n});\r\n\r\nL.rotatedMarker = function(pos, options) {\r\n    return new L.RotatedMarker(pos, options);\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/RotatedMarker.js","L.gmx.ExternalLayer = L.Class.extend({\r\n    createExternalLayer: function () {          // extend: must return <ILayer> or null = this.externalLayer\r\n        return null;\r\n    },\r\n\r\n    isExternalVisible: function (/*zoom*/) {    // extend: return true view this.externalLayer, return false view this.parentLayer\r\n        return true;\r\n    },\r\n\r\n    updateData: function (/*data*/) {           // extend: for data update in this.externalLayer\r\n    },\r\n\r\n    setDateInterval: function () {\r\n        if (this._observer) {\r\n            var gmx = this.parentLayer._gmx;\r\n            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);\r\n        }\r\n    },\r\n\r\n    options: {\r\n        useDataManager: true,\r\n        observerOptions: {\r\n            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']\r\n        }\r\n    },\r\n\r\n    initialize: function (options, layer) {\r\n        L.setOptions(this, options);\r\n        this.parentLayer = layer;\r\n        layer\r\n            .on('add', this._addEvent, this)\r\n            .on('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this.options.useDataManager) {\r\n            this._addObserver(this.options.observerOptions);\r\n        }\r\n\r\n        this.externalLayer = this.createExternalLayer();\r\n\r\n        if (layer._map) {\r\n            this._addEvent({target:{_map: layer._map}});\r\n            this._updateBbox();\r\n        }\r\n    },\r\n\r\n    _addObserver: function (opt) {\r\n        this._items = {};\r\n        this._observer = this.parentLayer.addObserver(\r\n            L.extend({\r\n                bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),\r\n                callback: L.bind(this.updateData, this)\r\n            }, opt)\r\n        ).deactivate();\r\n    },\r\n\r\n    unbindLayer: function () {\r\n        this.parentLayer\r\n            .off('add', this._addEvent, this)\r\n            .off('dateIntervalChanged', this.setDateInterval, this);\r\n\r\n        if (this._observer) { delete this.parentLayer.repaintObservers[this._observer.id]; }\r\n        var map = this._map || this.parentLayer._map;\r\n        this._onRemove(!map);\r\n        this._removeMapHandlers();\r\n    },\r\n\r\n    _addMapHandlers: function (map) {\r\n        this._map = map;\r\n        this._map.on({\r\n            moveend: this._updateBbox,\r\n            zoomend: this._chkZoom,\r\n            layeradd: this._layeradd,\r\n            layerremove: this._layerremove\r\n        }, this);\r\n    },\r\n\r\n    _removeMapHandlers: function () {\r\n        if (this._map) {\r\n            this._map.off({\r\n                moveend: this._updateBbox,\r\n                zoomend: this._chkZoom,\r\n                layeradd: this._layeradd,\r\n                layerremove: this._layerremove\r\n            }, this);\r\n        }\r\n        this._map = null;\r\n    },\r\n\r\n    _addEvent: function (ev) {\r\n        this._addMapHandlers(ev.target._map);\r\n        this._updateBbox();\r\n        this._chkZoom();\r\n    },\r\n\r\n    _isParentLayer: function (ev) {\r\n        var layer = ev.layer;\r\n        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;\r\n    },\r\n\r\n    _layeradd: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._chkZoom();\r\n        }\r\n    },\r\n\r\n    _layerremove: function (ev) {\r\n        if (this._isParentLayer(ev)) {\r\n            this._onRemove(true);\r\n            this._removeMapHandlers();\r\n        }\r\n    },\r\n\r\n    _onRemove: function (fromMapFlag) {    // remove external layer from parent layer\r\n        if (this._observer) {\r\n            this._observer.deactivate();\r\n        }\r\n        var map = this._map;\r\n        if (map) {\r\n            if (map.hasLayer(this.externalLayer)) {\r\n                this._chkZoom();\r\n                map.removeLayer(this.externalLayer);\r\n            }\r\n            if (!fromMapFlag) {\r\n                this.parentLayer.onAdd(map);\r\n            }\r\n        }\r\n    },\r\n\r\n    _chkZoom: function () {\r\n        if (!this._map) { return; }\r\n\r\n        var layer = this.parentLayer,\r\n            observer = this._observer,\r\n            map = this._map,\r\n            isExtLayerOnMap = map.hasLayer(this.externalLayer);\r\n\r\n        layer.setCurrentZoom(map);\r\n        if (!this.isExternalVisible(map.getZoom())) {\r\n            if (observer) { observer.deactivate(); }\r\n            if (!layer._map) {\r\n                if (isExtLayerOnMap) {\r\n                    map.removeLayer(this.externalLayer);\r\n                }\r\n                layer.onAdd(map);\r\n            }\r\n            layer.enablePopup();\r\n        } else if (layer._map) {\r\n            layer.onRemove(map);\r\n            if (!isExtLayerOnMap) {\r\n                map.addLayer(this.externalLayer);\r\n            }\r\n            this.setDateInterval();\r\n            if (observer) {\r\n                layer.getIcons(function () {\r\n                    observer.activate();\r\n                }.bind(this));\r\n            }\r\n            layer.disablePopup();\r\n        }\r\n    },\r\n\r\n\r\n    _updateBbox: function () {\r\n        if (!this._map || !this._observer) { return; }\r\n\r\n        var screenBounds = this._map.getBounds(),\r\n            p1 = screenBounds.getNorthWest(),\r\n            p2 = screenBounds.getSouthEast(),\r\n            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]);\r\n        this._observer.setBounds(bbox);\r\n    }\r\n});\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/ExternalLayer.js","(function() {\r\n    'use strict';\r\n    var BindWMS = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minZoom: 1,\r\n            maxZoom: 6,\r\n            useDataManager: false,\r\n            format: 'png',\r\n            transparent: true\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var poptions = this.parentLayer.options,\r\n                opt = {\r\n                    map: poptions.mapID,\r\n                    layers: poptions.layerID,\r\n                    format: this.options.format,\r\n                    transparent: this.options.transparent\r\n                },\r\n                rawProperties = this.parentLayer.getGmxProperties();\r\n\r\n            if (rawProperties && rawProperties.Temporal) { this._extendOptionsByDateInterval(opt); }\r\n            if (this.options.apikey) { opt.apikey = this.options.apikey; }\r\n            return L.tileLayer.wms('http://' + poptions.hostName + '/TileService.ashx', opt);\r\n        },\r\n\r\n        _extendOptionsByDateInterval: function (options) {\r\n            var dateInterval = this.parentLayer.getDateInterval(),\r\n                beginDate = dateInterval.beginDate,\r\n                endDate = dateInterval.endDate;\r\n            L.extend(options, {\r\n                StartDate: beginDate && beginDate.toLocaleDateString(),\r\n                EndDate: endDate && endDate.toLocaleDateString()\r\n            });\r\n        },\r\n\r\n        setDateInterval: function () {\r\n            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);\r\n            this.externalLayer.redraw();\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindWMS: function (options) {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n            }\r\n            this._layerWMS = new BindWMS(options, this);\r\n            this.isExternalVisible = this._layerWMS.isExternalVisible;\r\n            return this;\r\n        },\r\n\r\n        unbindWMS: function () {\r\n            if (this._layerWMS) {\r\n                this._layerWMS.unbindLayer();\r\n                this._layerWMS = null;\r\n                this.isExternalVisible = null;\r\n                this.enablePopup();\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/BindWMS.js","(function() {\r\n    'use strict';\r\n    var GmxHeatMap = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            minHeatMapZoom: 1,\r\n            maxHeatMapZoom: 6,\r\n            intensityField: '',\r\n            intensityScale: 1,\r\n            observerOptions: {\r\n                type: 'resend'\r\n            }\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            return L.heatLayer([], L.extend({\r\n                 // minOpacity: 0.05,\r\n                 // maxZoom: 18,\r\n                 // radius: 25,\r\n                 // blur: 15,\r\n                 // max: 1.0\r\n            }, this.options));\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            if (data.added) {\r\n                var latlngs = [],\r\n                    indexes = this.parentLayer.getTileAttributeIndexes(),\r\n                    altIndex = null,\r\n                    intensityField = this.options.intensityField || '',\r\n                    intensityScale = this.options.intensityScale || 1;\r\n\r\n                if (intensityField && intensityField in indexes) {\r\n                    altIndex = indexes[intensityField];\r\n                }\r\n                for (var i = 0, len = data.added.length; i < len; i++) {\r\n                    var it = data.added[i].properties,\r\n                        alt = altIndex !== null ? it[altIndex] : 1,\r\n                        geo = it[it.length - 1],\r\n                        coord = geo.coordinates,\r\n                        point = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});\r\n\r\n                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);\r\n                }\r\n                this.externalLayer.setLatLngs(latlngs);\r\n            }\r\n        }\r\n    });\r\n\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindHeatMap: function (options) {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                }\r\n                this._heatmap = new GmxHeatMap(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindHeatMap: function () {\r\n            if (L.heatLayer) {\r\n                if (this._heatmap) {\r\n                    this._heatmap.unbindLayer();\r\n                    this._heatmap = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/HeatMap.js","(function() {\r\n    'use strict';\r\n    var _DEFAULTS = {\r\n        radiusFunc: function (count) {\r\n            var r = Math.floor(count / 15);\r\n            if (r > 40) {\r\n                r = 40;\r\n            } else if (r < 20) {\r\n                r = 20;\r\n            }\r\n            return r;\r\n        },\r\n        text: {\r\n            stroke: 'black',\r\n            'stroke-width': 1,\r\n            'text-anchor': 'middle',\r\n            fill: 'white'\r\n        }\r\n    };\r\n    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({\r\n        options: {\r\n            observerOptions: {\r\n                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']\r\n            },\r\n            spiderfyOnMaxZoom: true,\r\n            minZoom: 1,\r\n            maxZoom: 6\r\n        },\r\n\r\n        createExternalLayer: function () {\r\n            var mOptions = L.extend({\r\n                showCoverageOnHover: false,\r\n                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)\r\n            }, this.options);\r\n\r\n            if ('clusterIconOptions' in this.options) {\r\n                var opt = this.options.clusterIconOptions;\r\n                if ('radialGradient' in opt) {\r\n                    var radialGradient = opt.radialGradient,\r\n                        text = opt.text || _DEFAULTS.text;\r\n                    mOptions.iconCreateFunction = function (cluster) {\r\n                        var childCount = cluster.getChildCount();\r\n\r\n                        text.count = childCount;\r\n                        return  L.gmxUtil.getSVGIcon({\r\n                            type: 'circle',\r\n                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),\r\n                            text: text,\r\n                            fillRadialGradient: radialGradient\r\n                        });\r\n                    };\r\n                }\r\n            }\r\n\r\n            if (this.options.clusterclick) {\r\n                mOptions.clusterclick = this.options.clusterclick;\r\n                if (mOptions.clusterclick === true) { mOptions.zoomToBoundsOnClick = false; }\r\n            }\r\n\r\n            this._popup = new L.Popup({maxWidth: 10000, className: 'gmxPopup'});\r\n            var markers = new L.MarkerClusterGroup(mOptions);\r\n\r\n            //   \r\n            var currentSpiderfiedCluster = null;\r\n\r\n            markers\r\n                .on('click', function (ev) {\r\n                    var propsArr = ev.layer.options.properties,\r\n                        properties = this.parentLayer.getItemProperties(propsArr),\r\n                        geometry = [propsArr[propsArr.length - 1]],\r\n                        id = propsArr[0];\r\n\r\n                    if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {\r\n                        currentSpiderfiedCluster.unspiderfy();\r\n                        markers.once('unspiderfied', function () {\r\n                            this._openPopup(propsArr, ev.latlng);\r\n                        }, this);\r\n                    } else {\r\n                        this._openPopup(propsArr, ev.latlng);\r\n                    }\r\n\r\n                    this.parentLayer.fire('click', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'click',\r\n                        gmx: {\r\n                            id: id,\r\n                            layer: this.parentLayer,\r\n                            properties: properties,\r\n                            target: {\r\n                                id: id,\r\n                                properties: propsArr,\r\n                                geometry: geometry\r\n                            }\r\n                        }\r\n                    }));\r\n                }, this)\r\n                .on('animationend', function () {\r\n                    if (this._popup && this._popup._map) {\r\n                        this._popup._map.removeLayer(this._popup);\r\n                    }\r\n                }, this)\r\n                .on('clusterclick', function (ev) {\r\n                    this.parentLayer.fire('clusterclick', L.extend(ev, {\r\n                        eventFrom: 'markerClusters',\r\n                        originalEventType: 'clusterclick'\r\n                    }));\r\n                }, this)\r\n                .on('spiderfied', function (ev) {\r\n                    currentSpiderfiedCluster = ev.cluster;\r\n                }, this)\r\n                .on('unspiderfied', function () {\r\n                    currentSpiderfiedCluster = null;\r\n                }, this);\r\n\r\n            if (mOptions.clusterclick) {\r\n                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {\r\n                    a.layer.spiderfy();\r\n                });\r\n            }\r\n\r\n            return markers;\r\n        },\r\n\r\n        isExternalVisible: function (zoom) {\r\n            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);\r\n        },\r\n\r\n        updateData: function (data) {\r\n            var arr = [],\r\n                i, len, vectorTileItem, id, marker;\r\n            if (data.removed) {\r\n                for (i = 0, len = data.removed.length; i < len; i++) {\r\n                    vectorTileItem = data.removed[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    if (marker) {\r\n                        arr.push(marker);\r\n                    }\r\n                    delete this._items[id];\r\n                }\r\n                this.externalLayer.removeLayers(arr);\r\n                arr = [];\r\n            }\r\n            if (data.added) {\r\n                for (i = 0, len = data.added.length; i < len; i++) {\r\n                    vectorTileItem = data.added[i];\r\n                    id = vectorTileItem.id;\r\n                    marker = this._items[id];\r\n                    var item = vectorTileItem.properties;\r\n                    if (marker && item.processing) {\r\n                        this.externalLayer.removeLayer(marker);\r\n                        marker = null;\r\n                    }\r\n                    if (!marker) {\r\n                        if (!vectorTileItem.item.parsedStyleKeys) {\r\n                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);\r\n                        }\r\n                        var geo = item[item.length - 1],\r\n                            parsedStyle = vectorTileItem.item.parsedStyleKeys,\r\n                            p = geo.coordinates,\r\n                            latlng = L.Projection.Mercator.unproject({x: p[0], y: p[1]}),\r\n                            opt = {\r\n                                properties: vectorTileItem.properties,\r\n                                mPoint: p\r\n                            };\r\n\r\n                        if (this.options.notClusteredIcon) {\r\n                            var icon = this.options.notClusteredIcon;\r\n                            if (icon instanceof L.Icon) {\r\n                                opt.icon = icon;\r\n                            } else {\r\n                                opt.icon = L.icon(icon);\r\n                            }\r\n                        } else if (parsedStyle) {\r\n                            if (parsedStyle.iconUrl) {\r\n                                var iconAnchor = parsedStyle.iconAnchor;\r\n                                if (!iconAnchor) {\r\n                                    var style = this.parentLayer.getItemStyle(id);\r\n                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];\r\n                                }\r\n                                opt.icon = L.icon({\r\n                                    iconAnchor: iconAnchor,\r\n                                    iconUrl: parsedStyle.iconUrl\r\n                                });\r\n                            } else {\r\n                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);\r\n                            }\r\n                        }\r\n                        if (parsedStyle.rotate) {\r\n                            marker = L.rotatedMarker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        } else {\r\n                            marker = L.marker(latlng, L.extend(opt, {\r\n                                angle: parsedStyle.rotate\r\n                            }));\r\n                        }\r\n                        this._items[id] = marker;\r\n                    }\r\n                    arr.push(marker);\r\n                }\r\n                this.externalLayer.addLayers(arr);\r\n            }\r\n        },\r\n\r\n        _openPopup: function (propsArr, latlng) {\r\n            var gmx = this.parentLayer._gmx,\r\n                id = propsArr[0],\r\n                balloonData = gmx.styleManager.getItemBalloon(id),\r\n                properties = this.parentLayer.getItemProperties(propsArr),\r\n                geometry = [propsArr[propsArr.length - 1]];\r\n\r\n            if (balloonData && !balloonData.DisableBalloonOnClick) {\r\n                var style = this.parentLayer.getItemStyle(id);\r\n                if (style && style.iconAnchor) {\r\n                    var protoOffset = L.Popup.prototype.options.offset;\r\n                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2,\r\n                        protoOffset[1] - style.iconAnchor[1] + style.sy / 2\r\n                    ];\r\n                }\r\n                this._popup\r\n                    .setLatLng(latlng)\r\n                    .setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {\r\n                        properties: properties,\r\n                        tileAttributeTypes: gmx.tileAttributeTypes,\r\n                        unitOptions: this._map.options || {},\r\n                        geometries: geometry\r\n                    }))\r\n                    .openOn(this._map);\r\n            }\r\n        }\r\n    });\r\n\r\n    L.gmx.VectorLayer.include({\r\n        bindClusters: function (options) {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                }\r\n                this._clusters = new GmxMarkerCluster(options, this);\r\n            }\r\n            return this;\r\n        },\r\n\r\n        unbindClusters: function () {\r\n            if (L.MarkerClusterGroup) {\r\n                if (this._clusters) {\r\n                    this._clusters.unbindLayer();\r\n                    this._clusters = null;\r\n                    this.enablePopup();\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    });\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/Layer/external/MarkerCluster.js","L.gmx = L.gmx || {};\r\nimport {gmxAPIutils} from './Utils.js';\r\n\r\nvar DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';\r\nvar DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;\r\n\r\n//Build in layer classes\r\nL.gmx._layerClasses = {\r\n    'Raster': L.gmx.RasterLayer,\r\n    'Vector': L.gmx.VectorLayer,\r\n    'VectorView': L.gmx.DummyLayer\r\n};\r\n\r\nL.gmx._loadingLayerClasses = {};\r\n\r\nL.gmx.addLayerClass = function(type, layerClass) {\r\n    L.gmx._layerClasses[type] = layerClass;\r\n};\r\n\r\nL.gmx._layerClassLoaders = [];\r\n\r\nL.gmx.addLayerClassLoader = function(layerClassLoader) {\r\n    L.gmx._layerClassLoaders.push(layerClassLoader);\r\n\r\n    //delete all loading promises to ensure that new loader will be invoked\r\n    L.gmx._loadingLayerClasses = {};\r\n};\r\n\r\nL.gmx._loadLayerClass = function(type) {\r\n    if (!L.gmx._loadingLayerClasses[type]) {\r\n        var promise = new L.gmx.Deferred();\r\n        promise.resolve();\r\n\r\n        L.gmx._layerClassLoaders.forEach(function(loader) {\r\n            promise = promise.then(function(layerClass) {\r\n                if (layerClass) {\r\n                    L.gmx._layerClasses[type] = layerClass;\r\n                    return layerClass;\r\n                }\r\n\r\n                return loader(type);\r\n            },\r\n            function(){\r\n                //just skip loader errors\r\n            });\r\n        });\r\n\r\n        promise = promise.then(function(layerClass) {\r\n            if (layerClass) {\r\n                L.gmx._layerClasses[type] = layerClass;\r\n                return layerClass;\r\n            }\r\n        }, function(){\r\n            //just skip loader errors\r\n        });\r\n\r\n        L.gmx._loadingLayerClasses[type] = promise;\r\n    }\r\n\r\n    return L.gmx._loadingLayerClasses[type];\r\n};\r\n\r\nL.gmx.loadLayer = function(mapID, layerID, options) {\r\n\r\n    var promise = new L.gmx.Deferred(),\r\n        layerParams = {\r\n            mapID: mapID,\r\n            layerID: layerID\r\n        };\r\n\r\n    options = options || {};\r\n\r\n    for (var p in options) {\r\n        layerParams[p] = options[p];\r\n    }\r\n\r\n    var hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n    layerParams.hostName = hostName;\r\n\r\n    L.gmx.gmxMapManager.getMap(hostName, options.apiKey, mapID, options.skipTiles).then(\r\n        function() {\r\n            var layerInfo = L.gmx.gmxMapManager.findLayerInfo(hostName, mapID, layerID);\r\n\r\n            if (!layerInfo) {\r\n                promise.reject('There is no layer ' + layerID + ' in map ' + mapID);\r\n                return;\r\n            }\r\n\r\n            //to know from what host the layer was loaded\r\n            layerInfo.properties.hostName = hostName;\r\n\r\n            var type = layerInfo.properties.ContentID || layerInfo.properties.type;\r\n\r\n            var doCreateLayer = function() {\r\n                var layer = L.gmx.createLayer(layerInfo, layerParams);\r\n                if (layer) {\r\n                    promise.resolve(layer);\r\n                } else {\r\n                    promise.reject('Unknown type of layer ' + layerID);\r\n                }\r\n            };\r\n\r\n            if (type in L.gmx._layerClasses) {\r\n                doCreateLayer();\r\n            } else {\r\n                L.gmx._loadLayerClass(type).then(doCreateLayer);\r\n            }\r\n        },\r\n        function(response) {\r\n            promise.reject('Can\\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);\r\n        }\r\n    );\r\n\r\n    return promise;\r\n};\r\n\r\nL.gmx.loadLayers = function(layers, globalOptions) {\r\n    var defs = layers.map(function(layerInfo) {\r\n        var options = L.extend({}, globalOptions, layerInfo.options);\r\n        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);\r\n    });\r\n\r\n    return L.gmx.Deferred.all.apply(null, defs);\r\n};\r\n\r\nL.gmx.loadMap = function(mapID, options) {\r\n    options = L.extend({}, options);\r\n    options.hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);\r\n\r\n    var def = new L.gmx.Deferred();\r\n\r\n    L.gmx.gmxMapManager.getMap(options.hostName, options.apiKey, mapID, options.skipTiles, options.isGeneralized).then(function(mapInfo) {\r\n        var loadedMap = new L.gmx.gmxMap(mapInfo, options);\r\n\r\n        loadedMap.layersCreated.then(function() {\r\n            if (options.leafletMap || options.setZIndex) {\r\n                var curZIndex = 0,\r\n                    layer, rawProperties;\r\n\r\n                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {\r\n                    layer = loadedMap.layers[l];\r\n\t\t\t\t\trawProperties = layer.getGmxProperties();\r\n\t\t\t\t\tif (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {\r\n                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);\r\n                    }\r\n                    if (options.setZIndex && layer.setZIndex) {\r\n                        layer.setZIndex(++curZIndex);\r\n                    }\r\n\r\n                    if (options.leafletMap && rawProperties.visible) {\r\n                        layer.addTo(options.leafletMap);\r\n                    }\r\n                }\r\n            }\r\n            def.resolve(loadedMap);\r\n        });\r\n    },\r\n    function(response) {\r\n        var errorMessage = (response && response.ErrorInfo && response.ErrorInfo.ErrorMessage) || 'Server error';\r\n        def.reject('Can\\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);\r\n    });\r\n    return def;\r\n};\r\n\r\nL.gmx.DummyLayer = function(props) {\r\n    this.onAdd = this.onRemove = function() {};\r\n    this.getGmxProperties = function() { return props; };\r\n};\r\n\r\nL.gmx.createLayer = function(layerInfo, options) {\r\n    if (!layerInfo) { layerInfo = {}; }\r\n    if (!layerInfo.properties) { layerInfo.properties = {type: 'Vector'}; }\r\n\r\n    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',\r\n        layer;\r\n\r\n\t\tif (type in L.gmx._layerClasses) {\r\n        try {\r\n            layer = new L.gmx._layerClasses[type](options);\r\n            layer = layer.initFromDescription(layerInfo);\r\n        } catch (e) {\r\n            layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n        }\r\n    } else {\r\n        layer = new L.gmx.DummyLayer(layerInfo.properties);\r\n    }\r\n\r\n    return layer;\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/LayerFactory.js"],"sourceRoot":""}